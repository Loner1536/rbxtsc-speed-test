<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">base</string>
      </Properties>
      <Item class="Folder" referent="2">
        <Properties>
          <string name="Name">client</string>
        </Properties>
        <Item class="Folder" referent="3">
          <Properties>
            <string name="Name">controllers</string>
          </Properties>
          <Item class="ModuleScript" referent="4">
            <Properties>
              <string name="Name">test</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Client
do
	Client = setmetatable({}, {
		__tostring = function()
			return "Client"
		end,
	})
	Client.__index = Client
	function Client.new(...)
		local self = setmetatable({}, Client)
		return self:constructor(...) or self
	end
	function Client:constructor()
	end
	function Client:onStart()
		print("Base Client")
	end
	do
		-- (Flamework) Client metadata
		Reflect.defineMetadata(Client, "identifier", "gj")
		Reflect.defineMetadata(Client, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) Client decorators
Reflect.decorate(Client, "$:flamework@Controller", Controller, { {} })
return {
	Client = Client,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Script" referent="5">
          <Properties>
            <string name="Name">runtime</string>
            <token name="RunContext">2</token>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "ReplicatedStorage", "base", "client", "controllers" } })
Flamework.ignite()
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="6">
        <Properties>
          <string name="Name">shared</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="7">
      <Properties>
        <string name="Name">lobby</string>
      </Properties>
      <Item class="Folder" referent="8">
        <Properties>
          <string name="Name">client</string>
        </Properties>
        <Item class="Folder" referent="9">
          <Properties>
            <string name="Name">controllers</string>
          </Properties>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">test</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Client
do
	Client = setmetatable({}, {
		__tostring = function()
			return "Client"
		end,
	})
	Client.__index = Client
	function Client.new(...)
		local self = setmetatable({}, Client)
		return self:constructor(...) or self
	end
	function Client:constructor()
	end
	function Client:onStart()
		print("Base Client")
	end
	do
		-- (Flamework) Client metadata
		Reflect.defineMetadata(Client, "identifier", "bO")
		Reflect.defineMetadata(Client, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) Client decorators
Reflect.decorate(Client, "$:flamework@Controller", Controller, { {} })
return {
	Client = Client,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Script" referent="11">
          <Properties>
            <string name="Name">runtime</string>
            <token name="RunContext">2</token>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "ReplicatedStorage", "lobby", "client", "controllers" } })
Flamework.ignite()
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="12">
        <Properties>
          <string name="Name">shared</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="13">
      <Properties>
        <string name="Name">rbxts_include</string>
      </Properties>
      <Item class="ModuleScript" referent="14">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="15">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(try, catch, finally)
	-- execute try
	local trySuccess, exitTypeOrTryError, returns = pcall(try)
	local exitType, tryError
	if trySuccess then
		exitType = exitTypeOrTryError
	else
		tryError = exitTypeOrTryError
	end

	local catchSuccess = true
	local catchError

	-- if try block failed, and catch block exists, execute catch
	if not trySuccess and catch then
		local newExitTypeOrCatchError, newReturns
		catchSuccess, newExitTypeOrCatchError, newReturns = pcall(catch, tryError)
		local newExitType
		if catchSuccess then
			newExitType = newExitTypeOrCatchError
		else
			catchError = newExitTypeOrCatchError
		end

		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	-- execute finally
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	-- if exit type is a control flow, do not rethrow errors
	if exitType ~= TS.TRY_RETURN and exitType ~= TS.TRY_BREAK and exitType ~= TS.TRY_CONTINUE then
		-- if catch block threw an error, rethrow it
		if not catchSuccess then
			error(catchError, 2)
		end

		-- if try block threw an error and there was no catch block, rethrow it
		if not trySuccess and not catch then
			error(tryError, 2)
		end
	end

	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="16">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="17">
          <Properties>
            <string name="Name">@flamework</string>
          </Properties>
          <Item class="Folder" referent="18">
            <Properties>
              <string name="Name">core</string>
            </Properties>
            <Item class="ModuleScript" referent="19">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
exports.Reflect = TS.import(script, script, "reflect").Reflect
exports.Modding = TS.import(script, script, "modding").Modding
local _flamework = TS.import(script, script, "flamework")
exports.Controller = _flamework.Controller
exports.Dependency = _flamework.Dependency
exports.Optional = _flamework.Optional
exports.Service = _flamework.Service
exports.Flamework = _flamework.Flamework
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="20">
                <Properties>
                  <string name="Name">flamework</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local Metadata = TS.import(script, script.Parent, "metadata").Metadata
local Modding = TS.import(script, script.Parent, "modding").Modding
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local isConstructor = TS.import(script, script.Parent, "utility").isConstructor
local ArtificialDependency, Flamework
local Flamework = {}
do
	local _container = Flamework
	-- RuntimeLib, which is required to import packages
	local tsImpl = _G[script]
	local isProfiling = Metadata.isProfiling()
	local hasFlameworkIgnited = false
	local isPreloading = false
	local inactiveThread
	--* @hidden 
	local function resolveDependency(id)
		if isPreloading then
			local source, line = debug.info(2, "sl")
			warn(`[Flamework] Attempting to load dependency '{id}' during preloading.`)
			warn("This is prone to race conditions and is not guaranteed to succeed.")
			warn(`Script '{source}', Line {line}`)
		elseif not hasFlameworkIgnited and Metadata.gameConfig.disableDependencyWarnings ~= true then
			local source, line = debug.info(2, "sl")
			warn(`[Flamework] Dependency '{id}' was loaded before ignition.`)
			warn("This is considered bad practice and should be avoided.")
			warn("You can disable this warning in flamework.json")
			warn(`Script '{source}', Line {line}`)
		end
		return Modding.resolveDependency(ArtificialDependency, id, 0, {})
	end
	_container.resolveDependency = resolveDependency
	--* @hidden 
	local logIfVerbose
	local function _addPaths(paths)
		local preloadPaths = {}
		for _, arg in paths do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			for i = 0, #arg - 1 do
				currentPath = currentPath:WaitForChild(arg[i + 1])
			end
			local _currentPath = currentPath
			table.insert(preloadPaths, _currentPath)
		end
		local preload = function(moduleScript)
			isPreloading = true
			local start = os.clock()
			local success, value = pcall(function()
				return tsImpl.import(script, moduleScript)
			end)
			local endTime = math.floor((os.clock() - start) * 1000)
			isPreloading = false
			if not success then
				error(`{moduleScript:GetFullName()} failed to preload ({endTime}ms): {value}`)
			end
		end
		for _, path in preloadPaths do
			logIfVerbose(`Preloading directory {path:GetFullName()}`)
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _1, instance in path:GetDescendants() do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container._addPaths = _addPaths
	--* @hidden 
	local function _addPathsGlob(arg)
		return _addPaths(Metadata.getGlob(arg) or {})
	end
	_container._addPathsGlob = _addPathsGlob
	--* @hidden 
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		local _callback = function(impl)
			local _impl = impl
			local _id = id
			return table.find(_impl, _id) ~= nil
		end
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	function logIfVerbose(...)
		local args = { ... }
		if Metadata.getLogLevel() == "verbose" then
			print("[Flamework (verbose)]", unpack(args))
		end
	end
	local function getIdentifier(obj, suffix)
		if suffix == nil then
			suffix = ""
		end
		local _condition = Reflect.getMetadata(obj, "identifier")
		if _condition == nil then
			_condition = `UnidentifiedFlameworkListener{suffix}`
		end
		return _condition
	end
	-- This returns a Map rather than an Array because table.sort is unstable and will not preserve element order.
	local function topologicalSort(objects)
		-- This implementation ignores circular dependency trees.
		local currentSize = 0
		local sorted = {}
		local visited = {}
		local visitor
		visitor = function(node)
			local _node = node
			if visited[_node] ~= nil then
				return nil
			end
			local _node_1 = node
			visited[_node_1] = true
			local _idToObj = Reflect.idToObj
			local _node_2 = node
			local object = _idToObj[_node_2]
			if not object then
				return nil
			end
			local dependencies = Reflect.getMetadata(object, "flamework:parameters")
			for _, dependency in dependencies or {} do
				visitor(dependency)
			end
			local _exp = node
			local _original = currentSize
			currentSize += 1
			sorted[_exp] = _original
		end
		for _, node in objects do
			visitor(node)
		end
		return sorted
	end
	local function reusableThread(func)
		local thread = coroutine.running()
		while true do
			if inactiveThread == thread then
				inactiveThread = nil
			end
			func()
			-- If there's a different idle thread, we should end the current thread.
			if inactiveThread ~= nil then
				break
			end
			inactiveThread = thread
			func = coroutine.yield()
		end
	end
	local function profileYielding(func, identifier)
		if isProfiling then
			return function()
				-- `profilebegin` will end when this thread dies or yields.
				debug.profilebegin(identifier)
				debug.setmemorycategory(identifier)
				func()
				debug.resetmemorycategory()
			end
		else
			return func
		end
	end
	local function reuseThread(func)
		if inactiveThread then
			task.spawn(inactiveThread, func)
		else
			task.spawn(reusableThread, func)
		end
	end
	--[[
		*
		     * Explicitly include an optional class in the startup cycle.
		     
	]]
	local function includeOptionalClass(ctor)
		Reflect.defineMetadata(ctor, "flamework:optional", false)
	end
	_container.includeOptionalClass = includeOptionalClass
	--[[
		*
		     * Initialize Flamework.
		     *
		     * This will start up the lifecycle events on all currently registered
		     * classes.
		     *
		     * You should preload all necessary directories before calling this
		     * as newly registered classes will not run their lifecycle events.
		     
	]]
	local function ignite()
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		for _, ctor in Reflect.idToObj do
			if not isConstructor(ctor) then
				continue
			end
			if not Reflect.getMetadata(ctor, "flamework:singleton") then
				continue
			end
			if Reflect.getMetadata(ctor, "flamework:optional") then
				continue
			end
			Modding.resolveSingleton(ctor)
			logIfVerbose(`Resolving singleton {ctor}`)
		end
		local dependencies = {}
		for ctor, dependency in Modding.getSingletons() do
			local _condition = Reflect.getMetadata(ctor, "flamework:loadOrder")
			if _condition == nil then
				_condition = 1
			end
			local loadOrder = _condition
			local _arg0 = { dependency, loadOrder }
			table.insert(dependencies, _arg0)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#dependencies)
		local _callback = function(_param)
			local obj = _param[1]
			return getIdentifier(obj)
		end
		for _k, _v in dependencies do
			_newValue[_k] = _callback(_v, _k - 1, dependencies)
		end
		-- ▲ ReadonlyArray.map ▲
		local sortedDependencies = topologicalSort(_newValue)
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		table.sort(dependencies, function(_param, _param_1)
			local depA = _param[1]
			local aOrder = _param[2]
			local depB = _param_1[1]
			local bOrder = _param_1[2]
			if aOrder ~= bOrder then
				return aOrder < bOrder
			end
			local _arg0 = getIdentifier(depA)
			local aIndex = sortedDependencies[_arg0]
			local _arg0_1 = getIdentifier(depB)
			local bIndex = sortedDependencies[_arg0_1]
			return aIndex < bIndex
		end)
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnTick")
			tick[_object] = _arg1
			return tick
		end, "$:flamework@OnTick")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnPhysics")
			physics[_object] = _arg1
			return physics
		end, "$:flamework@OnPhysics")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnRender")
			render[_object] = _arg1
			return render
		end, "$:flamework@OnRender")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = tick[_object] ~= nil
			tick[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnTick")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = physics[_object] ~= nil
			physics[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnPhysics")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = render[_object] ~= nil
			render[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnRender")
		for _, _binding in dependencies do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				local _arg0 = { dependency, getIdentifier(dependency) }
				table.insert(init, _arg0)
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				local _arg0 = { dependency, getIdentifier(dependency) }
				table.insert(start, _arg0)
			end
		end
		for _, _binding in init do
			local dependency = _binding[1]
			local identifier = _binding[2]
			if isProfiling then
				debug.setmemorycategory(identifier)
			end
			logIfVerbose(`OnInit {identifier}`)
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				local status, value = initResult:awaitStatus()
				if status == TS.Promise.Status.Rejected then
					error(`OnInit failed for dependency '{identifier}'. {tostring(value)}`)
				end
			end
		end
		debug.resetmemorycategory()
		RunService.Heartbeat:Connect(function(dt)
			for dependency, identifier in tick do
				reuseThread(profileYielding(function()
					return dependency:onTick(dt)
				end, identifier))
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for dependency, identifier in physics do
				reuseThread(profileYielding(function()
					return dependency:onPhysics(dt, time)
				end, identifier))
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for dependency, identifier in render do
					reuseThread(profileYielding(function()
						return dependency:onRender(dt)
					end, identifier))
				end
			end)
		end
		for _, _binding in start do
			local dependency = _binding[1]
			local identifier = _binding[2]
			logIfVerbose(`OnStart {identifier}`)
			reuseThread(profileYielding(function()
				return dependency:onStart()
			end, identifier))
		end
	end
	_container.ignite = ignite
	--[[
		*
		     * Preload the specified paths by requiring all ModuleScript descendants.
		     *
		     * @metadata macro intrinsic-arg-shift {@link _addPaths intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Preload the specified paths by requiring all ModuleScript descendants.
		     *
		     * This function supports globs allowing you to match files or directories based on patterns,
		     * but it should be noted that this can generate really large lists of paths and it is recommended to capture as few matches as possible.
		     *
		     * @metadata macro intrinsic-arg-shift {@link _addPathsGlob intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Retrieve the identifier for the specified type.
		     *
		     * @metadata macro {@link id intrinsic-inline}
		     
	]]
	--[[
		*
		     * Check if the constructor implements the specified interface.
		     *
		     * @metadata macro {@link _implements intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Check if object implements the specified interface.
		     *
		     * @metadata macro {@link _implements intrinsic-flamework-rewrite}
		     
	]]
	--[[
		*
		     * Hash a function using the method used internally by Flamework.
		     * If a context is provided, then Flamework will create a new hash
		     * if the specified string does not have one in that context.
		     * @param str The string to hash
		     * @param context A scope for the hash
		     * @metadata macro {@link meta intrinsic-inline}
		     
	]]
	--[[
		*
		     * Creates a type guard from any arbitrary type.
		     *
		     * @metadata macro
		     
	]]
	local function createGuard(meta)
		return meta
	end
	_container.createGuard = createGuard
end
--[[
	*
	 * An internal class used for resolving the Dependency<T> macro.
	 
]]
do
	ArtificialDependency = setmetatable({}, {
		__tostring = function()
			return "ArtificialDependency"
		end,
	})
	ArtificialDependency.__index = ArtificialDependency
	function ArtificialDependency.new(...)
		local self = setmetatable({}, ArtificialDependency)
		return self:constructor(...) or self
	end
	function ArtificialDependency:constructor()
	end
end
Reflect.defineMetadata(ArtificialDependency, "identifier", "$:flamework@ArtificialDependency")
Reflect.defineMetadata(ArtificialDependency, "flamework:isArtificial", true)
--[[
	*
	 * This function resolves a dependency and can be called outside of the usual dependency injection lifecycle.
	 *
	 * This function can make it harder to stub, test or modify your code so it is recommended to use this macro minimally.
	 * It is recommended that you pass dependencies to code that needs it from a singleton, component, etc.
	 *
	 * @metadata macro {@link Flamework.resolveDependency intrinsic-flamework-rewrite}
	 
]]
--[[
	*
	 * Register a class as a Service.
	 *
	 * @server
	 * @metadata flamework:implements flamework:parameters injectable
	 
]]
local Service = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsServer() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		Reflect.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	 * Register a class as a Controller.
	 *
	 * @client
	 * @metadata flamework:implements flamework:parameters injectable
	 
]]
local Controller = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsClient() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		Reflect.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	 * Marks a singleton as optional.
	 *
	 * This singleton will only be included if it is depended on or is explicitly included with `Flamework.includeOptionalClass`.
	 
]]
local Optional = Modding.createDecorator("Class", function(descriptor)
	if not Reflect.getMetadata(descriptor.object, "flamework:singleton") then
		warn("'Optional' decorator was applied to a non-singleton.", descriptor.object)
		warn("Make sure you apply the 'Optional' decorator above other decorators.")
	end
	Reflect.defineMetadata(descriptor.object, `flamework:optional`, true)
end)
--[[
	*
	 * Hook into the OnInit lifecycle event.
	 
]]
--[[
	*
	 * Hook into the OnStart lifecycle event.
	 
]]
--[[
	*
	 * Hook into the OnTick lifecycle event.
	 * Equivalent to: RunService.Heartbeat
	 
]]
--[[
	*
	 * Hook into the OnPhysics lifecycle event.
	 * Equivalent to: RunService.Stepped
	 
]]
--[[
	*
	 * Hook into the OnRender lifecycle event.
	 * Equivalent to: RunService.RenderStepped
	 *
	 * @client
	 
]]
return {
	Flamework = Flamework,
	Service = Service,
	Controller = Controller,
	Optional = Optional,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="21">
                <Properties>
                  <string name="Name">metadata</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
--[[
	*
	 * Metadata exposed by the Flamework transformer.
	 
]]
local Metadata = {}
do
	local _container = Metadata
	--[[
		*
		     * Runtime metadata generated by the transformer
		     
	]]
	--[[
		*
		     * Runtime metadata generated by the transformer
		     
	]]
	--[[
		*
		     * Runtime metadata generated by the transformer
		     
	]]
	local function getContainer(name)
		local current = script
		while current do
			local flamework = current:FindFirstChild("flamework")
			if flamework then
				local metadata = flamework:FindFirstChild(name)
				if metadata then
					return require(metadata)
				end
			end
			current = current.Parent
		end
	end
	local configContainer
	local function getConfig(packageId)
		local _result
		if packageId == nil then
			local _result_1 = configContainer
			if _result_1 ~= nil then
				_result_1 = _result_1.game
			end
			_result = _result_1
		else
			local _result_1 = configContainer
			if _result_1 ~= nil then
				local _packages = _result_1.packages
				local _packageId = packageId
				_result_1 = _packages[_packageId]
			end
			_result = _result_1
		end
		return _result
	end
	configContainer = getContainer("config")
	_container.configContainer = configContainer
	local globContainer = getContainer("globs")
	_container.globContainer = globContainer
	local _result = configContainer
	if _result ~= nil then
		_result = _result.game
	end
	local _condition = _result
	if _condition == nil then
		_condition = {}
	end
	local gameConfig = _condition
	_container.gameConfig = gameConfig
	local function getGlob(glob, packageId)
		local _result_1
		if packageId == nil then
			local _result_2 = globContainer
			if _result_2 ~= nil then
				_result_2 = _result_2.game
			end
			_result_1 = _result_2
		else
			local _result_2 = globContainer
			if _result_2 ~= nil then
				local _packages = _result_2.packages
				local _packageId = packageId
				_result_2 = _packages[_packageId]
			end
			_result_1 = _result_2
		end
		local globs = _result_1
		local _result_2 = globs
		if _result_2 ~= nil then
			local _glob = glob
			_result_2 = _result_2[_glob]
		end
		return _result_2
	end
	_container.getGlob = getGlob
	local function getLogLevel(packageId)
		local config = getConfig(packageId)
		if not config or config.logLevel == nil then
			return "none"
		end
		return config.logLevel
	end
	_container.getLogLevel = getLogLevel
	local function isProfiling(packageId)
		local config = getConfig(packageId)
		if not config or config.profiling == nil then
			return RunService:IsStudio()
		end
		return config.profiling
	end
	_container.isProfiling = isProfiling
end
return {
	Metadata = Metadata,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="22">
                <Properties>
                  <string name="Name">modding</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local isConstructor = TS.import(script, script.Parent, "utility").isConstructor
local getDeferredConstructor
local Modding = {}
do
	local _container = Modding
	local listeners = {}
	local lifecycleListeners = {}
	local decoratorListeners = {}
	local listenerAdded = Signal.new()
	local listenerRemoved = Signal.new()
	local listenerAddedEvents = {}
	local listenerRemovedEvents = {}
	local dependencyResolution = {}
	local resolvedSingletons = {}
	local loadingList = {}
	--[[
		*
		     * Retrieves an object from its identifier.
		     *
		     * The reverse (getting an identifier from an object) can be achieved using the Reflect API directly.
		     
	]]
	local function getObjectFromId(id)
		local _idToObj = Reflect.idToObj
		local _id = id
		return _idToObj[_id]
	end
	_container.getObjectFromId = getObjectFromId
	--[[
		*
		     * Registers a listener for lifecycle events.
		     
	]]
	local function addListener(object)
		local listener = {
			eventIds = {},
			involvement = {},
		}
		for _, lifecycleEvents in Reflect.getMetadatas(object, `flamework:implements`) do
			for _1, lifecycleEvent in lifecycleEvents do
				if listener.eventIds[lifecycleEvent] ~= nil then
					continue
				end
				local lifecycleListener = lifecycleListeners[lifecycleEvent]
				if not lifecycleListener then
					lifecycleListener = {}
					local _lifecycleListener = lifecycleListener
					lifecycleListeners[lifecycleEvent] = _lifecycleListener
				end
				local _lifecycleListener = lifecycleListener
				local _object = object
				_lifecycleListener[_object] = true
				listener.eventIds[lifecycleEvent] = true
				local _involvement = listener.involvement
				local _lifecycleListener_1 = lifecycleListener
				table.insert(_involvement, _lifecycleListener_1)
				local _result = listenerAddedEvents[lifecycleEvent]
				if _result ~= nil then
					_result:Fire(object)
				end
			end
		end
		local decorators = Reflect.getMetadata(object, `flamework:decorators`)
		if decorators then
			for _, decorator in decorators do
				if listener.eventIds[decorator] ~= nil then
					continue
				end
				local decoratorListener = decoratorListeners[decorator]
				if not decoratorListener then
					decoratorListener = {}
					local _decoratorListener = decoratorListener
					decoratorListeners[decorator] = _decoratorListener
				end
				local _decoratorListener = decoratorListener
				local _object = object
				_decoratorListener[_object] = true
				listener.eventIds[decorator] = true
				local _involvement = listener.involvement
				local _decoratorListener_1 = decoratorListener
				table.insert(_involvement, _decoratorListener_1)
				local _result = listenerAddedEvents[decorator]
				if _result ~= nil then
					_result:Fire(object)
				end
			end
		end
		local _object = object
		listeners[_object] = listener
		listenerAdded:Fire(object)
	end
	_container.addListener = addListener
	--[[
		*
		     * Removes a listener for lifecycle events and decorators.
		     
	]]
	local function removeListener(object)
		local _object = object
		local listener = listeners[_object]
		if not listener then
			return nil
		end
		for _, set in listener.involvement do
			local _object_1 = object
			set[_object_1] = nil
		end
		for id in listener.eventIds do
			local _result = listenerRemovedEvents[id]
			if _result ~= nil then
				_result:Fire(object)
			end
		end
		local _object_1 = object
		listeners[_object_1] = nil
		listenerRemoved:Fire(object)
	end
	_container.removeListener = removeListener
	--[[
		*
		     * Registers a listener added event.
		     * Fires whenever any listener is added.
		     *
		     * Fires for all existing listeners.
		     
	]]
	--[[
		*
		     * Registers a listener added event.
		     * Fires whenever a listener has a decorator with the specified ID.
		     *
		     * Fires for all existing listeners.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener added event.
		     * Fires whenever a listener has a lifecycle event with the specified ID.
		     *
		     * Fires for all existing listeners.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener added event.
		     
	]]
	local function onListenerAdded(func, id)
		if id ~= nil then
			local _id = id
			local listenerAddedEvent = listenerAddedEvents[_id]
			if not listenerAddedEvent then
				local _exp = id
				listenerAddedEvent = Signal.new()
				local _listenerAddedEvent = listenerAddedEvent
				listenerAddedEvents[_exp] = _listenerAddedEvent
			end
			local _id_1 = id
			local _condition = lifecycleListeners[_id_1]
			if not _condition then
				local _id_2 = id
				_condition = decoratorListeners[_id_2]
			end
			local existingListeners = _condition
			if existingListeners then
				for listener in existingListeners do
					task.spawn(func, listener)
				end
			end
			return listenerAddedEvent:Connect(func)
		else
			for listener in listeners do
				task.spawn(func, listener)
			end
			return listenerAdded:Connect(func)
		end
	end
	_container.onListenerAdded = onListenerAdded
	--[[
		*
		     * Registers a listener removed event.
		     *
		     * Fires whenever any listener is removed.
		     
	]]
	--[[
		*
		     * Registers a listener removed event.
		     *
		     * Fires whenever a listener has a decorator with the specified ID.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener removed event.
		     *
		     * Fires whenever a listener has a lifecycle event with the specified ID.
		     *
		     * @metadata macro
		     
	]]
	--[[
		*
		     * Registers a listener removed event.
		     
	]]
	local function onListenerRemoved(func, id)
		if id ~= nil then
			local _id = id
			local listenerRemovedEvent = listenerRemovedEvents[_id]
			if not listenerRemovedEvent then
				local _exp = id
				listenerRemovedEvent = Signal.new()
				local _listenerRemovedEvent = listenerRemovedEvent
				listenerRemovedEvents[_exp] = _listenerRemovedEvent
			end
			return listenerRemovedEvent:Connect(func)
		else
			return listenerRemoved:Connect(func)
		end
	end
	_container.onListenerRemoved = onListenerRemoved
	--[[
		*
		     * Registers a class decorator.
		     
	]]
	--[[
		*
		     * Registers a method decorator.
		     
	]]
	--[[
		*
		     * Registers a property decorator.
		     
	]]
	--[[
		*
		     * Registers a decorator.
		     
	]]
	local defineDecoratorMetadata
	local function createDecorator(_kind, func)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
				func(descriptor, config)
			end,
		}
	end
	_container.createDecorator = createDecorator
	--[[
		*
		     * Registers a metadata class decorator.
		     
	]]
	--[[
		*
		     * Registers a metadata method decorator.
		     
	]]
	--[[
		*
		     * Registers a metadata property decorator.
		     
	]]
	--[[
		*
		     * Registers a metadata decorator.
		     
	]]
	local function createMetaDecorator(_kind)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
			end,
		}
	end
	_container.createMetaDecorator = createMetaDecorator
	--[[
		*
		     * Retrieves registered decorators.
		     *
		     * @metadata macro
		     
	]]
	local function getDecorators(id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _decorators = Reflect.decorators
		local _id = id
		local decorators = _decorators[_id]
		if not decorators then
			return {}
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#decorators)
		local _callback = function(object)
			local decoratorConfig = Reflect.getOwnMetadata(object, `flamework:decorators.{id}`)
			assert(decoratorConfig)
			return {
				object = object,
				constructor = if isConstructor(object) then object else nil,
				arguments = decoratorConfig.arguments,
			}
		end
		for _k, _v in decorators do
			_newValue[_k] = _callback(_v, _k - 1, decorators)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	_container.getDecorators = getDecorators
	--[[
		*
		     * Creates a map of every property using the specified decorator.
		     *
		     * @metadata macro
		     
	]]
	local getDecorator
	local function getPropertyDecorators(obj, id)
		local decorators = {}
		local _arg0 = id ~= nil
		assert(_arg0)
		for _, prop in Reflect.getProperties(obj) do
			local decorator = getDecorator(obj, prop, id)
			if decorator then
				decorators[prop] = decorator
			end
		end
		return decorators
	end
	_container.getPropertyDecorators = getPropertyDecorators
	--[[
		*
		     * Retrieves a decorator from an object or its properties.
		     *
		     * @metadata macro
		     
	]]
	function getDecorator(object, property, id)
		local decorator = Reflect.getMetadata(object, `flamework:decorators.{id}`, property)
		if not decorator then
			return nil
		end
		return decorator
	end
	_container.getDecorator = getDecorator
	--[[
		*
		     * Retrieves a singleton or instantiates one if it does not exist.
		     
	]]
	local createDependency
	local function resolveSingleton(ctor)
		local _ctor = ctor
		local resolvedDependency = resolvedSingletons[_ctor]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local _ctor_1 = ctor
		if table.find(loadingList, _ctor_1) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _result = table.create(#loadingList)
			for _k, _v in loadingList do
				_result[_k] = tostring(_v)
			end
			-- ▲ ReadonlyArray.join ▲
			error(`Circular dependency detected {table.concat(_result, " <=> ")} <=> {ctor}`)
		end
		local _ctor_2 = ctor
		table.insert(loadingList, _ctor_2)
		-- Flamework can resolve singletons at any arbitrary point,
		-- so we should fetch custom dependency resolution (added via decorator) through the Reflect api.
		local opts = Reflect.getOwnMetadata(ctor, "flamework:dependency_resolution")
		local dependency = createDependency(ctor, opts)
		local _ctor_3 = ctor
		resolvedSingletons[_ctor_3] = dependency
		loadingList[#loadingList] = nil
		addListener(dependency)
		return dependency
	end
	_container.resolveSingleton = resolveSingleton
	--* @internal Used for bootstrapping 
	local function getSingletons()
		return resolvedSingletons
	end
	_container.getSingletons = getSingletons
	--[[
		*
		     * Modifies dependency resolution for a specific ID.
		     *
		     * If a function is passed, it will be called, passing the target constructor, every time that ID needs to be resolved.
		     * Otherwise, the passed object is returned directly.
		     *
		     * @metadata macro
		     
	]]
	local function registerDependency(dependency, id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _dependency = dependency
		if type(_dependency) == "function" then
			local _id = id
			local _dependency_1 = dependency
			dependencyResolution[_id] = _dependency_1
		else
			local _id = id
			dependencyResolution[_id] = function()
				return dependency
			end
		end
	end
	_container.registerDependency = registerDependency
	--[[
		*
		     * Instantiates this class using dependency injection.
		     
	]]
	local createDeferredDependency
	function createDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = createDeferredDependency(ctor, options)
		local obj = _binding[1]
		local construct = _binding[2]
		construct()
		return obj
	end
	_container.createDependency = createDependency
	--[[
		*
		     * Creates an object for this class and returns a deferred constructor.
		     
	]]
	local resolveDependency
	function createDeferredDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = getDeferredConstructor(ctor)
		local obj = _binding[1]
		local construct = _binding[2]
		return { obj, function()
			local dependencies = Reflect.getMetadata(ctor, "flamework:parameters")
			local constructorDependencies = {}
			if dependencies then
				for index, dependencyId in pairs(dependencies) do
					constructorDependencies[index] = resolveDependency(ctor, dependencyId, index - 1, options)
				end
			end
			construct(unpack(constructorDependencies))
		end }
	end
	_container.createDeferredDependency = createDeferredDependency
	--[[
		*
		     * Dependency resolution logic.
		     * @internal
		     
	]]
	function resolveDependency(ctor, dependencyId, index, options)
		if options.handle ~= nil then
			local dependency = options.handle(dependencyId, index)
			if dependency ~= nil then
				return dependency
			end
		end
		local _dependencyId = dependencyId
		local resolution = dependencyResolution[_dependencyId]
		if resolution ~= nil then
			return resolution(ctor)
		end
		local _idToObj = Reflect.idToObj
		local _dependencyId_1 = dependencyId
		local dependencyCtor = _idToObj[_dependencyId_1]
		if dependencyCtor and isConstructor(dependencyCtor) then
			return resolveSingleton(dependencyCtor)
		end
		if string.sub(dependencyId, 1, 2) == "$p" then
			if string.sub(dependencyId, 1, 3) == "$ps" then
				return string.sub(dependencyId, 5)
			end
			if string.sub(dependencyId, 1, 3) == "$pn" then
				local _condition = tonumber(string.sub(dependencyId, 5))
				if _condition == nil then
					_condition = 0
				end
				return _condition
			end
			if options.handlePrimitive ~= nil then
				return options.handlePrimitive(dependencyId, index)
			end
			error(`Unexpected primitive dependency '{dependencyId}' while constructing {ctor}`)
		end
		error(`Could not find constructor for {dependencyId} while constructing {ctor}`)
	end
	_container.resolveDependency = resolveDependency
	--[[
		*
		     * This function is able to utilize Flamework's user macros to generate and inspect types.
		     * This function supports all values natively supported by Flamework's user macros.
		     *
		     * For example, if you want to retrieve the properties of an instance, you could write code like this:
		     * ```ts
		     * // Returns an array of all keys part of the union.
		     * const basePartKeys = Modding.inspect<InstancePropertyNames<BasePart>[]>();
		     * ```
		     *
		     * @metadata macro
		     
	]]
	local function inspect(value)
		local _value = value
		assert(_value)
		return value
	end
	_container.inspect = inspect
	--[[
		*
		     * This API allows you to use more complex queries, inspect types, generate arbitrary objects based on types, etc.
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * Hashes a string literal type (such as an event name) under Flamework's {@link Many `Many`} API.
		     *
		     * The second type argument, `C`, is for providing a context to the hashing which will generate new hashes
		     * for strings which already have a hash under another context.
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * This is equivalent to {@link Hash `Hash`} except it will only hash strings when `obfuscation` is turned on.
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * Retrieves the labels from this tuple under Flamework's {@link Many `Many`} API.
		     *
		     * This can also be used to extract parameter names via `Parameters<T>`
		     *
		     * @experimental This API is considered experimental and may change.
		     
	]]
	--[[
		*
		     * Retrieves metadata about the specified type using Flamework's user macros.
		     
	]]
	--[[
		*
		     * Retrieves multiple types of metadata from Flamework's user macros.
		     
	]]
	--[[
		*
		     * Retrieves metadata about the callsite using Flamework's user macros.
		     
	]]
	--[[
		*
		     * Retrieves multiple types of metadata about the callsite using Flamework's user macros.
		     
	]]
	--[[
		*
		     * An internal type for intrinsic user macro metadata.
		     *
		     * @hidden
		     
	]]
	function defineDecoratorMetadata(descriptor, config)
		local propertyKey = if descriptor.isStatic then `static:{descriptor.property}` else descriptor.property
		Reflect.defineMetadata(descriptor.object, `flamework:decorators.{descriptor.id}`, {
			arguments = config,
		}, propertyKey)
		local decoratorList = Reflect.getMetadata(descriptor.object, `flamework:decorators`, propertyKey)
		if not decoratorList then
			local _exp = descriptor.object
			decoratorList = {}
			Reflect.defineMetadata(_exp, "flamework:decorators", decoratorList, propertyKey)
		end
		local _decoratorList = decoratorList
		local _id = descriptor.id
		table.insert(_decoratorList, _id)
	end
end
function getDeferredConstructor(ctor)
	local obj = setmetatable({}, ctor)
	return { obj, function(...)
		local args = { ... }
		local result = obj:constructor(unpack(args))
		local _arg0 = result == nil or result == obj
		local _arg1 = `Deferred constructors are not allowed to return values.`
		assert(_arg0, _arg1)
	end }
end
return {
	Modding = Modding,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="23">
                <Properties>
                  <string name="Name">prelude</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * This file contains preludes for the transformer.
	 *
	 * This is primarily necessary due to a bug with the `@rbxts/t` package.
	 
]]
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
return {
	t = t,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="24">
                <Properties>
                  <string name="Name">reflect</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local isConstructor = TS.import(script, script.Parent, "utility").isConstructor
--[[
	*
	 * Reflection/metadata API
	 
]]
local Reflect = {}
do
	local _container = Reflect
	--* object -> property -> key -> value 
	local metadata = setmetatable({}, {
		__mode = "k",
	})
	local objToId = {}
	--* @internal 
	local decorators = {}
	_container.decorators = decorators
	--* @internal 
	local idToObj = {}
	_container.idToObj = idToObj
	local NO_PROP_MARKER = {}
	local function getObjMetadata(obj, prop, create)
		local _condition = prop
		if _condition == nil then
			_condition = NO_PROP_MARKER
		end
		local realProp = _condition
		if create then
			local _obj = obj
			local objMetadata = metadata[_obj]
			if not objMetadata then
				local _exp = obj
				objMetadata = {}
				local _objMetadata = objMetadata
				metadata[_exp] = _objMetadata
			end
			local propMetadata = objMetadata[realProp]
			if not propMetadata then
				local _objMetadata = objMetadata
				propMetadata = {}
				local _propMetadata = propMetadata
				_objMetadata[realProp] = _propMetadata
			end
			return propMetadata
		else
			local _obj = obj
			local _result = metadata[_obj]
			if _result ~= nil then
				_result = _result[realProp]
			end
			return _result
		end
	end
	local function getParentConstructor(obj)
		local metatable = getmetatable(obj)
		if metatable and type(metatable) == "table" then
			return rawget(metatable, "__index")
		end
	end
	--[[
		*
		     * Apply metadata onto this object.
		     
	]]
	local function defineMetadata(obj, key, value, property)
		-- 'identifier' is a special, unique ID across all metadata classes.
		if key == "identifier" then
			local _value = value
			local _arg0 = type(_value) == "string"
			assert(_arg0, "identifier must be a string.")
			local _obj = obj
			local _arg0_1 = not (objToId[_obj] ~= nil)
			assert(_arg0_1, "obj is already registered.")
			local _value_1 = value
			local _arg0_2 = not (idToObj[_value_1] ~= nil)
			assert(_arg0_2, "id is already registered.")
			local _obj_1 = obj
			local _value_2 = value
			objToId[_obj_1] = _value_2
			local _value_3 = value
			local _obj_2 = obj
			idToObj[_value_3] = _obj_2
		end
		local metadata = getObjMetadata(obj, property, true)
		local _key = key
		local _value = value
		metadata[_key] = _value
	end
	_container.defineMetadata = defineMetadata
	--[[
		*
		     * Apply metadata in batch onto this object.
		     
	]]
	local function defineMetadataBatch(obj, list, property)
		local metadata = getObjMetadata(obj, property, true)
		for key, value in pairs(list) do
			metadata[key] = value
		end
	end
	_container.defineMetadataBatch = defineMetadataBatch
	--[[
		*
		     * Delete metadata from this object.
		     
	]]
	local function deleteMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result[_key] = nil
		end
	end
	_container.deleteMetadata = deleteMetadata
	--[[
		*
		     * Get metadata from this object.
		     * Type parameter is an assertion.
		     
	]]
	local function getOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result = _result[_key]
		end
		return _result
	end
	_container.getOwnMetadata = getOwnMetadata
	--[[
		*
		     * Check if this object has the specified metadata key.
		     
	]]
	local function hasOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result = _result[_key] ~= nil
		end
		local _condition = _result
		if _condition == nil then
			_condition = false
		end
		return _condition
	end
	_container.hasOwnMetadata = hasOwnMetadata
	--[[
		*
		     * Retrieve all metadata keys for this object.
		     
	]]
	local function getOwnMetadataKeys(obj, property)
		local metadata = getObjMetadata(obj, property)
		local keys = {}
		local _result = metadata
		if _result ~= nil then
			-- ▼ ReadonlyMap.forEach ▼
			local _callback = function(_, key)
				local _key = key
				table.insert(keys, _key)
				return #keys
			end
			for _k, _v in _result do
				_callback(_v, _k, _result)
			end
			-- ▲ ReadonlyMap.forEach ▲
		end
		return keys
	end
	_container.getOwnMetadataKeys = getOwnMetadataKeys
	--[[
		*
		     * Retrieves all properties (that contain metadata) on this object.
		     
	]]
	local function getOwnProperties(obj)
		local _obj = obj
		local properties = metadata[_obj]
		if not properties then
			return {}
		end
		local keys = {}
		for key in properties do
			if key ~= NO_PROP_MARKER then
				table.insert(keys, key)
			end
		end
		return keys
	end
	_container.getOwnProperties = getOwnProperties
	--[[
		*
		     * Retrieve all values for the specified key from the object and its parents.
		     * Type parameter is an assertion.
		     
	]]
	local function getMetadatas(obj, key, property)
		local values = {}
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			table.insert(values, value)
		end
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadatas(parent, key, property)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(value)
				local _value = value
				table.insert(values, _value)
				return #values
			end
			for _k, _v in _exp do
				_callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		return values
	end
	_container.getMetadatas = getMetadatas
	--[[
		*
		     * Get metadata from this object or its parents.
		     * Type parameter is an assertion.
		     
	]]
	local function getMetadata(obj, key, property)
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return getMetadata(parent, key, property)
		end
	end
	_container.getMetadata = getMetadata
	--[[
		*
		     * Check if this object or any of its parents has the specified metadata key.
		     
	]]
	local function hasMetadata(obj, key, property)
		local value = hasOwnMetadata(obj, key, property)
		if value then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return hasMetadata(parent, key, property)
		end
		return false
	end
	_container.hasMetadata = hasMetadata
	--[[
		*
		     * Retrieve all metadata keys for this object and its parents.
		     
	]]
	local function getMetadataKeys(obj, property)
		local _set = {}
		for _, _v in getOwnMetadataKeys(obj, property) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadataKeys(parent, property)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(key)
				local _key = key
				keys[_key] = true
				return keys
			end
			for _k, _v in _exp do
				_callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local _array = {}
		local _length = #_array
		for _v in keys do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	_container.getMetadataKeys = getMetadataKeys
	--[[
		*
		     * Retrieves all properties (that contain metadata) on this object and its parents.
		     
	]]
	local function getProperties(obj)
		local _set = {}
		for _, _v in getOwnProperties(obj) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getProperties(parent)
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(key)
				local _key = key
				keys[_key] = true
				return keys
			end
			for _k, _v in _exp do
				_callback(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local _array = {}
		local _length = #_array
		for _v in keys do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	_container.getProperties = getProperties
	--* @hidden 
	local function decorate(object, id, rawDecoration, args, property, isStatic)
		if isStatic == nil then
			isStatic = false
		end
		local decoration = rawDecoration
		local descriptor = {
			id = id,
			isStatic = isStatic,
			object = object,
			constructor = if isConstructor(object) then object else nil,
			property = property,
		}
		if property == nil then
			local _id = id
			local decoratedObjects = decorators[_id]
			if not decoratedObjects then
				local _exp = id
				decoratedObjects = {}
				local _decoratedObjects = decoratedObjects
				decorators[_exp] = _decoratedObjects
			end
			local _decoratedObjects = decoratedObjects
			local _object = object
			table.insert(_decoratedObjects, _object)
		end
		decoration.func(descriptor, args)
	end
	_container.decorate = decorate
	--* @hidden Internal use, do not use 
	local function resetObject(object)
		local _object = object
		local id = objToId[_object]
		if id ~= nil then
			local _object_1 = object
			objToId[_object_1] = nil
			idToObj[id] = nil
		end
		local _object_1 = object
		metadata[_object_1] = nil
	end
	_container.resetObject = resetObject
end
return {
	Reflect = Reflect,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="25">
                <Properties>
                  <string name="Name">utility</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--* @hidden 
local isAbstractConstructor
local function isConstructor(obj)
	return isAbstractConstructor(obj) and obj.new ~= nil
end
function isAbstractConstructor(obj)
	return obj.constructor ~= nil
end
return {
	isConstructor = isConstructor,
	isAbstractConstructor = isAbstractConstructor,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="26">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	dependencies = {
		["@rbxts/maid"] = "^1.0.0-ts.1",
		["@rbxts/object-utils"] = "^1.0.4",
		["@rbxts/services"] = "^1.1.4",
		["@rbxts/signal"] = "^1.0.3",
		["@rbxts/t"] = "^3.2.1",
	},
	description = "",
	devDependencies = {
		["@rbxts/compiler-types"] = "^3.0.0-types.0",
		["@rbxts/types"] = "^1.0.846",
		["@typescript-eslint/eslint-plugin"] = "^6.7.4",
		["@typescript-eslint/parser"] = "^6.7.4",
		eslint = "^7.32.0",
		["eslint-config-prettier"] = "^8.3.0",
		["eslint-plugin-prettier"] = "^3.4.0",
		["eslint-plugin-roblox-ts"] = "0.0.25",
		prettier = "^2.8.8",
		["roblox-ts"] = "^3.0.0",
		typescript = "^5.5.3",
	},
	files = {"out", "flamework.build"},
	homepage = "https://github.com/FireTS/rbxts-flamework",
	keywords = {},
	license = "ISC",
	main = "out/init.lua",
	name = "@flamework/core",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/FireTS/rbxts-flamework.git",
	},
	scripts = {
		build = "rbxtsc",
		prepare = "rbxtsc",
		watch = "rbxtsc -w",
	},
	types = "out/index.d.ts",
	version = "1.3.1",
}</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="27">
          <Properties>
            <string name="Name">@rbxts</string>
          </Properties>
          <Item class="Folder" referent="28">
            <Properties>
              <string name="Name">character-promise</string>
            </Properties>
            <Item class="ModuleScript" referent="29">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.9
local TS = _G[script]
local validateTree = TS.import(script, TS.getModule(script, "@rbxts", "validate-tree")).validateTree
local promiseTree = function(object, tree, timeout)
	if validateTree(object, tree) then
		return TS.Promise.resolve(object)
	end
	local connections = {}
	local _fn = TS.Promise
	local _condition = timeout
	if _condition == nil then
		_condition = 5
	end
	local warner = _fn.delay(_condition)
	local promise = TS.Promise.new(function(resolve, reject, onCancel)
		onCancel(function()
			local _arg0 = function(c)
				return c:Disconnect()
			end
			-- ▼ ReadonlyArray.forEach ▼
			for _k, _v in ipairs(connections) do
				_arg0(_v, _k - 1, connections)
			end
			-- ▲ ReadonlyArray.forEach ▲
			warner:cancel()
		end)
		local updateTree = function(violators)
			if validateTree(object, tree, violators) then
				resolve(object)
			end
		end
		for _, d in ipairs(object:GetDescendants()) do
			local _arg0 = d:GetPropertyChangedSignal("Name"):Connect(updateTree)
			-- ▼ Array.push ▼
			connections[#connections + 1] = _arg0
			-- ▲ Array.push ▲
		end
		local _arg0 = object.DescendantAdded:Connect(function(descendant)
			local _arg0_1 = descendant:GetPropertyChangedSignal("Name"):Connect(updateTree)
			-- ▼ Array.push ▼
			connections[#connections + 1] = _arg0_1
			-- ▲ Array.push ▲
			updateTree()
		end)
		-- ▼ Array.push ▼
		connections[#connections + 1] = _arg0
		-- ▲ Array.push ▲
		local _arg0_1 = function()
			local violators = {}
			if not validateTree(object, tree, violators) then
				local _arg0_2 = function(c)
					return c:Disconnect()
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _k, _v in ipairs(connections) do
					_arg0_2(_v, _k - 1, connections)
				end
				-- ▲ ReadonlyArray.forEach ▲
				reject("[promiseTree] Infinite wait possible. Waiting for: " .. table.concat(violators, ", "))
			end
		end
		warner:andThen(_arg0_1)
	end)
	promise:finally(function()
		local _arg0 = function(c)
			return c:Disconnect()
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _k, _v in ipairs(connections) do
			_arg0(_v, _k - 1, connections)
		end
		-- ▲ ReadonlyArray.forEach ▲
		warner:cancel()
	end)
	return promise
end
local characterR6 = {
	["$className"] = "Model",
	Head = {
		["$className"] = "Part",
		FaceCenterAttachment = "Attachment",
		FaceFrontAttachment = "Attachment",
		HairAttachment = "Attachment",
		HatAttachment = "Attachment",
	},
	HumanoidRootPart = {
		["$className"] = "BasePart",
		RootAttachment = "Attachment",
		RootJoint = "Motor6D",
	},
	Humanoid = {
		["$className"] = "Humanoid",
		Animator = "Animator",
		HumanoidDescription = "HumanoidDescription",
	},
	["Left Arm"] = {
		["$className"] = "BasePart",
		LeftGripAttachment = "Attachment",
		LeftShoulderAttachment = "Attachment",
	},
	["Left Leg"] = {
		["$className"] = "BasePart",
		LeftFootAttachment = "Attachment",
	},
	["Right Arm"] = {
		["$className"] = "BasePart",
		RightGripAttachment = "Attachment",
		RightShoulderAttachment = "Attachment",
	},
	["Right Leg"] = {
		["$className"] = "BasePart",
		RightFootAttachment = "Attachment",
	},
	Torso = {
		["$className"] = "BasePart",
		["Left Hip"] = "Motor6D",
		["Left Shoulder"] = "Motor6D",
		["Right Hip"] = "Motor6D",
		["Right Shoulder"] = "Motor6D",
		Neck = "Motor6D",
		BodyBackAttachment = "Attachment",
		BodyFrontAttachment = "Attachment",
		LeftCollarAttachment = "Attachment",
		NeckAttachment = "Attachment",
		RightCollarAttachment = "Attachment",
		WaistBackAttachment = "Attachment",
		WaistCenterAttachment = "Attachment",
		WaistFrontAttachment = "Attachment",
	},
	["Body Colors"] = "BodyColors",
}
local characterR15 = {
	["$className"] = "Model",
	HumanoidRootPart = {
		["$className"] = "BasePart",
		RootRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		OriginalSize = "Vector3Value",
	},
	LeftHand = {
		["$className"] = "MeshPart",
		LeftWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftGripAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftWrist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftLowerArm = {
		["$className"] = "MeshPart",
		LeftElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftElbow = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftUpperArm = {
		["$className"] = "MeshPart",
		LeftShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulderAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulder = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightHand = {
		["$className"] = "MeshPart",
		RightWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightGripAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightWrist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightLowerArm = {
		["$className"] = "MeshPart",
		RightElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightWristRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightElbow = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightUpperArm = {
		["$className"] = "MeshPart",
		RightShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightElbowRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulderAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulder = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	UpperTorso = {
		["$className"] = "MeshPart",
		WaistRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightShoulderRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		BodyFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		BodyBackAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftCollarAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightCollarAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Waist = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftFoot = {
		["$className"] = "MeshPart",
		LeftAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftAnkle = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftLowerLeg = {
		["$className"] = "MeshPart",
		LeftKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftKnee = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LeftUpperLeg = {
		["$className"] = "MeshPart",
		LeftHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftHip = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightFoot = {
		["$className"] = "MeshPart",
		RightAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightAnkle = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightLowerLeg = {
		["$className"] = "MeshPart",
		RightKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightAnkleRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightKnee = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	RightUpperLeg = {
		["$className"] = "MeshPart",
		RightHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightKneeRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightHip = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	LowerTorso = {
		["$className"] = "MeshPart",
		RootRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		LeftHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		RightHipRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistCenterAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		WaistBackAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Root = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	Humanoid = {
		["$className"] = "Humanoid",
		Animator = "Animator",
		BodyTypeScale = "NumberValue",
		BodyProportionScale = "NumberValue",
		BodyWidthScale = "NumberValue",
		BodyHeightScale = "NumberValue",
		BodyDepthScale = "NumberValue",
		HeadScale = "NumberValue",
		HumanoidDescription = "HumanoidDescription",
	},
	Head = {
		["$className"] = "MeshPart",
		FaceCenterAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		FaceFrontAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		HairAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		HatAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		NeckRigAttachment = {
			["$className"] = "Attachment",
			OriginalPosition = "Vector3Value",
		},
		Neck = "Motor6D",
		OriginalSize = "Vector3Value",
	},
	["Body Colors"] = "BodyColors",
}
local promiseR6 = function(obj, timeout)
	return promiseTree(obj, characterR6, timeout)
end
local promiseR15 = function(obj, timeout)
	return promiseTree(obj, characterR15, timeout)
end
local validateR6 = function(obj)
	return validateTree(obj, characterR6)
end
local validateR15 = function(obj)
	return validateTree(obj, characterR15)
end
local findR6 = function(obj)
	return if validateTree(obj, characterR6) then obj else nil
end
local findR15 = function(obj)
	return if validateTree(obj, characterR15) then obj else nil
end
return {
	promiseR6 = promiseR6,
	promiseR15 = promiseR15,
	validateR6 = validateR6,
	validateR15 = validateR15,
	findR6 = findR6,
	findR15 = findR15,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="30">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	dependencies = {
		["@rbxts/validate-tree"] = "^2.0.1",
	},
	description = "",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.2.4-types.0",
		["@rbxts/types"] = "^1.0.541",
		["@typescript-eslint/eslint-plugin"] = "^5.1.0",
		["@typescript-eslint/parser"] = "^5.1.0",
		eslint = "^8.0.1",
		["eslint-config-prettier"] = "^8.3.0",
		["eslint-plugin-prettier"] = "^4.0.0",
		["eslint-plugin-roblox-ts"] = "^0.0.32",
		prettier = "^2.4.1",
		typescript = "^4.4.4",
	},
	files = {"out"},
	keywords = {},
	license = "ISC",
	main = "out/init.lua",
	name = "@rbxts/character-promise",
	publishConfig = {
		access = "public",
	},
	scripts = {
		build = "rbxtsc",
		prepublishOnly = "npm run build",
		watch = "rbxtsc -w",
	},
	types = "out/index.d.ts",
	version = "1.0.2",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="31">
            <Properties>
              <string name="Name">charm</string>
              <string name="Source"><![CDATA[local src = require(script.src)

export type Atom<State> = src.Atom<State>
export type Selector<State> = src.Selector<State>
export type Molecule<State> = src.Selector<State>

return src
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="32">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	description = "An atomic state management library for Roblox",
	license = "MIT",
	main = "init.luau",
	name = "@rbxts/charm",
	repository = "littensy/charm",
	scripts = {
		["publish:wally"] = "wally publish",
	},
	types = "index.d.ts",
	version = "0.10.0",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="33">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[local atom = require(script.atom)
local computed = require(script.computed)
local effect = require(script.effect)
local mapped = require(script.mapped)
local observe = require(script.observe)
local store = require(script.store)
local subscribe = require(script.subscribe)
local types = require(script.types)

export type Atom<State> = types.Atom<State>
export type Selector<State> = types.Selector<State>
export type Molecule<State> = types.Selector<State>

return {
	atom = atom,
	computed = computed,
	effect = effect,
	mapped = mapped,
	observe = observe,
	subscribe = subscribe,
	batch = store.batch,
	capture = store.capture,
	isAtom = store.isAtom,
	notify = store.notify,
	peek = store.peek,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="34">
                <Properties>
                  <string name="Name">atom</string>
                  <string name="Source"><![CDATA[local store = require(script.Parent.store)
local types = require(script.Parent.types)
type Atom<T> = types.Atom<T>
type AtomOptions<T> = types.AtomOptions<T>

--[=[
	Creates a new atom with the given state.
	
	@param state The initial state.
	@param options Optional configuration.
	@return A new atom.
]=]
local function atom<T>(state: T, options: AtomOptions<T>?): Atom<T>
	local equals = options and options.equals

	local function atom(...)
		if select("#", ...) == 0 then
			local index = store.capturing.index

			if index > 0 then
				store.capturing.stack[index][atom] = true
			end

			return state
		end

		local nextState = store.peek(..., state)

		if state ~= nextState and not (equals and equals(state, nextState)) then
			state = nextState
			store.notify(atom)
		end

		return state
	end

	store.listeners[atom] = setmetatable({}, { __mode = "v" })

	return atom
end

return atom
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="35">
                <Properties>
                  <string name="Name">computed</string>
                  <string name="Source"><![CDATA[local atom = require(script.Parent.atom)
local store = require(script.Parent.store)
local types = require(script.Parent.types)
type AtomOptions<T> = types.AtomOptions<T>
type Selector<T> = types.Selector<T>

--[=[
	Creates a read-only atom that derives its state from one or more atoms.
	Used to avoid unnecessary recomputations if multiple listeners depend on
	the same atoms.

	@param callback The function that produces the state.
	@param options Optional configuration.
	@return A new read-only atom.
]=]
local function computed<T>(callback: Selector<T>, options: AtomOptions<T>?): Selector<T>
	local dependencies, state = store.capture(callback)
	local computedAtom = atom(state, options)
	local computedRef = setmetatable({ current = computedAtom }, { __mode = "v" })

	local function listener()
		local computedAtom = computedRef.current

		if computedAtom then
			store.disconnect(dependencies, listener)
			dependencies, state = store.capture(callback)
			store.connect(dependencies, listener, computedAtom)
			computedAtom(state)
		end
	end

	store.connect(dependencies, listener, computedAtom)

	return computedAtom
end

return computed
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="36">
                <Properties>
                  <string name="Name">effect</string>
                  <string name="Source"><![CDATA[local store = require(script.Parent.store)

type Cleanup = () -> ()

--[=[
	Runs the given callback immediately and whenever any atom it depends on
	changes. Returns a cleanup function that unsubscribes the callback.
	
	@param callback The function to run.
	@return A function that unsubscribes the callback.
]=]
local function effect(callback: (cleanup: Cleanup) -> Cleanup?): Cleanup
	local dependencies = {}
	local cleanup: Cleanup?
	local disconnected = false
	local disconnect

	local function listener()
		if cleanup then
			cleanup()
		end

		store.disconnect(dependencies, listener)
		dependencies, cleanup = store.capture(callback, disconnect)

		if not disconnected then
			store.connect(dependencies, listener)
		end
	end

	function disconnect()
		if disconnected then
			return
		end

		disconnected = true
		store.disconnect(dependencies, listener)

		if cleanup then
			cleanup()
		end
	end

	dependencies, cleanup = store.capture(callback, disconnect)

	if not disconnected then
		store.connect(dependencies, listener)
	end

	return disconnect
end

return effect :: (callback: ((cleanup: Cleanup) -> ()) | ((cleanup: Cleanup) -> Cleanup?)) -> Cleanup
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="37">
                <Properties>
                  <string name="Name">mapped</string>
                  <string name="Source"><![CDATA[local atom = require(script.Parent.atom)
local store = require(script.Parent.store)
local subscribe = require(script.Parent.subscribe)
local types = require(script.Parent.types)
type Atom<T> = types.Atom<T>
type Selector<T> = types.Selector<T>

type Map =
	(<K0, V0, K1, V1>(fn: Selector<{ [K0]: V0 }>, mapper: (V0, K0) -> (V1?, K1)) -> Selector<{ [K1]: V1 }>)
	& (<K0, V0, V1>(fn: Selector<{ [K0]: V0 }>, mapper: (V0, K0) -> V1?) -> Selector<{ [K0]: V1 }>)
	& (<K0, V0, K1, V1>(fn: Selector<{ [K0]: V0 }>, mapper: (V0, K0) -> (V1?, K1?)) -> Selector<{ [K1]: V1 }>)

--[=[
	Maps each entry in the atom's state to a new key-value pair. If the `mapper`
	function returns `undefined`, the entry is omitted from the resulting map.
	When the atom changes, the `mapper` is called for each entry in the state
	to compute the new state.
	
	@param callback The atom or selector to map.
	@param mapper The function that maps each entry.
	@return A new atom with the mapped state.
]=]
local function mapped<K0, V0, K1, V1>(callback: Selector<{ [K0]: V0 }>, mapper: (V0, K0) -> (V1?, K1?)): Selector<{ [K1]: V1 }>
	local mappedAtom = atom({})
	local mappedAtomRef = setmetatable({ current = mappedAtom }, { __mode = "v" })
	local prevMappedItems: { [K1]: V1 } = {}
	local unsubscribe

	local function listener(items: { [K0]: V0 })
		local mappedAtom = mappedAtomRef.current

		if not mappedAtom then
			return unsubscribe()
		end

		local mappedItems = table.clone(mappedAtom())
		local mappedKeys = {}

		-- TODO: Only call mapper if the item has changed.
		for key, item in next, items do
			local newItem, newKey = mapper(item, key)
			if newKey == nil then
				newKey = key :: any
			end
			if mappedItems[newKey :: K1] ~= newItem then
				mappedItems[newKey :: K1] = newItem :: V1
			else
				mappedKeys[newKey] = key
			end
		end

		for key in next, prevMappedItems do
			if mappedKeys[key] == nil and mappedItems[key] == prevMappedItems[key] then
				mappedItems[key] = nil
			end
		end

		prevMappedItems = mappedItems
		mappedAtom(mappedItems)
	end

	unsubscribe = subscribe(callback, listener)

	store.peek(function(): ()
		listener(callback())
	end)

	return mappedAtom
end

return mapped :: Map
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">observe</string>
                  <string name="Source"><![CDATA[local store = require(script.Parent.store)
local subscribe = require(script.Parent.subscribe)
local types = require(script.Parent.types)
type Selector<T> = types.Selector<T>

local function noop() end

--[=[
	Creates an instance of `factory` for each item in the atom's state, and
	cleans up the instance when the item is removed. Returns a cleanup function
	that unsubscribes all instances.
	
	@param callback The atom or selector to observe.
	@param factory The function that tracks the lifecycle of each item.
	@return A function that unsubscribes all instances.
]=]
local function observe<K, V>(callback: Selector<{ [K]: V }>, factory: (value: V, key: K) -> (() -> ())?): () -> ()
	local connections: { [K]: () -> () } = {}

	local function listener(state: { [K]: V })
		for key, disconnect in next, connections do
			if state[key] == nil then
				connections[key] = nil
				disconnect()
			end
		end

		for key, value in next, state do
			if not connections[key] then
				connections[key] = factory(value, key) or noop
			end
		end
	end

	local unsubscribe = subscribe(callback, listener)

	store.peek(function(): ()
		listener(callback())
	end)

	return function()
		unsubscribe()
		for _, disconnect in next, connections do
			disconnect()
		end
		table.clear(connections)
	end
end

return observe
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="39">
                <Properties>
                  <string name="Name">store</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.types)
type Atom<T> = types.Atom<T>
type Set<T> = types.Set<T>
type WeakMap<K, V> = types.WeakMap<K, V>

local __DEV__ = _G.__DEV__

local listeners: WeakMap<Atom<any>, WeakMap<() -> (), unknown>> = setmetatable({}, { __mode = "k" })

local batched: Set<() -> ()> = {}
local batching = false

local capturing = {
	stack = {} :: { Set<Atom<any>> },
	index = 0,
}

--[=[
	Calls the given function and returns the result. If the function yields or
	throws an error, the thread is closed and an error is thrown. Regardless of
	the outcome, the `finally` function is called to clean up any resources.
	
	@param callback The function to run.
	@param finally Cleanup logic to run before error handling.
	@param ... Arguments to pass to the callback.
	@return The result of the callback.
]=]
local function try<T, U...>(callback: (U...) -> T | any, finally: (() -> ())?, ...: U...): T
	if __DEV__ then
		local thread = coroutine.create(callback)
		local success, result = coroutine.resume(thread, ...)

		if finally then
			finally()
		end

		if coroutine.status(thread) == "suspended" then
			local source, line, name = debug.info(callback, "sln")

			coroutine.close(thread)

			error(
				"Yielding is not allowed in atom functions. Consider wrapping this code in a Promise or task.defer instead."
					.. `\nFunction defined at: {source}:{line}`
					.. if name == "" then "" else ` function {name}`
			)
		elseif not success then
			local source, line, name = debug.info(callback, "sln")

			error(
				"An error occurred while running an atom function"
					.. `\nFunction defined at: {source}:{line}`
					.. (if name == "" then "" else ` function {name}`)
					.. `\nError: {result}`
			)
		end

		return result
	end

	if not finally then
		return callback(...)
	end

	local success, result = pcall(callback, ...)

	finally()
	assert(success, result)

	return result
end

--[=[
	Returns whether the given value is an atom.

	@param value The value to check.
	@return `true` if the value is an atom, otherwise `false`.
]=]
local function isAtom(value: any): boolean
	return not not (value and listeners[value])
end

--[=[
	Notifies all subscribers of the given atom that the state has changed.
	
	@param atom The atom to notify.
]=]
local function notify(atom: Atom<any>)
	if batching then
		for listener in next, listeners[atom] do
			batched[listener] = true
		end
		return
	end

	for listener in next, table.clone(listeners[atom]) do
		try(listener)
	end
end

--[=[
	Returns the result of the function without subscribing to changes. If a
	non-function value is provided, it is returned as is.
	
	@param callback The atom or selector to get the state of.
	@param args Arguments to pass to the function.
	@return The current state.
]=]
local function peek<T, U...>(callback: ((U...) -> T) | T, ...: U...): T
	if type(callback) ~= "function" then
		return callback
	end

	if capturing.index == 0 then
		return callback(...)
	end

	capturing.index += 1
	capturing.stack[capturing.index] = {}

	local result = try(callback, function()
		capturing.stack[capturing.index] = nil
		capturing.index -= 1
	end, ...)

	return result
end

--[=[
	Captures all atoms that are read during the function call and returns them
	along with the result of the function. Useful for tracking dependencies.
	
	@param callback The function to run.
	@return A tuple containing the captured atoms and the result of the function.
]=]
local function capture<T, U...>(callback: (U...) -> T, ...: U...): (Set<Atom<any>>, T)
	-- If the callback is an atom, return it immediately
	if listeners[callback :: any] then
		return { [callback :: any] = true }, peek(callback)
	end

	local dependencies: Set<Atom<any>> = {}

	capturing.index += 1
	capturing.stack[capturing.index] = dependencies

	local result = try(callback, function()
		capturing.stack[capturing.index] = nil
		capturing.index -= 1
	end, ...)

	return dependencies, result
end

--[=[
	Runs the given function and schedules listeners to be notified only once
	after the function has completed. Useful for batching multiple changes.
	
	@param callback The function to run.
]=]
local function batch(callback: () -> ())
	if batching then
		return callback()
	end

	batching = true

	try(callback, function()
		batching = false
	end)

	for listener in next, batched do
		try(listener)
	end

	table.clear(batched)
end

--[=[
	Subscribes the listener to the changes of the given atoms.
	
	@param atoms The atoms to listen to.
	@param listener The function to call when the atoms change.
	@param ref Optionally bind the lifetime of the listener to a value.
]=]
local function connect(atoms: Set<Atom<any>>, listener: () -> (), ref: unknown?)
	for atom in next, atoms do
		listeners[atom][listener] = ref or true
	end
end

--[=[
	Unsubscribes the listener from every atom it was connected to.
	
	@param atoms The atoms to stop listening to.
	@param listener The function to stop calling when the atoms change.
]=]
local function disconnect(atoms: Set<Atom<any>>, listener: () -> ())
	for atom in next, atoms do
		listeners[atom][listener] = nil
	end
end

return {
	listeners = listeners,
	capturing = capturing,
	isAtom = isAtom,
	notify = notify,
	capture = capture,
	batch = batch,
	peek = peek,
	connect = connect,
	disconnect = disconnect,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="40">
                <Properties>
                  <string name="Name">subscribe</string>
                  <string name="Source"><![CDATA[local store = require(script.Parent.store)
local types = require(script.Parent.types)
type Selector<T> = types.Selector<T>

--[=[
	Subscribes to changes in the given atom or selector. The callback is
	called with the current state and the previous state immediately after a
	change occurs.
	
	@param callback The atom or selector to subscribe to.
	@param listener The function to call when the state changes.
	@return A function that unsubscribes the callback.
]=]
local function subscribe<T>(callback: Selector<T>, listener: (state: T, prev: T) -> ()): () -> ()
	local dependencies, state = store.capture(callback)
	local disconnected = false

	local function handler()
		local prevState = state

		store.disconnect(dependencies, handler)
		dependencies, state = store.capture(callback)

		if not disconnected then
			store.connect(dependencies, handler)
		end

		if state ~= prevState then
			listener(state, prevState)
		end
	end

	store.connect(dependencies, handler)

	return function()
		if not disconnected then
			disconnected = true
			store.disconnect(dependencies, handler)
		end
	end
end

return subscribe
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="41">
                <Properties>
                  <string name="Name">types</string>
                  <string name="Source"><![CDATA[export type Set<T> = { [T]: true }

export type WeakMap<K, V> = typeof(setmetatable({} :: { [K]: V }, { __mode = "k" }))

--[=[
	A primitive state container that can be read from and written to. When the
	state changes, all subscribers are notified.

	@param state The next state or a function that produces the next state.
	@return The current state, if no arguments are provided.
]=]
export type Atom<T> = (state: (T | (T) -> T)?) -> T

--[=[
	A function that depends on one or more atoms and produces a state. Can be
	used to derive state from atoms.

	@template State The type of the state.
	@return The current state.
]=]
export type Selector<T> = () -> T

--[=[
	Optional configuration for creating an atom.
]=]
export type AtomOptions<T> = {
	--[=[
		A function that determines whether the state has changed. By default,
		a strict equality check (`===`) is used.
	]=]
	equals: (prev: T, next: T) -> boolean,
}

return nil
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="42">
              <Properties>
                <string name="Name">wally</string>
                <string name="Source">return {
	dependencies = {
	},
	package = {
		exclude = {"package.json", "node_modules"},
		include = {"LICENSE.md"},
		name = "littensy/charm",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "0.10.0",
	},
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="43">
            <Properties>
              <string name="Name">charm-sync</string>
              <string name="Source"><![CDATA[local src = require(script.src)

export type SyncPayload = src.SyncPayload

return src
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="44">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	description = "Sync server state with clients using Charm",
	license = "MIT",
	main = "init.luau",
	name = "@rbxts/charm-sync",
	peerDependencies = {
		["@rbxts/charm"] = "0.10.0",
	},
	repository = "littensy/charm",
	scripts = {
		["publish:wally"] = "wally publish",
	},
	types = "index.d.ts",
	version = "0.3.0",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="45">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[local client = require(script.client)
local flatten = require(script.flatten)
local patch = require(script.patch)
local server = require(script.server)
local types = require(script.types)

export type SyncPayload = types.SyncPayload

--[=[
	Synchronizes state between the client and server. The server sends patches
	to the client, which applies them to its local state.
]=]
return {
	client = client,
	server = server,
	flatten = flatten,
	isNone = patch.isNone,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="46">
                <Properties>
                  <string name="Name">client</string>
                  <string name="Source"><![CDATA[local Charm = require(script.Parent.Parent.Parent.charm)
local patch = require(script.Parent.patch)
local types = require(script.Parent.types)
type AtomMap = types.AtomMap
type SyncPayload = types.SyncPayload

type ClientOptions = {
	--[=[
		The atoms to synchronize with the server.
	]=]
	atoms: AtomMap,
	--[=[
		Whether to ignore patches sent before the client has been hydrated.
		Default is `true`.
	]=]
	ignoreUnhydrated: boolean?,
}

type ClientSyncer = {
	--[=[
		Applies a patch or initializes the state of the atoms with the given
		payload from the server.
		
		@param ...payloads The patches or hydration payloads to apply.
	]=]
	sync: (self: ClientSyncer, ...SyncPayload) -> (),
}

--[=[
	Creates a `ClientSyncer` object that receives patches from the server and
	applies them to the local state.
	
	@param options The atoms to synchronize with the server.
	@return A `ClientSyncer` object.
]=]
local function client(options: ClientOptions): ClientSyncer
	local atoms = options.atoms
	local ignoreUnhydrated = options.ignoreUnhydrated ~= false

	local self = {} :: ClientSyncer
	local hydrated = false

	local function hydrate(state: { [string | number]: any })
		hydrated = true

		for key, value in next, state do
			local atom = atoms[key]
			atom(value)
		end
	end

	local function apply(data: { [string | number]: any })
		local target = {}

		for key, atom in next, atoms do
			target[key] = atom()
		end

		target = patch.apply(target, data)

		for key, atom in next, atoms do
			atom(target[key])
		end
	end

	function self:sync(...)
		for index = 1, select("#", ...) do
			local payload: SyncPayload = select(index, ...)

			Charm.batch(function()
				if payload.type == "init" then
					hydrate(payload.data)
				elseif not ignoreUnhydrated or hydrated then
					apply(payload.data)
				end
			end)
		end
	end

	return self
end

return client
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="47">
                <Properties>
                  <string name="Name">flatten</string>
                  <string name="Source"><![CDATA[local types = require(script.Parent.types)
type AtomMap = types.AtomMap

type NestedAtomMap = {
	[string]: NestedAtomMap | () -> (),
}

local function flatten(atoms: NestedAtomMap): AtomMap
	local result: AtomMap = {}

	local function visit(node: NestedAtomMap, path: string)
		for key, value in node do
			local location = if path == "" then key else path .. "/" .. key

			if type(value) == "table" then
				visit(value, location)
			else
				result[location] = value
			end
		end
	end

	visit(atoms, "")

	return result
end

return flatten
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="48">
                <Properties>
                  <string name="Name">interval</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

--[=[
	Schedules a function to be called at a fixed interval of `seconds`.
	
	@param callback The function to call.
	@param seconds The interval in seconds.
	@return A function that cancels the interval.
]=]
local function interval(callback: () -> (), seconds: number): () -> ()
	if seconds < 0 then
		return function() end
	end

	local clock = 0

	local connection = RunService.Heartbeat:Connect(function(delta)
		clock += delta
		if clock >= seconds then
			clock = 0
			callback()
		end
	end)

	return function()
		connection:Disconnect()
	end
end

return interval
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="49">
                <Properties>
                  <string name="Name">patch</string>
                  <string name="Source"><![CDATA[local validate = require(script.Parent.validate)

local __DEV__ = _G.__DEV__

--[=[
	A special symbol that denotes the absence of a value. Used to represent
	deleted values in patches.
]=]
local None = { __none = "__none" }

local function isNone(value: any): boolean
	return type(value) == "table" and value.__none == "__none"
end

--[=[
	JSON serialization can drop the last values of a sparse array. For example,
	`{ [1] = 1, [3] = 3 }` becomes `[1]` in some cases. Ambiguity in the
	serialization of sparse arrays can be resolved by converting them to
	dictionaries with string keys.

	The `apply` function will convert these dictionaries back into arrays as
	long as the target array is not sparse. This function ensures that the diff
	function produces a patch that can be correctly applied.
]=]
local function stringifySparseArray(object: { any }): { [string | number]: any }
	local maxn = table.maxn(object)

	if maxn == 0 or maxn == #object then
		-- The object is either not an array or a dense array
		return object
	end

	local dictionary = {}

	for index, value in next, object do
		dictionary[tostring(index)] = value
	end

	return dictionary
end

--[=[
	Compares two states and returns a patch that can be applied to the previous
	state to produce the next state.

	@param prevState The previous state.
	@param nextState The next state.
	@param serialize Whether to convert sparse arrays into dictionaries. Defaults to `true`.
	@returns A patch that can be applied to the previous state.
]=]
local function diff(prevState: { [any]: any }, nextState: { [any]: any }, serialize: boolean?)
	serialize = serialize ~= false

	local patches = table.clone(nextState)

	for key, previous in next, prevState do
		local current = nextState[key]

		if previous == current then
			patches[key] = nil
		elseif current == nil then
			patches[key] = None
		elseif type(previous) == "table" and type(current) == "table" then
			patches[key] = diff(previous, current, serialize)
		end
	end

	-- Coerce sparse array patches into dictionaries
	if serialize and (prevState[1] ~= nil or nextState[1] ~= nil) then
		patches = stringifySparseArray(patches)
	end

	if serialize and __DEV__ then
		for key, value in next, patches do
			validate(value, key)
		end
	end

	return patches
end

--[=[
	Applies a patch to a state and returns the next state.

	@param state The current state.
	@param patches The patches to apply.
	@returns The next state.
]=]
local function apply(state: any, patches: any): any
	if type(patches) == "table" and patches.__none == "__none" then
		return nil
	elseif type(state) ~= "table" or type(patches) ~= "table" then
		return patches
	end

	local nextState = table.clone(state)
	local stateIsArray = state[1] ~= nil

	for key, patch in next, patches do
		-- Diff-checking an array produces a sparse array, which will not be
		-- preserved when converted to JSON. To prevent this, we turn string
		-- keys back into numeric keys.
		if stateIsArray and type(key) == "string" then
			key = tonumber(key) or key
		end

		nextState[key] = apply(nextState[key], patch)
	end

	return nextState
end

return {
	isNone = isNone,
	diff = diff,
	apply = apply,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="50">
                <Properties>
                  <string name="Name">server</string>
                  <string name="Source"><![CDATA[local Players = game:GetService("Players")

local Charm = require(script.Parent.Parent.Parent.charm)
local interval = require(script.Parent.interval)
local patch = require(script.Parent.patch)
local types = require(script.Parent.types)
type AtomMap = types.AtomMap
type SyncPayload = types.SyncPayload

type ServerOptions = {
	--[=[
		The atoms to synchronize with the client.
	]=]
	atoms: AtomMap,
	--[=[
		The interval at which to send patches to the client, in seconds.
		Defaults to `0` (patches are sent up to once per frame). Set to a
		negative value to disable automatic syncing.
	]=]
	interval: number?,
	--[=[
		Whether the history of state changes since the client's last update
		should be preserved. This is useful for values that change multiple times
		per frame, where each individual change is important. Defaults to `false`.
	]=]
	preserveHistory: boolean?,
	--[=[
		When `true`, Charm will apply validation and serialize unsafe arrays
		to address remote event argument limitations. Defaults to `true`.

		This option should be disabled if your network library uses a custom
		serialization method (i.e. Zap, ByteNet) to prevent interference.
	]=]
	autoSerialize: boolean?,
}

type ServerSyncer = {
	--[=[
		Sets up a subscription to each atom that schedules a patch to be sent to
		the client whenever the state changes. When a change occurs, the `callback`
		is called with the player and the payload to send.

		Note that the `payload` object should not be mutated. If you need to
		modify the payload, apply the changes to a copy of the object.

		@param callback The function to call when the state changes.
		@return A cleanup function that unsubscribes all listeners.
	]=]
	connect: (self: ServerSyncer, callback: (player: Player, ...SyncPayload) -> ()) -> () -> (),
	--[=[
		Hydrates the client's state with the server's state. This should be
		called when a player joins the game and requires the server's state.

		@param player The player to hydrate.
	]=]
	hydrate: (self: ServerSyncer, player: Player) -> (),
	--[=[
		@deprecated For internal use only.
	]=]
	_sendPatch: (self: ServerSyncer, player: Player) -> (),
}

--[=[
	Creates a `ServerSyncer` object that sends patches to the client and
	hydrates the client's state.
	
	@param options The atoms to synchronize with the client.
	@return A `ServerSyncer` object.
]=]
local function server(options: ServerOptions): ServerSyncer
	local atoms = options.atoms
	local autoSerialize = options.autoSerialize ~= false
	local preserveHistory = options.preserveHistory
	local syncRate = options.interval or 0

	local self = {} :: ServerSyncer
	local sync: (player: Player, payload: SyncPayload) -> ()

	local function createSnapshot()
		local snapshot = {}

		for key, atom in next, atoms do
			snapshot[key] = atom()
		end

		return snapshot
	end

	-- Send the initial state to a player when they join the server.
	function self:hydrate(player)
		assert(sync, "connect() must be called before hydrate()")

		sync(player, {
			type = "init",
			data = createSnapshot(),
		})
	end

	-- If the history of state changes should be preserved, keep a list of
	-- previous snapshots and diff-check each one from the last.
	if preserveHistory then
		local snapshots = { createSnapshot() }
		local changed = false

		function self:connect(callback)
			local subscriptions = {}

			sync = callback

			local function pushSnapshot(key: string | number, current: any, previous: any)
				local lastSnapshot = snapshots[#snapshots]
				local previousSnapshot = snapshots[#snapshots - 1]

				-- Optimize snapshots by updating the most recent snapshot if the
				-- previous and current values are the same, since this allows us
				-- to group multiple changes into a single snapshot.
				if previousSnapshot and previousSnapshot[key] == previous and lastSnapshot[key] == previous then
					lastSnapshot[key] = current
				else
					local nextSnapshot = table.clone(lastSnapshot)
					nextSnapshot[key] = current
					table.insert(snapshots, nextSnapshot)
				end
			end

			-- Populate the snapshot with the initial state of each atom.
			-- Subscribe to each atom and update the state when it changes.
			for key, atom in next, atoms do
				subscriptions[key] = Charm.subscribe(atom, function(current, previous)
					pushSnapshot(key, current, previous)
					changed = true
				end)
			end

			local disconnect = interval(function()
				if not changed then
					return
				end

				local payloads: { SyncPayload } = {}
				local lastSnapshot

				for index, snapshot in next, snapshots do
					lastSnapshot = snapshot

					if index == 1 then
						continue
					end

					table.insert(payloads, {
						type = "patch",
						data = patch.diff(snapshots[index - 1], snapshot, autoSerialize),
					})
				end

				snapshots = { lastSnapshot }
				changed = false

				for _, player in next, Players:GetPlayers() do
					callback(player, unpack(payloads))
				end
			end, syncRate)

			return function()
				disconnect()

				for _, unsubscribe in next, subscriptions do
					unsubscribe()
				end
			end
		end

		function self:_sendPatch(player: Player)
			assert(sync, "connect() must be called before _sendPatch()")

			if not changed then
				return
			end

			local payloads: { SyncPayload } = {}

			for index, snapshot in next, snapshots do
				if index == 1 then
					continue
				end

				table.insert(payloads, {
					type = "patch",
					data = patch.diff(snapshots[index - 1], snapshot, autoSerialize),
				})
			end

			snapshots = { snapshots[#snapshots] }
			changed = false

			sync(player, unpack(payloads))
		end

		return self
	end

	local previousSnapshot = createSnapshot()
	local currentSnapshot = table.clone(previousSnapshot)
	local changed = false

	function self:connect(callback)
		local subscriptions = {}

		sync = callback

		-- Subscribe to each atom and update the state when one changes.
		for key, atom in next, atoms do
			subscriptions[key] = Charm.subscribe(atom, function(state)
				currentSnapshot[key] = state
				changed = true
			end)
		end

		local disconnect = interval(function()
			if not changed then
				return
			end

			local payload: SyncPayload = {
				type = "patch",
				data = patch.diff(previousSnapshot, currentSnapshot, autoSerialize),
			}

			previousSnapshot = table.clone(currentSnapshot)
			changed = false

			for _, player in next, Players:GetPlayers() do
				callback(player, payload)
			end
		end, syncRate)

		return function()
			disconnect()

			for _, unsubscribe in next, subscriptions do
				unsubscribe()
			end
		end
	end

	function self:_sendPatch(player)
		assert(sync, "connect() must be called before _sendPatch()")

		if not changed then
			return
		end

		local payload: SyncPayload = {
			type = "patch",
			data = patch.diff(previousSnapshot, currentSnapshot, autoSerialize),
		}

		previousSnapshot = table.clone(currentSnapshot)
		changed = false

		sync(player, payload)
	end

	return self
end

return server
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="51">
                <Properties>
                  <string name="Name">types</string>
                  <string name="Source"><![CDATA[local Charm = require(script.Parent.Parent.Parent.charm)
type Atom<T> = Charm.Atom<T>

--[=[
	A payload that can be sent from the server to the client to synchronize
	state between the two.
]=]
export type SyncPayload = {
	type: "init",
	data: { [string | number]: any },
} | {
	type: "patch",
	data: { [string | number]: any },
}

export type AtomMap = {
	[string | number]: Atom<any>,
}

return nil
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="52">
                <Properties>
                  <string name="Name">validate</string>
                  <string name="Source"><![CDATA[local SAFE_KEYS = { string = true, number = true }
local UNSAFE_VALUES = { ["function"] = true, thread = true }

local function isTableUnsafe(object: { [any]: any })
	local keyType = nil
	local objectSize = 0

	-- All keys must have the same type
	for key in next, object do
		local currentType = type(key)

		if not keyType and SAFE_KEYS[currentType] then
			keyType = currentType
		elseif keyType ~= currentType then
			return true
		end

		objectSize += 1
	end

	-- If there are more keys than the length of the array, it's an array with
	-- non-sequential keys.
	if objectSize > #object and keyType == "number" then
		return true
	end

	return false
end

--[=[
	Validates a value to ensure it can be synced over a remote event.

	@param value The value to validate.
	@param key The key of the value in the table.
	@error Throws an error if the value cannot be synced.
]=]
local function validate(value: any, key: any)
	local typeOfKey = type(key)
	local typeOfValue = type(value)

	if not SAFE_KEYS[typeOfKey] then
		error(`Invalid key type '{typeOfKey}' at key '{key}'`)
	elseif UNSAFE_VALUES[typeOfValue] then
		error(`Invalid value type '{typeOfValue}' at key '{key}'`)
	elseif typeOfValue == "table" then
		if getmetatable(value) ~= nil then
			error(`Cannot sync tables with metatables! Got {value} at key '{key}'`)
		elseif isTableUnsafe(value) then
			error(
				`Cannot sync tables unsupported by remote events! The value has the key '{key}'.\n\n`
					.. "This can be for the following reasons:\n"
					.. "1. The object is an array with non-sequential keys\n"
					.. "2. The object is a dictionary with mixed key types (e.g. string and number)\n\n"
					.. "Read more: https://create.roblox.com/docs/scripting/events/remote#argument-limitations"
			)
		end
	end

	if typeOfKey == "number" then
		if key == math.huge or key == -math.huge then
			error("Cannot sync infinity as key")
		elseif key ~= math.floor(key) then
			error("Cannot sync non-integer number as key")
		end
	end
end

return validate
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="53">
              <Properties>
                <string name="Name">wally</string>
                <string name="Source">return {
	dependencies = {
		charm = "littensy/charm@^0.10",
	},
	package = {
		exclude = {"package.json", "node_modules"},
		include = {"LICENSE.md"},
		name = "littensy/charm-sync",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "0.3.0",
	},
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="54">
            <Properties>
              <string name="Name">compiler-types</string>
            </Properties>
            <Item class="ModuleScript" referent="55">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "roblox-ts",
	description = "",
	devDependencies = {
		["@rbxts/types"] = "^1.0.805",
		["@typescript-eslint/eslint-plugin"] = "^8.5.0",
		["@typescript-eslint/parser"] = "^8.5.0",
		eslint = "^8.57.0",
		["eslint-config-prettier"] = "^9.1.0",
		["eslint-plugin-no-autofix"] = "^2.1.0",
		["eslint-plugin-prettier"] = "^5.2.1",
		["eslint-plugin-simple-import-sort"] = "^12.1.1",
		prettier = "^3.3.3",
		typescript = "^5.2.2",
	},
	files = {"types/*.d.ts"},
	license = "MIT",
	main = "types/core.d.ts",
	name = "@rbxts/compiler-types",
	scripts = {
		eslint = "npx eslint \"types/**/*.d.ts\" --max-warnings 0",
	},
	types = "types/core.d.ts",
	version = "3.0.0-types.0",
}</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="56">
              <Properties>
                <string name="Name">types</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="57">
            <Properties>
              <string name="Name">emittery</string>
            </Properties>
            <Item class="ModuleScript" referent="58">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "littensy",
	bugs = {
		url = "https://github.com/littensy/rbxts-jest/issues",
	},
	dependencies = {
		["@rbxts-js/emittery"] = "^3.13.2-ts.3",
	},
	description = "Emittery v0.11.0 bindings for Roblox.",
	files = {"src", "default.project.json"},
	keywords = {"roblox", "typescript", "roblox-ts"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/emittery",
	repository = {
		type = "git",
		url = "git+https://github.com/littensy/rbxts-jest.git",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "3.13.2-alpha.1",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="59">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[return require(script.Parent.Parent.Parent:WaitForChild("@rbxts-js").Emittery)
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="60">
            <Properties>
              <string name="Name">flamework</string>
            </Properties>
            <Item class="Folder" referent="61">
              <Properties>
                <string name="Name">node_modules</string>
              </Properties>
              <Item class="Folder" referent="62">
                <Properties>
                  <string name="Name">@rbxts</string>
                </Properties>
                <Item class="Folder" referent="63">
                  <Properties>
                    <string name="Name">t</string>
                  </Properties>
                  <Item class="Folder" referent="64">
                    <Properties>
                      <string name="Name">lib</string>
                    </Properties>
                    <Item class="ModuleScript" referent="65">
                      <Properties>
                        <string name="Name">ts</string>
                        <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></string>
                      </Properties>
                    </Item>
                  </Item>
                  <Item class="ModuleScript" referent="66">
                    <Properties>
                      <string name="Name">package</string>
                      <string name="Source">return {
	author = "osyris",
	bugs = {
		url = "https://github.com/osyrisrblx/t/issues",
	},
	description = "A Runtime Type Checker for Roblox",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.2.7-types.0",
		["@rbxts/types"] = "^1.0.544",
	},
	files = {"lib/ts.lua", "lib/t.d.ts"},
	homepage = "https://github.com/osyrisrblx/t#readme",
	keywords = {},
	license = "ISC",
	main = "lib/ts.lua",
	name = "@rbxts/t",
	repository = {
		type = "git",
		url = "git+https://github.com/osyrisrblx/t.git",
	},
	types = "lib/t.d.ts",
	version = "2.2.1",
}</string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="67">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1-dev.28798ed
local TS = _G[script]
local exports = {}
local _flamework_0 = TS.import(script, script, "flamework")
exports.Component = _flamework_0.Component
exports.Controller = _flamework_0.Controller
exports.Dependency = _flamework_0.Dependency
exports.External = _flamework_0.External
exports.Service = _flamework_0.Service
exports.Flamework = _flamework_0.Flamework
exports.Networking = TS.import(script, script, "networking").Networking
local _components_1 = TS.import(script, script, "components")
exports.BaseComponent = _components_1.BaseComponent
exports.Components = _components_1.Components
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="68">
                <Properties>
                  <string name="Name">components</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1-dev.28798ed
local TS = _G[script]
local Maid = TS.import(script, TS.getModule(script, "maid").Maid)
local CollectionService = TS.import(script, TS.getModule(script, "services")).CollectionService
local Flamework = TS.import(script, script.Parent, "flamework").Flamework
-- xpcall types are broken, so this is a workaround
local xpcall2 = xpcall
local BaseComponent
do
	BaseComponent = setmetatable({}, {
		__tostring = function()
			return "BaseComponent"
		end,
	})
	BaseComponent.__index = BaseComponent
	function BaseComponent.new(...)
		local self = setmetatable({}, BaseComponent)
		self:constructor(...)
		return self
	end
	function BaseComponent:constructor()
		self.maid = Maid.new()
		self._attributeChangeHandlers = {}
	end
	function BaseComponent:setInstance(instance)
		self.instance = instance
		self.attributes = instance:GetAttributes()
	end
	function BaseComponent:onAttributeChanged(name, cb)
		local _0 = self._attributeChangeHandlers
		local _1 = name
		local list = _0[_1]
		if not list then
			local _2 = self._attributeChangeHandlers
			local _3 = name
			list = {}
			local _4 = list
			-- ▼ Map.set ▼
			_2[_3] = _4
			-- ▲ Map.set ▲
		end
		local _2 = list
		local _3 = cb
		-- ▼ Array.push ▼
		_2[#_2 + 1] = _3
		-- ▲ Array.push ▲
	end
	function BaseComponent:destroy()
		self.maid:Destroy()
	end
end
--[[
	*
	* This class is responsible for loading and managing
	* all components in the game.
]]
local Components
do
	Components = setmetatable({}, {
		__tostring = function()
			return "Components"
		end,
	})
	Components.__index = Components
	function Components.new(...)
		local self = setmetatable({}, Components)
		self:constructor(...)
		return self
	end
	function Components:constructor()
		self.components = {}
		self.activeComponents = {}
		self.tick = {}
		self.physics = {}
		self.render = {}
	end
	function Components:onInit()
		local components = {}
		for ctor, metadata in pairs(Flamework.metadata) do
			local _0 = metadata.decorators
			local _1 = function(x)
				return x.config
			end
			-- ▼ ReadonlyArray.map ▼
			local _2 = table.create(#_0)
			for _k_3, _v_4 in ipairs(_0) do
				_2[_k_3] = _1(_v_4, _k_3 - 1, _0)
			end
			-- ▲ ReadonlyArray.map ▲
			local _3 = function(x)
				return x.type == "Component"
			end
			-- ▼ ReadonlyArray.find ▼
			local _4 = nil
			for _i_5, _v_6 in ipairs(_2) do
				if _3(_v_6, _i_5 - 1, _2) == true then
					_4 = _v_6
					break
				end
			end
			-- ▲ ReadonlyArray.find ▲
			local component = _4
			if component then
				local _5 = components
				local _6 = ctor
				local _7 = {
					metadata = metadata,
					ctor = ctor,
					config = component,
				}
				-- ▼ Map.set ▼
				_5[_6] = _7
				-- ▲ Map.set ▲
			end
		end
		self.components = components
	end
	function Components:onStart()
		for _, _binding_0 in pairs(self.components) do
			local config = _binding_0.config
			local ctor = _binding_0.ctor
			local metadata = _binding_0.metadata
			if config.tag ~= nil then
				CollectionService:GetInstanceAddedSignal(config.tag):Connect(function(instance)
					self:addComponent(instance, ctor)
				end)
				CollectionService:GetInstanceRemovedSignal(config.tag):Connect(function(instance)
					self:removeComponent(instance, ctor)
				end)
				for _, instance in ipairs(CollectionService:GetTagged(config.tag)) do
					self:safeCall("Failed to instantiate " .. tostring(instance), function()
						return self:addComponent(instance, ctor)
					end)
				end
			end
		end
	end
	function Components:onTick(dt)
		for component in pairs(self.tick) do
			local name = component.instance:GetFullName()
			self:safeCall("Component failed to tick " .. name, function()
				return component:onTick(dt)
			end)
		end
	end
	function Components:onRender(dt)
		for component in pairs(self.render) do
			local name = component.instance:GetFullName()
			self:safeCall("Component failed to tick " .. name, function()
				return component:onRender(dt)
			end)
		end
	end
	function Components:onPhysics(dt, time)
		for component in pairs(self.physics) do
			local name = component.instance:GetFullName()
			self:safeCall("Component failed to tick " .. name, function()
				return component:onPhysics(dt, time)
			end)
		end
	end
	function Components:getAttributes(ctor)
		local attributes = {}
		local _0 = self.components
		local _1 = ctor
		local metadata = _0[_1]
		if metadata then
			if metadata.config.attributes ~= nil then
				for attribute, guard in pairs(metadata.config.attributes) do
					local _2 = attributes
					local _3 = attribute
					local _4 = guard
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				end
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				for attribute, guard in pairs(self:getAttributes(parentCtor.__index)) do
					local _2 = attributes
					local _3 = attribute
					if not (_2[_3] ~= nil) then
						local _4 = attributes
						local _5 = attribute
						local _6 = guard
						-- ▼ Map.set ▼
						_4[_5] = _6
						-- ▲ Map.set ▲
					end
				end
			end
		end
		return attributes
	end
	function Components:getInstanceGuard(ctor)
		local _0 = self.components
		local _1 = ctor
		local metadata = _0[_1]
		if metadata then
			if metadata.config.instanceGuard ~= nil then
				return metadata.config.instanceGuard
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				return self:getInstanceGuard(parentCtor.__index)
			end
		end
	end
	function Components:validateAttributes(instance, guards)
		local attributes = instance:GetAttributes()
		for key, guard in pairs(guards) do
			local attribute = attributes[key]
			if not guard(attribute) then
				return false
			end
		end
		return true
	end
	function Components:safeCall(message, func)
		coroutine.wrap(function()
			xpcall2(func, function(err)
				local _0 = err
				if type(_0) == "string" then
					local stack = debug.traceback(err, 2)
					warn(message)
					warn(stack)
				else
					warn(message)
					warn(err)
					warn(debug.traceback(nil, 2))
				end
			end)
		end)()
	end
	function Components:setupComponent(instance, component, _param_0)
		local config = _param_0.config
		local ctor = _param_0.ctor
		component:setInstance(instance)
		if Flamework._implements(component, "$:4R") then
			local name = instance:GetFullName()
			self:safeCall("Component failed to start " .. name, function()
				return component:onStart()
			end)
		end
		if Flamework._implements(component, "$:Q0") then
			local _1 = self.render
			local _2 = component
			-- ▼ Set.add ▼
			_1[_2] = true
			-- ▲ Set.add ▲
			component.maid:GiveTask(function()
				local _3 = self.render
				local _4 = component
				-- ▼ Set.delete ▼
				local _5 = _3[_4] ~= nil
				_3[_4] = nil
				-- ▲ Set.delete ▲
				return _5
			end)
		end
		if Flamework._implements(component, "$:yM") then
			local _1 = self.physics
			local _2 = component
			-- ▼ Set.add ▼
			_1[_2] = true
			-- ▲ Set.add ▲
			component.maid:GiveTask(function()
				local _3 = self.physics
				local _4 = component
				-- ▼ Set.delete ▼
				local _5 = _3[_4] ~= nil
				_3[_4] = nil
				-- ▲ Set.delete ▲
				return _5
			end)
		end
		if Flamework._implements(component, "$:l2") then
			local _1 = self.tick
			local _2 = component
			-- ▼ Set.add ▼
			_1[_2] = true
			-- ▲ Set.add ▲
			component.maid:GiveTask(function()
				local _3 = self.tick
				local _4 = component
				-- ▼ Set.delete ▼
				local _5 = _3[_4] ~= nil
				_3[_4] = nil
				-- ▲ Set.delete ▲
				return _5
			end)
		end
		if config.refreshAttributes == nil or config.refreshAttributes then
			local attributes = self:getAttributes(ctor)
			for attribute, guard in pairs(attributes) do
				local _1 = attribute
				if type(_1) == "string" then
					component.maid:GiveTask(instance:GetAttributeChangedSignal(attribute):Connect(function()
						local _2 = component._attributeChangeHandlers
						local _3 = attribute
						local handlers = _2[_3]
						local value = instance:GetAttribute(attribute)
						local attributes = component.attributes
						if guard(value) then
							if handlers then
								for _, handler in ipairs(handlers) do
									self:safeCall("Failed to call onAttributeChanged for " .. attribute, function()
										local _4 = attributes
										local _5 = attribute
										return handler(value, _4[_5])
									end)
								end
							end
							local _4 = attributes
							local _5 = attribute
							local _6 = value
							-- ▼ Map.set ▼
							_4[_5] = _6
							-- ▲ Map.set ▲
						end
					end))
				end
			end
		end
	end
	function Components:getComponentFromSpecifier(componentSpecifier)
		local _1 = componentSpecifier
		local _result_2
		if type(_1) == "string" then
			local _3 = Flamework.idToTarget
			local _4 = componentSpecifier
			_result_2 = (_3[_4])
		else
			_result_2 = componentSpecifier
		end
		return _result_2
	end
	function Components:getComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _1 = component
		assert(_1 ~= 0 and _1 == _1 and _1 ~= "" and _1, "Could not find component from specifier")
		local _2 = self.activeComponents
		local _3 = instance
		local activeComponents = _2[_3]
		if not activeComponents then
			return nil
		end
		local _4 = activeComponents
		local _5 = component
		return _4[_5]
	end
	function Components:addComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _1 = component
		assert(_1 ~= 0 and _1 == _1 and _1 ~= "" and _1, "Could not find component from specifier")
		local _2 = self.components
		local _3 = component
		local componentInfo = _2[_3]
		local _4 = componentInfo
		assert(_4, "Provided componentSpecifier does not exist")
		local attributeGuards = self:getAttributes(component)
		if attributeGuards ~= nil then
			local _5 = self:validateAttributes(instance, attributeGuards)
			local _6 = instance:GetFullName() .. " has invalid attributes for " .. componentInfo.metadata.identifier
			assert(_5, _6)
		end
		local instanceGuard = self:getInstanceGuard(component)
		if instanceGuard ~= nil then
			local _5 = instanceGuard(instance)
			local _6 = instance:GetFullName() .. " did not pass instance guard check"
			assert(_5, _6)
		end
		local _5 = self.activeComponents
		local _6 = instance
		local activeComponents = _5[_6]
		if not activeComponents then
			local _7 = self.activeComponents
			activeComponents = {}
			local _8 = instance
			local _9 = activeComponents
			-- ▼ Map.set ▼
			_7[_8] = _9
			-- ▲ Map.set ▲
		end
		local _7 = activeComponents
		local _8 = component
		local existingComponent = _7[_8]
		if existingComponent ~= nil then
			return existingComponent
		end
		local componentInstance = Flamework.createDependency(component)
		local _9 = activeComponents
		local _10 = component
		local _11 = componentInstance
		-- ▼ Map.set ▼
		_9[_10] = _11
		-- ▲ Map.set ▲
		self:setupComponent(instance, componentInstance, componentInfo)
		return componentInstance
	end
	function Components:removeComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _1 = component
		assert(_1 ~= 0 and _1 == _1 and _1 ~= "" and _1, "Could not find component from specifier")
		local _2 = self.activeComponents
		local _3 = instance
		local activeComponents = _2[_3]
		if not activeComponents then
			return nil
		end
		local _4 = activeComponents
		local _5 = component
		local existingComponent = _4[_5]
		if not existingComponent then
			return nil
		end
		existingComponent:destroy()
		local _6 = activeComponents
		local _7 = component
		-- ▼ Map.delete ▼
		_6[_7] = nil
		-- ▲ Map.delete ▲
		-- ▼ ReadonlyMap.size ▼
		local _8 = 0
		for _ in pairs(activeComponents) do
			_8 += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _8 == 0 then
			local _9 = self.activeComponents
			local _10 = instance
			-- ▼ Map.delete ▼
			_9[_10] = nil
			-- ▲ Map.delete ▲
		end
	end
end
Flamework.registerMetadata(Components, {
	identifier = "$:p2",
	isExternal = false,
	decorators = { {
		identifier = "$:dz",
		config = {
			type = "Service",
			loadOrder = 0,
		},
	}, {
		identifier = "$:8j",
		config = {
			type = "Controller",
			loadOrder = 0,
		},
	} },
	implements = { "$:7w", "$:4R", "$:l2", "$:yM", "$:Q0" },
})
return {
	BaseComponent = BaseComponent,
	Components = Components,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="69">
                <Properties>
                  <string name="Name">flamework</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1-dev.28798ed
local TS = _G[script]
local _services_0 = TS.import(script, TS.getModule(script, "services"))
local Players = _services_0.Players
local RunService = _services_0.RunService
local Flamework
local Flamework = {}
do
	local _container_1 = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container_1.flameworkConfig = flameworkConfig
	_container_1.isInitialized = false
	local metadata = {}
	_container_1.metadata = metadata
	local targetToId = {}
	_container_1.targetToId = targetToId
	local idToTarget = {}
	_container_1.idToTarget = idToTarget
	-- * @hidden
	local function registerMetadata(target, data)
		local ctor = target
		local _2 = metadata
		local _3 = ctor
		local _4 = data
		-- ▼ Map.set ▼
		_2[_3] = _4
		-- ▲ Map.set ▲
		local _5 = targetToId
		local _6 = ctor
		local _7 = data.identifier
		-- ▼ Map.set ▼
		_5[_6] = _7
		-- ▲ Map.set ▲
		local _8 = idToTarget
		local _9 = data.identifier
		local _10 = ctor
		-- ▼ Map.set ▼
		_8[_9] = _10
		-- ▲ Map.set ▲
	end
	_container_1.registerMetadata = registerMetadata
	local resolvedDependencies = {}
	local loadingList = {}
	-- * @hidden
	local id, resolveDependency
	local function createDependency(ctor)
		local _2 = loadingList
		local _3 = ctor
		if table.find(_2, _3) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _4 = " <=> "
			if _4 == nil then
				_4 = ", "
			end
			local _5 = table.create(#loadingList)
			for _k_6, _v_7 in ipairs(loadingList) do
				_5[_k_6] = tostring(_v_7)
			end
			-- ▲ ReadonlyArray.join ▲
			error("Circular dependency detected " .. table.concat(_5, _4) .. " <=> " .. tostring(ctor))
		end
		local _4 = loadingList
		local _5 = ctor
		-- ▼ Array.push ▼
		_4[#_4 + 1] = _5
		-- ▲ Array.push ▲
		local _6 = metadata
		local _7 = ctor
		local dependencyMetadata = _6[_7]
		if not dependencyMetadata then
			error("Dependency " .. tostring(id) .. " metadata is missing.")
		end
		local constructorDependencies = {}
		if dependencyMetadata.dependencies then
			for index, dependencyId in pairs(dependencyMetadata.dependencies) do
				local dependency = resolveDependency(dependencyId)
				constructorDependencies[index - 1 + 1] = dependency
			end
		end
		local dependency = ctor.new(unpack(constructorDependencies))
		-- ▼ Array.pop ▼
		loadingList[#loadingList] = nil
		-- ▲ Array.pop ▲
		return dependency
	end
	_container_1.createDependency = createDependency
	-- * @hidden
	function resolveDependency(id)
		local _2 = resolvedDependencies
		local _3 = id
		local resolvedDependency = _2[_3]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local _4 = idToTarget
		local _5 = id
		local ctor = _4[_5]
		if ctor == nil then
			error("Dependency " .. id .. " could not be found.")
		end
		local dependency = createDependency(ctor)
		local _6 = resolvedDependencies
		local _7 = id
		local _8 = dependency
		-- ▼ Map.set ▼
		_6[_7] = _8
		-- ▲ Map.set ▲
		return dependency
	end
	_container_1.resolveDependency = resolveDependency
	-- * @hidden
	local function _addPaths(...)
		local args = { ... }
		local preloadPaths = {}
		for _, arg in ipairs(args) do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			do
				local _2 = false
				local _i_3 = 0
				local _4 = _i_3
				_i_3 = _4
				while true do
					local i = _i_3
					if _2 then
						i += 1
					else
						_2 = true
					end
					if not (i < #arg) then
						break
					end
					currentPath = currentPath:WaitForChild(arg[i + 1])
					_i_3 = i
				end
			end
			local _2 = preloadPaths
			local _3 = currentPath
			-- ▼ Array.push ▼
			_2[#_2 + 1] = _3
			-- ▲ Array.push ▲
		end
		local preload = function(moduleScript)
			local start = os.clock()
			local _2 = require
			local _3 = moduleScript
			local _success_4, _valueOrError_5 = pcall(_2, _3)
			local result = _success_4 and {
				success = true,
				value = _valueOrError_5,
			} or {
				success = false,
				error = _valueOrError_5,
			}
			local endTime = math.floor((os.clock() - start) * 1000)
			if not result.success then
				error(moduleScript:GetFullName() .. " failed to preload (" .. tostring(endTime) .. "ms): " .. result.error)
			end
			print("Preloaded " .. moduleScript:GetFullName() .. " (" .. tostring(endTime) .. "ms)")
		end
		for _, path in ipairs(preloadPaths) do
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _, instance in ipairs(path:GetDescendants()) do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container_1._addPaths = _addPaths
	-- * @hidden
	local function _implements(object, id)
		local objectMetadata
		while objectMetadata == nil and object ~= nil do
			local _2 = metadata
			local _3 = object
			objectMetadata = _2[_3]
			if objectMetadata then
				break
			end
			local mt = getmetatable(object)
			if mt then
				object = mt.__index
			else
				object = nil
			end
		end
		if not objectMetadata then
			return false
		end
		if not objectMetadata.implements then
			return false
		end
		local _2 = objectMetadata.implements
		local _3 = id
		return table.find(_2, _3) ~= nil
	end
	_container_1._implements = _implements
	local function getDecorator(ctor, configType)
		local _2 = metadata
		local _3 = ctor
		local objectMetadata = _2[_3]
		if not objectMetadata then
			return nil
		end
		for _, decorator in ipairs(objectMetadata.decorators) do
			if decorator.config.type == configType then
				return decorator
			end
		end
	end
	local function fastSpawn(func)
		local bindable = Instance.new("BindableEvent")
		bindable.Event:Connect(func)
		bindable:Fire()
		bindable:Destroy()
	end
	local externalClasses = {}
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		local _2 = externalClasses
		local _3 = ctor
		-- ▼ Set.add ▼
		_2[_3] = true
		-- ▲ Set.add ▲
	end
	_container_1.registerExternalClass = registerExternalClass
	local hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor, objectMetadata in pairs(metadata) do
			local _condition_2 = flameworkConfig.loadOverride
			if _condition_2 then
				local _3 = flameworkConfig.loadOverride
				local _4 = ctor
				_condition_2 = not (table.find(_3, _4) ~= nil)
			end
			if _condition_2 then
				if not objectMetadata.isPatched then
					continue
				end
			end
			resolveDependency(objectMetadata.identifier)
		end
		local dependencies = {}
		local decoratorType = RunService:IsServer() and "Service" or "Controller"
		for id in pairs(resolvedDependencies) do
			local _2 = idToTarget
			local _3 = id
			local ctor = _2[_3]
			if ctor == nil then
				error("Could not find constructor for " .. id)
			end
			local _4 = metadata
			local _5 = ctor
			local objectMetadata = _4[_5]
			if objectMetadata == nil then
				error("Could not find metadata for " .. id)
			end
			local decorator = getDecorator(ctor, decoratorType)
			if not decorator then
				continue
			end
			local _condition_6 = objectMetadata.isExternal
			if _condition_6 then
				local _7 = externalClasses
				local _8 = ctor
				_condition_6 = not (_7[_8] ~= nil)
			end
			if _condition_6 then
				continue
			end
			local dependency = resolveDependency(objectMetadata.identifier)
			local _7 = dependencies
			local _8 = { dependency, objectMetadata, decorator.config }
			-- ▼ Array.push ▼
			_7[#_7 + 1] = _8
			-- ▲ Array.push ▲
		end
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _2 = dependencies
		local _3 = function(_param_4, _param_5)
			local a = _param_4[3]
			local b = _param_5[3]
			local _condition_6 = a.loadOrder
			if _condition_6 == nil then
				_condition_6 = 1
			end
			local _condition_7 = b.loadOrder
			if _condition_7 == nil then
				_condition_7 = 1
			end
			return _condition_6 < _condition_7
		end
		-- ▼ Array.sort ▼
		table.sort(_2, _3)
		-- ▲ Array.sort ▲
		for _, _binding_6 in ipairs(dependencies) do
			local dependency = _binding_6[1]
			local objectMetadata = _binding_6[2]
			local config = _binding_6[3]
			if Flamework._implements(dependency, "$:7w") then
				local _7 = init
				local _8 = { dependency, objectMetadata, config }
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:4R") then
				local _7 = start
				local _8 = { dependency, objectMetadata, config }
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:l2") then
				local _7 = tick
				local _8 = dependency
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:yM") then
				local _7 = physics
				local _8 = dependency
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:Q0") then
				local _7 = render
				local _8 = dependency
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
		end
		for _, _binding_6 in ipairs(init) do
			local dependency = _binding_6[1]
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				initResult:await()
			end
		end
		_container_1.isInitialized = true
		RunService.Heartbeat:Connect(function(dt)
			for _, dependency in ipairs(tick) do
				coroutine.wrap(function()
					return dependency:onTick(dt)
				end)()
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for _, dependency in ipairs(physics) do
				coroutine.wrap(function()
					return dependency:onPhysics(dt, time)
				end)()
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for _, dependency in ipairs(render) do
					coroutine.wrap(function()
						return dependency:onRender(dt)
					end)()
				end
			end)
		end
		for _, _binding_6 in ipairs(start) do
			local dependency = _binding_6[1]
			fastSpawn(function()
				return dependency:onStart()
			end)
		end
		return dependencies
	end
	_container_1.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_2 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			local _3 = resolvedDependencies
			local _4 = id
			if _3[_4] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local _5 = idToTarget
			local _6 = id
			local idCtor = _5[_6]
			if idCtor == nil then
				error("Dependency " .. id .. " was not found and cannot be patched.")
			end
			local _7 = metadata
			local _8 = idCtor
			local classMetadata = _7[_8]
			if not classMetadata then
				error("Dependency " .. id .. " has no existing metadata.")
			end
			classMetadata.isPatched = true
			local _9 = metadata
			local _10 = idCtor
			-- ▼ Map.delete ▼
			_9[_10] = nil
			-- ▲ Map.delete ▲
			local _11 = metadata
			local _12 = patchedClass
			local _13 = classMetadata
			-- ▼ Map.set ▼
			_11[_12] = _13
			-- ▲ Map.set ▲
			local _14 = targetToId
			local _15 = patchedClass
			local _16 = id
			-- ▼ Map.set ▼
			_14[_15] = _16
			-- ▲ Map.set ▲
			local _17 = idToTarget
			local _18 = id
			local _19 = patchedClass
			-- ▼ Map.set ▼
			_17[_18] = _19
			-- ▲ Map.set ▲
		end
		_container_2.patchDependency = patchDependency
	end
	_container_1.Testing = Testing
end
-- eslint-disable-next-line @typescript-eslint/no-explicit-any
--[[
	*
	* Register a class as a Component.
]]
--[[
	*
	* Register a class as a Service.
	*
	* @server
]]
--[[
	*
	* Register a class as a Controller.
	*
	* @client
]]
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunService.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunService.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunService.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="70">
                <Properties>
                  <string name="Name">networking</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1-dev.28798ed
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "object-utils"))
local _services_0 = TS.import(script, TS.getModule(script, "services"))
local Players = _services_0.Players
local ReplicatedStorage = _services_0.ReplicatedStorage
local RunService = _services_0.RunService
local Networking = {}
do
	local _container_1 = Networking
	local Sink = {}
	_container_1.Sink = Sink
	local function populateEvents(names, map)
		for _, name in ipairs(names) do
			if RunService:IsClient() then
				local instance = ReplicatedStorage:WaitForChild(name)
				if instance:IsA("RemoteEvent") then
					local _2 = map
					local _3 = name
					local _4 = instance
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				end
			else
				local instance = ReplicatedStorage:FindFirstChild(name)
				if instance then
					if not instance:IsA("RemoteEvent") then
						error("Found " .. name .. " but it is not a remote.")
					end
					local _2 = map
					local _3 = name
					local _4 = instance
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				else
					local remote = Instance.new("RemoteEvent")
					remote.Name = name
					remote.Parent = ReplicatedStorage
					local _2 = map
					local _3 = name
					local _4 = remote
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				end
			end
		end
	end
	local function createEvent(_serverGuards, _clientGuards, serverMiddleware, clientMiddleware)
		local serverGuards = _serverGuards
		local clientGuards = _clientGuards
		local globalEvents = {}
		local remotes = {}
		populateEvents(Object.keys(serverGuards), remotes)
		populateEvents(Object.keys(clientGuards), remotes)
		local _result_2
		if RunService:IsServer() then
			_result_2 = serverMiddleware
		else
			_result_2 = clientMiddleware
		end
		local middleware = _result_2
		local connections = {}
		local eventExecutors = {}
		for name in pairs(remotes) do
			local executor = function(player, ...)
				local args = { ... }
				local _3 = connections
				local _4 = name
				local bindable = _3[_4]
				if not bindable then
					return warn("no bindable for", name)
				end
				return bindable:Fire(player, unpack(args))
			end
			local startingExecutor = executor
			local _3 = middleware
			if _3 ~= nil then
				_3 = _3[name]
			end
			local eventMiddleware = _3
			if eventMiddleware ~= nil then
				do
					local _4 = false
					local _i_5 = #eventMiddleware - 1
					local _6 = _i_5
					_i_5 = _6
					while true do
						local i = _i_5
						if _4 then
							i -= 1
						else
							_4 = true
						end
						if not (i >= 0) then
							break
						end
						local middleware = eventMiddleware[i + 1](startingExecutor, {
							name = name,
						})
						startingExecutor = middleware
						_i_5 = i
					end
				end
			end
			local _4 = eventExecutors
			local _5 = name
			local _6 = startingExecutor
			-- ▼ Map.set ▼
			_4[_5] = _6
			-- ▲ Map.set ▲
		end
		local function fireConnections(event, player, ...)
			local args = { ... }
			local _3 = eventExecutors
			local _4 = event
			local executor = _3[_4]
			if executor ~= nil then
				return executor(player, unpack(args))
			end
		end
		if RunService:IsServer() then
			globalEvents.server = {}
			globalEvents.server.connect = function(self, event, cb, additionalGuards)
				local _3 = remotes
				local _4 = event
				local remote = _3[_4]
				local guards = serverGuards[event]
				if not remote then
					error("Could not find remote " .. tostring(event))
				end
				if not guards then
					error("Could not find guards for " .. tostring(event))
				end
				local _5 = connections
				local _6 = event
				local bindable = _5[_6]
				if not bindable then
					local _7 = connections
					local _8 = event
					bindable = Instance.new("BindableEvent")
					local _9 = bindable
					-- ▼ Map.set ▼
					_7[_8] = _9
					-- ▲ Map.set ▲
				end
				return bindable.Event:Connect(function(player, ...)
					local args = { ... }
					if additionalGuards then
						do
							local _7 = false
							local _i_8 = 0
							local _9 = _i_8
							_i_8 = _9
							while true do
								local i = _i_8
								if _7 then
									i += 1
								else
									_7 = true
								end
								if not (i < #guards) then
									break
								end
								local guard = additionalGuards[i + 1]
								if guard ~= nil and not guard(args[i + 1]) then
									return nil
								end
								_i_8 = i
							end
						end
					end
					return cb(player, unpack(args))
				end)
			end
			for name in pairs(clientGuards) do
				local _3 = remotes
				local _4 = name
				local remote = _3[_4]
				local method = {
					fire = function(self, player, ...)
						local args = { ... }
						remote:FireClient(player, unpack(args))
					end,
					broadcast = function(self, ...)
						local args = { ... }
						remote:FireAllClients(unpack(args))
					end,
					except = function(self, players, ...)
						local args = { ... }
						local _5 = players
						if typeof(_5) == "Instance" then
							players = { players }
						end
						for _, player in ipairs(Players:GetPlayers()) do
							local _6 = players
							local _7 = player
							if not (table.find(_6, _7) ~= nil) then
								self:fire(player, unpack(args))
							end
						end
					end,
				}
				setmetatable(method, {
					__call = function(method, player, ...)
						local args = { ... }
						local _5 = player
						local _condition_6 = typeof(_5) == "Instance"
						if _condition_6 then
							_condition_6 = player:IsA("Player")
						end
						if _condition_6 then
							method:fire(player, unpack(args))
						end
					end,
				})
				globalEvents.server[name] = method
			end
			for name, remote in pairs(remotes) do
				remote.OnServerEvent:Connect(function(player, ...)
					local args = { ... }
					local guards = serverGuards[name]
					if not guards then
						error("Could not find guards for " .. name)
					end
					do
						local _3 = false
						local _i_4 = 0
						local _5 = _i_4
						_i_4 = _5
						while true do
							local i = _i_4
							if _3 then
								i += 1
							else
								_3 = true
							end
							if not (i < #guards) then
								break
							end
							local guard = guards[i + 1]
							if not guard(args[i + 1]) then
								return nil
							end
							_i_4 = i
						end
					end
					fireConnections(name, player, unpack(args))
				end)
			end
		else
			globalEvents.client = {}
			globalEvents.client.connect = function(self, event, cb, additionalGuards)
				local _3 = remotes
				local _4 = event
				local remote = _3[_4]
				local guards = clientGuards[event]
				if not remote then
					error("Could not find remote " .. tostring(event))
				end
				if not guards then
					error("Could not find guards for " .. tostring(event))
				end
				local _5 = connections
				local _6 = event
				local bindable = _5[_6]
				if not bindable then
					local _7 = connections
					local _8 = event
					bindable = Instance.new("BindableEvent")
					local _9 = bindable
					-- ▼ Map.set ▼
					_7[_8] = _9
					-- ▲ Map.set ▲
				end
				return bindable.Event:Connect(function(player, ...)
					local args = { ... }
					if additionalGuards then
						do
							local _7 = false
							local _i_8 = 0
							local _9 = _i_8
							_i_8 = _9
							while true do
								local i = _i_8
								if _7 then
									i += 1
								else
									_7 = true
								end
								if not (i < #guards) then
									break
								end
								local guard = additionalGuards[i + 1]
								if guard ~= nil and not guard(args[i + 1]) then
									return nil
								end
								_i_8 = i
							end
						end
					end
					return cb(unpack(args))
				end)
			end
			for name in pairs(serverGuards) do
				local _3 = remotes
				local _4 = name
				local remote = _3[_4]
				globalEvents.client[name] = (function(...)
					local args = { ... }
					remote:FireServer(unpack(args))
				end)
			end
			for name, remote in pairs(remotes) do
				remote.OnClientEvent:Connect(function(...)
					local args = { ... }
					local guards = clientGuards[name]
					if not guards then
						error("Could not find guards for " .. name)
					end
					do
						local _3 = false
						local _i_4 = 0
						local _5 = _i_4
						_i_4 = _5
						while true do
							local i = _i_4
							if _3 then
								i += 1
							else
								_3 = true
							end
							if not (i < #guards) then
								break
							end
							local guard = guards[i + 1]
							if not guard(args[i + 1]) then
								return nil
							end
							_i_4 = i
						end
					end
					fireConnections(name, nil, unpack(args))
				end)
			end
		end
		return globalEvents
	end
	_container_1.createEvent = createEvent
end
return {
	Networking = Networking,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="71">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	dependencies = {
		["@rbxts/maid"] = "^1.0.0-ts.1",
		["@rbxts/object-utils"] = "^1.0.4",
		["@rbxts/services"] = "^1.1.4",
		["@rbxts/signal"] = "^1.0.3",
		["@rbxts/t"] = "^2.1.4",
	},
	description = "",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.1.0-types.0",
		["@rbxts/types"] = "^1.0.479",
		["@typescript-eslint/eslint-plugin"] = "^4.22.0",
		["@typescript-eslint/parser"] = "^4.22.0",
		eslint = "^7.25.0",
		["eslint-config-prettier"] = "^8.3.0",
		["eslint-plugin-prettier"] = "^3.4.0",
		["eslint-plugin-roblox-ts"] = "0.0.25",
		prettier = "^2.2.1",
		["roblox-ts"] = "^1.1.1-dev.28798ed",
		typescript = "^4.3.2",
	},
	files = {"out", "flamework.build"},
	homepage = "https://github.com/FireTS/rbxts-flamework",
	keywords = {},
	license = "ISC",
	main = "out/init.lua",
	name = "@rbxts/flamework",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/FireTS/rbxts-flamework.git",
	},
	scripts = {
		build = "rbxtsc",
		prepublishOnly = "rbxtsc",
		watch = "rbxtsc -w",
	},
	types = "out/index.d.ts",
	version = "0.0.11",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="72">
            <Properties>
              <string name="Name">janitor</string>
            </Properties>
            <Item class="ModuleScript" referent="73">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = {
		name = "howmanysmall",
		url = "https://github.com/howmanysmall",
	},
	bugs = {
		url = "https://github.com/OverHash/Roblox-TS-Libraries/issues",
	},
	contributors = {{
		name = "OverHash",
		url = "https://github.com/OverHash/",
	}},
	description = "A port of howmanysmall's janitor module.",
	devDependencies = {
		["@rbxts/compiler-types"] = "^3.0.0-types.0",
		["@rbxts/types"] = "^1.0.855",
	},
	files = {"index.d.ts", "src/"},
	homepage = "https://github.com/OverHash/Roblox-TS-Libraries/blob/master/janitor/README.md",
	keywords = {"janitor", "cleanup", "garbage collection", "validark", "maid", "roblox", "roblox-typescript", "roblox-ts"},
	license = "Apache-2.0",
	main = "src/init.lua",
	name = "@rbxts/janitor",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/OverHash/Roblox-TS-Libraries/tree/master/janitor",
	},
	types = "index.d.ts",
	version = "1.18.3-ts.0",
	volta = {
		node = "20.11.0",
	},
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="74">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--!optimize 2
--!strict

-- Compiled with L+ C Edition
-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.
-- Cleanup edge cases fixed by codesenseAye.

local FastDefer = require(script.FastDefer)
local Promise = require(script.Promise)
type Promise<T...> = Promise.TypedPromise<T...>

local LinkToInstanceIndex = setmetatable({}, {
	__tostring = function()
		return "LinkToInstanceIndex"
	end;
})

local INVALID_METHOD_NAME =
	"Object is a %* and as such expected `true?` for the method name and instead got %*. Traceback: %*"
local METHOD_NOT_FOUND_ERROR = "Object %* doesn't have method %*, are you sure you want to add it? Traceback: %*"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %* (%*)) Traceback: %*"

export type Janitor = typeof(setmetatable({} :: {
	CurrentlyCleaning: boolean,
	SuppressInstanceReDestroy: boolean,
	UnsafeThreadCleanup: boolean,

	Add: <T>(self: Janitor, object: T, methodName: BooleanOrString?, index: any?) -> T,
	AddObject: <T, A...>(
		self: Janitor,
		constructor: {new: (A...) -> T},
		methodName: BooleanOrString?,
		index: any?,
		A...
	) -> T,
	AddPromise: <T...>(self: Janitor, promiseObject: Promise<T...>, index: unknown?) -> Promise<T...>,

	Remove: (self: Janitor, index: any) -> Janitor,
	RemoveNoClean: (self: Janitor, index: any) -> Janitor,

	RemoveList: (self: Janitor, ...any) -> Janitor,
	RemoveListNoClean: (self: Janitor, ...any) -> Janitor,

	Get: (self: Janitor, index: any) -> any?,
	GetAll: (self: Janitor) -> {[any]: any},

	Cleanup: (self: Janitor) -> (),
	Destroy: (self: Janitor) -> (),

	LinkToInstance: (self: Janitor, Object: Instance, allowMultiple: boolean?) -> RBXScriptConnection,
	LinkToInstances: (self: Janitor, ...Instance) -> Janitor,
}, {} :: {__call: (self: Janitor) -> ()}))
type Private = typeof(setmetatable({} :: {
	CurrentlyCleaning: boolean,
	SuppressInstanceReDestroy: boolean,
	UnsafeThreadCleanup: boolean,

	-- Private
	[any]: BooleanOrString,

	Add: <T>(self: Private, object: T, methodName: BooleanOrString?, index: any?) -> T,
	AddObject: <T, A...>(
		self: Private,
		constructor: {new: (A...) -> T},
		methodName: BooleanOrString?,
		index: any?,
		A...
	) -> T,
	AddPromise: <T...>(self: Private, promiseObject: Promise<T...>, index: unknown?) -> Promise<T...>,

	Remove: (self: Private, index: any) -> Private,
	RemoveNoClean: (self: Private, index: any) -> Private,

	RemoveList: (self: Private, ...any) -> Private,
	RemoveListNoClean: (self: Private, ...any) -> Private,

	Get: (self: Private, index: any) -> any?,
	GetAll: (self: Private) -> {[any]: any},

	Cleanup: (self: Private) -> (),
	Destroy: (self: Private) -> (),

	LinkToInstance: (self: Private, object: Instance, allowMultiple: boolean?) -> RBXScriptConnection,
	LinkToInstances: (self: Private, ...Instance) -> Private,
}, {} :: {__call: (self: Private) -> ()}))
type Static = {
	ClassName: "Janitor",

	CurrentlyCleaning: boolean,
	SuppressInstanceReDestroy: boolean,
	UnsafeThreadCleanup: boolean,

	new: () -> Janitor,
	Is: (object: any) -> boolean,
	instanceof: (object: any) -> boolean,
}
type PrivateStatic = Static & {
	__call: (self: Private) -> (),
	__tostring: (self: Private) -> string,
}

--[=[
	Janitor is a light-weight, flexible object for cleaning up connections,
	instances, or anything. This implementation covers all use cases, as it
	doesn't force you to rely on naive typechecking to guess how an instance
	should be cleaned up. Instead, the developer may specify any behavior for
	any object.

	This is the fastest OOP library on Roblox of its kind on both X86-64 as
	well as ARM64.

	@class Janitor
]=]
local Janitor = {} :: Janitor & Static
local Private = Janitor :: Private & PrivateStatic
Janitor.ClassName = "Janitor"
Janitor.CurrentlyCleaning = true
Janitor.SuppressInstanceReDestroy = false
Janitor.UnsafeThreadCleanup = false;
(Janitor :: any).__index = Janitor

local Janitors = setmetatable({} :: {[Private]: {[any]: any}}, {__mode = "ks"})

--[=[
	Whether or not the Janitor is currently cleaning up.
	@readonly
	@prop CurrentlyCleaning boolean
	@within Janitor
]=]
--[=[
	Whether or not you want to suppress the re-destroying of instances. Default
	is false, which is the original behavior.

	@since 1.15.4
	@prop SuppressInstanceReDestroy boolean
	@within Janitor
]=]
--[=[
	Whether or not to use the unsafe fast defer function for cleaning up
	threads. This might be able to throw, so be careful. If you're getting any
	thread related errors, chances are it is this.

	@since 1.18.0
	@prop UnsafeThreadCleanup boolean
	@within Janitor
]=]

local TYPE_DEFAULTS = {
	["function"] = true;
	thread = true;
	RBXScriptConnection = "Disconnect";
}

--[=[
	Instantiates a new Janitor object.
	@return Janitor
]=]
function Janitor.new(): Janitor
	return setmetatable({
		CurrentlyCleaning = false;
	}, Janitor) :: never
end

--[=[
	Determines if the passed object is a Janitor. This checks the metatable
	directly.

	@param object unknown -- The object you are checking.
	@return boolean -- `true` if `object` is a Janitor.
]=]
function Janitor.Is(object: any): boolean
	return type(object) == "table" and getmetatable(object) == Janitor
end

--[=[
	An alias for [Janitor.Is]. This is intended for roblox-ts support.

	@function instanceof
	@within Janitor

	@param object unknown -- The object you are checking.
	@return boolean -- `true` if `object` is a Janitor.
]=]
Janitor.instanceof = Janitor.Is

local Destroy = game.Destroy

-- very cheeky optimization
local function Remove(self: Private, index: any): Janitor
	local this = Janitors[self]

	if this then
		local object = this[index]
		if not object then
			return self
		end

		local methodName = self[object]
		if methodName then
			if methodName == true then
				if type(object) == "function" then
					object()
				else
					local wasCancelled: boolean? = nil
					if coroutine.running() ~= object then
						wasCancelled = pcall(function()
							task.cancel(object)
						end)
					end

					if not wasCancelled then
						local toCleanup = object
						if self.UnsafeThreadCleanup then
							FastDefer(function()
								task.cancel(toCleanup)
							end)
						else
							task.defer(function()
								task.cancel(toCleanup)
							end)
						end
					end
				end
			else
				if methodName == "Destroy" then
					if self.SuppressInstanceReDestroy and typeof(object) == "Instance" then
						pcall(Destroy, object)
					else
						local destroy = object.Destroy
						if destroy then
							destroy(object)
						end
					end
				elseif methodName == "Disconnect" then
					local disconnect = object.Disconnect
					if disconnect then
						disconnect(object)
					end
				else
					local objectMethod = (object :: never)[methodName] :: (object: unknown) -> ()
					if objectMethod then
						objectMethod(object)
					end
				end
			end

			self[object] = nil
		end

		this[index] = nil
	end

	return self
end

type BooleanOrString = boolean | string

local function Add<T>(self: Private, object: T, methodName: BooleanOrString?, index: any?): T
	if index then
		Remove(self, index)

		local this = Janitors[self]
		if not this then
			this = {}
			Janitors[self] = this
		end

		this[index] = object
	end

	local typeOf = typeof(object)
	local newMethodName = methodName or TYPE_DEFAULTS[typeOf] or "Destroy"

	if typeOf == "function" or typeOf == "thread" then
		if newMethodName ~= true then
			warn(string.format(INVALID_METHOD_NAME, typeOf, tostring(newMethodName), debug.traceback(nil, 2)))
		end
	else
		if not (object :: never)[newMethodName] then
			warn(
				string.format(
					METHOD_NOT_FOUND_ERROR,
					tostring(object),
					tostring(newMethodName),
					debug.traceback(nil, 2)
				)
			)
		end
	end

	self[object] = newMethodName
	return object
end

--[=[
	Adds an `object` to Janitor for later cleanup, where `methodName` is the
	key of the method within `object` which should be called at cleanup time.
	If the `methodName` is `true` the `object` itself will be called if it's a
	function or have `task.cancel` called on it if it is a thread. If passed an
	index it will occupy a namespace which can be `Remove()`d or overwritten.
	Returns the `object`.

	:::info Note
	Objects not given an explicit `methodName` will be passed into the `typeof`
	function for a very naive typecheck. RBXConnections will be assigned to
	"Disconnect", functions and threads will be assigned to `true`, and
	everything else will default to "Destroy". Not recommended, but hey, you do
	you.
	:::

	### Luau:

	```lua
	local Workspace = game:GetService("Workspace")
	local TweenService = game:GetService("TweenService")

	local obliterator = Janitor.new()
	local part = Workspace:FindFirstChild("Part") :: Part

	-- Queue the Part to be Destroyed at Cleanup time
	obliterator:Add(part, "Destroy")

	-- Queue function to be called with `true` methodName
	obliterator:Add(print, true)

	-- Close a thread.
	obliterator:Add(task.defer(function()
		while true do
			print("Running!")
			task.wait(0.5)
		end
	end), true)

	-- This implementation allows you to specify behavior for any object
	obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), "Cancel")

	-- By passing an index, the object will occupy a namespace
	-- If "CurrentTween" already exists, it will call :Remove("CurrentTween") before writing
	obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), "Destroy", "CurrentTween")
	```

	### TypeScript:

	```ts
	import { Workspace, TweenService } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor<{ CurrentTween: Tween }>();
	const part = Workspace.FindFirstChild("Part") as Part;

	// Queue the part to be Destroyed at Cleanup time
	obliterator.Add(part, "Destroy");

	// Queue function to be called with `true` methodName
	obliterator.Add(print, true);

	// Close a thread.
	obliterator.Add(task.defer(() => {
		while (true) {
			print("Running!");
			task.wait(0.5);
		}
	}), true);

	// This implementation allows you to specify behavior for any object
	obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), "Cancel");

	// By passing an index, the object will occupy a namespace
	// If "CurrentTween" already exists, it will call :Remove("CurrentTween") before writing
	obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), "Destroy", "CurrentTween");
	```

	@method Add
	@within Janitor

	@param object T -- The object you want to clean up.
	@param methodName? boolean | string -- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param index? unknown -- The index that can be used to clean up the object manually.
	@return T -- The object that was passed as the first argument.
]=]
Private.Add = Add

--[=[
	Constructs an object for you and adds it to the Janitor. It's really just
	shorthand for `Janitor:Add(object.new(), methodName, index)`.

	### Luau:

	```lua
	local obliterator = Janitor.new()
	local subObliterator = obliterator:AddObject(Janitor, "Destroy")
	-- subObliterator is another Janitor!
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor();
	const subObliterator = obliterator.AddObject(Janitor, "Destroy");
	```

	@since v1.16.0
	@param constructor {new: (A...) -> T} -- The constructor for the object you want to add to the Janitor.
	@param methodName? boolean | string -- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param index? unknown -- The index that can be used to clean up the object manually.
	@param ... A... -- The arguments that will be passed to the constructor.
	@return T -- The object that was passed as the first argument.
]=]
function Janitor:AddObject<T, A...>(constructor: {new: (A...) -> T}, methodName: BooleanOrString?, index: any?, ...: A...): T
	return Add(self, constructor.new(...), methodName, index)
end

local function Get(self: Private, index: unknown): any?
	local this = Janitors[self]
	return if this then this[index] else nil
end

--[=[
	Gets whatever object is stored with the given index, if it exists. This was
	added since Maid allows getting the task using `__index`.

	### Luau:

	```lua
	local obliterator = Janitor.new()
	obliterator:Add(Workspace.Baseplate, "Destroy", "Baseplate")
	print(obliterator:Get("Baseplate")) -- Returns Baseplate.
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor<{ Baseplate: Part }>();
	obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	print(obliterator.Get("Baseplate")); // Returns Baseplate.
	```

	@method Get
	@within Janitor

	@param index unknown -- The index that the object is stored under.
	@return unknown? -- This will return the object if it is found, but it won't return anything if it doesn't exist.
]=]
Janitor.Get = Get

--[=[
	Adds a [Promise](https://github.com/evaera/roblox-lua-promise) to the
	Janitor. If the Janitor is cleaned up and the Promise is not completed, the
	Promise will be cancelled.

	### Luau:

	```lua
	local obliterator = Janitor.new()
	obliterator:AddPromise(Promise.delay(3)):andThenCall(print, "Finished!"):catch(warn)
	task.wait(1)
	obliterator:Cleanup()
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor();
	obliterator.AddPromise(Promise.delay(3)).andThenCall(print, "Finished!").catch(warn);
	task.wait(1);
	obliterator.Cleanup();
	```

	@error NotAPromiseError -- Thrown if the promise is not a Promise.

	@param promiseObject Promise -- The promise you want to add to the Janitor.
	@param index? unknown -- The index that can be used to clean up the object manually.
	@return Promise
]=]
function Janitor:AddPromise<T...>(promiseObject: Promise<T...>, index: unknown?): Promise<T...>
	if not Promise then
		return promiseObject
	end

	if not Promise.is(promiseObject) then
		error(string.format(NOT_A_PROMISE, typeof(promiseObject), tostring(promiseObject), debug.traceback(nil, 2)))
	end

	if promiseObject:getStatus() ~= Promise.Status.Started then
		return promiseObject
	end

	local uniqueId = index
	if uniqueId == nil then
		uniqueId = newproxy(false)
	end

	local newPromise = Add(self, Promise.new(function(resolve, _, onCancel)
		if onCancel(function()
			promiseObject:cancel()
		end) then
			return
		end

		resolve(promiseObject)
	end), "cancel", uniqueId)

	newPromise:finally(function()
		if Get(self, uniqueId) == newPromise then
			Remove(self, uniqueId)
		end
	end)

	return newPromise :: never
end

--[=[
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of [Janitor.Add](#Add).

	### Luau:

	```lua
	local obliterator = Janitor.new()
	obliterator:Add(workspace.Baseplate, "Destroy", "Baseplate")
	obliterator:Remove("Baseplate")
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor<{ Baseplate: Part }>();
	obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	obliterator.Remove("Baseplate");
	```

	@method Remove
	@within Janitor

	@param index unknown -- The index you want to remove.
	@return Janitor
]=]
Private.Remove = Remove

--[=[
	Removes an object from the Janitor without running a cleanup.

	### Luau

	```lua
	local obliterator = Janitor.new()
	obliterator:Add(function()
		print("Removed!")
	end, true, "Function")

	obliterator:RemoveNoClean("Function") -- Does not print.
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor<{ Function: () => void }>();
	obliterator.Add(() => print("Removed!"), true, "Function");

	obliterator.RemoveNoClean("Function"); // Does not print.
	```

	@method RemoveNoClean
	@within Janitor

	@since v1.15.0
	@param index unknown -- The index you are removing.
	@return Janitor
]=]
function Private:RemoveNoClean(index: any): Janitor
	local this = Janitors[self]

	if this then
		local object = this[index]
		if object then
			self[object] = nil
			this[index] = nil
		end
	end

	return self
end

--[=[
	Cleans up multiple objects at once.

	### Luau:

	```lua
	local obliterator = Janitor.new()
	obliterator:Add(function()
		print("Removed One")
	end, true, "One")

	obliterator:Add(function()
		print("Removed Two")
	end, true, "Two")

	obliterator:Add(function()
		print("Removed Three")
	end, true, "Three")

	obliterator:RemoveList("One", "Two", "Three") -- Prints "Removed One", "Removed Two", and "Removed Three"
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	type NoOp = () => void

	const obliterator = new Janitor<{ One: NoOp, Two: NoOp, Three: NoOp }>();
	obliterator.Add(() => print("Removed One"), true, "One");
	obliterator.Add(() => print("Removed Two"), true, "Two");
	obliterator.Add(() => print("Removed Three"), true, "Three");

	obliterator.RemoveList("One", "Two", "Three"); // Prints "Removed One", "Removed Two", and "Removed Three"
	```

	@since v1.14.0
	@param ... unknown -- The indices you want to remove.
	@return Janitor
]=]
function Janitor:RemoveList(...: any): Janitor
	local this = Janitors[self]
	if this then
		local length = select("#", ...)
		if length == 1 then
			return Remove(self, ...)
		end
		if length == 2 then
			local indexA, indexB = ...
			Remove(self, indexA)
			Remove(self, indexB)
			return self
		end
		if length == 3 then
			local indexA, indexB, indexC = ...
			Remove(self, indexA)
			Remove(self, indexB)
			Remove(self, indexC)
			return self
		end

		for selectIndex = 1, length do
			local removeObject = select(selectIndex, ...)
			Remove(self, removeObject)
		end
	end

	return self
end

--[=[
	Cleans up multiple objects at once without running their cleanup.

	### Luau:

	```lua
	local obliterator = Janitor.new()
	obliterator:Add(function()
		print("Removed One")
	end, true, "One")

	obliterator:Add(function()
		print("Removed Two")
	end, true, "Two")

	obliterator:Add(function()
		print("Removed Three")
	end, true, "Three")

	obliterator:RemoveListNoClean("One", "Two", "Three") -- Nothing is printed.
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	type NoOperation = () => void

	const obliterator = new Janitor<{ One: NoOperation, Two: NoOperation, Three: NoOperation }>();
	obliterator.Add(() => print("Removed One"), true, "One");
	obliterator.Add(() => print("Removed Two"), true, "Two");
	obliterator.Add(() => print("Removed Three"), true, "Three");

	obliterator.RemoveListNoClean("One", "Two", "Three"); // Nothing is printed.
	```

	@since v1.15.0
	@param ... unknown -- The indices you want to remove.
	@return Janitor
]=]
function Janitor:RemoveListNoClean(...: any): Janitor
	local this = Janitors[self]
	if this then
		local length = select("#", ...)
		if length == 1 then
			local indexA = ...
			local object = this[indexA]
			if object then
				self[object] = nil
				this[indexA] = nil
			end
			return self
		end
		if length == 2 then
			local indexA, indexB = ...
			local objectA = this[indexA]
			if objectA then
				self[objectA] = nil
				this[indexA] = nil
			end
			local objectB = this[indexB]
			if objectB then
				self[objectB] = nil
				this[indexB] = nil
			end
			return self
		end
		if length == 3 then
			local indexA, indexB, indexC = ...
			local objectA = this[indexA]
			if objectA then
				self[objectA] = nil
				this[indexA] = nil
			end
			local objectB = this[indexB]
			if objectB then
				self[objectB] = nil
				this[indexB] = nil
			end
			local objectC = this[indexC]
			if objectC then
				self[objectC] = nil
				this[indexC] = nil
			end
			return self
		end

		for selectIndex = 1, length do
			local index = select(selectIndex, ...)
			local object = this[index]
			if object then
				self[object] = nil
				this[index] = nil
			end
		end
	end

	return self
end

--[=[
	Returns a frozen copy of the Janitor's indices.

	### Luau:

	```lua
	local obliterator = Janitor.new()
	obliterator:Add(Workspace.Baseplate, "Destroy", "Baseplate")
	print(obliterator:GetAll().Baseplate) -- Prints Baseplate.
	```

	### TypeScript:

	```ts
	import { Workspace } from "@rbxts/services";
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor<{ Baseplate: Part }>();
	obliterator.Add(Workspace.FindFirstChild("Baseplate") as Part, "Destroy", "Baseplate");
	print(obliterator.GetAll().Baseplate); // Prints Baseplate.
	```

	@since v1.15.1
	@return {[any]: any}
]=]
function Janitor:GetAll(): {[any]: any}
	local this = Janitors[self]
	return if this then table.freeze(table.clone(this)) else {}
end

--[=[
	Calls each object's `methodName` (or calls the object if
	`methodName == true`) and removes them from the Janitor. Also clears the
	namespace. This function is also called when you call a Janitor object (so
	it can be used as a destructor callback).

	### Luau:

	```lua
	obliterator:Cleanup() -- Valid.
	obliterator() -- Also valid.
	```

	### TypeScript:

	```ts
	obliterator.Cleanup()
	// TypeScript version doesn't support the __call method of cleaning.
	```

	@method Cleanup
	@within Janitor
]=]
local function Cleanup(self: Private): ()
	if not self.CurrentlyCleaning then
		local suppressInstanceReDestroy = self.SuppressInstanceReDestroy
		local unsafeThreadCleanup = self.UnsafeThreadCleanup

		self.CurrentlyCleaning = nil :: never
		self.SuppressInstanceReDestroy = nil :: never
		self.UnsafeThreadCleanup = nil :: never

		local object, methodName = next(self)
		while object and methodName do
			if methodName == true then
				if type(object) == "function" then
					object()
				else
					local wasCancelled: boolean? = nil
					if coroutine.running() ~= object then
						wasCancelled = pcall(function()
							task.cancel(object)
						end)
					end

					if not wasCancelled then
						local toCleanup = object
						if unsafeThreadCleanup then
							FastDefer(function()
								task.cancel(toCleanup)
							end)
						else
							task.defer(function()
								task.cancel(toCleanup)
							end)
						end
					end
				end
			else
				if methodName == "Destroy" then
					if self.SuppressInstanceReDestroy and typeof(object) == "Instance" then
						pcall(Destroy, object)
					else
						local destroy = object.Destroy
						if destroy then
							destroy(object)
						end
					end
				elseif methodName == "Disconnect" then
					local disconnect = object.Disconnect
					if disconnect then
						disconnect(object)
					end
				else
					local objectMethod = (object :: never)[methodName] :: (object: unknown) -> ()
					if objectMethod then
						objectMethod(object)
					end
				end
			end

			self[object] = nil
			object, methodName = next(self, object)
		end

		local this = Janitors[self]
		if this then
			table.clear(this)
			Janitors[self] = nil
		end

		self.CurrentlyCleaning = false
		self.SuppressInstanceReDestroy = suppressInstanceReDestroy
		self.UnsafeThreadCleanup = unsafeThreadCleanup
	end
end
Private.Cleanup = Cleanup

--[=[
	Calls [Janitor.Cleanup](#Cleanup) and renders the Janitor unusable.

	:::warning Metatable Removal
	Running this will make any further attempts to call a method of Janitor
	error.
	:::
]=]
function Janitor:Destroy(): ()
	Cleanup(self)
	table.clear(self :: never)
	setmetatable(self :: any, nil)
end

Private.__call = Cleanup

local function LinkToInstance(self: Private, object: Instance, allowMultiple: boolean?): RBXScriptConnection
	local indexToUse = if allowMultiple then newproxy(false) else LinkToInstanceIndex

	return Add(self, object.Destroying:Connect(function()
		Cleanup(self)
	end), "Disconnect", indexToUse)
end

--[=[
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup`
	when the Instance is `Destroy()`d and garbage collected. A Janitor may only
	be linked to one instance at a time, unless `allowMultiple` is true. When
	called with a truthy `allowMultiple` parameter, the Janitor will "link" the
	Instance without overwriting any previous links, and will also not be
	overwritable. When called with a falsy `allowMultiple` parameter, the
	Janitor will overwrite the previous link which was also called with a falsy
	`allowMultiple` parameter, if applicable.

	### Luau:

	```lua
	local obliterator = Janitor.new()

	obliterator:Add(function()
		print("Cleaning up!")
	end, true)

	do
		local folder = Instance.new("Folder")
		obliterator:LinkToInstance(folder)
		folder:Destroy()
	end
	```

	### TypeScript:

	```ts
	import { Janitor } from "@rbxts/janitor";

	const obliterator = new Janitor();
	obliterator.Add(() => print("Cleaning up!"), true);

	{
		const folder = new Instance("Folder");
		obliterator.LinkToInstance(folder, false);
		folder.Destroy();
	}
	```

	@method LinkToInstance
	@within Janitor

	@param object Instance -- The instance you want to link the Janitor to.
	@param allowMultiple? boolean -- Whether or not to allow multiple links on the same Janitor.
	@return RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance.
]=]
Private.LinkToInstance = LinkToInstance;

(Janitor :: never).LegacyLinkToInstance = LinkToInstance

--[=[
	Links several instances to a new Janitor, which is then returned.

	@param ... Instance -- All the Instances you want linked.
	@return Janitor -- A new Janitor that can be used to manually disconnect all LinkToInstances.
]=]
function Janitor:LinkToInstances(...: Instance): Janitor
	local manualCleanup = Janitor.new()
	for index = 1, select("#", ...) do
		local object = select(index, ...)
		if typeof(object) ~= "Instance" then
			continue
		end

		manualCleanup:Add(LinkToInstance(self, object, true), "Disconnect")
	end

	return manualCleanup
end

function Private:__tostring()
	return "Janitor"
end

return table.freeze({
	Janitor = Janitor :: Static;
})
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="75">
                <Properties>
                  <string name="Name">FastDefer</string>
                  <string name="Source"><![CDATA[--!native
--!optimize 2
--!strict

local FreeThreads: {thread} = table.create(500)
local function RunFunction<Arguments...>(callback: (Arguments...) -> (), thread: thread, ...: Arguments...)
	callback(...)
	table.insert(FreeThreads, thread)
end

local function Yield()
	while true do
		RunFunction(coroutine.yield())
	end
end

local function FastDefer<Arguments...>(callback: (Arguments...) -> (), ...: Arguments...): thread
	local thread: thread
	local freeAmount = #FreeThreads

	if freeAmount > 0 then
		thread = FreeThreads[freeAmount]
		FreeThreads[freeAmount] = nil
	else
		thread = coroutine.create(Yield)
		coroutine.resume(thread)
	end

	-- TODO: This might be able to throw?
	return task.defer(thread, callback, thread, ...)
end

return FastDefer
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="76">
                <Properties>
                  <string name="Name">Promise</string>
                  <string name="Source"><![CDATA[--!optimize 2
--!strict
-- Partial types for Promise

-- monkey patched by OverHash for roblox-ts support
-- roblox-ts exposes the TS runtime lib through _G[script]
-- which exposes the Promise library
-- selene: allow(global_usage)
local Promise = _G[script.Parent].Promise

export type Status = "Started" | "Resolved" | "Rejected" | "Cancelled"
export type ErrorKind = "ExecutionError" | "AlreadyCancelled" | "NotResolvedInTime" | "TimedOut"

type ErrorStaticAndShared = {
	Kind: {
		ExecutionError: "ExecutionError",
		AlreadyCancelled: "AlreadyCancelled",
		NotResolvedInTime: "NotResolvedInTime",
		TimedOut: "TimedOut",
	},
}
type ErrorOptions = {
	error: string,
	trace: string?,
	context: string?,
	kind: ErrorKind,
}

export type Error = typeof(setmetatable({} :: ErrorStaticAndShared & {
	error: string,
	trace: string?,
	context: string?,
	kind: ErrorKind,
	parent: Error?,
	createdTick: number,
	createdTrace: string,

	extend: (self: Error, options: ErrorOptions?) -> Error,
	getErrorChain: (self: Error) -> {Error},
}, {} :: {__tostring: (self: Error) -> string}))
type ErrorStatic = ErrorStaticAndShared & {
	new: (options: ErrorOptions?, parent: Error?) -> Error,
	is: (anything: any) -> boolean,
	isKind: (anything: any, kind: ErrorKind) -> boolean,
}

export type Promise = {
	andThen: (
		self: Promise,
		successHandler: (...any) -> ...any,
		failureHandler: ((...any) -> ...any)?
	) -> Promise,
	andThenCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> any,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, ...any),
	awaitStatus: (self: Promise) -> (Status, ...any),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> ...any,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (...any) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}
export type TypedPromise<T...> = {
	andThen: (self: Promise, successHandler: (T...) -> ...any, failureHandler: ((...any) -> ...any)?) -> Promise,
	andThenCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, T...),
	awaitStatus: (self: Promise) -> (Status, T...),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> T...,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (T...) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> TypedPromise<T...>,
}

type Signal<T...> = {
	Connect: (self: Signal<T...>, callback: (T...) -> ...any) -> SignalConnection,
}

type SignalConnection = {
	Disconnect: (self: SignalConnection) -> ...any,
	[any]: any,
}
export type PromiseStatic = {
	Error: ErrorStatic,
	Status: {
		Started: "Started",
		Resolved: "Resolved",
		Rejected: "Rejected",
		Cancelled: "Cancelled",
	},

	all: <T>(promises: {TypedPromise<T>}) -> TypedPromise<{T}>,
	allSettled: <T>(promise: {TypedPromise<T>}) -> TypedPromise<{Status}>,
	any: <T>(promise: {TypedPromise<T>}) -> TypedPromise<T>,
	defer: <TReturn...>(
		executor: (
			resolve: (TReturn...) -> (),
			reject: (...any) -> (),
			onCancel: (abortHandler: (() -> ())?) -> boolean
		) -> ()
	) -> TypedPromise<TReturn...>,
	delay: (seconds: number) -> TypedPromise<number>,
	each: <T, TReturn>(
		list: {T | TypedPromise<T>},
		predicate: (value: T, index: number) -> TReturn | TypedPromise<TReturn>
	) -> TypedPromise<{TReturn}>,
	fold: <T, TReturn>(
		list: {T | TypedPromise<T>},
		reducer: (accumulator: TReturn, value: T, index: number) -> TReturn | TypedPromise<TReturn>
	) -> TypedPromise<TReturn>,
	fromEvent: <TReturn...>(
		event: Signal<TReturn...>,
		predicate: ((TReturn...) -> boolean)?
	) -> TypedPromise<TReturn...>,
	is: (object: any) -> boolean,
	new: <TReturn...>(
		executor: (
			resolve: (TReturn...) -> (),
			reject: (...any) -> (),
			onCancel: (abortHandler: (() -> ())?) -> boolean
		) -> ()
	) -> TypedPromise<TReturn...>,
	onUnhandledRejection: (callback: (promise: TypedPromise<any>, ...any) -> ()) -> () -> (),
	promisify: <TArgs..., TReturn...>(callback: (TArgs...) -> TReturn...) -> (TArgs...) -> TypedPromise<TReturn...>,
	race: <T>(promises: {TypedPromise<T>}) -> TypedPromise<T>,
	reject: (...any) -> TypedPromise<...any>,
	resolve: <TReturn...>(TReturn...) -> TypedPromise<TReturn...>,
	retry: <TArgs..., TReturn...>(
		callback: (TArgs...) -> TypedPromise<TReturn...>,
		times: number,
		TArgs...
	) -> TypedPromise<TReturn...>,
	retryWithDelay: <TArgs..., TReturn...>(
		callback: (TArgs...) -> TypedPromise<TReturn...>,
		times: number,
		seconds: number,
		TArgs...
	) -> TypedPromise<TReturn...>,
	some: <T>(promise: {TypedPromise<T>}, count: number) -> TypedPromise<{T}>,
	try: <TArgs..., TReturn...>(callback: (TArgs...) -> TReturn..., TArgs...) -> TypedPromise<TReturn...>,
}

return Promise :: PromiseStatic?
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="77">
            <Properties>
              <string name="Name">jecs</string>
            </Properties>
            <Item class="ModuleScript" referent="78">
              <Properties>
                <string name="Name">jecs</string>
                <string name="Source"><![CDATA[--!optimize 2
--!native
--!strict
--draft 4

type i53 = number
type i24 = number

type Ty = { Entity }
type ArchetypeId = number

type Column = { any }

type Map<K, V> = { [K]: V }

export type Archetype = {
	id: number,
	types: Ty,
	type: string,
	entities: { Entity },
	columns: { Column },
	columns_map: { [Id]: Column },
	dead: boolean,
}

export type QueryInner = {
	compatible_archetypes: { Archetype },
	ids: { i53 },
	filter_with: { i53 },
	filter_without: { i53 },
	next: () -> (number, ...any),
	world: World,
}

export type Entity<T = any> = number | { __T: T }
export type Id<T = any> = number | { __T: T }
export type Pair<P, O> = Id<P>
type ecs_id_t<T = unknown> = Id<T> | Pair<T, "Tag"> | Pair<"Tag", T>
export type Item<T...> = (self: Query<T...>) -> (Entity, T...)
export type Iter<T...> = (query: Query<T...>) -> () -> (Entity, T...)

export type Query<T...> = typeof(setmetatable(
	{} :: {
		iter: Iter<T...>,
		with: (<a>(Query<T...>, Id<a>) -> Query<T...>)
			& (<a, b>(Query<T...>, Id<a>, Id<b>) -> Query<T...>)
			& (<a, b, c>(Query<T...>, Id<a>, Id<b>, Id<c>) -> Query<T...>)
			& (<a, b, c>(Query<T...>, Id<a>, Id<b>, Id<c>) -> Query<T...>)
			& (<a, b, c, d>(Query<T...>, Id<a>, Id<b>, Id<c>, Id) -> Query<T...>),
		without: (<a>(Query<T...>, Id<a>) -> Query<T...>)
			& (<a, b>(Query<T...>, Id<a>, Id<b>) -> Query<T...>)
			& (<a, b, c>(Query<T...>, Id<a>, Id<b>, Id<c>) -> Query<T...>)
			& (<a, b, c>(Query<T...>, Id<a>, Id<b>, Id<c>) -> Query<T...>)
			& (<a, b, c, d>(Query<T...>, Id<a>, Id<b>, Id<c>, Id) -> Query<T...>),
		archetypes: (self: Query<T...>) -> { Archetype },
		cached: (self: Query<T...>) -> Query<T...>,
	},
	{} :: {
		__iter: Iter<T...>,
	}
))

type QueryArm<T...> = () -> ()

export type Observer = {
	callback: (archetype: Archetype) -> (),
	query: QueryInner,
}

export type World = {
	archetype_edges: Map<Entity, Map<Entity, Archetype>>,
	archetype_index: { [string]: Archetype },
	archetypes: Archetypes,
	component_index: ComponentIndex,
	entity_index: EntityIndex,
	ROOT_ARCHETYPE: Archetype,

	max_component_id: number,
	max_archetype_id: number,

	observable: Map<Id, Map<Id, { Observer }>>,

	--- Enforce a check on entities to be created within desired range
	range: (self: World, range_begin: number, range_end: number?) -> (),

	--- Creates a new entity
	entity: <T>(self: World, id: Entity<T>?) -> Entity<T>,
	--- Creates a new entity located in the first 256 ids.
	--- These should be used for static components for fast access.
	component: <T>(self: World) -> Entity<T>,
	--- Gets the target of an relationship. For example, when a user calls
	--- `world:target(id, ChildOf(parent), 0)`, you will obtain the parent entity.
	target: <T, a>(self: World, id: Entity<T>, relation: Id<a>, index: number?) -> Entity?,
	--- Deletes an entity and all it's related components and relationships.
	delete: <T>(self: World, id: Entity<T>) -> (),

	--- Adds a component to the entity with no value
	add: <T, a>(self: World, id: Entity<T>, component: Id<a>) -> (),
	--- Assigns a value to a component on the given entity
	set: <T, a>(self: World, id: Entity<T>, component: Id<a>, data: a) -> (),

	cleanup: (self: World) -> (),
	-- Clears an entity from the world
	clear: <a>(self: World, id: Id<a>) -> (),
	--- Removes a component from the given entity
	remove: <T, a>(self: World, id: Entity<T>, component: Id<a>) -> (),
	--- Retrieves the value of up to 4 components. These values may be nil.
	get: & (<T, a>(World, Entity<T>, Id<a>) -> a?)
		& (<T, a, b>(World, Entity<T>, Id<a>, Id<b>) -> (a?, b?))
		& (<T, a, b, c>(World, Entity<T>, Id<a>, Id<b>, Id<c>) -> (a?, b?, c?))
		& (<T, a, b, c, d>(World, Entity<T>, Id<a>, Id<b>, Id<c>, Id<d>) -> (a?, b?, c?, d?)),

	--- Returns whether the entity has the ID.
	has: (<T, a>(World, Entity<T>, Id<a>) -> boolean)
		& (<T, a, b>(World, Entity<T>, Id<a>, Id<a>) -> boolean)
		& (<T, a, b, c>(World, Entity<T>, Id<a>, Id<b>, Id<c>) -> boolean)
		& <T, a, b, c, d>(World, Entity<T>, Id<a>, Id<b>, Id<c>, Id<d>) -> boolean,

	--- Get parent (target of ChildOf relationship) for entity. If there is no ChildOf relationship pair, it will return nil.
	parent: <T>(self: World, entity: Entity<T>) -> Entity?,

	--- Checks if the world contains the given entity
	contains: <T>(self: World, entity: Entity<T>) -> boolean,

	--- Checks if the entity exists
	exists: <T>(self: World, entity: Entity<T>) -> boolean,

	each: <T>(self: World, id: Id<T>) -> () -> Entity,

	children: <T>(self: World, id: Id<T>) -> () -> Entity,

	--- Searches the world for entities that match a given query
	query: (<A>(World, Id<A>) -> Query<A>)
		& (<A, B>(World, Id<A>, Id<B>) -> Query<A, B>)
		& (<A, B, C>(World, Id<A>, Id<B>, Id<C>) -> Query<A, B, C>)
		& (<A, B, C, D>(World, Id<A>, Id<B>, Id<C>, Id<D>) -> Query<A, B, C, D>)
		& (<A, B, C, D, E>(World, Id<A>, Id<B>, Id<C>, Id<D>, Id<E>) -> Query<A, B, C, D, E>)
		& (<A, B, C, D, E, F>(World, Id<A>, Id<B>, Id<C>, Id<D>, Id<E>, Id<F>) -> Query<A, B, C, D, E, F>)
		& (<A, B, C, D, E, F, G>(
			World,
			Id<A>,
			Id<B>,
			Id<C>,
			Id<D>,
			Id<E>,
			Id<F>,
			Id<G>
		) -> Query<A, B, C, D, E, F, G>)
		& (<A, B, C, D, E, F, G, H>(
			World,
			Id<A>,
			Id<B>,
			Id<C>,
			Id<D>,
			Id<E>,
			Id<F>,
			Id<G>,
			Id<H>,
			...Id<any>
		) -> Query<A, B, C, D, E, F, G, H>),
}

export type Record = {
	archetype: Archetype,
	row: number,
	dense: i24,
}
export type ComponentRecord = {
	records: { [Id]: number },
	counts: { [Id]: number },
	flags: number,
	size: number,

	on_add: (<T>(entity: Entity, id: Entity<T>, value: T?) -> ())?,
	on_change: (<T>(entity: Entity, id: Entity<T>, value: T) -> ())?,
	on_remove: ((entity: Entity, id: Entity) -> ())?,
}
export type ComponentIndex = Map<Id, ComponentRecord>
export type Archetypes = { [Id]: Archetype }

export type EntityIndex = {
	dense_array: Map<number, Entity>,
	sparse_array: Map<i24, Record>,
	alive_count: number,
	max_id: number,
	range_begin: number?,
	range_end: number?,
}

-- stylua: ignore start

local ECS_ENTITY_MASK =       bit32.lshift(1, 24)
local ECS_GENERATION_MASK =   bit32.lshift(1, 16)
local ECS_PAIR_OFFSET = 	                 2^48

local ECS_ID_DELETE =                 	   0b0001
local ECS_ID_IS_TAG =                 	   0b0010
local ECS_ID_IS_EXCLUSIVE =                0b0100
local ECS_ID_MASK =                   	   0b0000

local HI_COMPONENT_ID =                       256
local EcsOnAdd =             HI_COMPONENT_ID +  1
local EcsOnRemove =          HI_COMPONENT_ID +  2
local EcsOnChange =          HI_COMPONENT_ID +  3
local EcsWildcard =          HI_COMPONENT_ID +  4
local EcsChildOf =           HI_COMPONENT_ID +  5
local EcsComponent =         HI_COMPONENT_ID +  6
local EcsOnDelete =          HI_COMPONENT_ID +  7
local EcsOnDeleteTarget =    HI_COMPONENT_ID +  8
local EcsDelete =            HI_COMPONENT_ID +  9
local EcsRemove =            HI_COMPONENT_ID + 10
local EcsName =              HI_COMPONENT_ID + 11
local EcsOnArchetypeCreate = HI_COMPONENT_ID + 12
local EcsOnArchetypeDelete = HI_COMPONENT_ID + 13
local EcsExclusive =         HI_COMPONENT_ID + 14
local EcsRest =              HI_COMPONENT_ID + 15

local NULL_ARRAY = table.freeze({}) :: Column
local NULL = newproxy(false)

local ECS_INTERNAL_ERROR = [[
	This is an internal error, please file a bug report via the following link:

	https://github.com/Ukendio/jecs/issues/new?template=BUG-REPORT.md
]]

local function ecs_assert(condition, msg: string?)
	if not condition then
		error(msg)
	end
end

local ecs_metadata: Map<i53, Map<i53, any>> = {}
local ecs_max_component_id = 0
local ecs_max_tag_id = EcsRest

local function ECS_COMPONENT()
	ecs_max_component_id += 1
	if ecs_max_component_id > HI_COMPONENT_ID then
		error("Too many components")
	end
	return ecs_max_component_id
end

local function ECS_TAG()
	ecs_max_tag_id += 1
	return ecs_max_tag_id
end

local function ECS_META(id: i53, ty: i53, value: any?)
	local bundle = ecs_metadata[id]
	if bundle == nil then
		bundle = {}
		ecs_metadata[id] = bundle
	end
	bundle[ty] = if value == nil then NULL else value
end

local function ECS_META_RESET()
	ecs_metadata = {}
	ecs_max_component_id = 0
	ecs_max_tag_id = EcsRest
end

local function ECS_COMBINE(id: number, generation: number): i53
	return id + (generation * ECS_ENTITY_MASK)
end

local function ECS_IS_PAIR(e: number): boolean
	return e > ECS_PAIR_OFFSET
end

local function ECS_GENERATION_INC(e: i53): i53
	if e > ECS_ENTITY_MASK then
		local id = e % ECS_ENTITY_MASK
		local generation = e // ECS_ENTITY_MASK

		local next_gen = generation + 1
		if next_gen >= ECS_GENERATION_MASK then
			return id
		end

		return ECS_COMBINE(id, next_gen)
	end
	return ECS_COMBINE(e, 1)
end

local function ECS_ENTITY_T_LO(e: i53): i24
	return e % ECS_ENTITY_MASK
end

local function ECS_ID(e: i53)
	return e % ECS_ENTITY_MASK
end

local function ECS_GENERATION(e: i53)
	return e // ECS_ENTITY_MASK
end

local function ECS_ENTITY_T_HI(e: i53): i24
	return e // ECS_ENTITY_MASK
end

local function ECS_PAIR(pred: i53, obj: i53): i53
	pred %= ECS_ENTITY_MASK
	obj %= ECS_ENTITY_MASK

	return obj + (pred * ECS_ENTITY_MASK) + ECS_PAIR_OFFSET
end

local function ECS_PAIR_FIRST(e: i53): i24
	return (e - ECS_PAIR_OFFSET) // ECS_ENTITY_MASK
end

local function ECS_PAIR_SECOND(e: i53): i24
	return (e - ECS_PAIR_OFFSET) % ECS_ENTITY_MASK
end

local function entity_index_try_get_any(
	entity_index: EntityIndex,
	entity: Entity
): Record?
	local r = entity_index.sparse_array[ECS_ENTITY_T_LO(entity::number)]

	if not r or r.dense == 0 then
		return nil
	end

	return r
end

local function entity_index_try_get(entity_index: EntityIndex, entity: Entity): Record?
	local r = entity_index_try_get_any(entity_index, entity :: number)
	if r then
		local r_dense = r.dense
		if r_dense > entity_index.alive_count then
			return nil
		end
		if entity_index.dense_array[r_dense] ~= entity then
			return nil
		end
	end
	return r
end

local function entity_index_try_get_fast(entity_index: EntityIndex, entity: Entity): Record?
	local r = entity_index_try_get_any(entity_index, entity)
	if r then
		local r_dense = r.dense
		-- if r_dense > entity_index.alive_count then
		-- 	return nil
		-- end
		if entity_index.dense_array[r_dense] ~= entity then
			return nil
		end
	end
	return r
end

local function entity_index_is_alive<T>(entity_index: EntityIndex, entity: Entity<T>): boolean
	return entity_index_try_get(entity_index, entity) ~= nil
end

local function entity_index_get_alive<T>(entity_index: EntityIndex, entity: Entity<T>): Entity<T>?
	local r = entity_index_try_get_any(entity_index, entity :: number)
	if r then
		return entity_index.dense_array[r.dense]
	end
	return nil
end

local function ecs_get_alive<T>(world: World, entity: Entity<T>): Entity
	if entity == 0 then
		return 0
	end

	local eindex = world.entity_index

	if entity_index_is_alive(eindex, entity) then
		return entity
	end

	if (entity :: number) > ECS_ENTITY_MASK then
		return 0
	end

	local current = entity_index_get_alive(eindex, entity)
	if not current or not entity_index_is_alive(eindex, current) then
		return 0
	end

	return current
end

local ECS_INTERNAL_ERROR_INCOMPATIBLE_ENTITY = "Entity is outside range"

local function entity_index_new_id(entity_index: EntityIndex): Entity
	local dense_array = entity_index.dense_array
	local alive_count = entity_index.alive_count
	local sparse_array = entity_index.sparse_array
	local max_id = entity_index.max_id

	if alive_count < max_id then
		alive_count += 1
		entity_index.alive_count = alive_count
		local id = dense_array[alive_count]
		return id
	end

	local id = max_id + 1
	local range_end = entity_index.range_end
	ecs_assert(range_end == nil or id < range_end, ECS_INTERNAL_ERROR_INCOMPATIBLE_ENTITY)

	entity_index.max_id = id
	alive_count += 1
	entity_index.alive_count = alive_count
	dense_array[alive_count] = id
	sparse_array[id] = { dense = alive_count } :: Record

	return id
end

local function ecs_pair_first(world: World, e: i53)
	local pred = ECS_PAIR_FIRST(e)
	return ecs_get_alive(world, pred)
end

local function ecs_pair_second(world: World, e: i53)
	local obj = ECS_PAIR_SECOND(e)
	return ecs_get_alive(world, obj)
end

local function query_match(query: QueryInner, archetype: Archetype)
	local columns_map = archetype.columns_map
	local with = query.filter_with

	for _, id in with do
		if not columns_map[id] then
			return false
		end
	end

	local without = query.filter_without
	if without then
		for _, id in without do
			if columns_map[id] then
				return false
			end
		end
	end

	return true
end

local function find_observers(world: World, event: Id, component: Id): { Observer }?
	local cache = world.observable[event]
	if not cache then
		return nil
	end
	return cache[component] :: any
end

local function archetype_move(
	entity_index: EntityIndex,
	entity: Entity,
	to: Archetype,
	dst_row: i24,
	from: Archetype,
	src_row: i24
)
	local src_columns = from.columns
	local dst_entities = to.entities
	local src_entities = from.entities

	local last = #src_entities
	local id_types = from.types
	local columns_map = to.columns_map

	if src_row ~= last then
		-- If the entity is the last row in the archetype then swapping it would be meaningless.

		for i, column in src_columns do
			if column == NULL_ARRAY then
				continue
			end
			-- Retrieves the new column index from the source archetype's record from each component
			-- We have to do this because the columns are tightly packed and indexes may not correspond to each other.
			local dst_column = columns_map[id_types[i]]

			-- Sometimes target column may not exist, e.g. when you remove a component.
			if dst_column then
				dst_column[dst_row] = column[src_row]
			end

			-- Swap rempves columns to ensure there are no holes in the archetype.
			column[src_row] = column[last]
			column[last] = nil
		end


		-- Move the entity from the source to the destination archetype.
		-- Because we have swapped columns we now have to update the records
		-- corresponding to the entities' rows that were swapped.

		local e2 = src_entities[last]
		src_entities[src_row] = e2

		local sparse_array = entity_index.sparse_array
		local record2 = sparse_array[ECS_ENTITY_T_LO(e2 :: number)]
		record2.row = src_row
	else
		for i, column in src_columns do
			if column == NULL_ARRAY then
				continue
			end
			-- Retrieves the new column index from the source archetype's record from each component
			-- We have to do this because the columns are tightly packed and indexes may not correspond to each other.
			local dst_column = columns_map[id_types[i]]

			-- Sometimes target column may not exist, e.g. when you remove a component.
			if dst_column then
				dst_column[dst_row] = column[src_row]
			end

			column[last] = nil
		end
	end

	src_entities[last] = nil :: any
	dst_entities[dst_row] = entity
end

local function archetype_append(
	entity: Entity,
	archetype: Archetype
): number
	local entities = archetype.entities
	local length = #entities + 1
	entities[length] = entity
	return length
end

local function new_entity(
	entity: Entity,
	record: Record,
	archetype: Archetype
): Record
	local row = archetype_append(entity, archetype)
	record.archetype = archetype
	record.row = row
	return record
end

local function entity_move(
	entity_index: EntityIndex,
	entity: Entity,
	record: Record,
	to: Archetype
)
	local sourceRow = record.row
	local from = record.archetype
	local dst_row = archetype_append(entity, to)
	archetype_move(entity_index, entity, to, dst_row, from, sourceRow)
	record.archetype = to
	record.row = dst_row
end

local function hash(arr: { Entity }): string
	return table.concat(arr, "_")
end

local function fetch(id: Id, columns_map: { [Entity]: Column }, row: number): any
	local column = columns_map[id]

	if not column then
		return nil
	end

	return column[row]
end

local function world_get(world: World, entity: Entity,
	a: Id, b: Id?, c: Id?, d: Id?, e: Id?): ...any
	local record = entity_index_try_get(world.entity_index, entity)
	if not record then
		return nil
	end

	local archetype = record.archetype
	if not archetype then
		return nil
	end

	local columns_map = archetype.columns_map
	local row = record.row

	local va = fetch(a, columns_map, row)

	if not b then
		return va
	elseif not c then
		return va, fetch(b, columns_map, row)
	elseif not d then
		return va, fetch(b, columns_map, row), fetch(c, columns_map, row)
	elseif not e then
		return va, fetch(b, columns_map, row), fetch(c, columns_map, row), fetch(d, columns_map, row)
	else
		error("args exceeded")
	end
end

local function world_has_one_inline(world: World, entity: Entity, id: i53): boolean
	local record = entity_index_try_get(world.entity_index, entity)
	if not record then
		return false
	end

	local archetype = record.archetype
	if not archetype then
		return false
	end

	return archetype.columns_map[id] ~= nil
end

local function world_target(world: World, entity: Entity, relation: Id, index: number?): Entity?
	local entity_index = world.entity_index
	local record = entity_index_try_get(entity_index, entity)
	if not record then
		return nil
	end

	local archetype = record.archetype
	if not archetype then
		return nil
	end

	local r = ECS_PAIR(relation :: number, EcsWildcard)
	local idr = world.component_index[r]

	if not idr then
		return nil
	end

	local archetype_id = archetype.id
	local count = idr.counts[archetype_id]
	if not count then
		return nil
	end

	local nth = index or 0

	if nth >= count then
		nth = nth + count + 1
	end

	nth = archetype.types[nth + idr.records[archetype_id]]

	if not nth then
		return nil
	end

	return entity_index_get_alive(entity_index,
	    ECS_PAIR_SECOND(nth :: number))
end

local function ECS_ID_IS_WILDCARD(e: i53): boolean
	local first = ECS_ENTITY_T_HI(e)
	local second = ECS_ENTITY_T_LO(e)
	return first == EcsWildcard or second == EcsWildcard
end

local function id_record_get(world: World, id: Entity): ComponentRecord?
	local component_index = world.component_index
	local idr: ComponentRecord = component_index[id]

	if idr then
		return idr
	end

	return nil
end

local function id_record_ensure(world: World, id: Entity): ComponentRecord
	local component_index = world.component_index
	local entity_index = world.entity_index
	local idr: ComponentRecord? = component_index[id]

	if idr then
		return idr
	end

	local flags = ECS_ID_MASK
	local relation = id
	local target = 0
	local is_pair = ECS_IS_PAIR(id :: number)

	local has_delete = false
	local is_exclusive = false

	if is_pair then
		relation = entity_index_get_alive(entity_index, ECS_PAIR_FIRST(id :: number)) :: i53
		ecs_assert(relation and entity_index_is_alive(
			entity_index, relation), ECS_INTERNAL_ERROR)
		target = entity_index_get_alive(entity_index, ECS_PAIR_SECOND(id :: number)) :: i53
		ecs_assert(target and entity_index_is_alive(
			entity_index, target), ECS_INTERNAL_ERROR)

		local cleanup_policy_target = world_target(world, relation, EcsOnDeleteTarget, 0)

		if cleanup_policy_target == EcsDelete then
			has_delete = true
		end

		if world_has_one_inline(world, relation, EcsExclusive) then
			is_exclusive = true
		end
	else
		local cleanup_policy = world_target(world, relation, EcsOnDelete, 0)

		if cleanup_policy == EcsDelete then
			has_delete = true
		end
	end

	local on_add, on_change, on_remove = world_get(world,
		relation, EcsOnAdd, EcsOnChange, EcsOnRemove)

	local is_tag = not world_has_one_inline(world,
		relation, EcsComponent)

	if is_tag and is_pair then
		is_tag = not world_has_one_inline(world, target, EcsComponent)
	end

	flags = bit32.bor(
		flags,
		if has_delete then ECS_ID_DELETE else 0,
		if is_tag then ECS_ID_IS_TAG else 0,
		if is_exclusive then ECS_ID_IS_EXCLUSIVE else 0
	)

	idr = {
		size = 0,
		records = {},
		counts = {},
		flags = flags,

		on_add = on_add,
		on_change = on_change,
		on_remove = on_remove,
	} :: ComponentRecord

	component_index[id] = idr

	return idr
end

local function archetype_append_to_records(
	idr: ComponentRecord,
	archetype_id: number,
	columns_map: { [Id]: Column },
	id: i53,
	index: number,
	column: Column
)
	local idr_records = idr.records
	local idr_counts = idr.counts
	local tr = idr_records[archetype_id]
	if not tr then
		idr_records[archetype_id] = index
		idr_counts[archetype_id] = 1
		columns_map[id] = column
	else
		local max_count = idr_counts[archetype_id] + 1
		idr_counts[archetype_id] = max_count
	end
end

local function archetype_register(world: World, archetype: Archetype)
	local archetype_id = archetype.id
	local columns_map = archetype.columns_map
	local columns = archetype.columns

	for i, component_id in archetype.types do
		local idr = id_record_ensure(world, component_id)
		local is_tag = bit32.btest(idr.flags, ECS_ID_IS_TAG)
		local column = if is_tag then NULL_ARRAY else {}
		columns[i] = column

		archetype_append_to_records(idr, archetype_id, columns_map, component_id :: number, i, column)

		if ECS_IS_PAIR(component_id :: number) then
			local relation = ECS_PAIR_FIRST(component_id :: number)
			local object = ECS_PAIR_SECOND(component_id :: number)
			local r = ECS_PAIR(relation, EcsWildcard)
			local idr_r = id_record_ensure(world, r)

			archetype_append_to_records(idr_r, archetype_id, columns_map, r, i, column)

			local t = ECS_PAIR(EcsWildcard, object)
			local idr_t = id_record_ensure(world, t)

			archetype_append_to_records(idr_t, archetype_id, columns_map, t, i, column)
		end
	end

	world.archetype_index[archetype.type] = archetype
	world.archetypes[archetype_id] = archetype
	world.archetype_edges[archetype.id] = {} :: Map<Id, Archetype>
end

local function archetype_create(world: World, id_types: { Id }, ty, prev: i53?): Archetype
	local archetype_id = (world.max_archetype_id :: number) + 1
	world.max_archetype_id = archetype_id

	local length = #id_types
	local columns = (table.create(length) :: any) :: { Column }

	local columns_map: { [Id]: Column } = {}

	local archetype: Archetype = {
		columns = columns,
		columns_map = columns_map,
		entities = {},
		id = archetype_id,
		type = ty,
		types = id_types,
		dead = false,
	}

	archetype_register(world, archetype, false)

	for id in columns_map do
		local observer_list = find_observers(world, EcsOnArchetypeCreate, id)
		if not observer_list then
			continue
		end
		for _, observer in observer_list do
			if query_match(observer.query :: QueryInner, archetype) then
				observer.callback(archetype)
			end
		end
	end


	return archetype
end

local function world_range(world: World, range_begin: number, range_end: number?)
	local entity_index = world.entity_index

	entity_index.range_begin = range_begin
	entity_index.range_end = range_end

	local max_id = entity_index.max_id

	if range_begin > max_id then
		local dense_array = entity_index.dense_array
		local sparse_array = entity_index.sparse_array

		for i = max_id + 1, range_begin do
			dense_array[i] = i
			sparse_array[i] = {
				dense = 0
			} :: Record
		end
		entity_index.max_id = range_begin - 1
		entity_index.alive_count = range_begin - 1
	end
end

local function archetype_ensure(world: World, id_types: { Id }): Archetype
	if #id_types < 1 then
		return world.ROOT_ARCHETYPE
	end

	local ty = hash(id_types)
	local archetype = world.archetype_index[ty]
	if archetype then
		if archetype.dead then
			archetype_register(world, archetype)
			archetype.dead = false :: any
		end
		return archetype
	end

	return archetype_create(world, id_types, ty)
end

local function find_insert(id_types: { i53 }, toAdd: i53): number
	for i, id in id_types do
		if id == toAdd then
			return -1
		end
		if id > toAdd then
			return i
		end
	end
	return #id_types + 1
end

local function find_archetype_without(
	world: World,
	node: Archetype,
	id: Id
): Archetype
	local id_types = node.types
	local at = table.find(id_types, id)

	local dst = table.clone(id_types)
	table.remove(dst, at)

	return archetype_ensure(world, dst)
end


local function create_edge_for_remove(
	world: World,
	node: Archetype,
	edge: Map<Id, Archetype>,
	id: Id
): Archetype
	local to = find_archetype_without(world, node, id)
	local edges = world.archetype_edges
	local archetype_id = node.id
	edges[archetype_id][id] = to
	edges[to.id][id] = node
	return to
end

local function archetype_traverse_remove(
	world: World,
	id: Id,
	from: Archetype
): Archetype
	local edges = world.archetype_edges
	local edge = edges[from.id]

	local to: Archetype = edge[id]
	if to == nil then
		to = find_archetype_without(world, from, id)
		edge[id] = to
		edges[to.id][id] = from
	end

	return to
end

local function find_archetype_with(world: World, id: Id, from: Archetype): Archetype
	local id_types = from.types
	local dst = table.clone(id_types)

	local at = find_insert(id_types :: { number } , id :: number)

	table.insert(dst, at, id)

	return archetype_ensure(world, dst)
end

local function archetype_traverse_add(world: World, id: Id, from: Archetype): Archetype
	from = from or world.ROOT_ARCHETYPE
	if from.columns_map[id] then
		return from
	end
	local edges = world.archetype_edges
	local edge = edges[from.id]

	local to = edge[id]
	if not to then
		to = find_archetype_with(world, id, from)
		edge[id] = to
		edges[to.id][id] = from
	end

	return to
end

local function world_component(world: World): i53
	local id = (world.max_component_id :: number) + 1
	if id > HI_COMPONENT_ID then
		-- IDs are partitioned into ranges because component IDs are not nominal,
		-- so it needs to error when IDs intersect into the entity range.
		error("Too many components, consider using world:entity() instead to create components.")
	end
	world.max_component_id = id

	return id
end

local function archetype_fast_delete_last(columns: { Column }, column_count: number)
	for i, column in columns do
		if column ~= NULL_ARRAY then
			column[column_count] = nil
		end
	end
end

local function archetype_fast_delete(columns: { Column }, column_count: number, row: number)
	for i, column in columns do
		if column ~= NULL_ARRAY then
			column[row] = column[column_count]
			column[column_count] = nil
		end
	end
end

local function archetype_delete(world: World, archetype: Archetype, row: number)
	local entity_index = world.entity_index
	local component_index = world.component_index
	local columns = archetype.columns
	local id_types = archetype.types
	local entities = archetype.entities
	local column_count = #entities
	local last = #entities
	local move = entities[last]
	-- We assume first that the entity is the last in the archetype
	local delete = move

	if row ~= last then
		local record_to_move = entity_index_try_get_any(entity_index, move :: number)
		if record_to_move then
			record_to_move.row = row
		end

		delete = entities[row]
		entities[row] = move
	end

	for _, id in id_types do
		local idr = component_index[id]
		local on_remove = idr.on_remove
		if on_remove then
			on_remove(delete, id)
		end
	end

	entities[last] = nil :: any

	if row == last then
		archetype_fast_delete_last(columns, column_count)
	else
		archetype_fast_delete(columns, column_count, row)
	end
end


local function archetype_destroy(world: World, archetype: Archetype)
	if archetype == world.ROOT_ARCHETYPE then
		return
	end

	local component_index = world.component_index
	local archetype_edges = world.archetype_edges

	for id, edge in archetype_edges[archetype.id] do
		archetype_edges[edge.id][id] = nil
	end

	local archetype_id = archetype.id
	world.archetypes[archetype_id] = nil :: any
	world.archetype_index[archetype.type] = nil :: any
	local columns_map = archetype.columns_map

	for id in columns_map do
		local idr = component_index[id]
		idr.records[archetype_id] = nil :: any
		idr.counts[archetype_id] = nil
		idr.size -= 1
		if idr.size == 0 then
			component_index[id] = nil :: any
		end
		local observer_list = find_observers(world, EcsOnArchetypeDelete, id)
		if not observer_list then
			continue
		end
		for _, observer in observer_list do
			if query_match(observer.query, archetype) then
				observer.callback(archetype)
			end
		end
	end

	archetype.dead = true
end

local function NOOP() end


local function query_iter_init(query: QueryInner): () -> (number, ...any)
	local world_query_iter_next

	local compatible_archetypes = query.compatible_archetypes
	local lastArchetype = 1
	local archetype = compatible_archetypes[1]
	if not archetype then
		return NOOP :: () -> (number, ...any)
	end
	local entities = archetype.entities
	local i = #entities
	local columns_map = archetype.columns_map

	local ids = query.ids
	local A, B, C, D, E, F, G, H, I = unpack(ids)
	local a: Column, b: Column, c: Column, d: Column
	local e: Column, f: Column, g: Column, h: Column

	if not B then
		a = columns_map[A]
	elseif not C then
		a = columns_map[A]
		b = columns_map[B]
	elseif not D then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
	elseif not E then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
	elseif not F then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
	elseif not G then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
		f = columns_map[F]
	elseif not H then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
		f = columns_map[F]
		g = columns_map[G]
	else
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
		f = columns_map[F]
		g = columns_map[G]
		h = columns_map[H]
	end

	if not B then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
			end

			local row = i
			i -= 1

			return entity, a[row]
		end
	elseif not C then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row]
		end
	elseif not D then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row]
		end
	elseif not E then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row]
		end
	elseif not F then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row]
		end
	elseif not G then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row]
		end
	elseif not H then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row]
		end
	elseif not I then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row]
		end
	else
		local output = {}
		local ids_len = #ids
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			for i = 9, ids_len do
				output[i - 8] = columns_map[i][row]
			end

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row], unpack(output)
		end
	end

	query.next = world_query_iter_next
	return world_query_iter_next
end

local function query_iter(query): () -> (number, ...any)
	local query_next = query.next
	if not query_next then
		query_next = query_iter_init(query)
	end
	return query_next
end

local function query_without(query: QueryInner, ...: i53)
	local without = { ... }
	query.filter_without = without
	local compatible_archetypes = query.compatible_archetypes
	for i = #compatible_archetypes, 1, -1 do
		local archetype = compatible_archetypes[i]
		local columns_map = archetype.columns_map
		local matches = true

		for _, id in without do
			if columns_map[id] then
				matches = false
				break
			end
		end

		if matches then
			continue
		end

		local last = #compatible_archetypes
		if last ~= i then
			compatible_archetypes[i] = compatible_archetypes[last]
		end
		compatible_archetypes[last] = nil :: any
	end

	return query :: any
end

local function query_with(query: QueryInner, ...: i53)
	local compatible_archetypes = query.compatible_archetypes
	local with = { ... }
	query.filter_with = with

	for i = #compatible_archetypes, 1, -1 do
		local archetype = compatible_archetypes[i]
		local columns_map = archetype.columns_map
		local matches = true

		for _, id in with do
			if not columns_map[id] then
				matches = false
				break
			end
		end

		if matches then
			continue
		end

		local last = #compatible_archetypes
		if last ~= i then
			compatible_archetypes[i] = compatible_archetypes[last]
		end
		compatible_archetypes[last] = nil :: any
	end

	return query :: any
end

-- Meant for directly iterating over archetypes to minimize
-- function call overhead. Should not be used unless iterating over
-- hundreds of thousands of entities in bulk.
local function query_archetypes(query)
	return query.compatible_archetypes
end

local function query_cached(query: QueryInner)
	local with = query.filter_with
	local ids = query.ids
	if with then
		table.move(ids, 1, #ids, #with + 1, with)
	else
		query.filter_with = ids
	end

	local compatible_archetypes = query.compatible_archetypes
	local lastArchetype = 1

	local A, B, C, D, E, F, G, H, I = unpack(ids)
	local a: Column, b: Column, c: Column, d: Column
	local e: Column, f: Column, g: Column, h: Column

	local world_query_iter_next
	local entities: { Entity }
	local i: number
	local archetype: Archetype
	local columns_map: { [Id]: Column }
	local archetypes = query.compatible_archetypes

	local world = query.world
	-- Only need one observer for EcsArchetypeCreate and EcsArchetypeDelete respectively
	-- because the event will be emitted for all components of that Archetype.
	local observable = world.observable
	local on_create_action = observable[EcsOnArchetypeCreate]
	if not on_create_action then
		on_create_action = {} :: Map<Id, { Observer }>
		observable[EcsOnArchetypeCreate] = on_create_action
	end
	local query_cache_on_create = on_create_action[A]
	if not query_cache_on_create then
		query_cache_on_create = {}
		on_create_action[A] = query_cache_on_create
	end

	local on_delete_action = observable[EcsOnArchetypeDelete]
	if not on_delete_action then
		on_delete_action = {} :: Map<Id, { Observer }>
		observable[EcsOnArchetypeDelete] = on_delete_action
	end
	local query_cache_on_delete = on_delete_action[A]
	if not query_cache_on_delete then
		query_cache_on_delete = {}
		on_delete_action[A] = query_cache_on_delete
	end

	local function on_create_callback(archetype)
		table.insert(archetypes, archetype)
	end

	local function on_delete_callback(archetype)
		local i = table.find(archetypes, archetype) :: number
		if i == nil then
			return
		end
		local n = #archetypes
		archetypes[i] = archetypes[n]
		archetypes[n] = nil
	end

	local observer_for_create = { query = query, callback = on_create_callback }
	local observer_for_delete = { query = query, callback = on_delete_callback }

	table.insert(query_cache_on_create, observer_for_create)
	table.insert(query_cache_on_delete, observer_for_delete)

	local function cached_query_iter()
		lastArchetype = 1
		archetype = compatible_archetypes[lastArchetype]
		if not archetype then
			return NOOP
		end
		entities = archetype.entities
		i = #entities
		columns_map = archetype.columns_map
		if not B then
			a = columns_map[A]
		elseif not C then
			a = columns_map[A]
			b = columns_map[B]
		elseif not D then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
		elseif not E then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
		elseif not F then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
		elseif not G then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
			f = columns_map[F]
		elseif not H then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
			f = columns_map[F]
			g = columns_map[G]
		else
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
			f = columns_map[F]
			g = columns_map[G]
			h = columns_map[H]
		end

		return world_query_iter_next
	end

	if not B then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
			end

			local row = i
			i -= 1

			return entity, a[row]
		end
	elseif not C then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row]
		end
	elseif not D then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row]
		end
	elseif not E then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row]
		end
	elseif not F then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row]
		end
	elseif not G then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row]
		end
	elseif not H then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row]
		end
	elseif not I then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row]
		end
	else
		local output = {}
		local ids_len = #ids
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			for i = 9, ids_len do
				output[i - 8] = columns_map[i][row]
			end

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], unpack(output)
		end
	end

	local cached_query = query :: any
	cached_query.archetypes = query_archetypes
	cached_query.__iter = cached_query_iter
	cached_query.iter = cached_query_iter
	setmetatable(cached_query, cached_query)
	return cached_query
end

local Query = {}
Query.__index = Query
Query.__iter = query_iter
Query.iter = query_iter_init
Query.without = query_without
Query.with = query_with
Query.archetypes = query_archetypes
Query.cached = query_cached

local function world_query(world: World, ...)
	local compatible_archetypes = {}
	local length = 0

	local ids = { ... }

	local archetypes = world.archetypes

	local idr: ComponentRecord?
	local component_index = world.component_index

	local q = setmetatable({
		ids = ids,
		compatible_archetypes = compatible_archetypes,
		world = world,
	}, Query)

	for _, id in ids do
		local map = component_index[id]
		if not map then
			return q
		end

		if idr == nil or (map.size :: number) < (idr.size :: number) then
			idr = map
		end
	end

	if idr == nil then
		return q
	end

	for archetype_id in idr.records do
		local compatibleArchetype = archetypes[archetype_id]
		if #compatibleArchetype.entities == 0 then
			continue
		end
		local columns_map = compatibleArchetype.columns_map

		local skip = false

		for i, id in ids do
			local column = columns_map[id]
			if not column then
				skip = true
				break
			end
		end

		if skip then
			continue
		end

		length += 1
		compatible_archetypes[length] = compatibleArchetype
	end

	return q
end

local function world_each<a>(world: World, id: Id<a>): () -> Entity
	local idr = world.component_index[id]
	if not idr then
		return NOOP :: () -> Entity
	end

	local records = idr.records
	local archetypes = world.archetypes
	local archetype_id = next(records, nil) :: number
	local archetype = archetypes[archetype_id]
	if not archetype then
		return NOOP :: () -> Entity
	end

	local entities = archetype.entities
	local row = #entities

	return function(): any
		local entity = entities[row]
		while not entity do
			archetype_id = next(records, archetype_id) :: number
			if not archetype_id then
				return
			end
			archetype = archetypes[archetype_id]
			entities = archetype.entities
			row = #entities
			entity = entities[row]
		end
		row -= 1
		return entity
	end
end

local function world_children<a>(world: World, parent: Id<a>)
	return world_each(world, ECS_PAIR(EcsChildOf, parent::number))
end

local function ecs_bulk_insert(world: World, entity: Entity, ids: { Entity }, values: { any })
	local entity_index = world.entity_index
	local r = entity_index_try_get(entity_index, entity)
	if not r then
		return
	end
	local from = r.archetype
	local component_index = world.component_index
	if not from then
		local dst_types = ids
		local to = archetype_ensure(world, dst_types)
		new_entity(entity, r, to)
		local row = r.row
		local columns_map = to.columns_map
		for i, id in ids do
			local value = values[i]
			local cdr = component_index[id]

			local on_add = cdr.on_add
			if value then
				columns_map[id][row] = value
				if on_add then
					on_add(entity, id, value :: any)
				end
			else
				if on_add then
					on_add(entity, id)
				end
			end
		end
		return
	end

	local dst_types = table.clone(from.types)

	local emplaced: { [number]: boolean } = {}

	for i, id in ids do
	    local at = find_insert(dst_types :: { number }, id :: number)
	    if at == -1 then
			emplaced[i] = true
			continue
	    end

		emplaced[i] = false

	    table.insert(dst_types, at, id)
	end

	local to = archetype_ensure(world, dst_types)
	local columns_map = to.columns_map

	if from ~= to then
		entity_move(entity_index, entity, r, to)
	end
	local row = r.row

	for i, set in emplaced do
		local id = ids[i]
		local idr = component_index[id]

		local value = values[i] :: any

		local on_add = idr.on_add

		if value ~= nil then
			columns_map[id][row] = value
			local on_change = idr.on_change
			local hook = if set then on_change else on_add
			if hook then
				hook(entity, id, value :: any)
			end
		elseif on_add then
			on_add(entity, id)
		end
	end
end

local function ecs_bulk_remove(world: World, entity: Entity, ids: { Entity })
	local entity_index = world.entity_index
	local r = entity_index_try_get(entity_index, entity)
	if not r then
		return
	end
	local from = r.archetype
	local component_index = world.component_index
	if not from then
		return
	end

	local remove: { [Entity]: boolean } = {}

	local columns_map = from.columns_map

	for i, id in ids do
		if not columns_map[id] then
			continue
		end

	    remove[id] = true
		local idr = component_index[id]

		local on_remove = idr.on_remove
		if on_remove then
			on_remove(entity, id)
		end
	end

	local to = r.archetype
	if from ~= to then
		from = to
	end

	local dst_types = table.clone(from.types) :: { Entity }

	for id in remove do
		local at = table.find(dst_types, id)
		table.remove(dst_types, at)
	end

	to = archetype_ensure(world, dst_types)
	if from ~= to then
		entity_move(entity_index, entity, r, to)
	end
end

local function world_new()
	local eindex_dense_array = {} :: { Entity }
	local eindex_sparse_array = {} :: { Record }
	local eindex_alive_count = 0
	local eindex_max_id = 0

	local entity_index = {
		dense_array = eindex_dense_array,
		sparse_array = eindex_sparse_array,
		alive_count = eindex_alive_count,
		max_id = eindex_max_id,
	} :: EntityIndex

	local component_index = {} :: ComponentIndex

	local archetype_index = {} :: { [string]: Archetype }
	local archetypes = {} :: Archetypes
	local archetype_edges = {} :: { [number]: { [Id]: Archetype } }

	local observable = {}

	local world = {
		archetype_edges = archetype_edges,

		component_index = component_index,
		entity_index = entity_index,
		ROOT_ARCHETYPE = nil :: any,

		archetypes = archetypes,
		archetype_index = archetype_index,
		max_archetype_id = 0,
		max_component_id = ecs_max_component_id,

		observable = observable,
	} :: World


	local ROOT_ARCHETYPE = archetype_create(world, {}, "")
	world.ROOT_ARCHETYPE = ROOT_ARCHETYPE

	local function inner_entity_index_try_get_any(entity: number): Record?
		local r = eindex_sparse_array[ECS_ENTITY_T_LO(entity)]

		if not r or r.dense == 0 then
			return nil
		end

		return r
	end

	local function inner_archetype_move(
		entity: Entity,
		to: Archetype,
		dst_row: i24,
		from: Archetype,
		src_row: i24
	)
		local src_columns = from.columns
		local dst_entities = to.entities
		local src_entities = from.entities

		local last = #src_entities
		local id_types = from.types
		local columns_map = to.columns_map

		if src_row ~= last then
			for i, column in src_columns do
				if column == NULL_ARRAY then
					continue
				end
				local dst_column = columns_map[id_types[i]]

				if dst_column then
					dst_column[dst_row] = column[src_row]
				end

				column[src_row] = column[last]
				column[last] = nil
			end

			local e2 = src_entities[last]
			src_entities[src_row] = e2

			local record2 = eindex_sparse_array[ECS_ENTITY_T_LO(e2 :: number)]
			record2.row = src_row
		else
			for i, column in src_columns do
				if column == NULL_ARRAY then
					continue
				end
				-- Retrieves the new column index from the source archetype's record from each component
				-- We have to do this because the columns are tightly packed and indexes may not correspond to each other.
				local dst_column = columns_map[id_types[i]]

				-- Sometimes target column may not exist, e.g. when you remove a component.
				if dst_column then
					dst_column[dst_row] = column[src_row]
				end

				column[last] = nil
			end
		end
		src_entities[last] = nil :: any
		dst_entities[dst_row] = entity
	end

	local function inner_entity_move(
		entity_index: EntityIndex,
		entity: Entity,
		record: Record,
		to: Archetype
	)
		local sourceRow = record.row
		local from = record.archetype
		local dst_row = archetype_append(entity, to)
		inner_archetype_move(entity, to, dst_row, from, sourceRow)
		record.archetype = to
		record.row = dst_row
	end

	-- local function inner_entity_index_try_get(entity: number): Record?
	-- 	local r = inner_entity_index_try_get_any(entity)
	-- 	if r then
	-- 		local r_dense = r.dense
	-- 		if r_dense > entity_index.alive_count then
	-- 			return nil
	-- 		end
	-- 		if eindex_dense_array[r_dense] ~= entity then
	-- 			return nil
	-- 		end
	-- 	end
	-- 	return r
	-- end

	local function inner_entity_index_try_get_unsafe(entity: number): Record?
		local r = inner_entity_index_try_get_any(entity)
		if r then
			local r_dense = r.dense
			-- if r_dense > entity_index.alive_count then
			-- 	return nil
			-- end
			if eindex_dense_array[r_dense] ~= entity then
				return nil
			end
		end
		return r
	end

	local function inner_world_add<T, a>(
		world: World,
		entity: Entity<T>,
		id: Id<a>
	): ()
		local entity_index = world.entity_index
		local record = inner_entity_index_try_get_unsafe(entity :: number)
		if not record then
			return
		end

		local from = record.archetype
		if ECS_IS_PAIR(id::number) then
			local src = from or ROOT_ARCHETYPE
			local edge = archetype_edges[src.id]
			local to = edge[id]
			local idr: ComponentRecord
			if not to then
				local first = ECS_PAIR_FIRST(id::number)
				local wc = ECS_PAIR(first, EcsWildcard)
				idr = component_index[wc]
				if idr and bit32.btest(idr.flags, ECS_ID_IS_EXCLUSIVE) then
					local cr = idr.records[src.id]
					if cr then
						local on_remove = idr.on_remove
						local id_types = src.types
						if on_remove then
							on_remove(entity, id_types[cr])
							src = record.archetype
							id_types = src.types
							cr = idr.records[src.id]
						end
						local dst = table.clone(id_types)
						dst[cr] = id
						to = archetype_ensure(world, dst)
					else
						to = find_archetype_with(world, id, src)
						idr = component_index[id]
					end
				else
					to = find_archetype_with(world, id, src)
					idr = component_index[id]
				end
				edge[id] = to
			else
				if to.dead then
					archetype_register(world, to)
					to.dead = false
				end
				idr = component_index[id]
			end
			if from == to then
				return
			end
			if from then
				inner_entity_move(entity_index, entity, record, to)
			else
				if #to.types > 0 then
					new_entity(entity, record, to)
				end
			end

			local on_add = idr.on_add

			if on_add then
				on_add(entity, id)
			end

			return
		end
		local to = archetype_traverse_add(world, id, from)
		if from == to then
			return
		end
		if from then
			inner_entity_move(entity_index, entity, record, to)
		else
			if #to.types > 0 then
				new_entity(entity, record, to)
			end
		end

		local idr = component_index[id]
		local on_add = idr.on_add

		if on_add then
			on_add(entity, id)
		end
	end

	local function inner_world_get(world: World, entity: Entity,
		a: Id, b: Id?, c: Id?, d: Id?, e: Id?): ...any
		local record = inner_entity_index_try_get_unsafe(entity::number)
		if not record then
			return nil
		end

		local archetype = record.archetype
		if not archetype then
			return nil
		end

		local columns_map = archetype.columns_map
		local row = record.row

		local va = fetch(a, columns_map, row)

		if not b then
			return va
		elseif not c then
			return va, fetch(b, columns_map, row)
		elseif not d then
			return va, fetch(b, columns_map, row), fetch(c, columns_map, row)
		elseif not e then
			return va, fetch(b, columns_map, row), fetch(c, columns_map, row), fetch(d, columns_map, row)
		else
			error("args exceeded")
		end
	end

	local function inner_world_has(world: World, entity: i53,
		a: i53, b: i53?, c: i53?, d: i53?, e: i53?): boolean

		local record = inner_entity_index_try_get_unsafe(entity)
		if not record then
			return false
		end

		local archetype = record.archetype
		if not archetype then
			return false
		end

		local columns_map = archetype.columns_map

		return columns_map[a] ~= nil and
			(b == nil or columns_map[b] ~= nil) and
			(c == nil or columns_map[c] ~= nil) and
			(d == nil or columns_map[d] ~= nil) and
			(e == nil or error("args exceeded"))
	end

	local function inner_world_target<T, a>(world: World, entity: Entity<T>, relation: Id<a>, index: number?): Entity?
		local record = inner_entity_index_try_get_unsafe(entity :: number)
		if not record then
			return nil
		end

		local archetype = record.archetype
		if not archetype then
			return nil
		end

		local r = ECS_PAIR(relation::number, EcsWildcard)
		local idr = world.component_index[r]

		if not idr then
			return nil
		end

		local archetype_id = archetype.id
		local count = idr.counts[archetype_id]
		if not count then
			return nil
		end

		local nth = index or 0

		if nth >= count then
			nth = nth + count + 1
		end

		nth = archetype.types[nth + idr.records[archetype_id]]

		if not nth then
			return nil
		end

		return entity_index_get_alive(world.entity_index,
		    ECS_PAIR_SECOND(nth :: number))
	end

	local function inner_world_parent<T>(world: World, entity: Entity<T>): Entity?
		return inner_world_target(world, entity, EcsChildOf, 0)
	end

	local function inner_archetype_traverse_add(id: Id, from: Archetype): Archetype
		from = from or ROOT_ARCHETYPE
		if from.columns_map[id] then
			return from
		end
		local edges = archetype_edges
		local edge = edges[from.id]

		local to = edge[id] :: Archetype
		if not to then
			to = find_archetype_with(world, id, from)
			edge[id] = to
			edges[to.id][id] = from
		end

		return to
	end

	local function inner_world_set<T, a>(world: World, entity: Entity<T>, id: Id<a>, data: a): ()
		local record = inner_entity_index_try_get_unsafe(entity :: number)
		if not record then
			return
		end

		local from: Archetype = record.archetype
		local src = from or ROOT_ARCHETYPE
		local column = src.columns_map[id]
		if column then
			local idr = component_index[id]
			column[record.row] = data

			-- If the archetypes are the same it can avoid moving the entity
			-- and just set the data directly.
			local on_change = idr.on_change
			if on_change then
				on_change(entity, id, data)
			end
		else
			local to: Archetype
			local idr: ComponentRecord
			if ECS_IS_PAIR(id::number) then
				local edge = archetype_edges[src.id]
				to = edge[id]
				if not to then
					local first = ECS_PAIR_FIRST(id::number)
					local wc = ECS_PAIR(first, EcsWildcard)
					idr = component_index[wc]
					if idr and bit32.btest(idr.flags, ECS_ID_IS_EXCLUSIVE) then
						local cr = idr.records[src.id]
						if cr then
							local on_remove = idr.on_remove
							local id_types = src.types
							if on_remove then
								on_remove(entity, id_types[cr])
								src = record.archetype
								id_types = src.types
								cr = idr.records[src.id]
							end
							local dst = table.clone(id_types)
							dst[cr] = id
							to = archetype_ensure(world, dst)
						else
							to = find_archetype_with(world, id, src)
							idr = component_index[id]
						end
					else
						to = find_archetype_with(world, id, src)
						idr = component_index[id]
					end
					edge[id] = to
				else
					idr = component_index[id]
				end
			else
				to = inner_archetype_traverse_add(id, from)
				idr = component_index[id]
			end

			if from then
				-- If there was a previous archetype, then the entity needs to move the archetype
				inner_entity_move(entity_index, entity, record, to)
			else
				new_entity(entity, record, to)
			end

			column = to.columns_map[id]
			column[record.row] = data

			local on_add = idr.on_add
			if on_add then
				on_add(entity, id, data)
			end
		end
	end

	local function inner_world_entity<T>(world: World, entity: Entity<T>?): Entity<T>
		if entity then
			local index = ECS_ID(entity :: number)
			local alive_count = entity_index.alive_count
			local r = eindex_sparse_array[index]
			if r then
				local dense = r.dense

				if not dense or r.dense == 0 then
					r.dense = index
					dense = index
					local any = eindex_dense_array[dense]
					if any == entity then
						local e_swap = eindex_dense_array[dense]
						local r_swap = inner_entity_index_try_get_any(e_swap :: number) :: Record

						r_swap.dense = dense
						alive_count += 1
						entity_index.alive_count = alive_count
						r.dense = alive_count

						eindex_dense_array[dense] = e_swap
						eindex_dense_array[alive_count] = entity
					end
					return entity
				end

				local any = eindex_dense_array[dense]
				if any ~= entity then
					if alive_count <= dense then
						local e_swap = eindex_dense_array[dense]
						local r_swap = inner_entity_index_try_get_any(e_swap :: number) :: Record

						r_swap.dense = dense
						alive_count += 1
						entity_index.alive_count = alive_count
						r.dense = alive_count

						eindex_dense_array[dense] = e_swap
						eindex_dense_array[alive_count] = entity
					end
				end

				return entity
			else
				for i = eindex_max_id + 1, index do
					eindex_sparse_array[i] = { dense = i } :: Record
					eindex_dense_array[i] = i
				end
				entity_index.max_id = index

				local e_swap = eindex_dense_array[alive_count]
				local r_swap = eindex_sparse_array[alive_count]
				r_swap.dense = index

				alive_count += 1
				entity_index.alive_count = alive_count

				r = eindex_sparse_array[index]

				r.dense = alive_count

				eindex_sparse_array[index] = r

				eindex_dense_array[index] = e_swap
				eindex_dense_array[alive_count] = entity

				return entity
			end
		end
		return entity_index_new_id(entity_index)
	end

	local function inner_world_remove<T, a>(world: World, entity: Entity<T>, id: Id<a>)
		local record = inner_entity_index_try_get_unsafe(entity :: number)
		if not record then
			return
		end
		local from = record.archetype

		if not from then
			return
		end

		if from.columns_map[id] then
			local idr = world.component_index[id]
			local on_remove = idr.on_remove
			if on_remove then
				on_remove(entity, id)
			end

			local to = archetype_traverse_remove(world, id, record.archetype)

			inner_entity_move(entity_index, entity, record, to)
		end
	end

	local function inner_world_clear<T>(world: World, entity: Entity<T>)
		local tgt = ECS_PAIR(EcsWildcard, entity::number)
		local idr_t = component_index[tgt]
		local idr = component_index[entity]
		local rel = ECS_PAIR(entity::number, EcsWildcard)
		local idr_r = component_index[rel]

		if idr then
			local count = 0
			local queue = {}
			for archetype_id in idr.records do
				local idr_archetype = archetypes[archetype_id]
				local entities = idr_archetype.entities
				local n = #entities
				table.move(entities, 1, n, count + 1, queue)
				count += n
			end
			for _, e in queue do
				inner_world_remove(world, e, entity)
			end
		end

		if idr_t then
			local archetype_ids = idr_t.records
			for archetype_id in archetype_ids do
				local idr_t_archetype = archetypes[archetype_id]
				local idr_t_types = idr_t_archetype.types
				local entities = idr_t_archetype.entities

				local node = idr_t_archetype

				for _, id in idr_t_types do
					if not ECS_IS_PAIR(id::number) then
						continue
					end
					local object = entity_index_get_alive(
					    entity_index, ECS_PAIR_SECOND(id::number))
					if object ~= entity then
						continue
					end
					node = archetype_traverse_remove(world, id, node)
					local on_remove = component_index[id].on_remove
					if on_remove then
						for _, entity in entities do
							on_remove(entity, id)
						end
					end
				end

				for i = #entities, 1, -1 do
					local e = entities[i]
					local r = inner_entity_index_try_get_unsafe(e::number) :: Record
					inner_entity_move(entity_index, e, r, node)
				end
			end
		end

		if idr_r then
			local archetype_ids = idr_r.records
			local records = idr_r.records
			local counts = idr_r.counts
			for archetype_id in archetype_ids do
				local idr_r_archetype = archetypes[archetype_id]
				local node = idr_r_archetype
				local entities = idr_r_archetype.entities
				local tr = records[archetype_id]
				local tr_count = counts[archetype_id]
				local types = idr_r_archetype.types
				for i = tr, tr + tr_count - 1 do
					local id = types[i]
					node = archetype_traverse_remove(world, id, idr_r_archetype)
					local on_remove = component_index[id].on_remove
					if on_remove then
						for _, entity in entities do
							on_remove(entity, id)
						end
					end
				end
				for i = #entities, 1, -1 do
					local e = entities[i]
					local r = inner_entity_index_try_get_unsafe(e::number) :: Record
					inner_entity_move(entity_index, e, r, node)
				end
			end
		end
	end

	local function inner_world_delete<T>(world: World, entity: Entity<T>)
		local record = inner_entity_index_try_get_unsafe(entity::number)
		if not record then
			return
		end

		local archetype = record.archetype
		local row = record.row

		if archetype then
			-- In the future should have a destruct mode for
			-- deleting archetypes themselves. Maybe requires recycling
			archetype_delete(world, archetype, row)
		end

		local component_index = world.component_index
		local archetypes = world.archetypes
		local tgt = ECS_PAIR(EcsWildcard, entity::number)
		local rel = ECS_PAIR(entity::number, EcsWildcard)

		local idr_t = component_index[tgt]
		local idr = component_index[entity::number]
		local idr_r = component_index[rel]

		if idr then
			local flags = idr.flags
			if bit32.btest(flags, ECS_ID_DELETE) then
				for archetype_id in idr.records do
					local idr_archetype = archetypes[archetype_id]

					local entities = idr_archetype.entities
					local n = #entities
					for i = n, 1, -1 do
						inner_world_delete(world, entities[i])
					end

					archetype_destroy(world, idr_archetype)
				end
			else
				local on_remove = idr.on_remove
				if on_remove then
					for archetype_id in idr.records do
						local idr_archetype = archetypes[archetype_id]
						local to = archetype_traverse_remove(world, entity, idr_archetype)
						local entities = idr_archetype.entities
						local n = #entities
						for i = n, 1, -1 do
							local e = entities[i]
							on_remove(e, entity)
							local r = eindex_sparse_array[ECS_ID(e :: number)]
							local from = r.archetype
							if from ~= idr_archetype then
								-- unfortunately the on_remove hook allows a window where `e` can have changed archetype
								-- this is hypothetically not that expensive of an operation anyways
								to = archetype_traverse_remove(world, entity, from)
							end
							inner_entity_move(entity_index, e, r, to)
						end

						archetype_destroy(world, idr_archetype)
					end
				else
					for archetype_id in idr.records do
						local idr_archetype = archetypes[archetype_id]
						local to = archetype_traverse_remove(world, entity, idr_archetype)
						local entities = idr_archetype.entities
						local n = #entities
						for i = n, 1, -1 do
							local e = entities[i]
							entity_move(entity_index, e, eindex_sparse_array[ECS_ID(e :: number)], to)
						end

						archetype_destroy(world, idr_archetype)
					end
				end
			end
		end
		if idr_t then
			local archetype_ids = idr_t.records
			for archetype_id in archetype_ids do
				local idr_t_archetype = archetypes[archetype_id]
				local node = idr_t_archetype
				local idr_t_types = idr_t_archetype.types
				local entities = idr_t_archetype.entities

				local deleted = false
				for _, id in idr_t_types do
					if not ECS_IS_PAIR(id::number) then
						continue
					end
					local object = entity_index_get_alive(
					    entity_index, ECS_PAIR_SECOND(id::number))
					if object ~= entity then
						continue
					end
					local id_record = component_index[id]
					local flags = id_record.flags
					local flags_delete_mask = bit32.btest(flags, ECS_ID_DELETE)
					if flags_delete_mask then
						for i = #entities, 1, -1 do
							local child = entities[i]
							inner_world_delete(world, child)
						end
						deleted = true
						break
					else
						node = archetype_traverse_remove(world, id, node)
						local on_remove = component_index[id].on_remove
						if on_remove then
							for _, entity in entities do
								on_remove(entity, id)
							end
						end
					end
				end

				if not deleted then
					for i = #entities, 1, -1 do
						local e = entities[i]
						local r = inner_entity_index_try_get_unsafe(e::number) :: Record
						inner_entity_move(entity_index, e, r, node)
					end
				end
			end

			for archetype_id in archetype_ids do
				archetype_destroy(world, archetypes[archetype_id])
			end
		end

		if idr_r then
			local archetype_ids = idr_r.records
			local flags = idr_r.flags
			if bit32.btest(flags, ECS_ID_DELETE) then
				for archetype_id in archetype_ids do
					local idr_r_archetype = archetypes[archetype_id]
					local entities = idr_r_archetype.entities
					local n = #entities
					for i = n, 1, -1 do
						inner_world_delete(world, entities[i])
					end
					archetype_destroy(world, idr_r_archetype)
				end
			else
				local counts = idr_r.counts
				local records = idr_r.records
				for archetype_id in archetype_ids do
					local idr_r_archetype = archetypes[archetype_id]
					local node = idr_r_archetype
					local entities = idr_r_archetype.entities
					local tr = records[archetype_id]
					local tr_count = counts[archetype_id]
					local types = idr_r_archetype.types
					for i = tr, tr + tr_count - 1 do
						local id = types[i]
						node = archetype_traverse_remove(world, id, node)
						local on_remove = component_index[id].on_remove
						if on_remove then
							for _, entity in entities do
								on_remove(entity, id)
							end
						end
					end
					for i = #entities, 1, -1 do
						local e = entities[i]
						local r = inner_entity_index_try_get_unsafe(e::number) :: Record
						inner_entity_move(entity_index, e, r, node)
					end
				end

				for archetype_id in archetype_ids do
					archetype_destroy(world, archetypes[archetype_id])
				end
			end
		end

		local dense = record.dense
		local i_swap = entity_index.alive_count
		entity_index.alive_count = i_swap - 1

		local e_swap = eindex_dense_array[i_swap]
		local r_swap = inner_entity_index_try_get_any(e_swap :: number) :: Record
		r_swap.dense = dense
		record.archetype = nil :: any
		record.row = nil :: any
		record.dense = i_swap

		eindex_dense_array[dense] = e_swap
		eindex_dense_array[i_swap] = ECS_GENERATION_INC(entity :: number)
	end

	local function inner_world_exists<T>(world: World, entity: Entity<T>): boolean
		return inner_entity_index_try_get_any(entity :: number) ~= nil
	end

	local function inner_world_contains<T>(world: World, entity: Entity<T>): boolean
		return entity_index_is_alive(world.entity_index, entity)
	end

	local function inner_world_cleanup(world: World)
		for _, archetype in archetypes do
			if #archetype.entities == 0 then
				archetype_destroy(world, archetype)
			end
		end

		local new_archetypes = {}
		local new_archetype_map = {}

		for index, archetype in archetypes do
			new_archetypes[index] = archetype
			new_archetype_map[archetype.type] = archetype
		end

		archetypes = new_archetypes
		archetype_index = new_archetype_map

		world.archetypes = new_archetypes
		world.archetype_index = new_archetype_map
	end

	world.entity = inner_world_entity
	world.query = world_query :: any
	world.remove = inner_world_remove
	world.clear = inner_world_clear
	world.delete = inner_world_delete
	world.component = world_component
	world.add = inner_world_add
	world.set = inner_world_set
	world.get = inner_world_get :: any
	world.has = inner_world_has :: any
	world.target = inner_world_target
	world.parent = inner_world_parent
	world.contains = inner_world_contains
	world.exists = inner_world_exists
	world.cleanup = inner_world_cleanup
	world.each = world_each
	world.children = world_children
	world.range = world_range

	for i = 1, HI_COMPONENT_ID do
		local e = entity_index_new_id(entity_index)
		inner_world_add(world, e, EcsComponent)
	end

	for i = HI_COMPONENT_ID + 1, EcsRest do
		-- Initialize built-in components
		entity_index_new_id(entity_index)
	end

	inner_world_add(world, EcsName, EcsComponent)
	inner_world_add(world, EcsOnChange, EcsComponent)
	inner_world_add(world, EcsOnAdd, EcsComponent)
	inner_world_add(world, EcsOnRemove, EcsComponent)
	inner_world_add(world, EcsWildcard, EcsComponent)
	inner_world_add(world, EcsRest, EcsComponent)

	inner_world_set(world, EcsOnAdd, EcsName, "jecs.OnAdd")
	inner_world_set(world, EcsOnRemove, EcsName, "jecs.OnRemove")
	inner_world_set(world, EcsOnChange, EcsName, "jecs.OnChange")
	inner_world_set(world, EcsWildcard, EcsName, "jecs.Wildcard")
	inner_world_set(world, EcsChildOf, EcsName, "jecs.ChildOf")
	inner_world_set(world, EcsComponent, EcsName, "jecs.Component")
	inner_world_set(world, EcsOnDelete, EcsName, "jecs.OnDelete")
	inner_world_set(world, EcsOnDeleteTarget, EcsName, "jecs.OnDeleteTarget")
	inner_world_set(world, EcsDelete, EcsName, "jecs.Delete")
	inner_world_set(world, EcsRemove, EcsName, "jecs.Remove")
	inner_world_set(world, EcsName, EcsName, "jecs.Name")
	inner_world_set(world, EcsRest, EcsRest, "jecs.Rest")

	inner_world_add(world, EcsChildOf, ECS_PAIR(EcsOnDeleteTarget, EcsDelete))
	inner_world_add(world, EcsChildOf, EcsExclusive)

	for i = EcsRest + 1, ecs_max_tag_id do
		entity_index_new_id(entity_index)
	end

	for i, bundle in ecs_metadata do
		for ty, value in bundle do
			if value == NULL then
				inner_world_add(world, i, ty)
			else
				inner_world_set(world, i, ty, value)
			end
		end
	end

	return world
end

-- type function ecs_id_t(entity)
-- 	local ty = entity:components()[2]
-- 	local __T = ty:readproperty(types.singleton("__T"))
-- 	if not __T then
-- 		return ty:readproperty(types.singleton("__jecs_pair_value"))
-- 	end
-- 	return __T
-- end

-- type function ecs_pair_t(first, second)
-- 	if ecs_id_t(first):is("nil") then
-- 		return second
-- 	else
-- 		return first
-- 	end
-- end
--

local function ecs_is_tag(world: World, entity: Entity): boolean
	local idr = world.component_index[entity]
	if idr then
		return bit32.btest(idr.flags, ECS_ID_IS_TAG)
	end
	return not world_has_one_inline(world, entity, EcsComponent)
end

return {
	world = world_new :: () -> World,
	component = (ECS_COMPONENT :: any) :: <T>() -> Entity<T>,
	tag = (ECS_TAG :: any) :: <T>() -> Entity<T>,
	meta = (ECS_META :: any) :: <T, a>(id: Entity<T>, id: Id<a>, value: a?) -> Entity<T>,
	is_tag = (ecs_is_tag :: any) :: <T>(World, Id<T>) -> boolean,

    OnAdd = (EcsOnAdd :: any) :: Entity<<T>(entity: Entity, id: Id<T>, data: T) -> ()>,
	OnRemove = (EcsOnRemove :: any) :: Entity<(entity: Entity, id: Id) -> ()>,
	OnChange = (EcsOnChange :: any) :: Entity<<T>(entity: Entity, id: Id<T>, data: T) -> ()>,
	ChildOf = (EcsChildOf :: any) :: Entity,
	Component = (EcsComponent :: any) :: Entity,
	Wildcard = (EcsWildcard :: any) :: Entity,
	w = (EcsWildcard :: any) :: Entity,
	OnDelete = (EcsOnDelete :: any) :: Entity,
	OnDeleteTarget = (EcsOnDeleteTarget :: any) :: Entity,
	Delete = (EcsDelete :: any) :: Entity,
	Remove = (EcsRemove :: any) :: Entity,
	Name = (EcsName :: any) :: Entity<string>,
	Exclusive = EcsExclusive :: Entity,
	ArchetypeCreate = EcsOnArchetypeCreate,
	ArchetypeDelete = EcsOnArchetypeDelete,
	Rest = (EcsRest :: any) :: Entity,

	pair = (ECS_PAIR :: any) :: <P, O>(first: Id<P>, second: Id<O>) -> Pair<P, O>,

	-- Inwards facing API for testing
	ECS_ID = ECS_ENTITY_T_LO,
	ECS_GENERATION_INC = ECS_GENERATION_INC,
	ECS_GENERATION = ECS_GENERATION,
	ECS_ID_IS_WILDCARD = ECS_ID_IS_WILDCARD,
	ECS_ID_DELETE = ECS_ID_DELETE,
	ECS_META_RESET = ECS_META_RESET,

	IS_PAIR = (ECS_IS_PAIR :: any) :: <P, O>(pair: Pair<P, O>) -> boolean,
	ECS_PAIR_FIRST = ECS_PAIR_FIRST :: <P, O>(pair: Pair<P, O>) -> Id<P>,
	ECS_PAIR_SECOND = ECS_PAIR_SECOND :: <P, O>(pair: Pair<P, O>) -> Id<O>,
	pair_first = (ecs_pair_first :: any) :: <P, O>(world: World, pair: Pair<P, O>) -> Id<P>,
	pair_second = (ecs_pair_second :: any) :: <P, O>(world: World, pair: Pair<P, O>) -> Id<O>,
	entity_index_get_alive = entity_index_get_alive,

	archetype_append_to_records = archetype_append_to_records,
	id_record_ensure = id_record_ensure,
	component_record = id_record_get,
	archetype_create = archetype_create,
	archetype_ensure = archetype_ensure,
	find_insert = find_insert,
	find_archetype_with = find_archetype_with,
	find_archetype_without = find_archetype_without,
	create_edge_for_remove = create_edge_for_remove,
	archetype_traverse_add = archetype_traverse_add,
	archetype_traverse_remove = archetype_traverse_remove,
	bulk_insert = ecs_bulk_insert,
	bulk_remove = ecs_bulk_remove,

	entity_move = entity_move,

	entity_index_try_get = entity_index_try_get,
	entity_index_try_get_fast = entity_index_try_get_fast,
	entity_index_try_get_any = entity_index_try_get_any,
	entity_index_is_alive = entity_index_is_alive,
	entity_index_new_id = entity_index_new_id,

	query_iter = query_iter,
	query_iter_init = query_iter_init,
	query_with = query_with,
	query_without = query_without,
	query_archetypes = query_archetypes,
	query_match = query_match,

	find_observers = find_observers,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="79">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "Ukendio",
	contributors = {"Ukendio", "EncodedVenom"},
	description = "Stupidly fast Entity Component System",
	devDependencies = {
		["@rbxts/compiler-types"] = "^2.3.0-types.1",
		["@rbxts/types"] = "^1.0.781",
		["@typescript-eslint/eslint-plugin"] = "^5.8.0",
		["@typescript-eslint/parser"] = "^5.8.0",
		eslint = "^8.5.0",
		["eslint-config-prettier"] = "^8.3.0",
		["eslint-plugin-prettier"] = "^4.0.0",
		["eslint-plugin-roblox-ts"] = "^0.0.32",
		prettier = "^2.5.1",
		["roblox-ts"] = "^3.0.0",
		typescript = "^5.4.2",
		vitepress = "^1.3.0",
	},
	files = {"jecs.luau", "jecs.d.ts", "LICENSE.md", "README.md"},
	homepage = "https://github.com/ukendio/jecs",
	keywords = {},
	license = "MIT",
	main = "jecs.luau",
	name = "@rbxts/jecs",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/ukendio/jecs.git",
	},
	scripts = {
		["docs:build"] = "vitepress build docs",
		["docs:dev"] = "vitepress dev docs",
		["docs:preview"] = "vitepress preview docs",
	},
	types = "jecs.d.ts",
	version = "0.8.3",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="80">
            <Properties>
              <string name="Name">jest</string>
            </Properties>
            <Item class="ModuleScript" referent="81">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "littensy",
	bugs = {
		url = "https://github.com/littensy/rbxts-jest/issues",
	},
	dependencies = {
		["@rbxts-js/jest"] = "^3.13.2-ts.3",
		["@rbxts/emittery"] = "3.13.2-alpha.1",
		["@rbxts/jest-globals"] = "3.13.2-alpha.1",
		["@rbxts/pretty-format"] = "3.13.2-alpha.1",
	},
	description = "Delightful testing for Roblox TypeScript",
	files = {"src", "default.project.json"},
	keywords = {"roblox", "typescript", "roblox-ts"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/jest",
	repository = {
		type = "git",
		url = "git+https://github.com/littensy/rbxts-jest.git",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "3.13.2-alpha.1",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="82">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[return require(script.Parent.Parent.Parent:WaitForChild("@rbxts-js").Jest)
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="83">
            <Properties>
              <string name="Name">jest-globals</string>
            </Properties>
            <Item class="ModuleScript" referent="84">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "littensy",
	bugs = {
		url = "https://github.com/littensy/rbxts-jest/issues",
	},
	dependencies = {
		["@rbxts-js/jest-globals"] = "^3.13.2-ts.3",
		["@rbxts/jest-matcher-utils"] = "3.13.2-alpha.1",
		["@rbxts/pretty-format"] = "3.13.2-alpha.1",
	},
	description = "JestGlobal bindings for Roblox",
	files = {"src", "default.project.json"},
	keywords = {"roblox", "typescript", "roblox-ts"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/jest-globals",
	repository = {
		type = "git",
		url = "git+https://github.com/littensy/rbxts-jest.git",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "3.13.2-alpha.1",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="85">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[return require(script.Parent.Parent.Parent:WaitForChild("@rbxts-js").JestGlobals)
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="86">
            <Properties>
              <string name="Name">jest-matcher-utils</string>
            </Properties>
            <Item class="ModuleScript" referent="87">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "littensy",
	bugs = {
		url = "https://github.com/littensy/rbxts-jest/issues",
	},
	dependencies = {
		["@rbxts-js/jest-matcher-utils"] = "^3.13.2-ts.3",
		["@rbxts/pretty-format"] = "3.13.2-alpha.1",
	},
	description = "JestMatcherUtils bindings for Roblox",
	files = {"src", "default.project.json"},
	keywords = {"roblox", "typescript", "roblox-ts"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/jest-matcher-utils",
	repository = {
		type = "git",
		url = "git+https://github.com/littensy/rbxts-jest.git",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "3.13.2-alpha.1",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="88">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[return require(script.Parent.Parent.Parent:WaitForChild("@rbxts-js").JestMatcherUtils)
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="89">
            <Properties>
              <string name="Name">lemon-signal</string>
            </Properties>
            <Item class="ModuleScript" referent="90">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	description = "",
	devDependencies = {
		["@rbxts/compiler-types"] = "^3.0.0-types.0",
		["@rbxts/types"] = "^1.0.813",
		["@typescript-eslint/eslint-plugin"] = "^8.10.0",
		["@typescript-eslint/parser"] = "^8.10.0",
		eslint = "^8.57.1",
		["eslint-config-prettier"] = "^9.1.0",
		["eslint-plugin-prettier"] = "^5.2.1",
		["eslint-plugin-roblox-ts"] = "^0.0.36",
		prettier = "^3.3.3",
		["roblox-ts"] = "^3.0.0",
		typescript = "^5.6.3",
	},
	files = {"src", "!**/*.tsbuildinfo"},
	keywords = {},
	license = "ISC",
	main = "src/init.lua",
	name = "@rbxts/lemon-signal",
	publishConfig = {
		access = "public",
	},
	scripts = {
		build = "rbxtsc",
		prepublishOnly = "npm run build",
		watch = "rbxtsc -w",
	},
	types = "src/index.d.ts",
	version = "1.2.0",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="91">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--!nocheck

export type Connection<U...> = {
	Connected: boolean,

	Disconnect: (self: Connection<U...>) -> (),
	Reconnect: (self: Connection<U...>) -> (),
}

export type Signal<T...> = {
	RBXScriptConnection: RBXScriptConnection?,

	Connect: <U...>(self: Signal<T...>, fn: (...any) -> (), U...) -> Connection<U...>,
	Once: <U...>(self: Signal<T...>, fn: (...any) -> (), U...) -> Connection<U...>,
	Wait: (self: Signal<T...>) -> T...,
	Fire: (self: Signal<T...>, T...) -> (),
	DisconnectAll: (self: Signal<T...>) -> (),
	Destroy: (self: Signal<T...>) -> (),
}

local freeThreads: { thread } = {}

local function runCallback(callback, thread, ...)
	callback(...)
	table.insert(freeThreads, thread)
end

local function yielder()
	while true do
		runCallback(coroutine.yield())
	end
end

local Connection = {}
Connection.__index = Connection

local function disconnect<U...>(self: Connection<U...>)
	if not self.Connected then
		return
	end
	self.Connected = false

	local next = self._next
	local prev = self._prev

	if next then
		next._prev = prev
	end
	if prev then
		prev._next = next
	end

	local signal = self._signal
	if signal._head == self then
		signal._head = next
	end
end

local function reconnect<U...>(self: Connection<U...>)
	if self.Connected then
		return
	end
	self.Connected = true

	local signal = self._signal
	local head = signal._head
	if head then
		head._prev = self
	end
	signal._head = self

	self._next = head
	self._prev = false
end

Connection.Disconnect = disconnect
Connection.Reconnect = reconnect

--\\ Signal //--
local Signal = {}
Signal.__index = Signal

-- stylua: ignore
local rbxConnect, rbxDisconnect do
	if task then
		local bindable = Instance.new("BindableEvent")
		rbxConnect = bindable.Event.Connect
		rbxDisconnect = bindable.Event:Connect(function() end).Disconnect
		bindable:Destroy()
	end
end

local function connect<T..., U...>(self: Signal<T...>, fn: (...any) -> (), ...: U...): Connection<U...>
	local head = self._head
	local cn = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_varargs = if not ... then false else { ... },
		_next = head,
		_prev = false,
	}, Connection)

	if head then
		head._prev = cn
	end
	self._head = cn

	return cn
end

local function once<T..., U...>(self: Signal<T...>, fn: (...any) -> (), ...: U...)
	local cn
	cn = connect(self, function(...)
		disconnect(cn)
		fn(...)
	end, ...)
	return cn
end

local wait = if task
	then function<T...>(self: Signal<T...>): ...any
		local thread = coroutine.running()
		local cn
		cn = connect(self, function(...)
			disconnect(cn)
			task.spawn(thread, ...)
		end)
		return coroutine.yield()
	end
	else function<T...>(self: Signal<T...>): ...any
		local thread = coroutine.running()
		local cn
		cn = connect(self, function(...)
			disconnect(cn)
			local passed, message = coroutine.resume(thread, ...)
			if not passed then
				error(message, 0)
			end
		end)
		return coroutine.yield()
	end

local fire = if task
	then function<T...>(self: Signal<T...>, ...: any)
		local cn = self._head
		while cn do
			local thread
			if #freeThreads > 0 then
				thread = freeThreads[#freeThreads]
				freeThreads[#freeThreads] = nil
			else
				thread = coroutine.create(yielder)
				coroutine.resume(thread)
			end

			if not cn._varargs then
				task.spawn(thread, cn._fn, thread, ...)
			else
				local args = cn._varargs
				local len = #args
				local count = len
				for _, value in { ... } do
					count += 1
					args[count] = value
				end

				task.spawn(thread, cn._fn, thread, table.unpack(args))

				for i = count, len + 1, -1 do
					args[i] = nil
				end
			end

			cn = cn._next
		end
	end
	else function<T...>(self: Signal<T...>, ...: any)
		local cn = self._head
		while cn do
			local thread
			if #freeThreads > 0 then
				thread = freeThreads[#freeThreads]
				freeThreads[#freeThreads] = nil
			else
				thread = coroutine.create(yielder)
				coroutine.resume(thread)
			end

			if not cn._varargs then
				local passed, message = coroutine.resume(thread, cn._fn, thread, ...)
				if not passed then
					print(string.format("%s\nstacktrace:\n%s", message, debug.traceback()))
				end
			else
				local args = cn._varargs
				local len = #args
				local count = len
				for _, value in { ... } do
					count += 1
					args[count] = value
				end

				local passed, message = coroutine.resume(thread, cn._fn, thread, table.unpack(args))
				if not passed then
					print(string.format("%s\nstacktrace:\n%s", message, debug.traceback()))
				end

				for i = count, len + 1, -1 do
					args[i] = nil
				end
			end

			cn = cn._next
		end
	end

local function disconnectAll<T...>(self: Signal<T...>)
	local cn = self._head
	while cn do
		disconnect(cn)
		cn = cn._next
	end
end

local function destroy<T...>(self: Signal<T...>)
	disconnectAll(self)
	local cn = self.RBXScriptConnection
	if cn then
		rbxDisconnect(cn)
		self.RBXScriptConnection = nil
	end
end

--\\ Constructors
function Signal.new<T...>(): Signal<T...>
	return setmetatable({ _head = false }, Signal)
end
function Signal.is(val: unknown): boolean
	local mt = getmetatable(val)
	return mt == Signal
end

function Signal.wrap<T...>(signal: RBXScriptSignal): Signal<T...>
	local wrapper = setmetatable({ _head = false }, Signal)
	wrapper.RBXScriptConnection = rbxConnect(signal, function(...)
		fire(wrapper, ...)
	end)
	return wrapper
end

--\\ Methods
Signal.Connect = connect
Signal.Once = once
Signal.Wait = wait
Signal.Fire = fire
Signal.DisconnectAll = disconnectAll
Signal.Destroy = destroy

-- ts deviation, for multi-export
local SignalConstructor = { new = Signal.new, wrap = Signal.wrap, is = Signal.is }

return {
	default = SignalConstructor,
	Signal = SignalConstructor,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="92">
            <Properties>
              <string name="Name">lyra</string>
              <string name="Source"><![CDATA[--[=[
	@class Lyra

	The main entry point and public facade for the Lyra library.

	This module re-exports the primary functions and constructors needed to interact
	with Lyra, simplifying the public API and hiding internal module structure.
	Users of the library should typically only need to require this top-level module.
]=]

local Log = require(script.Log)
local Migrations = require(script.Migrations)
local Store = require(script.Store)
local PlayerStore = require(script.PlayerStore)
local MockDataStoreService = require(script.MockDataStoreService)
local MockMemoryStoreService = require(script.MockMemoryStoreService)

--[=[
	Provides helper functions for creating common migration steps.
	
	@interface MigrationStep
	.field addFields (name: string, fields: { [string]: any }) -> MigrationStep -- Creates a step to add new fields with default values.
	.field transform (name: string, transformFunc: (currentValue: { [string]: any }) -> { [string]: any }) -> MigrationStep -- Creates a step with a custom data transformation function.

	@within Lyra
]=]
local MigrationStep = {
	addFields = Migrations.makeAddFieldsStep,
	transform = Migrations.makeTransformStep,
}

--[=[
	Factory function to create a new PlayerStore instance.
	
	@function createPlayerStore<T>
	@param context PlayerStoreConfig<T> -- The configuration for the PlayerStore.
	@return PlayerStore<T> -- A new PlayerStore instance.
	@within Lyra
]=]
local createPlayerStore = PlayerStore.createPlayerStore

--[=[
	Sets the global minimum log level for all Lyra loggers.

	@function setLogLevel
	@param level LogLevel -- The minimum log level ("fatal", "error", "warn", "info", "debug", "trace").
	@within Lyra
]=]
local setLogLevel = Log.setLevel

-- The public interface of the Lyra library.
return {
	MigrationStep = MigrationStep,
	createPlayerStore = createPlayerStore,
	setLogLevel = setLogLevel,
	Store = Store,
	PlayerStore = PlayerStore,
	MockDataStoreService = MockDataStoreService,
	MockMemoryStoreService = MockMemoryStoreService,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="93">
              <Properties>
                <string name="Name">Constants</string>
                <string name="Source"><![CDATA[--[=[
	@class Constants
	@private

	Module containing constant values used throughout the Lyra library.
]=]

-- Estimated bytes reserved within the DataStore value for Lyra's internal metadata
-- (like appliedMigrations, orphanedFiles list, and File object overhead when sharded).
-- This ensures that the actual user data shards stay safely within the DataStore limits.
local INTERNAL_SPACE_RESERVE_BYTES = 10_000

--[=[
	@interface Constants
	@within Constants

	.RECORD_SCOPE "lyra/records" -- Scope prefix used for keys storing the main DataStoreRecord objects.

	.TX_SCOPE "lyra/tx" -- Scope prefix used for keys storing transaction status markers in a DataStore.

	.SHARD_SCOPE "lyra/shards" -- Scope prefix used for keys storing data shards in a DataStore.

	.LOCK_SCOPE "lyra/locks" -- Scope prefix used for keys storing lock information in a MemoryStore HashMap.

	.MAX_CHUNK_SIZE number -- Maximum size (in bytes) for a single data shard stored in DataStore. Derived from the Roblox DataStore value limit (4MB) minus a reserved amount (INTERNAL_SPACE_RESERVE_BYTES) for Lyra's internal metadata within the main record.

	.LOCK_REFRESH_INTERVAL_SECONDS number -- How often (in seconds) a held lock should be refreshed in MemoryStore to prevent it from expiring while still actively being used. Should be significantly shorter than LOCK_DURATION_SECONDS.

	.LOCK_DURATION_SECONDS number -- The initial time-to-live (TTL) duration (in seconds) for a lock acquired in MemoryStore. If the lock isn't refreshed within this time, it will automatically expire. Must be longer than LOCK_REFRESH_INTERVAL_SECONDS to allow time for refreshes.

	.AUTOSAVE_INTERVAL_SECONDS number -- How often (in seconds) the automatic saving mechanism should attempt to save dirty session data.
]=]
local Constants = {
	RECORD_SCOPE = "lyra/records",
	TX_SCOPE = "lyra/tx",
	SHARD_SCOPE = "lyra/shards",
	LOCK_SCOPE = "lyra/locks",

	MAX_CHUNK_SIZE = 4_000_000 - INTERNAL_SPACE_RESERVE_BYTES,

	LOCK_REFRESH_INTERVAL_SECONDS = 60,

	LOCK_DURATION_SECONDS = 90,

	AUTOSAVE_INTERVAL_SECONDS = 5 * 60, -- 5 minutes
}

return Constants
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="94">
              <Properties>
                <string name="Name">Files</string>
                <string name="Source"><![CDATA[--[=[
	@class Files
	@private

	Handles the storage and retrieval of potentially large data blobs within Roblox DataStores,
	working around the size limitations imposed by DataStore `SetAsync`/`GetAsync` calls.

	**Core Problem:** Roblox DataStores have a maximum size limit per key (currently 4MB).
	Data that exceeds this limit cannot be stored directly.

	**Solution: Sharding & Compression**
	1.  **Sharding:** If the JSON-encoded data exceeds the configured `maxShardSize`, it is
	    split into multiple smaller chunks (shards). Metadata about these shards (a unique
	    shard ID and the total shard count) is stored in the primary DataStore entry for the
	    original key, while the actual shard data is stored under separate keys derived from
	    the shard ID.
	2.  **Compression:** Before sharding, the JSON-encoded data is converted to binary using
	    `buffer.fromstring`. This binary representation is then JSON-encoded *again* before
	    being split into shards. Roblox automatically compresses buffers when encoding them
		using `JSONEncode`. This helps reduce the number of shards required, minimizing
		DataStore requests.

	**Shard Key Naming:** Shard data is stored using keys formatted as `{shardId}-{shardIndex}`,
	where `shardId` is a unique GUID generated for the file and `shardIndex` is the 1-based
	index of the shard.
]=]

local HttpService = game:GetService("HttpService")

local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local dataStoreRetry = require(script.Parent.dataStoreRetry)

--[=[
	Splits a string into chunks of a specified size.
	Used for sharding large data blobs into smaller pieces.

	@within Files
	@param str string -- The string to be split.
	@param chunkSize number -- The size of each chunk.
	@return { string } -- A table containing the split chunks.
]=]
local function splitString(str: string, chunkSize: number): { string }
	local numChunks = math.ceil(#str / chunkSize)
	local chunks = {}
	for i = 1, numChunks do
		local start = (i - 1) * chunkSize + 1
		local chunk = string.sub(str, start, start + chunkSize - 1)
		table.insert(chunks, chunk)
	end
	return chunks
end

--[=[
	Checks if a file object represents a sharded file (i.e., data stored across multiple keys).

	@within Files
	@param file File -- The file object to check.
	@return boolean -- True if the file is sharded, false otherwise.
]=]
local function isLargeFile(file: Types.File): boolean
	return file.shard ~= nil
end

--[=[
	@within Files
	Parameters required for the `write` function.

	@interface WriteParams
	.store DataStore -- The DataStore instance to write to.
	.data any -- The Luau data to be stored. Must be JSON-encodable.
	.maxShardSize number -- The maximum size (in bytes) allowed for a single shard. Data exceeding this size after initial JSON encoding will trigger the sharding process.
	.key string -- The primary key under which the file metadata (or the full data if not sharded) will be conceptually associated. This key is *not* directly used for storing shards.
	.userIds { number }? -- An optional array of UserIDs for DataStore tagging.
]=]
export type WriteParams = {
	store: DataStore,
	data: any,
	maxShardSize: number,
	key: string, -- Primarily for context/logging, not direct shard storage key
	userIds: { number }?,
}

--[=[
	@interface WriteError
	@within Files
	Structure representing an error encountered during the `write` operation.

	.error string -- A string describing the error.
	.file File -- The file metadata that was being processed when the error occurred. This is used for cleanup operations if shards were partially written.
]=]
export type WriteError = {
	error: string,
	file: Types.File,
}

--[=[
	Writes data to the DataStore, automatically handling sharding and compression if necessary.

	If the JSON-encoded data is smaller than `maxShardSize`, it's stored directly within the
	returned [File] object (in the `data` field).

	If the data is larger, it's compressed, sharded, and stored across multiple DataStore keys.
	The returned [File] object will contain `shard` (the unique ID for the shards) and
	`count` (the number of shards) instead of the `data` field.

	@within Files
	@param params WriteParams -- The parameters for the write operation.
	@return Promise<File> -- A Promise that resolves with a [File] object representing the stored data (either directly containing the data or shard metadata).
	@error WriteError -- Rejects with a `WriteError` if any shard fails to write.
	@error string -- Propagates errors from `DataStore:SetAsync` via `dataStoreRetry`.
]=]
local function write(params: WriteParams): Promise.TPromise<Types.File>
	-- Step 1: Initial JSON encode to check size against the limit.
	local dataEncoded = HttpService:JSONEncode(params.data)
	if #dataEncoded <= params.maxShardSize then
		-- Data fits within a single shard, no sharding needed. Return directly.
		return Promise.resolve({ data = params.data } :: Types.File)
	end

	-- Step 2: Convert the JSON-encoded data to a binary buffer.
	-- This binary buffer is then JSON encoded *again*, which Roblox automatically compresses.
	-- This helps reduce the size of the data before sharding.
	local dataCompressed = HttpService:JSONEncode(buffer.fromstring(dataEncoded))

	-- Step 3: Split the compressed, double-encoded string into shards.
	local shards = splitString(dataCompressed, params.maxShardSize)

	-- Step 4: Generate metadata for the sharded file.
	local shardId = HttpService:GenerateGUID(false) -- Unique ID for this set of shards.
	local file = { shard = shardId, count = #shards } -- File object containing shard info.

	-- Step 5: Write each shard to the DataStore using derived keys.
	local shardPromises = Tables.map(shards, function(shard, index)
		-- Key format: {shardId}-{shardIndex} (1-based index)
		local shardKey = `{shardId}-{index}`
		return dataStoreRetry(function()
			-- Attempt to write the individual shard with retry logic.
			return params.store:SetAsync(shardKey, shard, params.userIds)
		end)
	end)

	-- Step 6: Wait for all shard writes to complete.
	return Promise
		.all(shardPromises)
		:andThenReturn(file) -- If all succeed, return the file metadata.
		:catch(function(err)
			-- If any shard write fails, reject the promise with detailed error info.
			return Promise.reject({
				error = `Failed to write file: {err}`,
				file = file, -- Include file metadata for cleanup.
			} :: WriteError)
		end)
end

--[=[
	@interface ReadParams
	@within Files
	Parameters required for the `read` function.

	.store DataStore -- The DataStore instance to read from.
	.file File -- The [File] object obtained from a previous `write` operation or retrieved from the primary DataStore key. This object determines whether to read directly or reconstruct from shards.
]=]
export type ReadParams = {
	store: DataStore,
	file: Types.File,
}

--[=[
	Reads data from the DataStore, automatically handling reconstruction from shards if necessary.

	If the provided `file` object contains the `data` field directly, it returns that data.
	If the `file` object contains `shard` and `count` fields, it reads all corresponding shards
	from the DataStore, concatenates them, decompresses the result, and returns the original data.

	@within Files
	@param params ReadParams -- The parameters for the read operation.
	@return Promise<any> -- A Promise that resolves with the original data.
	@error string -- Rejects with an error message string if any shard is missing or if decoding/decompression fails. Propagates errors from `DataStore:GetAsync` via `dataStoreRetry`.
]=]
local function read(params: ReadParams): Promise.TPromise<any>
	-- Step 1: Check if the file is sharded.
	if not isLargeFile(params.file) then
		-- Not sharded, data is stored directly in the file object.
		return Promise.resolve(params.file.data)
	end

	-- Step 2: Prepare to read shards.
	local shardId = params.file.shard
	assert(shardId, "Shard ID missing from large file object") -- Should be guaranteed by isLargeFile
	local shardCount = params.file.count
	assert(shardCount, "Shard count missing from large file object")

	local promises = {}

	-- Step 3: Create promises to fetch each shard.
	for i = 1, shardCount do
		local shardKey = `{shardId}-{i}`
		table.insert(
			promises,
			dataStoreRetry(function()
				-- Attempt to read the individual shard with retry logic.
				return params.store:GetAsync(shardKey)
			end)
		)
	end

	-- Step 4: Wait for all shard reads to complete.
	return Promise.all(promises):andThen(function(shards)
		-- Step 5: Validate that all shards were retrieved.
		for i = 1, shardCount do
			if shards[i] == nil then
				-- A shard is missing, cannot reconstruct the file.
				return Promise.reject(`Missing shard {i} for file (shardId: {shardId})`)
			end
		end

		-- Step 6: Concatenate and decode the compressed data (first JSON decode, decompresses).
		-- This reverses the double JSON encoding done during the write process.
		local ok, compressedData = pcall(function()
			return HttpService:JSONDecode(table.concat(shards))
		end)
		if not ok then
			return Promise.reject(`Error decoding compressed file data (shardId: {shardId}): {compressedData}`) -- compressedData contains error msg here
		end
		if typeof(compressedData) ~= "buffer" then
			return Promise.reject(
				`Expected buffer after first decode, got {typeof(compressedData)} (shardId: {shardId})`
			)
		end

		-- Step 7: Convert the buffer back to a string and decode the original JSON data.
		local ok2, originalData = pcall(function()
			return HttpService:JSONDecode(buffer.tostring(compressedData))
		end)
		if not ok2 then
			return Promise.reject(`Error decoding original file data (shardId: {shardId}): {originalData}`) -- originalData contains error msg here
		end

		return originalData -- Successfully reconstructed original data.
	end)
	-- No explicit :catch here, errors from GetAsync (via retry) or rejections above will propagate.
end

return {
	isLargeFile = isLargeFile,
	write = write,
	read = read,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="95">
              <Properties>
                <string name="Name">JsonPatch</string>
                <string name="Source"><![CDATA[local Tables = require(script.Parent.Tables)
local Types = require(script.Parent.Types)

--[[
  RFC 6902 implementation in Luau (Roblox) with two public functions:
    1) JSONPatch.applyPatch(doc, patch) -> applies the patch in-place (mutates & returns doc).
    2) JSONPatch.createPatch(original, modified) -> returns a minimal set of patch operations.
]]

--[[
	Based on https://github.com/Starcounter-Jack/JSON-Patch

	(The MIT License)

	Copyright (c) 2013, 2014, 2020 Joachim Wester

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	'Software'), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- JSON Pointer Utilities

local function isArray(value: any): boolean
	if typeof(value) ~= "table" then
		return false
	end

	if next(value) == nil then
		return true
	end

	local length = #value

	if length == 0 then
		return false
	end

	local count = 0
	local sum = 0
	for key in value do
		if typeof(key) ~= "number" then
			return false
		end
		if key % 1 ~= 0 or key < 1 then
			return false
		end
		count += 1
		sum += key
	end

	return sum == (count * (count + 1) / 2)
end

local function unescapeSegment(segment: string): string
	-- ~1 -> '/'
	-- ~0 -> '~'
	local res = string.gsub(segment, "~1", "/")
	res = string.gsub(res, "~0", "~")
	return res
end

local function escapeSegment(segment: string): string
	-- / -> '~1'
	-- ~ -> '~0'
	local res = string.gsub(segment, "~", "~0")
	res = string.gsub(res, "/", "~1")
	return res
end

local function parsePointer(pointer: string): { string }
	-- An empty string "" means "root"
	if pointer == "" then
		return {}
	end
	if string.sub(pointer, 1, 1) ~= "/" then
		error("Invalid JSON pointer (must start with / or be empty)")
	end
	local raw = string.sub(pointer, 2) -- skip leading '/'
	local segments = string.split(raw, "/")
	for i, seg in segments do
		segments[i] = unescapeSegment(seg)
	end
	return segments
end

-- Patch Application

local function getArrayIndexOrError(key: string, length: number, op: string): number
	local idx = tonumber(key)
	if idx == nil then
		error(`'{op}' path must be a valid numeric index; got '{key}'`)
	end
	idx += 1 -- 0-based to 1-based
	if idx < 1 or idx > length then
		error(`Array {op} index {idx - 1} out of bounds for length {length}`)
	end
	return idx
end

local function isStringifiedNumberOk(key: string): boolean
	if key == "0" then
		return true
	end

	local num = tonumber(key)
	if num == nil then
		return false
	end

	local str = tostring(num)
	return str == key
end

local function applyOperation(doc: any, opObj: Types.PatchOperation): any
	local op = opObj.op
	if typeof(op) ~= "string" then
		error("'op' must be a string")
	end

	local path = opObj.path
	if typeof(path) ~= "string" then
		error("missing valid 'path' string")
	end
	local segments = parsePointer(path)

	local parent = doc
	for i = 1, (#segments - 1) do
		local seg = segments[i]

		if isArray(parent) then
			if not isStringifiedNumberOk(seg) then
				error(`Path segment '{seg}' is not a valid array index`)
			end
			seg = getArrayIndexOrError(seg, #parent, op) :: any
		end

		if parent[seg] == nil then
			error("add to a non-existent target")
		end

		if typeof(parent[seg]) ~= "table" then
			error("cannot 'add' into non-table parent")
		end

		parent = parent[seg]
	end

	if opObj.op == "add" then
		local value = opObj.value
		if value == nil then
			error("missing 'value' parameter")
		end

		-- If path is empty, replace entire doc
		if #segments == 0 then
			return Tables.copyDeep(value)
		end

		local key = segments[#segments]

		local parentIsArray = isArray(parent)

		-- There's complex behavior with adding to arrays/objects based on the
		-- key and what kind of table the parent is. We treat parent as an array
		-- IF:
		-- 1. It's an empty table AND the key is "-" (append is the only valid
		--      operation)
		-- 2. It's a non-empty array AND the key is a number or "-" (append or
		--    insert)
		--
		-- Otherwise, we treat it as an object.

		local isAddingIntoEmptyArray = parentIsArray and #parent == 0 and key == "-"
		local isAddingIntoPopulatedArray = parentIsArray and #parent > 0 and (tonumber(key) ~= nil or key == "-")

		if isAddingIntoEmptyArray or isAddingIntoPopulatedArray then
			if key == "-" then
				-- append
				table.insert(parent, Tables.copyDeep(value))
			else
				if not isStringifiedNumberOk(key) then
					error("add op shouldn't add to array with bad number")
				end

				local index = getArrayIndexOrError(key, #parent, op)
				table.insert(parent, index, Tables.copyDeep(value))
			end
		else
			if parentIsArray and #parent > 0 then
				error("Object operation on array target")
			end

			parent[key] = Tables.copyDeep(value)
		end

		return doc
	elseif opObj.op == "remove" then
		-- If path is empty, remove entire doc => doc becomes nil
		if #segments == 0 then
			return nil
		end

		local key = segments[#segments]
		if isArray(parent) and tonumber(key) ~= nil then
			if not isStringifiedNumberOk(key) then
				error("remove op shouldn't remove from array with bad number")
			end

			local index = getArrayIndexOrError(key, #parent, op)
			table.remove(parent, index)
		else
			if parent[key] == nil then
				error(`Cannot remove non-existent key '{key}'`)
			end

			parent[key] = nil
		end

		return doc
	elseif opObj.op == "replace" then
		local value = opObj.value
		if value == nil then
			error("missing 'value' parameter")
		end

		-- If path is empty, replace entire doc
		if #segments == 0 then
			return Tables.copyDeep(value)
		end

		local key = segments[#segments]
		if isArray(parent) and tonumber(key) ~= nil then
			if not isStringifiedNumberOk(key) then
				error("replace op shouldn't replace in array with bad number")
			end

			local index = getArrayIndexOrError(key, #parent, op)
			parent[index] = Tables.copyDeep(value)
		else
			if parent[key] == nil then
				error(("Cannot replace non-existent path '%s'"):format(key))
			end
			parent[key] = Tables.copyDeep(value)
		end

		return doc
	else
		error(`Unrecognized op '{op}'`)
	end
end

-- Patch Generation

local function keys(obj: { [any]: any }): { any }
	local result = {}
	for k in obj do
		table.insert(result, k)
	end
	return result
end

local function getZeroBasedKey(key: any, parentIsArray: boolean): string
	if not parentIsArray then
		return escapeSegment(key)
	end
	local numericKey = tonumber(key)
	if numericKey == nil then
		return escapeSegment(key)
	end
	return tostring(numericKey - 1)
end

local function generate(obj1: any, obj2: any, patches: { Types.PatchOperation }, path: string): ()
	if obj1 == obj2 then
		return
	end

	local newKeys = keys(obj2)
	local oldKeys = keys(obj1)
	local deleted = false

	local obj1IsArray = isArray(obj1)
	local obj2IsArray = isArray(obj2)

	local obj1VirtualLength = obj1IsArray and #obj1 or 0

	for i = #oldKeys, 1, -1 do
		local key = oldKeys[i]
		local oldVal = obj1[key]

		local isKeyInObj = obj2[key] ~= nil
		local isUndefinedInNonArray = obj2[key] == nil and oldVal ~= nil and not obj2IsArray

		if isKeyInObj and not isUndefinedInNonArray then
			local newVal = obj2[key]

			local bothAreTables = typeof(oldVal) == "table" and typeof(newVal) == "table"
			local sameArrayType = isArray(oldVal) == isArray(newVal)
			local bothAreSameKindOfTable = bothAreTables and sameArrayType

			if bothAreSameKindOfTable then
				generate(oldVal, newVal, patches, path .. "/" .. getZeroBasedKey(key, obj1IsArray))
			else
				if oldVal ~= newVal then
					table.insert(patches, {
						op = "replace",
						path = path .. "/" .. getZeroBasedKey(key, obj1IsArray),
						value = Tables.copyDeep(newVal),
					})
				end
			end
		elseif obj1IsArray == obj2IsArray then
			table.insert(patches, {
				op = "remove",
				path = path .. "/" .. getZeroBasedKey(key, obj1IsArray),
			})
			deleted = true
		else
			table.insert(patches, {
				op = "replace",
				path = path,
				value = obj2,
			})
		end
	end

	if not deleted and #newKeys == #oldKeys then
		return
	end

	for _, key in newKeys do
		if obj1[key] == nil and obj2[key] ~= nil then
			if obj1IsArray then
				obj1VirtualLength += 1

				local numericKey = tonumber(key)
				if numericKey ~= nil and numericKey == obj1VirtualLength then
					table.insert(patches, {
						op = "add",
						path = path .. "/-",
						value = Tables.copyDeep(obj2[key]),
					})

					continue
				end
			end

			table.insert(patches, {
				op = "add",
				path = path .. "/" .. getZeroBasedKey(key, obj2IsArray),
				value = Tables.copyDeep(obj2[key]),
			})
		end
	end
end

local JSONPatch = {}

function JSONPatch.applyPatch(doc: any, patch: { Types.PatchOperation }): any
	for _, operation in patch do
		doc = applyOperation(doc, operation)
	end
	return doc
end

function JSONPatch.createPatch(original: any, modified: any): { Types.PatchOperation }
	local patches = {}
	generate(original, modified, patches, "")
	return patches
end

return JSONPatch
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="96">
              <Properties>
                <string name="Name">Locks</string>
                <string name="Source"><![CDATA[--[=[
	Implements a distributed locking mechanism using Roblox's MemoryStoreService.
	This allows coordinating access to shared resources (like DataStore keys)
	across different game servers or instances.

	The locking strategy involves:
	- Attempting to atomically acquire a lock using `MemoryStoreService:UpdateAsync`.
	- Setting a Time-To-Live (TTL) on the lock key in MemoryStore.
	- Periodically refreshing the lock's TTL in a background task to maintain ownership.
	- Providing a mechanism (`onLockLost`) to notify the holder if the lock refresh fails
	  or the lock expires unexpectedly.

	This ensures that typically only one process holds the lock for a given key at a time.

	@class Locks
	@private
]=]

local HttpService = game:GetService("HttpService")

-- Small buffer subtracted from the TTL when calculating the local expiry time.
-- This helps account for potential clock skew or network latency, reducing the
-- chance of the local check (`isLocked`) returning true after the lock has
-- actually expired in MemoryStore.
local LOCK_TTL_ERROR_MARGIN_SECS = 0.2

local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Promise)
local hashMapRetry = require(script.Parent.hashMapRetry)

--[=[
	Possible states of the lock acquisition and holding process.
	@type LockStatus "acquiring" | "held" | "released"
	@within Locks
	@tag enum
	@private
]=]
type LockStatus = "acquiring" | "held" | "released"

--[=[
	Represents an acquired lock handle, providing methods to interact with the lock.

	@interface LockHandle
	@within Locks
	.release () -> Promise -- Releases the lock immediately. Stops the refresh loop and attempts to clear the lock key in MemoryStore (by setting TTL to 0). Resolves when the release attempt is complete.
	.isLocked () -> boolean -- Checks if the lock is currently considered held locally. This checks both the internal status and compares the last confirmed expiry time (from MemoryStore) against the current local time. True if the lock is believed to be held.
	.onLockLost (() -> ()) -> (() -> ()) -- Registers a callback function to be invoked if the lock is lost unexpectedly (e.g., refresh fails, TTL expires). Returns a function to disconnect/unregister the callback.
]=]
export type LockHandle = {
	release: () -> Promise.Promise,
	isLocked: () -> boolean,
	onLockLost: (callback: () -> ()) -> () -> (),
}

--[=[
	Parameters for acquiring a lock.

	@interface AcquireLockParams
	@within Locks
	.storeContext Types.StoreContext<any> -- Shared store context containing logger and MemoryStoreHashMap instance.
	.key string -- The unique key identifying the resource to be locked.
	.duration number -- The duration (TTL) in seconds for which the lock should be held/refreshed.
	.refreshInterval number -- The interval in seconds at which the lock refresh should be attempted.
]=]
export type AcquireLockParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
	duration: number,
	refreshInterval: number,
}

--[=[
	Attempts to acquire a distributed lock for the specified key.

	Manages the lock acquisition process, including retries with exponential
	backoff, setting up the background refresh loop, and providing a LockHandle
	on success.

	@param params -- Configuration for the lock acquisition.
	@return Promise<LockHandle> -- Resolves with a LockHandle if the lock is acquired successfully.
	@error Rejects if the lock cannot be acquired within the specified duration/attempts, or if other MemoryStore errors occur.
	@within Locks
]=]
local function acquireLock(params: AcquireLockParams): Promise.TPromise<LockHandle>
	-- Unique identifier for this specific lock attempt/instance.
	local lockId = HttpService:GenerateGUID(false)
	-- List of callbacks to invoke if the lock is lost.
	local expiredCallbacks: { () -> () } = {}
	-- Handle for the `task.delay` used to trigger expiry callbacks locally.
	local expiryThread: thread? = nil
	-- Promise representing the background refresh loop.
	local refreshPromise: Promise.Promise? = nil

	-- Current state of the lock.
	local status: LockStatus
	-- The local time (`os.clock()`) when the lock is expected to expire based on the
	-- last successful `UpdateAsync` call, minus the error margin.
	local lastConfirmedExpiry: number? = nil

	local ctx = params.storeContext
	local key = params.key
	local logger = ctx.logger:extend({ method = "acquireLock", key = key, lockId = lockId })

	--[=[
		Helper function to update the internal lock status and log the transition.
		@param newStatus -- The new status to set.
		@within Locks
		@private
	]=]
	local function transitionTo(newStatus: LockStatus)
		logger:log("trace", `lock transition: {status or "nil"} -> {newStatus}`)
		status = newStatus
	end

	--[=[
		Invokes all registered `onLockLost` callbacks.
		Called when the local expiry timer (`expiryThread`) fires or when refresh fails.
		@within Locks
		@private
	]=]
	local function spawnExpiryCallbacks()
		-- Only spawn if still considered 'held' locally to avoid duplicate calls after release.
		if status == "held" then
			logger:log("warn", "lock expiry timer fired or refresh failed, invoking onLockLost callbacks")
			transitionTo("released")
			for _, callback in expiredCallbacks do
				task.spawn(callback)
			end
		end
	end

	--[=[
		Attempts to update the lock key in MemoryStore using UpdateAsync.
		This is used for initial acquisition, refresh, and release (with ttl=0).

		The transform function ensures atomicity:
		- If the key doesn't exist (`otherLockId == nil`), set it to our `lockId`.
		- If the key exists and holds our `lockId`, update the TTL (refresh).
		- If the key exists and holds a different `lockId`, do nothing (fail acquisition/refresh).

		Also manages the local expiry timer (`expiryThread`) based on successful updates.

		@param ttl -- The Time-To-Live in seconds for the UpdateAsync call.
		@return Types.RetryHandle<Promise<any>> -- Handle containing the promise and cancel function from `hashMapRetry`.
		@within Locks
		@private
	]=]
	local function tryUpdate(ttl: number): Types.RetryHandle<Promise.TPromise<any>>
		logger:log("trace", `attempting UpdateAsync on key '{key}' with ttl {ttl}`)

		-- Transform function for atomic update
		local function transformFunction(otherLockId: string?): string?
			if otherLockId == nil or otherLockId == lockId then
				-- Key is empty or already held by us, allow update/acquisition.
				return lockId
			end
			-- Key is held by someone else, prevent update. UpdateAsync returns nil.
			return nil
		end

		-- Wrap the MemoryStore call in retry logic
		local retryHandle = hashMapRetry(function()
			return ctx.lockHashMap:UpdateAsync(key, transformFunction, ttl)
		end)

		-- Side effects on successful update
		retryHandle.promise:tap(function(value)
			-- `value` will be `lockId` if UpdateAsync succeeded, `nil` otherwise.
			if value ~= nil then
				-- Update local expiry time based on successful MemoryStore update.
				lastConfirmedExpiry = os.clock() + ttl - LOCK_TTL_ERROR_MARGIN_SECS
				logger:log("trace", `UpdateAsync succeeded, lastConfirmedExpiry updated to {lastConfirmedExpiry}`)

				-- Cancel any existing expiry timer thread.
				if expiryThread then
					task.cancel(expiryThread)
				end

				-- If TTL > 0 (acquisition/refresh), start a new local timer.
				-- If TTL is 0 (release), don't start a timer.
				if ttl > 0 then
					logger:log("trace", `starting local expiry timer for {ttl} seconds`)
					expiryThread = task.delay(ttl, spawnExpiryCallbacks)
				end
			else
				logger:log("trace", `UpdateAsync failed or returned nil (lock held by another?)`)
			end
		end)

		return retryHandle
	end

	--[=[
		Releases the lock. Stops refresh/expiry timers and attempts to clear the
		lock in MemoryStore by setting TTL to 0.

		@return Promise -- Resolves when the release process is complete.
		@within Locks
		@private
	]=]
	local function release(): Promise.Promise
		logger:log("trace", "release function called")

		-- Idempotency check: only proceed if currently 'held'.
		if status ~= "held" then
			logger:log("trace", `lock not 'held' (status: {status}), skipping release logic`)
			return Promise.resolve()
		end
		transitionTo("released")

		-- Cancel local expiry timer.
		if expiryThread then
			task.cancel(expiryThread)
			expiryThread = nil
			logger:log("trace", "cancelled expiryThread")
		end

		-- Cancel background refresh loop.
		if refreshPromise then
			refreshPromise:cancel()
			refreshPromise = nil
			logger:log("trace", "cancelled refreshPromise")
		end

		-- Check if the lock is likely still valid in MemoryStore before trying to clear it.
		local isLikelyAcquiredRemotely = lastConfirmedExpiry and lastConfirmedExpiry > os.clock()
		if isLikelyAcquiredRemotely then
			logger:log("trace", "attempting to clear lock in MemoryStore (UpdateAsync with TTL 0)")
			-- Attempt to set TTL to 0. We don't need to wait for this promise to resolve fully,
			-- but we return it so the caller can wait if needed.
			return tryUpdate(0).promise:catch(function(err)
				logger:log("warn", "failed during final UpdateAsync(ttl=0) on release", { error = err })
				return Promise.reject(err) -- Pass through the error if needed
			end)
		else
			logger:log("trace", "lock likely already expired remotely, skipping final UpdateAsync")
			return Promise.resolve()
		end
	end

	--[=[
		Main loop for attempting to acquire the lock initially.
		Uses `tryUpdate` with exponential backoff.

		@return Promise -- Resolves when the lock is acquired, rejects if timeout occurs.
		@within Locks
		@private
	]=]
	local function waitForLock(): Promise.Promise
		logger:log("trace", "entering waitForLock loop")
		transitionTo("acquiring")

		local acquisitionStartTime = os.clock()
		local currentRetryHandle: Types.RetryHandle<Promise.TPromise<any>>? = nil
		local attemptCount = 0
		local maxAcquisitionTime = params.duration -- Use lock duration as acquisition timeout

		return Promise.new(function(resolve, reject, onCancel)
			-- Setup cancellation handler: clean up any pending retry and release the lock.
			onCancel(function()
				logger:log("trace", "waitForLock cancelled")
				local cleanupPromise = Promise.resolve()
				if currentRetryHandle then
					currentRetryHandle.cancel()
					-- The retry may have an in-flight request. To prevent race
					-- conditions, we only release after it settles.
					cleanupPromise = (currentRetryHandle :: any).promise
				end

				-- After potential retry settles, attempt release.
				cleanupPromise:finally(function()
					release():catch(function(err)
						-- Log release errors during cancellation but don't reject for them.
						logger:log("error", "failed to release lock during cancellation", { error = err })
					end)
				end)
			end)

			-- Run the acquisition loop in a separate thread to allow
			-- cancellation without abruptly stopping via coroutine.close.
			task.spawn(function()
				while (os.clock() - acquisitionStartTime) < maxAcquisitionTime do
					-- Check for cancellation at the start of each attempt.
					if onCancel() then
						logger:log("trace", "detected cancellation within loop")
						return -- Exit loop if cancelled
					end

					attemptCount += 1
					logger:log("trace", `acquisition attempt {attemptCount}`)
					currentRetryHandle = tryUpdate(params.duration)
					-- Await the result of the UpdateAsync attempt (wrapped in retry logic)
					local resolved, value = (currentRetryHandle :: any).promise:await()
					currentRetryHandle = nil -- Clear handle once settled

					if resolved and value ~= nil then
						-- Success! Lock acquired.
						logger:log("info", "lock acquired successfully")
						transitionTo("held")
						return resolve() -- Resolve the main acquireLock promise
					elseif not resolved then
						-- UpdateAsync (or retry logic) failed. Log warning.
						logger:log("warn", "attempt to acquire lock failed", {
							attemptCount = attemptCount,
							error = value, -- Error message from rejection
						})
						-- Continue loop if error is deemed retryable by hashMapRetry
					else
						-- UpdateAsync succeeded but returned nil (lock held by someone else).
						logger:log("trace", "lock currently held by another instance")
						-- Continue loop to retry.
					end

					-- Check for cancellation again after the attempt.
					if onCancel() then
						logger:log("trace", "detected cancellation after attempt")
						return -- Exit loop if cancelled
					end

					-- Exponential backoff before next attempt, capped at 30s.
					local retryAfter = math.min(2 ^ (attemptCount - 1), 30)
					logger:log("trace", `waiting {retryAfter}s before next attempt`)
					task.wait(retryAfter)
				end

				-- Loop finished without acquiring the lock within the time limit.
				logger:log("error", "failed to acquire lock within time limit", { duration = maxAcquisitionTime })
				return reject(`Failed to acquire lock for key '{key}' within {maxAcquisitionTime} seconds`)
			end)
		end)
	end

	--[=[
		Starts the background loop responsible for periodically refreshing the lock TTL.
		@within Locks
		@private
	]=]
	local function setupLockRefresh(): ()
		logger:log("trace", "setting up background lock refresh loop")

		local currentRefreshHandle: Types.RetryHandle<Promise.TPromise<any>>? = nil

		-- Create a promise representing the refresh loop's lifetime.
		refreshPromise = Promise.new(function(resolveLoop, _, onCancelLoop)
			-- Setup cancellation for the refresh loop promise itself.
			onCancelLoop(function()
				logger:log("trace", "refreshPromise cancelled")
				-- If a refresh attempt is in progress, cancel its retry handle.
				if currentRefreshHandle then
					currentRefreshHandle.cancel()
				end
			end)

			-- Run the refresh loop in a separate thread to allow
			-- cancellation without abruptly stopping via coroutine.close.
			task.spawn(function()
				-- Continue looping as long as the lock is considered 'held'.
				while status == "held" do
					-- Wait for the specified refresh interval.
					task.wait(params.refreshInterval)

					-- Check for cancellation or status change during the wait.
					if onCancelLoop() or status ~= "held" then
						logger:log("trace", "exiting refresh loop due to cancellation or status change")
						break
					end

					logger:log("trace", "attempting lock refresh")
					-- Attempt to update the lock TTL using tryUpdate.
					currentRefreshHandle = tryUpdate(params.duration)
					-- Await the result of the refresh attempt
					local resolved, value = (currentRefreshHandle :: any).promise:await()
					currentRefreshHandle = nil -- Clear handle once settled

					-- Check status again after the refresh attempt.
					if status ~= "held" then
						logger:log("trace", "exiting refresh loop, status changed during refresh attempt")
						break
					end

					-- If refresh failed (rejected or returned nil), the lock is lost.
					if not resolved or value == nil then
						logger:log("warn", "failed to refresh lock, lock considered lost", { error = value })
						-- Trigger expiry callbacks and exit the loop.
						spawnExpiryCallbacks()
						break
					else
						logger:log("trace", "lock refreshed successfully")
					end
				end

				-- Loop exited (either normally due to status change/cancellation, or due to refresh failure).
				logger:log("trace", "background refresh loop finished")
				resolveLoop() -- Resolve the main refreshPromise.
			end)
		end)
	end

	-- Construct the LockHandle object to be returned.
	local lockHandle: LockHandle = {
		release = release,
		isLocked = function(): boolean
			-- Check both internal status and local expiry time.
			return status == "held" and (lastConfirmedExpiry or 0) > os.clock()
		end,
		onLockLost = function(callback: () -> ()): () -> ()
			-- Add callback to the list.
			table.insert(expiredCallbacks, callback)
			-- Return a function to remove the callback from the list.
			return function()
				local idx = table.find(expiredCallbacks, callback)
				if idx then
					table.remove(expiredCallbacks, idx)
				end
			end
		end,
	}

	-- Chain the acquisition and refresh setup.
	return waitForLock() -- Attempt initial acquisition.
		:andThen(function()
			-- If acquisition succeeded, set up the refresh loop and return the handle.
			setupLockRefresh()
			return lockHandle
		end)
		:catch(function(err)
			-- If acquisition failed, attempt to release any partially acquired state
			-- and then re-reject with the original error.
			logger:log("error", "failed to acquire lock", { error = err })
			return release():andThen(function()
				-- Ensure the original error propagates.
				return Promise.reject(err)
			end)
		end)
end

--[=[
	Parameters for probing if a lock is active.

	@interface ProbeLockActiveParams
	@within Locks
	.storeContext Types.StoreContext<any> -- Shared store context containing logger and MemoryStoreHashMap instance.
	.key string -- The unique key identifying the resource to be locked.
]=]
export type ProbeLockActiveParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
}

--[=[
	Checks if a lock key currently exists in MemoryStore without attempting to acquire it.
	Useful for determining if another process likely holds the lock.

	Note: This is a point-in-time check and doesn't guarantee the lock state won't
	change immediately after the check completes.

	@param params -- Parameters for probing the lock.
	@return Promise<boolean> -- Resolves with true if the lock key exists, false otherwise.
	@within Locks
]=]
local function probeLockActive(params: ProbeLockActiveParams): Promise.TPromise<boolean>
	local ctx = params.storeContext
	local key = params.key
	local logger = ctx.logger:extend({ method = "probeLockActive", key = key })

	logger:log("trace", "probing if lock is active via GetAsync")

	-- Use GetAsync wrapped in retry logic.
	local retryHandle = hashMapRetry(function()
		return ctx.lockHashMap:GetAsync(key)
	end)

	-- Check if the GetAsync call returned a value (meaning the key exists).
	return retryHandle.promise:andThen(function(value)
		local isActive = value ~= nil
		logger:log("trace", `probe result: {isActive}`)
		return isActive
	end)
end

return {
	acquireLock = acquireLock,
	probeLockActive = probeLockActive,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="97">
              <Properties>
                <string name="Name">Log</string>
                <string name="Source"><![CDATA[--[=[
	@class Log
	@private

	Provides a structured logging implementation for the Lyra library.

	**Design:**
	- **Callback-based:** Instead of directly printing or sending logs, this module
	  uses a callback function (`logCallback`) provided during logger creation. This
	  allows the consuming application to decide how and where log messages are routed
	  (e.g., print to console, send to an external service, store in memory).
	- **Structured Context:** Log messages include a `context` table. Loggers can be
	  `extend`ed with additional context fields, which are automatically merged into
	  every subsequent log message created by that logger instance or its descendants.
	  This helps provide detailed, structured information for debugging and monitoring.
	- **Log Levels:** Supports standard log levels (`fatal`, `error`, `warn`, `info`,
	  `debug`, `trace`). A global log level can be set using `Log.setLevel` to filter
	  out messages below the desired severity.

	**Usage:**
	```lua
	local Log = require(script.Parent.Log)

	-- Set the global minimum log level (optional, defaults to "info")
	Log.setLevel("debug")

	-- Create a logger instance with a callback
	local myLogger = Log.createLogger(function(logMessage)
		print(`[{logMessage.level}] {logMessage.message}`, logMessage.context)
	end, { initialContext = "value" })

	-- Log messages
	myLogger:log("info", "User logged in", { userId = 123 })

	-- Create a logger with extended context
	local sessionLogger = myLogger:extend({ sessionId = "abc" })
	sessionLogger:log("debug", "Session data loaded")
	-- Output will include { initialContext = "value", sessionId = "abc", userId = 123 }
	-- if logged via myLogger, or { initialContext = "value", sessionId = "abc" }
	-- if logged via sessionLogger.
	```
]=]

--[=[
	Represents the different log levels available for logging messages.

	@type LogLevel "fatal" | "error" | "warn" | "info" | "debug" | "trace"
	@tag enum
	@within Log
]=]
export type LogLevel = "fatal" | "error" | "warn" | "info" | "debug" | "trace"

--[=[
	Represents a log message sent to the logger's callback function.

	@interface LogMessage
	@within Log
	.message string -- The main content of the log message.
	.level LogLevel -- The severity level of the message.
	.context { [string]: any }? -- Optional table containing additional structured context.
]=]
export type LogMessage = {
	message: string,
	level: LogLevel,
	context: { [string]: any }?,
}

export type LoggerImpl = {
	__index: LoggerImpl,

	log: (self: Logger, level: LogLevel, message: string, context: { [string]: any }?) -> (),
	extend: (self: Logger, context: { [string]: any }) -> Logger,
}

export type LoggerProps = {
	_logCallback: (logMessage: LogMessage) -> (),
	_context: { [string]: any },
}

export type Logger = typeof(setmetatable({} :: LoggerProps, {} :: LoggerImpl))

-- Ordered list of log levels from most severe to least severe.
local levels = {
	"fatal",
	"error",
	"warn",
	"info",
	"debug",
	"trace",
}

-- The main Log module table, holds global settings like the current log level.
local Log = {
	level = "info", -- Default global log level.
}

--[=[
	Sets the global minimum log level.
	Messages with a severity lower than this level will be ignored by all loggers.

	@within Log
	@param level LogLevel -- The minimum log level to allow.
	@error string -- Throws an error if the provided level is invalid.
]=]
function Log.setLevel(level: LogLevel)
	if table.find(levels, level) == nil then
		error(`Invalid log level: '{level}'`)
	end
	Log.level = level
end

-- Metatable implementing the Logger methods. (Internal)
local Logger: LoggerImpl = {} :: LoggerImpl
Logger.__index = Logger

--[=[
	Logs a message if its level is at or above the globally set log level.

	Merges the provided `context` table with the logger's persistent context
	before calling the configured `_logCallback`.

	@within Log
	@param level LogLevel -- The severity level of the message.
	@param message string -- The log message content.
	@param context { [string]: any }? -- Optional additional context specific to this log call.
]=]
function Logger:log(level: LogLevel, message: string, context: { [string]: any }?)
	-- Filter messages based on the global log level.
	if table.find(levels, level) > table.find(levels, Log.level) then
		return
	end

	-- Merge instance context with call-specific context.
	local finalContext = table.clone(self._context)
	if context then
		for key, value in context do
			finalContext[key] = value
		end
	end

	-- Call the configured log callback within a protected call to catch errors.
	local ok, result = pcall(function()
		self._logCallback({
			level = level,
			message = message,
			context = finalContext,
		})
	end)

	if not ok then
		-- If the logging callback itself errors, print a warning.
		warn(`Error in log callback: {result}`)
	end
end

--[=[
	Creates a new Logger instance that inherits the parent's callback
	but has an extended context.

	The new logger's context is a merged table containing the parent's context
	and the additional `context` provided here.

	@within Log
	@param context { [string]: any } -- The additional context fields to add.
	@return Logger -- A new Logger instance with the extended context.
]=]
function Logger:extend(context: { [string]: any }): Logger
	-- Merge existing context with the new context.
	local finalContext = table.clone(self._context)
	for key, value in context do
		finalContext[key] = value
	end

	-- Create and return a new logger instance sharing the callback but with the new context.
	return setmetatable({
		_logCallback = self._logCallback,
		_context = finalContext,
	}, Logger)
end

--[=[
	Factory function to create a new root Logger instance.

	@within Log
	@param logCallback (logMessage: LogMessage) -> () -- The function that will be called for each log message that passes the level filter. This function receives the complete `LogMessage` object including merged context.
	@param context { [string]: any }? -- Optional initial context for this logger.
	@return Logger -- A new Logger instance.
]=]
function Log.createLogger(logCallback: (logMessage: LogMessage) -> (), context: { [string]: any }?): Logger
	return setmetatable({
		_logCallback = logCallback,
		_context = context or {},
	}, Logger)
end

return Log
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="98">
              <Properties>
                <string name="Name">Migrations</string>
                <string name="Source"><![CDATA[--[=[
	@class Migrations
	@private

	Provides functionality for managing and applying data migrations.

	**Concept:** As data schemas evolve over time, older data stored
	in DataStores needs to be updated to match the new structure. This module
	allows defining a series of migration steps (`Types.MigrationStep`) that
	transform data from one version of the schema to the next.

	**Workflow:**
	1. Define migration steps using helpers like `makeAddFieldsStep` or `makeTransformStep`.
	   Each step must have a unique `name`.
	2. Provide the list of steps to the `Store` via `StoreContext`.
	3. When data is loaded (`Session:load`), the `apply` function in this module is called.
	4. `apply` compares the list of all defined steps against the `appliedMigrations`
	   list stored within the `DataStoreRecord`.
	5. It executes the `apply` function of any step that hasn't been applied yet, in the
	   order they are defined.
	6. The `apply` function of each step receives the current data and returns the transformed data.
	7. The names of successfully applied steps are added to the `appliedMigrations` list,
	   which is then saved back to the `DataStoreRecord`.

	**Idempotency:** The system ensures migrations are idempotent (applying them multiple
	times has the same effect as applying them once) by checking the `appliedMigrations` list
	before running a step.

	**Error Handling:** Each step's `apply` function is executed within a `pcall` to catch
	errors. If a step fails, the migration process stops, and the error is propagated.
]=]

local Log = require(script.Parent.Log)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local Types = require(script.Parent.Types)

--[=[
	Alias for a generic data table type used in migrations.

	@type Data { [string]: any }
	@within Migrations
	@private
]=]
type Data = { [string]: any }

--[=[
	Validates that the provided migration steps adhere to the expected structure.

	@within Migrations
	@param steps {Types.MigrationStep} -- The list of migration steps to validate.
	@error string -- Throws an error if any step is malformed.
]=]
local function validate(steps: { Types.MigrationStep })
	assert(typeof(steps) == "table", "steps must be a table")
	for _, step in steps do
		assert(typeof(step) == "table", "step must be a table")
		assert(typeof(step.name) == "string", "step.name must be a string")
		assert(typeof(step.apply) == "function", "step.apply must be a function")
	end
end

--[=[
	Helper function to create a common type of migration step: adding new fields
	with default values to existing data. Uses a deep merge strategy.

	@within Migrations
	@param name string -- The unique name for this migration step.
	@param fields Data -- A table containing the new fields and their default values.
	@return Types.MigrationStep -- A migration step object.
]=]
local function makeAddFieldsStep(name: string, fields: Data): Types.MigrationStep
	return {
		name = name,
		apply = function(data)
			-- Merges the default `fields` into the existing `data`.
			-- Existing keys in `data` are preserved unless they are tables themselves,
			-- in which case they are recursively merged.
			return Tables.mergeDeep(fields, data)
		end,
	}
end

--[=[
	Helper function to create a migration step that applies a custom transformation
	function to the data.

	@within Migrations
	@param name string -- The unique name for this migration step.
	@param transformFunc (currentValue: Data) -> Data -- The function that takes the current data and returns the transformed data.
	@return Types.MigrationStep -- A migration step object.
]=]
local function makeTransformStep(name: string, transformFunc: (currentValue: Data) -> Data): Types.MigrationStep
	return {
		name = name,
		apply = transformFunc,
	}
end

--[=[
	Parameters for the `apply` function.

	@interface ApplyParams
	@within Migrations
	.logger Log.Logger -- Logger instance for logging migration progress and errors.
	.data Data -- The current data loaded from the DataStore record's File.
	.steps {Types.MigrationStep} -- The list of all defined migration steps for the store.
	.appliedMigrations {string} -- The list of names of migration steps already applied to this specific data record, loaded from the DataStoreRecord.
]=]
export type ApplyParams = {
	logger: Log.Logger,
	data: Data,
	steps: { Types.MigrationStep },
	appliedMigrations: { string },
}

--[=[
	Result returned by the `apply` function upon successful completion.

	@interface ApplyResult
	@within Migrations
	.data Data -- The potentially modified data after applying necessary migration steps.
	.appliedMigrations {string} -- The updated list of applied migration names, including any newly applied steps. This should be saved back to the DataStoreRecord.
]=]
export type ApplyResult = {
	data: Data,
	appliedMigrations: { string },
}

--[=[
	Applies pending migration steps to the data.

	Iterates through the defined `steps` and applies any step whose name is not
	present in the `appliedMigrations` list. Ensures idempotency and uses `pcall`
	for safe execution of each step's `apply` function.

	@within Migrations
	@param params ApplyParams -- The parameters for applying migrations.
	@return Promise<ApplyResult> -- A Promise that resolves with the updated data and the new list of applied migration names.
	@error string -- Rejects if any migration step fails during `pcall`.
]=]
local function apply(params: ApplyParams): Promise.TPromise<ApplyResult>
	local logger = params.logger
	local currentData = params.data
	-- Clone the list to avoid modifying the original list passed in params directly within this function scope.
	local appliedMigrations = table.clone(params.appliedMigrations)

	-- Create a set for quick lookup of already applied migrations.
	local appliedSet = {}
	for _, name in appliedMigrations do
		appliedSet[name] = true
	end

	return Promise.new(function(resolve, reject)
		for _, step in params.steps do
			-- Idempotency Check: Only apply if the step name is not in the applied set.
			if not appliedSet[step.name] then
				logger:log("trace", "applying migration step", { stepName = step.name })

				-- Deep copy the data before applying the step to avoid modifying the original
				-- `currentData` reference in case of an error within `step.apply`.
				-- TODO: Do we actually care about atomicity here? This might be a performance hit.
				local staged = Tables.copyDeep(currentData)
				-- Safely execute the migration step's apply function.
				local ok, result = pcall(step.apply, staged)

				if not ok then
					-- If pcall failed, log the error and reject the promise.
					logger:log("error", "failed to apply migration step", { stepName = step.name, error = result })
					return reject(`Failed migration step '{step.name}': {result}`)
				end

				-- If pcall succeeded, update currentData with the result.
				-- Deep copy again to ensure `currentData` holds a distinct copy for the next step.
				-- TODO: We should probably just warn about not modifying the data after returning - this is expensive.
				currentData = Tables.copyDeep(result)
				-- Add the step name to the list of applied migrations for this record.
				table.insert(appliedMigrations, step.name)
				-- Also update the lookup set for the next iteration.
				appliedSet[step.name] = true
			end
		end

		-- All applicable steps applied successfully. Resolve with the final data and updated list.
		return resolve({
			data = currentData,
			appliedMigrations = appliedMigrations,
		})
	end)
end

--[=[
	Utility function to extract just the names from a list of migration steps.

	@within Migrations
	@param migrations {Types.MigrationStep} -- The list of migration steps.
	@return {string} -- A list containing only the names of the migration steps.
]=]
local function getStepNames(migrations: { Types.MigrationStep }): { string }
	local names = {}
	for _, step in migrations do
		table.insert(names, step.name)
	end
	return names
end

return {
	makeAddFieldsStep = makeAddFieldsStep,
	makeTransformStep = makeTransformStep,
	validate = validate,
	apply = apply,
	getStepNames = getStepNames,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="99">
              <Properties>
                <string name="Name">MockDataStoreService</string>
                <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Tables = require(script.Parent.Tables)

local MAX_QUEUE_SIZE = 30
local RATE_LIMITS = {
	GetAsync = { Base = 60, PlayerMultiplier = 10 },
	SetAsync = { Base = 60, PlayerMultiplier = 10 },
	UpdateAsync = { Base = 60, PlayerMultiplier = 10 },
	RemoveAsync = { Base = 60, PlayerMultiplier = 10 },
	GetVersion = { Base = 5, PlayerMultiplier = 2 },
}

local MAX_KEY_LENGTH = 50
local MAX_DATA_SIZE = 4_194_304
local MAX_METADATA_SIZE = 300
local CACHE_DURATION = 4

local function getLatencyForRequest(service: any, requestType: string): number
	if service._latencyByRequestType[requestType] then
		return service._latencyByRequestType[requestType]
	end

	if service._randomLatencyRange then
		local min = service._randomLatencyRange.min
		local max = service._randomLatencyRange.max
		return min + math.random() * (max - min)
	end

	return service._globalLatency or 0.1
end

local function shouldSimulateError(service: any, requestType: string): (boolean, string?)
	if #service.queuedErrors[requestType] > 0 then
		return true, table.remove(service.queuedErrors[requestType], 1)
	end

	if service._errorRates[requestType] and math.random() < service._errorRates[requestType] then
		return true, "DataStore request failed due to random error simulation"
	end

	if service._simulateThrottling then
		return true, "DataStore request was throttled, try again later"
	end

	if service._simulateTimeout then
		return true, "DataStore request timed out"
	end

	return false, nil
end

local function doLatency(service: any, requestType: string)
	local latency = getLatencyForRequest(service, requestType)
	if latency > 0 then
		task.wait(latency)
	end
end

local function getNow()
	return DateTime.now().UnixTimestampMillis
end

local function msToHours(ms: number)
	return math.floor(ms / (60 * 60 * 1000))
end

local function getUtcHour()
	return msToHours(getNow())
end

local function createVersion(value: any, userIds: any, metadata: any)
	return {
		Value = value,
		UserIds = userIds or {},
		Metadata = metadata or {},
		CreatedTime = getNow(),
		Version = tostring(getNow()),
	}
end

local function createMockKeyInfo(userIds: any, metadata: any)
	local info = {
		CreatedTime = getNow(),
		UpdatedTime = getNow(),
		Version = tostring(getNow()),
		userIds = userIds or {},
		metadata = metadata or {},
		GetUserIds = function(self)
			return self.userIds
		end,
		GetMetadata = function(self)
			return self.metadata
		end,
	}
	return info
end

local function validateMetadata(metadata: any)
	if metadata == nil then
		return
	end

	if typeof(metadata) ~= "table" then
		error("DataStoreService: Metadata must be a table", 0)
	end

	local serialized = game:GetService("HttpService"):JSONEncode(metadata)
	if #serialized > MAX_METADATA_SIZE then
		error(`DataStoreService: Metadata size exceeds {MAX_METADATA_SIZE} limit`, 0)
	end
end

local function getScopedData(self: any)
	local datastore = self._service.mockData[self.datastoreName]
	if not datastore then
		datastore = {}
		self._service.mockData[self.datastoreName] = datastore
	end

	local scopedData = datastore[self.scope]
	if not scopedData then
		scopedData = {}
		datastore[self.scope] = scopedData
	end

	return scopedData
end

local function getVersionsForKey(self: any, key: string)
	local versionKey = `{self.datastoreName}|{self.scope}|{key}`
	if not self._service.mockVersions[versionKey] then
		self._service.mockVersions[versionKey] = {}
	end
	return self._service.mockVersions[versionKey]
end

local function getCacheKey(self: any, key: string)
	return `{self.datastoreName}|{self.scope}|{key}`
end

local function getCachedValue(self: any, key: string)
	local cacheKey = getCacheKey(self, key)
	local cached = self._service.mockCache[cacheKey]
	if cached and (os.time() - cached.timestamp) < CACHE_DURATION then
		return cached.value, cached.keyInfo
	end
	return nil, nil :: any
end

local function setCachedValue(self: any, key: string, value: any, keyInfo: any)
	local cacheKey = getCacheKey(self, key)
	self._service.mockCache[cacheKey] = {
		value = value,
		keyInfo = keyInfo,
		timestamp = os.time(),
	}
end

local function enforceKeyLimits(key: any)
	if typeof(key) ~= "string" then
		error("DataStoreService: Key must be a string", 0)
	end

	if #key == 0 then
		error("DataStoreService: Key name can't be empty", 0)
	end

	if #key > MAX_KEY_LENGTH then
		error(`DataStoreService: Key name exceeds the {MAX_KEY_LENGTH} character limit`, 0)
	end
end

local function enforceDataLimits(value: any)
	if value == nil then
		return
	end

	local success, result = pcall(function()
		return game:GetService("HttpService"):JSONEncode(value)
	end)
	if not success then
		error(`DataStoreService: Cannot store {typeof(value)} in DataStore`, 0)
	end

	if #result > MAX_DATA_SIZE then
		error(`DataStoreService: Serialized value exceeds {MAX_DATA_SIZE} limit`, 0)
	end
end

local function doRateLimitAndQueue(self: any, requestType: string)
	local queue = self._service.requestQueues[requestType]
	local limitData = RATE_LIMITS[requestType]
	if not limitData then
		limitData = RATE_LIMITS.GetAsync
	end

	local budget = self._service._customBudgets[requestType]
	if not budget then
		local currentPlayers = 15
		budget = limitData.Base + (currentPlayers * limitData.PlayerMultiplier)
	end

	if #queue >= budget then
		return false
	end

	if #queue >= MAX_QUEUE_SIZE then
		error(
			`DataStoreService:{requestType}() request dropped. Request was throttled, but throttled request queue was full`,
			0
		)
	end

	if self._service._forcedThrottles[requestType] then
		local throttleInfo = self._service._forcedThrottles[requestType]
		if throttleInfo.endTime > os.time() then
			error("DataStoreService: Request is currently throttled", 0)
		else
			self._service._forcedThrottles[requestType] = nil
		end
	end

	table.insert(queue, true)
	doLatency(self._service, requestType)
	local fn = table.remove(queue, 1)

	local shouldError, errorMessage = shouldSimulateError(self._service, requestType)
	if shouldError then
		error(errorMessage, 0)
	end

	if typeof(fn) == "function" then
		fn()
	end

	return true
end

local function sanitize(value: any)
	return Tables.copyDeep(value)
end

local MockDataStore = {}

function MockDataStore:SetAsync(key, value, userIds, options)
	value = sanitize(value)
	enforceKeyLimits(key)
	enforceDataLimits(value)
	if options then
		validateMetadata(options:GetMetadata())
	end

	doRateLimitAndQueue(self, "SetAsync")

	local scopedData = getScopedData(self)
	local versions = getVersionsForKey(self, key)
	local currentHour = getUtcHour()

	if #versions == 0 or msToHours(versions[#versions].CreatedTime) ~= currentHour then
		table.insert(versions, createVersion(value, userIds, options and options:GetMetadata()))
	else
		local currentVersion = versions[#versions]
		currentVersion.Value = value
		if userIds then
			currentVersion.UserIds = userIds
		end
		if options then
			currentVersion.Metadata = options:GetMetadata() or {}
		end
	end

	local latestVersion = versions[#versions].Version
	scopedData[key] = value
	local keyInfo = createMockKeyInfo(userIds, options and options:GetMetadata())
	self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`] = keyInfo

	setCachedValue(self, key, value, keyInfo)

	return latestVersion
end

function MockDataStore:GetAsync(key, options)
	enforceKeyLimits(key)

	if options == nil or options.UseCache == true then
		local cachedValue, cachedKeyInfo = getCachedValue(self, key)
		if cachedValue ~= nil then
			return cachedValue, cachedKeyInfo
		end
	end

	doRateLimitAndQueue(self, "GetAsync")

	local scopedData = getScopedData(self)
	local data = scopedData[key]
	local keyInfo = self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`]

	if data ~= nil then
		setCachedValue(self, key, data, keyInfo)
	end

	return data, keyInfo
end

function MockDataStore:UpdateAsync(key, transformFunction)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "UpdateAsync")

	while true do
		local scopedData = getScopedData(self)
		local keyInfo = self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`] or createMockKeyInfo()
		local currentValue = scopedData[key]
		local valueForCallback = currentValue ~= nil and Tables.copyDeep(currentValue)

		local newValue, newUserIds, newMetadata = transformFunction(valueForCallback, keyInfo)
		if newValue == nil then
			return currentValue, keyInfo
		end
		newValue = sanitize(newValue)

		enforceDataLimits(newValue)
		validateMetadata(newMetadata)

		if not Tables.equalsDeep(currentValue, scopedData[key]) then
			continue
		end

		local versions = getVersionsForKey(self, key)
		local currentHour = getUtcHour()

		if #versions == 0 or versions[#versions].CreatedTime ~= currentHour then
			table.insert(
				versions,
				createVersion(newValue, newUserIds or keyInfo:GetUserIds(), newMetadata or keyInfo:GetMetadata())
			)
		else
			local currentVersion = versions[#versions]
			currentVersion.Value = newValue
			if newUserIds then
				currentVersion.UserIds = newUserIds
			end
			if newMetadata then
				currentVersion.Metadata = newMetadata
			end
		end

		scopedData[key] = newValue
		if newUserIds ~= nil then
			keyInfo.userIds = newUserIds
		end
		if newMetadata ~= nil then
			keyInfo.metadata = newMetadata
		end
		keyInfo.UpdatedTime = getNow()
		keyInfo.Version = tostring(getNow())

		setCachedValue(self, key, newValue, keyInfo)
		return newValue, keyInfo
	end
end

function MockDataStore:RemoveAsync(key)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "RemoveAsync")

	local scopedData = getScopedData(self)
	local data = scopedData[key]
	local keyInfo = self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`]

	if data ~= nil then
		local versions = getVersionsForKey(self, key)
		table.insert(versions, createVersion(nil, nil, nil))
	end

	scopedData[key] = nil

	local cacheKey = getCacheKey(self, key)
	self._service.mockCache[cacheKey] = nil

	return data, keyInfo
end

function MockDataStore:GetVersionAsync(key, version)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "GetVersion")

	local versions = getVersionsForKey(self, key)
	for _, v in versions do
		if v.Version == version then
			return v.Value, createMockKeyInfo(v.UserIds, v.Metadata)
		end
	end
	return nil, nil :: any
end

function MockDataStore:ListVersionsAsync(key, sortDirection, minDate, maxDate)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "GetVersion")

	local versions = getVersionsForKey(self, key)
	local results = {}

	for _, v in versions do
		if (not minDate or v.CreatedTime >= minDate) and (not maxDate or v.CreatedTime <= maxDate) then
			table.insert(results, {
				Version = v.Version,
				CreatedTime = v.CreatedTime,
			})
		end
	end

	if sortDirection == Enum.SortDirection.Descending then
		table.sort(results, function(a, b)
			return a.CreatedTime > b.CreatedTime
		end)
	else
		table.sort(results, function(a, b)
			return a.CreatedTime < b.CreatedTime
		end)
	end

	return {
		IsFinished = true,
		GetCurrentPage = function()
			return results
		end,
	}
end

local function createMockStore(service: any, datastoreName: string, scope: string?)
	return setmetatable({
		datastoreName = datastoreName,
		scope = scope or "global",
		_service = service,
	}, service.mockStoreMeta)
end

local function new()
	local mockStoreMeta = table.clone(MockDataStore)
	mockStoreMeta.__index = mockStoreMeta

	local tbl = {
		dataStores = {},
		mockData = {},
		mockKeyInfo = {},
		mockVersions = {},
		mockCache = {},
		requestQueues = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
			GetVersion = {},
		},
		queuedErrors = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
			GetVersion = {},
		},
		mockStoreMeta = mockStoreMeta,

		_globalLatency = nil,
		_latencyByRequestType = {},
		_randomLatencyRange = nil,
		_errorRates = {},
		_simulateThrottling = false,
		_simulateTimeout = false,
		_customBudgets = {},
		_forcedThrottles = {},
	}

	tbl.GetDataStore = function(self, datastoreName: string, scope: string?)
		local store = self.dataStores[`{datastoreName}{scope or ""}`]
		if not store then
			store = createMockStore(self, datastoreName, scope)
			self.dataStores[`{datastoreName}{scope or ""}`] = store
		end
		return store
	end

	tbl.GetRequestBudgetForRequestType = function(self, requestType: Enum.DataStoreRequestType)
		local requestTypeStr = requestType.Name

		local queueKey = requestTypeStr
		if requestTypeStr == "GetVersionAsync" then
			queueKey = "GetVersion"
		end
		if requestTypeStr == "GetIncrementAsync" then
			queueKey = "GetAsync"
		end
		if requestTypeStr == "SetIncrementAsync" then
			queueKey = "SetAsync"
		end

		if self._customBudgets[queueKey] then
			return self._customBudgets[queueKey]
		end

		local limitData = RATE_LIMITS[queueKey]
		if not limitData then
			limitData = RATE_LIMITS.GetAsync
		end

		local currentPlayers = 15
		local totalBudget = limitData.Base + (currentPlayers * limitData.PlayerMultiplier)

		local currentQueueSize = #self.requestQueues[queueKey]
		return math.max(0, totalBudget - currentQueueSize)
	end

	return (tbl :: any) :: DataStoreService
end

return {
	new = new,

	mockStoreMethod = function(service, method: string, jest: any)
		local real = service.mockStoreMeta[method]
		local mock, fn = jest.fn(real)
		service.mockStoreMeta[method] = fn
		return mock, real
	end,

	setGlobalLatency = function(service: any, seconds: number)
		service._globalLatency = seconds
	end,
	setLatencyForRequestType = function(service: any, requestType: string, seconds: number)
		service._latencyByRequestType[requestType] = seconds
	end,
	setRandomLatency = function(service: any, minSeconds: number, maxSeconds: number)
		service._randomLatencyRange = { min = minSeconds, max = maxSeconds }
	end,
	queueError = function(service: any, requestType: string, errorMessage: string, count: number?)
		for _ = 1, count or 1 do
			table.insert(service.queuedErrors[requestType], errorMessage)
		end
	end,
	setErrorRate = function(service: any, requestType: string, rate: number)
		service._errorRates[requestType] = rate
	end,
	simulateThrottling = function(service: any, enabled: boolean)
		service._simulateThrottling = enabled
	end,
	simulateTimeout = function(service: any, enabled: boolean)
		service._simulateTimeout = enabled
	end,
	setRequestBudget = function(service: any, requestType: string, budget: number)
		service._customBudgets[requestType] = budget
	end,
	forceThrottle = function(service: any, requestType: string, duration: number)
		service._forcedThrottles[requestType] = {
			endTime = os.time() + duration,
		}
	end,
	snapshot = function(service: any)
		return HttpService:JSONEncode({
			mockData = service.mockData,
			mockKeyInfo = service.mockKeyInfo,
			mockVersions = service.mockVersions,
			mockCache = service.mockCache,
		})
	end,
	restore = function(service: any, snapshot: string)
		local decoded = HttpService:JSONDecode(snapshot)
		service.mockData = decoded.mockData
		service.mockKeyInfo = decoded.mockKeyInfo
		service.mockVersions = decoded.mockVersions
		service.mockCache = decoded.mockCache
	end,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="100">
              <Properties>
                <string name="Name">MockMemoryStoreService</string>
                <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Tables = require(script.Parent.Tables)

local MAX_QUEUE_SIZE = 30
local RATE_LIMITS = {
	GetAsync = { Base = 100, PlayerMultiplier = 10 },
	SetAsync = { Base = 100, PlayerMultiplier = 10 },
	UpdateAsync = { Base = 100, PlayerMultiplier = 10 },
	RemoveAsync = { Base = 100, PlayerMultiplier = 10 },
}

local MAX_KEY_LENGTH = 128
local MAX_VALUE_SIZE = 32 * 1024 -- 32KB
local MAX_UPDATE_RETRIES = 3
local MAX_EXPIRATION = 3888000 -- 45 days in seconds

local function getNow()
	return DateTime.now().UnixTimestampMillis
end

local function getLatencyForRequest(service: any, requestType: string): number
	if service._latencyByRequestType[requestType] then
		return service._latencyByRequestType[requestType]
	end

	if service._randomLatencyRange then
		local min = service._randomLatencyRange.min
		local max = service._randomLatencyRange.max
		return min + math.random() * (max - min)
	end

	return service._globalLatency or 0.1
end

local function shouldSimulateError(service: any, requestType: string): (boolean, string?)
	if #service.queuedErrors[requestType] > 0 then
		return true, table.remove(service.queuedErrors[requestType], 1)
	end

	if service._errorRates[requestType] and math.random() < service._errorRates[requestType] then
		return true, "InternalError: random error simulation"
	end

	if service._simulateThrottling then
		return true, "Throttled: MemoryStore request was throttled, try again later"
	end

	if service._simulateTimeout then
		return true, "Timeout: MemoryStore request timed out"
	end

	return false, nil
end

local function doLatency(service: any, requestType: string)
	local latency = getLatencyForRequest(service, requestType)
	if latency > 0 then
		task.wait(latency)
	end
end

local function doRateLimitAndQueue(service: any, requestType: string)
	local queue = service.requestQueues[requestType]
	local limitData = RATE_LIMITS[requestType]
	local budget = service._customBudgets[requestType]
	if not budget then
		local currentPlayers = 15
		budget = limitData.Base + (currentPlayers * limitData.PlayerMultiplier)
	end

	if #queue >= budget then
		error("TotalRequestsOverLimit", 0)
	end

	if #queue >= MAX_QUEUE_SIZE then
		error("RequestThrottled", 0)
	end

	if service._forcedThrottles[requestType] then
		local throttleInfo = service._forcedThrottles[requestType]
		if throttleInfo.endTime > os.time() then
			error("MemoryStore request is currently throttled", 0)
		else
			service._forcedThrottles[requestType] = nil
		end
	end

	table.insert(queue, true)
	doLatency(service, requestType)
	local fn = table.remove(queue, 1)

	local shouldError, errorMessage = shouldSimulateError(service, requestType)
	if shouldError then
		error(errorMessage, 0)
	end

	if typeof(fn) == "function" then
		fn()
	end
end

local function enforceKeyLimits(key: string)
	if typeof(key) ~= "string" then
		error("InvalidRequest: key must be a string", 0)
	end
	if #key == 0 then
		error("InvalidRequest: key cannot be empty", 0)
	end
	if #key > MAX_KEY_LENGTH then
		error("InvalidRequest: key length exceeds limit", 0)
	end
end

local function enforceValueLimits(value: any)
	if value == nil then
		return
	end

	local success, encoded = pcall(function()
		return game:GetService("HttpService"):JSONEncode(value)
	end)

	if not success then
		error("InvalidRequest: value cannot be encoded to JSON", 0)
	end

	if #encoded > MAX_VALUE_SIZE then
		error("ItemValueSizeTooLarge", 0)
	end
end

local function enforceExpirationLimits(expiration: number)
	if typeof(expiration) ~= "number" then
		error("InvalidRequest: expiration must be a number", 0)
	end
	if expiration < 0 then
		error("InvalidRequest: expiration must be >= 0", 0)
	end
	if expiration > MAX_EXPIRATION then
		error("InvalidRequest: expiration exceeds maximum", 0)
	end
end

local function getScopedData(self: any)
	local hashMap = self.service.mockData[self.name]
	if not hashMap then
		hashMap = {}
		self.service.mockData[self.name] = hashMap
	end
	return hashMap
end

local function isExpired(entry: any): boolean
	if not entry or not entry.expiration then
		return true
	end
	return getNow() > entry.expiration
end

local function sanitize(value: any): any
	return Tables.copyDeep(value)
end

local MockHashMap = {}

function MockHashMap:GetAsync(key: string): any?
	enforceKeyLimits(key)

	doRateLimitAndQueue(self.service, "GetAsync")

	local scopedData = getScopedData(self)
	local entry = scopedData[key]

	if isExpired(entry) then
		scopedData[key] = nil
		return nil
	end

	return entry.value
end

function MockHashMap:SetAsync(key: string, value: any, expiration: number): boolean
	value = sanitize(value)
	enforceKeyLimits(key)
	enforceValueLimits(value)
	enforceExpirationLimits(expiration)

	doRateLimitAndQueue(self.service, "SetAsync")

	local scopedData = getScopedData(self)
	local serialized = HttpService:JSONEncode(value)
	if serialized == nil then
		return false
	end

	scopedData[key] = {
		value = value,
		expiration = getNow() + expiration * 1000,
	}

	return true
end

function MockHashMap:UpdateAsync(key: string, transformFunction: (any?) -> any?, expiration: number): any?
	enforceKeyLimits(key)
	enforceExpirationLimits(expiration)

	doRateLimitAndQueue(self.service, "UpdateAsync")

	local scopedData = getScopedData(self)
	local retries = 0

	while retries < MAX_UPDATE_RETRIES do
		local entry = scopedData[key]
		local currentValue = nil

		if not isExpired(entry) then
			currentValue = Tables.copyDeep(entry.value)
		end

		local success, newValue = pcall(transformFunction, currentValue)
		if not success then
			error("TransformCallbackFailed", 0)
		end

		if newValue == nil then
			return nil
		end
		newValue = sanitize(newValue)

		enforceValueLimits(newValue)

		if entry and not isExpired(entry) and not Tables.equalsDeep(entry.value, currentValue) then
			retries += 1
			if retries >= MAX_UPDATE_RETRIES then
				error("DataUpdateConflict", 0)
			end
			continue
		end

		scopedData[key] = {
			value = newValue,
			expiration = getNow() + expiration * 1000,
		}

		return newValue
	end

	error("UpdateConflict: Exceeded max number of retries", 0)
end

function MockHashMap:RemoveAsync(key: string)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self.service, "RemoveAsync")

	local scopedData = getScopedData(self)
	scopedData[key] = nil
end

local function createMockHashMap(service: any, name: string): any
	return setmetatable({
		service = service,
		name = name,
	}, { __index = service.mockHashMapMeta })
end

local function new(): MemoryStoreService
	local mockHashMapMeta = table.clone(MockHashMap)
	mockHashMapMeta.__index = mockHashMapMeta

	local tbl = {
		mockData = {},
		hashMaps = {},
		mockHashMapMeta = mockHashMapMeta,
		requestQueues = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
		},
		queuedErrors = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
		},

		_globalLatency = nil,
		_latencyByRequestType = {},
		_randomLatencyRange = nil,
		_errorRates = {},
		_simulateThrottling = false,
		_simulateTimeout = false,
		_customBudgets = {},
		_forcedThrottles = {},
	}

	tbl.GetHashMap = function(self, name: string): any
		if not self.hashMaps[name] then
			self.hashMaps[name] = createMockHashMap(self, name)
		end
		return self.hashMaps[name]
	end

	return (tbl :: any) :: MemoryStoreService
end

return {
	new = new,

	mockHashMapMethod = function(service: any, method: string, jest: any)
		local real = service.mockHashMapMeta[method]
		local mock, fn = jest.fn(real)
		service.mockHashMapMeta[method] = fn
		return mock, real
	end,

	setGlobalLatency = function(service: any, seconds: number)
		service._globalLatency = seconds
	end,
	setLatencyForRequestType = function(service: any, requestType: string, seconds: number)
		service._latencyByRequestType[requestType] = seconds
	end,
	setRandomLatency = function(service: any, minSeconds: number, maxSeconds: number)
		service._randomLatencyRange = { min = minSeconds, max = maxSeconds }
	end,
	queueError = function(service: any, requestType: string, errorMessage: string, count: number?)
		for _ = 1, count or 1 do
			table.insert(service.queuedErrors[requestType], errorMessage)
		end
	end,
	setErrorRate = function(service: any, requestType: string, rate: number)
		service._errorRates[requestType] = rate
	end,
	simulateThrottling = function(service: any, enabled: boolean)
		service._simulateThrottling = enabled
	end,
	simulateTimeout = function(service: any, enabled: boolean)
		service._simulateTimeout = enabled
	end,
	setRequestBudget = function(service: any, requestType: string, budget: number)
		service._customBudgets[requestType] = budget
	end,
	forceThrottle = function(service: any, requestType: string, duration: number)
		service._forcedThrottles[requestType] = {
			endTime = os.time() + duration,
		}
	end,

	snapshot = function(service: any)
		return HttpService:JSONEncode({
			mockData = service.mockData,
		})
	end,
	restore = function(service: any, snapshot: string)
		local decoded = HttpService:JSONDecode(snapshot)
		service.mockData = decoded.mockData
	end,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="101">
              <Properties>
                <string name="Name">PlayerStore</string>
                <string name="Source"><![CDATA[--[=[
	A PlayerStore wraps a regular Store to provide a more convenient API for working with Player data.
	It automatically converts Players to UserId keys and handles player kicks on data errors.

	```lua
	local playerStore = PlayerStore.create({
		name = "PlayerData",
		template = {
			coins = 0,
			items = {},
		},
		schema = function(data)
			return typeof(data.coins) == "number" and typeof(data.items) == "table",
			"Invalid data format"
		end,
	})

	-- Load data when player joins
	Players.PlayerAdded:Connect(function(player)
		playerStore:loadAsync(player)
	end)

	-- Unload data when player leaves
	Players.PlayerRemoving:Connect(function(player)
		playerStore:unloadAsync(player)
	end)
	```

	@class PlayerStore
]=]

local Players = game:GetService("Players")

local Log = require(script.Parent.Log)
local Promise = require(script.Parent.Promise)
local Store = require(script.Parent.Store)
local Types = require(script.Parent.Types)

type PlayerStoreImpl<T> = {
	__index: PlayerStoreImpl<T>,
	_kickPlayer: (self: PlayerStore<T>, keyOrPlayer: string | Player, message: string) -> (),

	get: (self: PlayerStore<T>, player: Player) -> Promise.TPromise<T>,
	load: (self: PlayerStore<T>, player: Player) -> Promise.Promise,
	unload: (self: PlayerStore<T>, player: Player) -> Promise.Promise,
	update: (
		self: PlayerStore<T>,
		player: Player,
		transformFunction: (data: T) -> boolean
	) -> Promise.TPromise<boolean>,
	updateImmutable: (
		self: PlayerStore<T>,
		player: Player,
		transformFunction: (data: T) -> T | false
	) -> Promise.TPromise<boolean>,
	tx: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> boolean
	) -> Promise.TPromise<boolean>,
	txImmutable: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
	) -> Promise.TPromise<boolean>,
	save: (self: PlayerStore<T>, player: Player) -> Promise.Promise,
	close: (self: PlayerStore<T>) -> Promise.Promise,
	peek: (self: PlayerStore<T>, userId: number) -> T,

	getAsync: (self: PlayerStore<T>, player: Player) -> T,
	loadAsync: (self: PlayerStore<T>, player: Player) -> (),
	unloadAsync: (self: PlayerStore<T>, player: Player) -> (),
	updateAsync: (self: PlayerStore<T>, player: Player, transformFunction: (data: T) -> boolean) -> boolean,
	updateImmutableAsync: (
		self: PlayerStore<T>,
		player: Player,
		transformFunction: (data: T) -> T | false
	) -> boolean,
	txAsync: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> boolean
	) -> (),
	txImmutableAsync: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
	) -> boolean,
	saveAsync: (self: PlayerStore<T>, player: Player) -> (),
	closeAsync: (self: PlayerStore<T>) -> (),
	peekAsync: (self: PlayerStore<T>, userId: number) -> T,
}

type PlayerStoreProps<T> = {
	_store: Store.Store<T>,
}

--[=[
	Configuration for creating a new Store.

	@interface PlayerStoreConfig
	.name string -- The name of the store
	.template T -- The template data for new keys
	.schema (value: any) -> (boolean, string?) -- A function to validate data
	.migrationSteps { MigrationStep }? -- Optional migration steps
	.importLegacyData ((key: string) -> any?)? -- Optional function to import legacy data
	.changedCallbacks { (key: string, newData: T, oldData: T?) -> () }? -- Optional callbacks for data changes
	.logCallback ((logMessage: LogMessage) -> ())? -- Optional callback for log messages
	.memoryStoreService MemoryStoreService? -- Optional MemoryStoreService instance for mocking
	.dataStoreService DataStoreService? -- Optional DataStoreService instance for mocking

	@within PlayerStore
]=]
type PlayerStoreConfig<T> = {
	name: string,
	template: T,
	schema: (value: any) -> (boolean, string?),
	migrationSteps: { Types.MigrationStep }?,
	importLegacyData: ((key: string) -> any?)?,
	changedCallbacks: { (key: string, newData: T, oldData: T?) -> () }?,
	logCallback: ((logMessage: Log.LogMessage) -> ())?,
	memoryStoreService: MemoryStoreService?,
	dataStoreService: DataStoreService?,
}

type PlayerStore<T> = typeof(setmetatable({} :: PlayerStoreProps<T>, {} :: PlayerStoreImpl<T>))

local function getUserIdKey(player: Player): string
	return tostring(player.UserId)
end

local PlayerStore: PlayerStoreImpl<any> = {} :: PlayerStoreImpl<any>
PlayerStore.__index = PlayerStore

--[=[
	Creates a new PlayerStore with the given configuration.
	Configuration is similar to Store.createStore, but automatically adds player kick handling.

	```lua
	local playerStore = PlayerStore.create({
		name = "PlayerData",
		template = { coins = 0 },
		schema = function(data)
			return typeof(data.coins) == "number", "coins must be a number"
		end,

		-- Optional: Runs whenever data changes
		changedCallbacks = {
			function(key, newData, oldData)
				print(key, "changed from", oldData.coins, "to", newData.coins)
			end,
		},
	})
	```

	Players will be automatically kicked with an error message if:
	- Their data fails to load
	- The DataStore lock is lost during their session

	@param config PlayerStoreConfig<T> -- Configuration for the store
	@return PlayerStore<T>
	@within PlayerStore
]=]
local function createPlayerStore<T>(config: PlayerStoreConfig<T>): PlayerStore<T>
	local self: PlayerStore<T>

	local storeConfig: Store.StoreConfig<T> = {
		name = config.name,
		template = config.template,
		schema = config.schema,
		migrationSteps = config.migrationSteps,
		importLegacyData = config.importLegacyData,
		changedCallbacks = config.changedCallbacks,
		logCallback = config.logCallback,
		onLockLost = function(key: string)
			self:_kickPlayer(key, "DataStore lock lost, please rejoin the game.")
		end,
		memoryStoreService = config.memoryStoreService,
		dataStoreService = config.dataStoreService,
	}

	local store = Store.createStore(storeConfig)
	self = setmetatable({ _store = store }, PlayerStore)
	return self
end

--[=[
	Internal helper to kick players when data errors occur.

	@within PlayerStore
	@private
]=]
function PlayerStore:_kickPlayer(keyOrPlayer: string | Player, message: string): ()
	if typeof(keyOrPlayer) ~= "string" then
		keyOrPlayer:Kick(message)
	else
		local player = Players:GetPlayerByUserId(tonumber(keyOrPlayer))
		if player ~= nil then
			player:Kick(message)
		end
	end
end

--[=[
	Gets the current data for the given player.

	```lua
	playerStore:get(player):andThen(function(data)
		print(player.Name, "has", data.coins, "coins")
	end)
	```

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@return Promise<T> -- Resolves with the player's data
	@within PlayerStore
]=]
function PlayerStore:get(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:get(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:get(player):expect()`.

	See [PlayerStore:get]
	@yields
]=]
function PlayerStore:getAsync(player: Player)
	return self:get(player):expect()
end

--[=[
	Loads data for the given player. Must be called before using other methods.

	```lua
	playerStore:load(player):andThen(function()
		print("Data loaded for", player.Name)
	end)
	```

	:::caution
	If loading fails, the player will be kicked from the game.
	:::

	@error "Load already in progress" -- Another load is in progress for this player
	@error "Store is closed" -- The store has been closed
	@return Promise -- Resolves when data is loaded
	@within PlayerStore
]=]
function PlayerStore:load(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:load(userIdKey, { player.UserId }):catch(function(e)
		self:_kickPlayer(player, "DataStore load failed, please rejoin the game.")
		return Promise.reject(e)
	end)
end

--[=[
	Syntactic sugar for `playerStore:load(player):expect()`.

	See [PlayerStore:load]
	@yields
]=]
function PlayerStore:loadAsync(player: Player)
	return self:load(player):expect()
end

--[=[
	Unloads data for the given player.

	```lua
	playerStore:unload(player):andThen(function()
		print("Data unloaded for", player.Name)
	end)
	```

	@error "Store is closed" -- The store has been closed
	@return Promise<boolean> -- Resolves when the update is complete, with a boolean indicating success
	@within PlayerStore
]=]
function PlayerStore:unload(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:unload(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:unload(player):expect()`.

	See [PlayerStore:unload]
	@yields
]=]
function PlayerStore:unloadAsync(player: Player)
	return self:unload(player):expect()
end

--[=[
	Updates data for the given player using a transform function.
	The transform function must return true to commit changes, or false to abort.

	```lua
	playerStore:update(player, function(data)
		if data.coins < 100 then
			data.coins += 50
			return true -- Commit changes
		end
		return false -- Don't commit changes
	end)
	```

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves when the update is complete
	@within PlayerStore
]=]
function PlayerStore:update<T>(player: Player, transformFunction: (data: T) -> boolean)
	local userIdKey = getUserIdKey(player)
	return self._store:update(userIdKey, transformFunction)
end

--[=[
	Syntactic sugar for `playerStore:update(player, transformFunction):expect()`.

	See [PlayerStore:update]
	@yields
]=]
function PlayerStore:updateAsync<T>(player: Player, transformFunction: (data: T) -> boolean)
	return self:update(player, transformFunction):expect()
end

--[=[
	Updates data for the given player using a transform function that does not mutate the original data.
	The transform function must return the new data or false to abort.

	```lua
	playerStore:updateImmutable(player, function(data)
		if data.coins < 100 then
			return { coins = data.coins + 50 } -- Return new data to commit changes
		end
		return false -- Don't commit changes
	end)
	```

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves when the update is complete
	@within PlayerStore
]=]
function PlayerStore:updateImmutable<T>(
	player: Player,
	transformFunction: (data: T) -> T | false
): Promise.TPromise<boolean>
	local userIdKey = getUserIdKey(player)
	return self._store:updateImmutable(userIdKey, transformFunction)
end

--[=[
	Syntactic sugar for `playerStore:updateImmutable(player, transformFunction):expect()`.

	See [PlayerStore:updateImmutable]
	@yields
]=]
function PlayerStore:updateImmutableAsync<T>(player: Player, transformFunction: (data: T) -> T | false)
	return self:updateImmutable(player, transformFunction):expect()
end

--[=[
	Performs a transaction across multiple players' data atomically.
	All players' data must be loaded first. Either all changes apply or none do.

	```lua
	playerStore:tx({player1, player2}, function(state)
		-- Transfer coins between players
		if state[player1].coins >= 100 then
			state[player1].coins -= 100
			state[player2].coins += 100
			return true -- Commit transaction
		end
		return false -- Abort transaction
	end)
	```

	@error "Key not loaded" -- One or more players' data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@within PlayerStore
]=]
function PlayerStore:tx<T>(
	players: { Player },
	transformFunction: (state: { [Player]: T }) -> boolean
): Promise.TPromise<boolean>
	local userIdKeys = table.create(#players)
	local userIdKeyToPlayer = {}
	for i, player in players do
		local key = getUserIdKey(player)
		userIdKeys[i] = key
		userIdKeyToPlayer[key] = player
	end

	local function wrapped(state: { [string]: any }): boolean
		local userIdState = {}
		for key, value in state do
			local player = userIdKeyToPlayer[key]
			userIdState[player] = value
		end

		local success = transformFunction(userIdState)
		if success == false then
			return false
		end

		for key in state do
			state[key] = nil
		end

		for playerVariant, value in userIdState do
			local stringKey = getUserIdKey(playerVariant)
			state[stringKey] = value
		end

		return success
	end

	return self._store:tx(userIdKeys, wrapped)
end

--[=[
	Syntactic sugar for `playerStore:tx(players, transformFunction):expect()`.

	See [PlayerStore:tx]
	@yields
]=]
function PlayerStore:txAsync<T>(players: { Player }, transformFunction: (state: { [Player]: T }) -> boolean)
	return self:tx(players, transformFunction):expect()
end

--[=[
	Performs a transaction across multiple players' data atomically using immutable updates.
	All players' data must be loaded first. Either all changes apply or none do.

	```lua
	playerStore:txImmutable({player1, player2}, function(state)
		-- Transfer coins between players
		if state[player1].coins >= 100 then
			return {
				[player1] = { coins = state[player1].coins - 100 },
				[player2] = { coins = state[player2].coins + 100 },
			} -- Commit transaction with new data
		end
		return false -- Abort transaction
	end)
	```

	@error "Key not loaded" -- One or more players' data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@within PlayerStore
]=]
function PlayerStore:txImmutable<T>(
	players: { Player },
	transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
): Promise.TPromise<boolean>
	local userIdKeys = table.create(#players)
	local userIdKeyToPlayer = {}
	for i, player in players do
		local key = getUserIdKey(player)
		userIdKeys[i] = key
		userIdKeyToPlayer[key] = player
	end

	local function wrapped(state: { [string]: any }): { [string]: any } | false
		local userIdState = {}
		for key, value in state do
			local player = userIdKeyToPlayer[key]
			userIdState[player] = value
		end

		local newData = transformFunction(userIdState)
		if newData == false then
			return false
		end

		for key in state do
			state[key] = nil
		end

		for playerVariant, value in newData :: { [Player]: T } do
			local stringKey = getUserIdKey(playerVariant)
			state[stringKey] = value
		end

		return state
	end

	return self._store:txImmutable(userIdKeys, wrapped)
end

--[=[
	Syntactic sugar for `playerStore:txImmutable(players, transformFunction):expect()`.

	See [PlayerStore:txImmutable]
	@yields
]=]
function PlayerStore:txImmutableAsync<T>(
	players: { Player },
	transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
)
	return self:txImmutable(players, transformFunction):expect()
end

--[=[
	Forces an immediate save of the given player's data.

	:::info
	Data is automatically saved periodically, so manual saves are usually unnecessary.
	:::

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@return Promise -- Resolves when the save is complete
	@within PlayerStore
]=]
function PlayerStore:save(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:save(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:save(player):expect()`.

	See [PlayerStore:save]
	@yields
]=]
function PlayerStore:saveAsync(player: Player)
	return self:save(player):expect()
end

--[=[
	Closes the store and unloads all active sessions.
	The store cannot be used after closing.

	@return Promise -- Resolves when the store is closed
	@within PlayerStore
]=]
function PlayerStore:close()
	return self._store:close()
end

--[=[
	Syntactic sugar for `playerStore:close():expect()`.

	See [PlayerStore:close]
	@yields
]=]
function PlayerStore:closeAsync()
	return self:close():expect()
end

--[=[
	Returns the current data for the given key without loading it into the store.

	```lua
	playerStore:peek(userId):andThen(function(data)
		print("Current coins:", data.coins)
	end)
	```

	@return Promise<T> -- Resolves with the current data
	@within PlayerStore
]=]
function PlayerStore:peek(userId: number)
	local userIdKey = tostring(userId)
	return self._store:peek(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:peek(userId):expect()`.

	See [PlayerStore:peek]
	@yields
]=]
function PlayerStore:peekAsync(userId: number)
	return self:peek(userId):expect()
end

return {
	createPlayerStore = createPlayerStore,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="102">
              <Properties>
                <string name="Name">Promise</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- rbxts_include
local Promise = require(script.Parent.Parent.Parent.Parent:WaitForChild("Promise"))

export type Status = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type Promise = {
	andThen: (
		self: Promise,
		successHandler: (...any) -> ...any,
		failureHandler: ((...any) -> ...any)?
	) -> Promise,
	andThenCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> any,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, ...any),
	awaitStatus: (self: Promise) -> (Status, ...any),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> ...any,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (...any) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

export type TPromise<T... = ...any> = {
	andThen: (self: Promise, successHandler: (T...) -> ...any, failureHandler: ((...any) -> ...any)?) -> Promise,
	andThenCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, T...),
	awaitStatus: (self: Promise) -> (Status, T...),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> T...,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (T...) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

type Signal<T...> = {
	Connect: (self: Signal<T...>, callback: (T...) -> ...any) -> SignalConnection,
}

type SignalConnection = {
	Disconnect: (self: SignalConnection) -> ...any,
	[any]: any,
}

export type ErrorKind = "ExecutionError" | "AlreadyCancelled" | "NotResolvedInTime" | "TimedOut"

type Error = {
	is: (anything: any) -> boolean,
	isKind: (anything: any, kind: ErrorKind) -> boolean,
	Kind: {
		ExecutionError: "ExecutionError",
		AlreadyCancelled: "AlreadyCancelled",
		NotResolvedInTime: "NotResolvedInTime",
		TimedOut: "TimedOut",
	},
}

type PromiseModule = {
	Error: Error,
	Status: {
		Started: Status,
		Resolved: Status,
		Rejected: Status,
		Cancelled: Status,
	},

	all: <T>(promises: { TPromise<T> }) -> TPromise<{ T }>,
	allSettled: <T>(promise: { TPromise<T> }) -> TPromise<{ Status }>,
	any: <T>(promise: { TPromise<T> }) -> TPromise<T>,
	defer: <TReturn...>(
		executor: (
			resolve: (TReturn...) -> (),
			reject: (...any) -> (),
			onCancel: (abortHandler: (() -> ())?) -> boolean
		) -> ()
	) -> TPromise<TReturn...>,
	delay: (seconds: number) -> TPromise<number>,
	each: <T, TReturn>(
		list: { T | TPromise<T> },
		predicate: (value: T, index: number) -> TReturn | TPromise<TReturn>
	) -> TPromise<{ TReturn }>,
	fold: <T, TReturn>(
		list: { T | TPromise<T> },
		reducer: (accumulator: TReturn, value: T, index: number) -> TReturn | TPromise<TReturn>
	) -> TPromise<TReturn>,
	fromEvent: <TReturn...>(
		event: Signal<TReturn...>,
		predicate: ((TReturn...) -> boolean)?
	) -> TPromise<TReturn...>,
	is: (object: any) -> boolean,
	new: <TReturn...>(
		executor: (
			resolve: (TReturn...) -> (),
			reject: (...any) -> (),
			onCancel: (abortHandler: (() -> ())?) -> boolean
		) -> ()
	) -> TPromise<TReturn...>,
	onUnhandledRejection: (callback: (promise: TPromise<any>, ...any) -> ()) -> () -> (),
	promisify: <TArgs..., TReturn...>(callback: (TArgs...) -> TReturn...) -> (TArgs...) -> TPromise<TReturn...>,
	race: <T>(promises: { TPromise<T> }) -> TPromise<T>,
	reject: (...any) -> TPromise<...any>,
	resolve: <TReturn...>(TReturn...) -> TPromise<TReturn...>,
	retry: <TArgs..., TReturn...>(
		callback: (TArgs...) -> TPromise<TReturn...>,
		times: number,
		TArgs...
	) -> TPromise<TReturn...>,
	retryWithDelay: <TArgs..., TReturn...>(
		callback: (TArgs...) -> TPromise<TReturn...>,
		times: number,
		seconds: number,
		TArgs...
	) -> TPromise<TReturn...>,
	some: <T>(promise: { TPromise<T> }, count: number) -> TPromise<{ T }>,
	try: <TArgs..., TReturn...>(callback: (TArgs...) -> TReturn..., TArgs...) -> TPromise<TReturn...>,
}

return (Promise :: any) :: PromiseModule
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="103">
              <Properties>
                <string name="Name">PromiseQueue</string>
                <string name="Source"><![CDATA[--[=[
	@class PromiseQueue
	@private

	Implements a queue that processes asynchronous operations (represented by functions
	returning Promises or synchronous functions) one at a time, ensuring serial execution.

	**Purpose:** Useful for scenarios where operations on a shared resource must not
	run concurrently to prevent race conditions or ensure logical order. For example,
	processing updates to a specific player's data session.

	**Core Logic:**
	- Operations are added to the queue via the `add` method.
	- Each operation is wrapped in a `Promise`.
	- A single processing loop ([PromiseQueue:_processQueue]) runs as long as the queue is not empty.
	- The loop takes the next item, executes its associated function, and waits for
	  its Promise to resolve or reject before moving to the next item.
	- Includes timeout and deadlock detection for individual items.
	- Supports adding an operation atomically across multiple queues ([PromiseQueue:multiQueueAdd]).
]=]

local Log = require(script.Parent.Log)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)

--[=[
	Internal implementation details and methods for the PromiseQueue class.
	@interface PromiseQueueImpl
	@within PromiseQueue
	@private
	.__index PromiseQueueImpl
	.new (params: CreatePromiseQueueParams) -> PromiseQueue
	._processQueue (self: PromiseQueue) -> ()
	._addResumableBlock (queue: PromiseQueue) -> Promise<() -> ()>
	._getLogContext (self: PromiseQueue, item: QueueItem?) -> { [string]: any }
	.add (self: PromiseQueue, callback: () -> ()) -> Promise
	.multiQueueAdd (queues: { PromiseQueue }, callback: () -> ()) -> Promise -- Public static method
]=]
type PromiseQueueImpl = {
	__index: PromiseQueueImpl,
	new: (params: CreatePromiseQueueParams) -> PromiseQueue,
	_processQueue: (self: PromiseQueue) -> (),
	_addResumableBlock: (queue: PromiseQueue) -> Promise.TPromise<() -> ()>,
	_getLogContext: (self: PromiseQueue, item: QueueItem?) -> { [string]: any },
	multiQueueAdd: (queues: { PromiseQueue }, callback: () -> ()) -> Promise.Promise,
	add: (self: PromiseQueue, callback: () -> ()) -> Promise.Promise,
}

--[=[
	Internal properties stored within a PromiseQueue instance.
	@interface PromiseQueueProps
	@within PromiseQueue
	@private
	._queue { QueueItem } -- The actual queue holding items to be processed.
	._logger Log.Logger -- Logger instance for internal logging.
	._totalItemCount number -- Counter for assigning unique IDs to queue items.
]=]
type PromiseQueueProps = {
	_queue: { QueueItem },
	_logger: Log.Logger,
	_totalItemCount: number,
}

--[=[
	Represents a single item within the queue.
	@interface QueueItem
	@within PromiseQueue
	@private
	.id number -- Unique identifier for the item within this queue instance.
	.fn () -> () -- The function to execute for this item. Can be sync or return a Promise.
	.resolve (value: any) -> () -- The resolve function of the Promise returned by `add`.
	.reject (error: any) -> () -- The reject function of the Promise returned by `add`.
	.trace string -- Debug traceback captured when the item was added.
]=]
type QueueItem = {
	id: number,
	fn: () -> (),
	resolve: (value: any) -> (),
	reject: (error: any) -> (),
	trace: string,
}

export type PromiseQueue = typeof(setmetatable({} :: PromiseQueueProps, {} :: PromiseQueueImpl))

local PromiseQueue = {} :: PromiseQueueImpl
PromiseQueue.__index = PromiseQueue

--[=[
	Parameters for creating a new PromiseQueue instance.
	@interface CreatePromiseQueueParams
	@within PromiseQueue
	.logger Log.Logger
]=]
type CreatePromiseQueueParams = {
	logger: Log.Logger,
}

--[=[
	Creates a new PromiseQueue instance.
	@param params -- Configuration parameters.
	@return PromiseQueue -- A new PromiseQueue object.
	@within PromiseQueue
]=]
function PromiseQueue.new(params: CreatePromiseQueueParams): PromiseQueue
	return setmetatable({
		_queue = {},
		_logger = params.logger,
		_totalItemCount = 0,
	}, PromiseQueue) :: PromiseQueue
end

--[=[
	Adds a new operation (callback function) to the end of the queue.

	The callback will be executed only after all preceding items in the queue
	have completed.

	@param callback () -> T -- The function to execute. This function can be synchronous or return a Promise. Its result or error will resolve/reject the Promise returned by this `add` call.
	@return Promise<T> -- A Promise that resolves or rejects with the result or error of the provided `callback` function once it's processed by the queue.
	@within PromiseQueue
]=]
function PromiseQueue:add(callback: () -> ()): Promise.Promise
	local trace = debug.traceback(nil, 2) -- Capture stack trace for debugging slow/failed items.
	return Promise.new(function(resolve, reject, onCancel)
		self._totalItemCount += 1

		-- Create the queue item record.
		local record = {
			id = self._totalItemCount,
			fn = callback,
			resolve = resolve,
			reject = reject,
			trace = trace,
		}
		table.insert(self._queue, record)

		self._logger:log("trace", "added item to queue", self:_getLogContext())

		-- Handle cancellation: if the returned promise is cancelled before processing,
		-- remove the item from the queue.
		onCancel(function()
			local idx = table.find(self._queue, record)
			if idx then
				table.remove(self._queue, idx)
				self._logger:log("trace", "removed cancelled item from queue", self:_getLogContext(record))
			end
		end)

		-- If this is the first item added to an empty queue, start the processing loop.
		if #self._queue == 1 then
			task.spawn(function()
				self:_processQueue()
			end)
		end
	end)
end

--[=[
	Internal function that processes items from the queue sequentially.
	It runs as long as there are items in the queue.
	@within PromiseQueue
	@private
]=]
function PromiseQueue:_processQueue()
	self._logger:log("trace", "processing queue", self:_getLogContext())
	-- Loop continues as long as items exist in the queue.
	while #self._queue > 0 do
		local item = self._queue[1] -- Get the next item from the front.

		-- Set up a warning timer for potential deadlocks or long-running items.
		-- If an item takes longer than 60 seconds, a warning is logged.
		local deadlockWarn = task.delay(60, function()
			local ctx = self:_getLogContext(item)
			ctx.trace = item.trace -- Include original call stack in warning.
			self._logger:log("warn", "queue item taking > 60s", ctx)
		end)

		self._logger:log("trace", "processing queue item", self:_getLogContext(item))
		-- Execute the item's function within a Promise context.
		Promise
			.try(item.fn)
			:timeout(60) -- Apply a 60-second timeout to the item's execution.
			:andThen(
				item.resolve, -- If successful, resolve the original promise returned by `add`.
				function(e) -- If failed (error or timeout)...
					-- Log the failure details.
					local ctx = self:_getLogContext(item)
					ctx.error = e
					ctx.trace = item.trace

					local msg
					if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
						msg = "queue item timed out"
					else
						msg = "queue item failed"
					end
					self._logger:log("debug", msg, ctx)

					-- Reject the original promise with the error and traceback.
					item.reject(`Queue item failed: {e}\nCreated at:\n{item.trace}`)
				end
			)
			:finally(function()
				-- This runs regardless of success or failure.
				self._logger:log("trace", "finished processing queue item", self:_getLogContext(item))

				-- Remove the item *only if* it's still the first item.
				-- This prevents issues if an item was cancelled and removed while processing.
				if self._queue[1] == item then
					table.remove(self._queue, 1)
				end

				-- Cancel the deadlock warning timer as the item has finished.
				task.cancel(deadlockWarn)
			end)
			:await() -- Wait for the item's promise (including timeout/finally) to complete before the loop continues.
	end
	self._logger:log("trace", "finished processing queue", self:_getLogContext())
end

--[=[
	Internal helper function used by `multiQueueAdd`.
	Adds a special "blocking" item to a single queue. This item's function
	returns a Promise that only resolves when an external `resume` function is called.
	`resume` is just a Promise resolver function - calling it unblocks the queue item.

	@param queue -- The PromiseQueue instance to add the block to.
	@return Promise<() -> ()> -- A Promise that resolves with the `resume` function once the block becomes the active item in the queue.
	@within PromiseQueue
	@private
]=]
local function addResumableBlock(queue: PromiseQueue): Promise.TPromise<() -> ()>
	return Promise.new(function(outerResolve)
		-- Add an item whose function returns a promise...
		queue:add(function()
			return Promise.new(function(resume)
				-- ...that resolves the outer promise (`addResumableBlock`'s promise)
				-- with the `resume` function needed to unblock this item.
				outerResolve(resume :: any)
			end)
		end)
	end)
end
PromiseQueue._addResumableBlock = addResumableBlock -- Assign to the metatable for internal use.

--[=[
	Atomically adds a callback function to be executed across multiple queues.

	Ensures that the callback only runs when it has effectively acquired the "lock"
	(become the currently processing item) on *all* specified queues simultaneously.
	This is useful for operations that need to coordinate across multiple resources
	managed by separate queues.

	**Mechanism:**
	1. Uses `_addResumableBlock` to add a blocking item to each queue.
	2. Waits for all these blocking items to become active (i.e., all `_addResumableBlock`
	   promises resolve, returning their `resume` functions).
	3. Once all queues are blocked, executes the provided `callback`.
	4. After the `callback` finishes (successfully or with an error), calls all the
	   `resume` functions to unblock all the queues.

	@param queues -- A table array of PromiseQueue instances to coordinate.
	@param callback -- The function to execute once all queues are ready.
	@return Promise -- A Promise that resolves/rejects with the result/error of the `callback`.
	@within PromiseQueue
]=]
function PromiseQueue.multiQueueAdd(queues: { PromiseQueue }, callback: () -> ()): Promise.Promise
	local trace = debug.traceback(nil, 2)
	return Promise.new(function(resolve, reject)
		-- Add a resumable block to each queue.
		local promises = Tables.map(queues, addResumableBlock)

		-- Wait for all blocks to be added and become active.
		Promise.all(promises):andThen(function(resumes)
			-- All queues are now blocked at our added item. Execute the callback.
			Promise.try(callback)
				:andThen(resolve, function(e) -- Handle callback success/failure
					reject(`multiQueueAdd callback failed: {e}\nCreated at:\n{trace}`)
				end)
				:finally(function()
					-- Unblock all queues regardless of callback outcome.
					for _, resume in resumes do
						resume()
					end
				end)
		end)
	end)
end

--[=[
	Internal helper to generate a context table for logging.
	@param item -- (Optional) The QueueItem currently being processed.
	@return { [string]: any } -- A table containing common context fields like queue length and item ID.
	@within PromiseQueue
	@private
]=]
function PromiseQueue:_getLogContext(item: QueueItem?): { [string]: any }
	return {
		queueLength = #self._queue,
		totalItems = self._totalItemCount,
		itemId = item and item.id,
	}
end

return PromiseQueue
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="104">
              <Properties>
                <string name="Name">Session</string>
                <string name="Source"><![CDATA[--[=[
	Manages the in-memory state and persistence lifecycle for a single data key
	within a Store. A Session represents an active, locked instance of a key's
	data, coordinating data loading, saving, updates, transactions, migrations,
	and cleanup.

	Sessions are created internally by [Store:load] after acquiring a distributed
	lock via the Locks module. They handle:
	- Loading initial data by reading the main record, file shards, and pending
	  transactions, applying migrations, or importing legacy data.
	- Providing access to the current data ([Session:get]).
	- Applying mutations ([Session:update]) safely within a `noYield` context and
	  tracking changes.
	- Saving changes back to DataStores ([Session:save], [Session:updateRecord], [Session:writeRecord]),
	  potentially sharding large data via the Files module.
	- Coordinating multi-key transactions ([Store:tx] interacts with Session state).
	- Automatically saving data periodically ([Session:startAutosaving]).
	- Cleaning up orphaned file shards in the background ([Session:orphanFile]).
	- Gracefully unloading data ([Session:unload]), ensuring final saves and lock release.

	A Session is intrinsically tied to a [Locks.LockHandle]. If the lock is lost,
	the Session becomes 'closed' and unusable, triggering cleanup.

	@class Session
	@private
]=]

local HttpService = game:GetService("HttpService")

local Constants = require(script.Parent.Constants)
local Files = require(script.Parent.Files)
local Locks = require(script.Parent.Locks)
local Log = require(script.Parent.Log)
local Migrations = require(script.Parent.Migrations)
local PromiseQueue = require(script.Parent.PromiseQueue)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local t = require(script.Parent.Parent:WaitForChild("t").lib.ts).t
local Types = require(script.Parent.Types)
local Transactions = require(script.Parent.Transactions)
local dataStoreRetry = require(script.Parent.dataStoreRetry)
local noYield = require(script.Parent.noYield)

--[=[
	Internal type definition for Session methods (used for metatable).

	@interface SessionImpl<T>
	@within Session
	@private
	.__index SessionImpl<T> -- Metatable self-reference.

	-- Static method to load data and create a session
	.load (params: LoadSessionParams<T>) -> Promise<Session<T>>

	-- Internal methods for saving data
	.updateRecord (self: Session<T>) -> Promise<any>
	.orphanFile (self: Session<T>, file: Types.File) -> ()
	.writeRecord (self: Session<T>, txInfo: Types.TxInfo) -> Promise<any>

	-- State checking
	.isSaved (self: Session<T>) -> boolean

	-- Internal state mutation
	.setData (self: Session<T>, data: T) -> ()
	.mutateKey (self: Session<T>, newData: T) -> ()

	-- Autosave management
	.startAutosaving (self: Session<T>) -> ()
	.stopAutosaving (self: Session<T>) -> ()

	-- Public API methods (called via Store)
	.unload (self: Session<T>) -> Promise
	.get (self: Session<T>) -> Promise<T>
	.update (self: Session<T>, transformFunction: (data: T) -> boolean) -> Promise<boolean>
	.save (self: Session<T>) -> Promise
]=]
type SessionImpl<T> = {
	__index: SessionImpl<T>,
	load: (params: LoadSessionParams<T>) -> Promise.TPromise<Session<T>>,
	updateRecord: (self: Session<T>) -> Promise.TPromise<any>,
	orphanFile: (self: Session<T>, file: Types.File) -> (),
	writeRecord: (self: Session<T>, txInfo: Types.TxInfo) -> Promise.TPromise<any>,
	isSaved: (self: Session<T>) -> boolean,
	setData: (self: Session<T>, data: T) -> (),
	mutateKey: (self: Session<T>, newData: T) -> (),
	startAutosaving: (self: Session<T>) -> (),
	stopAutosaving: (self: Session<T>) -> (),
	unload: (self: Session<T>) -> Promise.Promise,
	get: (self: Session<T>) -> Promise.TPromise<T>,
	update: (self: Session<T>, transformFunction: (data: T) -> boolean) -> Promise.TPromise<boolean>,
	updateImmutable: (self: Session<T>, transformFunction: (data: T) -> T | false) -> Promise.TPromise<boolean>,
	save: (self: Session<T>) -> Promise.Promise,
}

--[=[
	Internal state properties of a Session instance.

	@interface SessionProps<T>
	@within Session
	@private
	._cleanupAutosave (() -> ())? -- Function to stop the running autosave loop, if active.

	.key string -- The unique key this session manages.
	.ctx Types.StoreContext<T> -- Shared context from the parent Store.
	.lockHandle Locks.LockHandle -- The active distributed lock handle for this key.

	.userIds { number }? -- User IDs associated with this session (primarily for SetAsync).

	.data T? -- The current, mutable in-memory data.
	.appliedMigrations { string } -- List of migration step names already applied to this data.

	.changeSet { [string]: true } -- Tracks unsaved changes. Keys are unique mutation IDs, value is always true. Cleared on successful save.

	.orphanedFiles { Types.File } -- List of file shards (from previous saves) marked for deletion.
	.currentFile Types.File? -- Reference to the current file structure (potentially sharded) representing the saved state.
	.queue PromiseQueue.PromiseQueue -- PromiseQueue to serialize save/unload/tx operations for this key.
	.txLockPromise Promise? -- A promise used during multi-key transactions (`Store:tx`) to block concurrent `Session:update` calls on this key until the transaction completes.

	.closed boolean -- Flag indicating if the session is closed (e.g., lock lost, unloaded).
	.unloadPromise Promise? -- Promise tracking an ongoing unload operation.

	.keyInfo DataStoreKeyInfo? -- DataStoreKeyInfo obtained during the initial load.

	.logger Log.Logger -- Logger instance specific to this session (includes key).
]=]
type SessionProps<T> = {
	_cleanupAutosave: (() -> ())?,
	key: string,
	ctx: Types.StoreContext<T>,
	lockHandle: Locks.LockHandle,
	userIds: { number }?,
	data: T?,
	appliedMigrations: { string },
	changeSet: { [string]: true },
	orphanedFiles: { Types.File },
	currentFile: Types.File?,
	queue: PromiseQueue.PromiseQueue,
	txLockPromise: Promise.Promise?,
	closed: boolean,
	unloadPromise: Promise.Promise?,
	keyInfo: DataStoreKeyInfo?,
	logger: Log.Logger,
}

--[=[
	Represents an active, locked session for a specific data key.

	@type Session<T> typeof(setmetatable({} :: SessionProps<T>, {} :: SessionImpl<T>))
	@within Session
]=]
export type Session<T> = typeof(setmetatable({} :: SessionProps<T>, {} :: SessionImpl<T>))

--[=[
	Parameters for the static Session.load method.

	@interface LoadSessionParams<T>
	@within Session
	@private
	.key string
	.storeContext Types.StoreContext<T>
	.userIds { number }?
]=]
type LoadSessionParams<T> = {
	key: string,
	storeContext: Types.StoreContext<T>,
	userIds: { number }?,
}
-- Runtime check for LoadSessionParams.
local loadSessionParamsCheck = t.strictInterface({
	key = t.string,
	storeContext = t.any, -- StoreContext is a complex type, using `any` for simplicity
	userIds = t.optional(t.array(t.number)),
})

--[=[
	Parameters for the internal load helper function.

	@interface LoadParams
	@within Session
	@private
	.storeContext Types.StoreContext<any>
	.key string
]=]
export type LoadParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
}

--[=[
	Result structure for the internal load helper function.

	@interface LoadResult
	@within Session
	@private
	.data any
	.appliedMigrations { string }
	.orphanedFiles { Types.File }
	.currentFile Types.File?
	.keyInfo DataStoreKeyInfo?
]=]
export type LoadResult = {
	data: any,
	appliedMigrations: { string },
	orphanedFiles: { Types.File },
	currentFile: Types.File?,
	keyInfo: DataStoreKeyInfo?,
}

--[=[
	Internal helper function to perform the multi-stage loading process for a key.
	This runs *after* the lock has been acquired.

	Steps:
	1. Get the main record from `recordStore`.
	2. Extract metadata (applied migrations, orphaned files).
	3. If a file reference exists, read the file data (potentially from shards via `Files.read`).
	4. If file data contains transaction info (`txInfo`), resolve the transaction state via `Transactions.readTx`.
	5. If no data found yet, attempt to import legacy data via `ctx.importLegacyData`.
	6. If still no data, use the `ctx.template` as the base.
	7. Apply any pending migrations via `Migrations.apply`.
	8. Return the final loaded data and metadata.

	@within Session
	@private
	@param params LoadParams -- Parameters for loading.
	@return Promise<LoadResult> -- Promise resolving with the loaded data and metadata.
]=]
local function load(params: LoadParams): Promise.TPromise<LoadResult>
	local ctx = params.storeContext
	local key = params.key

	local logger = ctx.logger:extend({ method = "load", key = params.key })
	logger:log("trace", `loading key`)

	-- Initialize default metadata
	local appliedMigrations: { string } = Migrations.getStepNames(ctx.migrationSteps)
	local orphanedFiles: { Types.File } = {}
	local currentFile: Types.File?
	local keyInfo: DataStoreKeyInfo?

	-- 1. Get the main record
	return dataStoreRetry(function()
			return ctx.recordStore:GetAsync(key)
		end)
		:andThen(function(record: Types.DataStoreRecord?, _keyInfo: DataStoreKeyInfo?)
			-- 2. Extract metadata
			logger:log("trace", "got record")
			if record == nil then
				record = {} :: Types.DataStoreRecord -- Handle case where key doesn't exist yet
			end
			assert(record, "luau") -- Forcefully narrowing type due to old type solver limitations

			keyInfo = _keyInfo
			if record.appliedMigrations then
				appliedMigrations = record.appliedMigrations
			end

			if record.orphanedFiles then
				orphanedFiles = record.orphanedFiles
			end

			-- 3. Read file data if reference exists
			local file = record.file
			if file then
				if Files.isLargeFile(file) then
					currentFile = file -- Store reference if it's sharded
				end

				logger:log("trace", "reading file", { file = HttpService:JSONEncode(file) })
				local readParams: Files.ReadParams = {
					store = ctx.shardStore,
					file = file,
				}
				return Files.read(readParams)
			end

			logger:log("trace", "no file reference in record")
			return nil :: any -- No file means no TxInfo
		end)
		:andThen(function(txInfo: Types.TxInfo?): Promise.TPromise<any?>
			-- 4. Resolve transaction state if TxInfo exists
			if txInfo then
				logger:log("trace", "got txInfo, resolving transaction", { txInfo = txInfo })

				local readTxParams = {
					store = ctx.txStore,
					txInfo = txInfo,
				}
				return Transactions.readTx(readTxParams)
			end

			logger:log("trace", "no txInfo from file")
			return Promise.resolve(nil) -- No TxInfo means no data from file
		end)
		:andThen(function(data: any?)
			-- 5. Attempt legacy import if no data yet
			if data ~= nil then
				logger:log("trace", "got data from file/transaction")
				return data -- Data found, proceed to migrations
			end

			local importLegacyData = ctx.importLegacyData
			if importLegacyData == nil then
				logger:log("trace", "no data, no importLegacyData function provided")
				return nil -- No data, no import function, proceed to template
			end

			-- Try importing
			logger:log("trace", "no data, attempting to import legacy data")
			local importOk, importResult = pcall(importLegacyData, key)
			if not importOk then
				logger:log("error", "failed to import legacy data", { error = importResult })
				return Promise.reject(`Failed to import legacy data for key {key}: {importResult}`)
			end

			local oldData = importResult
			if oldData == nil then
				logger:log("trace", "legacy import returned nil")
				return nil -- Import returned nothing, proceed to template
			else
				-- Data was imported, assume no migrations have been applied to it
				appliedMigrations = {}
				logger:log("trace", "imported legacy data", { oldData = oldData })
				return oldData -- Imported data found, proceed to migrations
			end
		end)
		:andThen(function(data: any?)
			-- 6. Use template if still no data
			if data == nil then
				logger:log("trace", "no data found, using template")
				data = Tables.copyDeep(ctx.template)
			end
			assert(data, "luau") -- Forcefully narrowing type due to old type solver limitations

			-- 7. Apply migrations
			if #ctx.migrationSteps > 0 then
				logger:log("debug", "applying migrations if necessary")
				local migrationParams: Migrations.ApplyParams = {
					logger = logger:extend({ component = "Migrations" }),
					data = data,
					steps = ctx.migrationSteps,
					appliedMigrations = appliedMigrations,
				}

				return Migrations.apply(migrationParams):andThen(function(result: Migrations.ApplyResult)
					-- Update appliedMigrations list based on migration result
					appliedMigrations = result.appliedMigrations
					logger:log(
						"trace",
						"migrations applied",
						{ data = result.data, appliedMigrations = appliedMigrations }
					)
					return result.data -- Return the potentially migrated data
				end)
			end

			-- No migrations to apply or needed
			logger:log("trace", "data loaded (no migrations run)")
			return data
		end)
		:andThen(function(finalData)
			-- 8. Return final result
			logger:log("trace", "load process complete")
			local loadResult: LoadResult = {
				data = finalData,
				appliedMigrations = appliedMigrations,
				orphanedFiles = orphanedFiles,
				currentFile = currentFile,
				keyInfo = keyInfo,
			}
			return loadResult
		end)
end

local Session: SessionImpl<any> = {} :: SessionImpl<any>
Session.__index = Session

--[=[
	Parameters for the internal createSession function.

	@interface CreateSessionParams
	@within Session
	@private
	.storeContext Types.StoreContext<any>
	.key string
	.lockHandle Locks.LockHandle
	.userIds { number }?
	.appliedMigrations { string }
	.orphanedFiles { Types.File }
	.currentFile Types.File?
	.keyInfo DataStoreKeyInfo?
]=]
type CreateSessionParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
	lockHandle: Locks.LockHandle,
	userIds: { number }?,
	appliedMigrations: { string },
	orphanedFiles: { Types.File },
	currentFile: Types.File?,
	keyInfo: DataStoreKeyInfo?,
}

--[=[
	Internal factory function to create a new Session instance.
	Initializes the session state based on loaded data and acquired lock.

	@within Session
	@private
	@param params CreateSessionParams -- Parameters for session creation.
	@return Session<T> -- The newly created session instance.
]=]
local function createSession<T>(params: CreateSessionParams): Session<T>
	local logger = params.storeContext.logger:extend({ key = params.key })

	-- Create a dedicated queue for this session's save/unload/tx operations
	local queue = PromiseQueue.new({
		logger = logger:extend({ component = "PromiseQueue" }),
	})

	local props: SessionProps<T> = {
		key = params.key,
		ctx = params.storeContext,
		lockHandle = params.lockHandle,

		userIds = params.userIds,

		data = nil, -- Initial data set later by mutateKey
		appliedMigrations = params.appliedMigrations,

		changeSet = {}, -- Starts with no unsaved changes

		orphanedFiles = params.orphanedFiles,
		currentFile = params.currentFile,

		queue = queue,
		txLockPromise = nil, -- Not initially locked by a transaction

		closed = false, -- Starts open
		unloadPromise = nil, -- Not initially unloading

		keyInfo = params.keyInfo,
		logger = logger,
		_cleanupAutosave = nil, -- Autosave not started yet
	}

	return setmetatable(props, Session) :: Session<T>
end

--[=[
	Static method to load data and create a Session. This is the main entry point
	called by `Store:load`.

	Steps:
	1. Acquire the distributed lock for the key using `Locks.acquireLock`.
	2. If lock acquired, call the internal `load` helper function.
	3. If load successful and lock still held, create the Session instance using `createSession`.
	4. Set up lock loss handling (`lockHandle.onLockLost`) to close the session.
	5. Initiate background cleanup for any orphaned files found during load.
	6. Set the initial data in the session using `mutateKey`.
	7. Return the created Session.
	8. Ensure the lock is released if loading fails at any stage.

	@within Session
	@param params LoadSessionParams<T> -- Parameters for loading the session.
	@return Promise<Session<T>> -- Resolves with the new Session instance.
	@error "Lock was lost while loading key"
	@error string -- Propagates errors from `Locks.acquireLock` or internal `load`.
]=]
function Session.load<T>(params: LoadSessionParams<T>): Promise.TPromise<Session<T>>
	assert(loadSessionParamsCheck(params))

	local ctx = params.storeContext
	local logger = ctx.logger:extend({ method = "load", key = params.key })

	-- 1. Acquire lock
	local acquireLockParams: Locks.AcquireLockParams = {
		storeContext = ctx,
		key = params.key,
		duration = Constants.LOCK_DURATION_SECONDS,
		refreshInterval = Constants.LOCK_REFRESH_INTERVAL_SECONDS,
	}

	return Locks.acquireLock(acquireLockParams):andThen(function(lockHandle)
		-- Lock acquired, proceed to load data
		local loadParams: LoadParams = {
			storeContext = ctx,
			key = params.key,
		}

		-- 2. Call internal load helper
		return load(loadParams):andThen(function(loadResult: LoadResult)
			-- 3. Check lock still held after potentially long load operation
			if not lockHandle.isLocked() then
				logger:log("error", "lock was lost while loading key")
				-- Lock release handled by the `finally` block below
				return Promise.reject("Lock was lost while loading key")
			end

			-- 4. Create Session instance
			local createParams: CreateSessionParams = {
				storeContext = ctx,
				key = params.key,
				lockHandle = lockHandle,
				userIds = params.userIds,
				appliedMigrations = loadResult.appliedMigrations,
				orphanedFiles = loadResult.orphanedFiles,
				currentFile = loadResult.currentFile,
				keyInfo = loadResult.keyInfo,
			}
			local session = createSession(createParams)

			-- 5. Set up lock loss handler
			lockHandle.onLockLost(function()
				logger:log("warn", "lock was lost, closing session and stopping autosave")
				session.closed = true
				session:stopAutosaving()
				-- Mark unload as immediately resolved if lock is lost
				session.unloadPromise = Promise.resolve()
				-- Trigger Store's onLockLost callback if provided
				if ctx.onLockLost then
					ctx.onLockLost(params.key)
				end
			end)

			-- 6. Initiate orphan cleanup for files found during load
			for _, file in loadResult.orphanedFiles do
				session:orphanFile(file)
			end

			-- 7. Set initial data (triggers changed callbacks if enabled)
			logger:log("trace", "loaded key, setting initial data", { data = loadResult.data })
			session:mutateKey(loadResult.data)

			-- 8. Return the fully initialized session
			return session :: any
		end):finally(function(status): ()
			-- 9. Ensure lock release on failure
			-- This runs if `load(loadParams)` or the subsequent steps reject, or if the load was canceled.
			if status ~= Promise.Status.Resolved then
				logger:log("trace", "failed to load key, releasing lock")
				-- Attempt to release the lock, but don't block or fail further if release fails.
				lockHandle.release():catch(function(e)
					logger:log("warn", "failed to release lock after load failure", { error = e })
				end)
			end
		end)
	end)
end

--[=[
	Internal method to trigger a save operation if there are pending changes.
	This is called by `Session:save` and `Session:unload`.

	@within Session
	@private
	@return Promise -- Resolves when the save is complete (or immediately if no changes).
]=]
function Session:updateRecord(): Promise.TPromise<any>
	local logger = self.logger:extend({ method = "updateRecord" })
	logger:log("trace", "updateRecord called")

	-- Check if there are any unsaved changes
	if self:isSaved() then
		logger:log("trace", "no changes detected, skipping write")
		return Promise.resolve() -- Nothing to save
	end

	-- Prepare the data structure to be saved. TxInfo is the harness even if there's no transaction.
	local txInfo: Types.TxInfo = { committedData = self.data }

	logger:log("trace", "writing record via writeRecord", { txInfo = txInfo })
	-- Delegate the actual writing process to writeRecord
	return self:writeRecord(txInfo)
end

--[=[
	Marks a file (usually an older, sharded file) for deletion and starts a
	background task to remove its shards from the `shardStore`.

	Handles DataStore budget limitations by waiting if the budget is too low.

	@within Session
	@private
	@param file Types.File -- The file metadata (must include `shard` and `count` if sharded).
]=]
function Session:orphanFile(file: Types.File): ()
	-- Only sharded files need cleanup
	if not Files.isLargeFile(file) then
		return
	end
	local logger = self.ctx.logger:extend({ method = "orphanFile", key = self.key, shard = file.shard })

	logger:log("trace", "adding file to orphaned list", { file = file })
	-- Add to list immediately so `writeRecord` includes it if it runs concurrently.
	table.insert(self.orphanedFiles, file)

	-- Start background cleanup task
	task.spawn(function()
		-- Wait for sufficient DataStore budget before proceeding
		-- RemoveAsync uses the SetIncrementAsync budget.
		while true do
			local minBudget = 100 -- Arbitrary minimum budget threshold
			local curBudget =
				self.ctx.dataStoreService:GetRequestBudgetForRequestType(Enum.DataStoreRequestType.SetIncrementAsync)
			if curBudget < minBudget then
				logger:log("debug", "insufficient budget for orphan cleanup, waiting", {
					curBudget = curBudget,
					minBudget = minBudget,
				})
				task.wait(1) -- Wait and retry
			else
				break -- Budget sufficient
			end
		end

		logger:log("debug", "sufficient budget, processing orphaned file")

		-- Create promises to remove each shard
		local promises = {}
		for i = 1, file.count do
			logger:log("trace", `Queueing removal of shard {i} of {file.count}`)
			table.insert(
				promises,
				dataStoreRetry(function()
					-- Construct shard key and remove it
					return self.ctx.shardStore:RemoveAsync(`{file.shard}-{i}`)
				end)
			)
		end

		-- Wait for all shard removals to complete
		Promise.all(promises)
			:andThen(function()
				logger:log("trace", "successfully removed all shards for orphaned file")
				-- Remove the file from the session's orphaned list now that it's cleaned up.
				for i, otherFile in self.orphanedFiles do
					if Tables.equalsDeep(file, otherFile) then
						table.remove(self.orphanedFiles, i)
						break
					end
				end
			end)
			:catch(function(err)
				-- Log error but don't retry indefinitely. The file remains in orphanedFiles.
				-- Subsequent removals on already removed keys are idempotent.
				logger:log("error", `failed to remove shards for orphaned file: {err}`)
			end)
			:finally(function()
				logger:log("trace", "finished processing orphaned file task")
			end)
	end)
end

--[=[
	Core internal method responsible for writing the current session data to DataStores.

	Steps:
	1. Write the data (as `txInfo`) to potentially multiple shards using `Files.write`.
	2. If sharding fails, mark the failed shards as orphaned and reject.
	3. If file write succeeds, check if the session lock is still held.
	4. If lock lost, mark the newly written file as orphaned and reject.
	5. Prepare the main record (`DataStoreRecord`) containing metadata (migrations,
	   new file reference, list of files now orphaned by this save).
	6. Write the main record to the `recordStore` using SetAsync.
	7. If record write succeeds:
		a. Mark the *previous* `currentFile` (if any) as orphaned using `orphanFile`.
		b. Update `self.currentFile` to the newly written file reference.
		c. Return the written record.
	8. If record write fails, mark the newly written file as orphaned and reject.

	@within Session
	@private
	@param txInfo Types.TxInfo -- The data payload to write (contains `committedData`).
	@return Promise<Types.DataStoreRecord> -- Resolves with the written record on success.
	@error "lock was lost while writing file"
	@error string -- Propagates errors from `Files.write` or `SetAsync`.
]=]
function Session:writeRecord(txInfo: Types.TxInfo): Promise.TPromise<Types.DataStoreRecord>
	local logger = self.logger:extend({ method = "writeRecord" })
	logger:log("trace", "writeRecord called")

	-- 1. Write data to file (potentially sharded)
	local writeParams: Files.WriteParams = {
		store = self.ctx.shardStore,
		data = txInfo,
		maxShardSize = Constants.MAX_CHUNK_SIZE,
		key = self.key,
		userIds = self.userIds,
	}
	logger:log("trace", "calling Files.write", { writeParams = writeParams })

	return Files.write(writeParams)
		:catch(function(err: Files.WriteError)
			-- 2. Handle file write failure
			logger:log("error", "Files.write failed", { error = err.error })
			-- Mark the potentially partially written shards for cleanup
			self:orphanFile(err.file)
			return Promise.reject(err.error)
		end)
		:andThen(function(file: Types.File)
			-- File write successful
			logger:log("trace", "Files.write succeeded", { file = file })

			-- 3. Check lock status *after* potentially long file write
			if not self.lockHandle.isLocked() then
				logger:log("error", "lock was lost while writing file")
				-- Mark the newly created file/shards for cleanup as they are now unreachable
				self:orphanFile(file)
				return Promise.reject("lock was lost while writing file")
			end

			-- 5. Prepare the main record
			-- Clone orphanedFiles list at this point to avoid race conditions with background cleanup.
			local stagedOrphanedFiles = table.clone(self.orphanedFiles)
			-- Add the file that *this* save is replacing to the list of orphans for this record.
			if self.currentFile then
				table.insert(stagedOrphanedFiles, self.currentFile)
			end

			local record: Types.DataStoreRecord = {
				appliedMigrations = self.appliedMigrations,
				file = file, -- Reference to the file structure just written
				orphanedFiles = stagedOrphanedFiles,
			}

			-- 6. Write the main record
			logger:log("trace", "writing main record", { record = record })
			return dataStoreRetry(function()
					return self.ctx.recordStore:SetAsync(self.key, record, self.userIds)
				end)
				:andThen(function()
					-- 7. Record write successful
					logger:log("trace", "main record written successfully")

					-- a. Orphan the previous file now that the record points to the new one
					if self.currentFile then
						self:orphanFile(self.currentFile)
					end
					-- b. Update session state to point to the new file
					self.currentFile = if Files.isLargeFile(file) then file else nil

					-- c. Return the record written
					return record
				end)
				:catch(function(err)
					-- 8. Handle record write failure
					logger:log("error", "failed to write main record", { error = err })
					-- Mark the file/shards created in step 1 for cleanup as the record update failed.
					self:orphanFile(file)
					return Promise.reject(err)
				end)
		end)
end

--[=[
	Checks if the session has any unsaved changes.

	@within Session
	@return boolean -- True if there are no unsaved changes, false otherwise.
]=]
function Session:isSaved(): boolean
	-- The changeSet is empty if and only if `next` returns nil.
	return next(self.changeSet) == nil
end

--[=[
	Internal method to update the session's in-memory data state.
	Marks the session as having unsaved changes and updates the data.

	@within Session
	@private
	@param data any -- The new data value.
]=]
function Session:setData(data: any): ()
	-- Generate a unique ID for this mutation and add it to the changeSet.
	local mutationId = HttpService:GenerateGUID(false)
	self.changeSet[mutationId] = true
	-- Freeze and update the data reference.
	Tables.freezeDeep(data)
	self.data = data
end

--[=[
	Internal method called after data has been changed (either initially loaded or via `update`).
	Updates the session state (`setData`) and triggers any configured `changedCallbacks`.

	@within Session
	@private
	@param newData any -- The new data value.
]=]
function Session:mutateKey(newData: any): ()
	local oldData = self.data -- Store reference to previous data

	-- Update internal data (sets .data and marks changeSet)
	self:setData(newData)

	-- Trigger change callbacks asynchronously
	for _, callback in self.ctx.changedCallbacks do
		task.spawn(callback, self.key, self.data, oldData)
	end
end

--[=[
	Starts the background autosave loop for this session.
	Does nothing if already started or if the session is closed.

	@within Session
]=]
function Session:startAutosaving(): ()
	local logger = self.logger:extend({ method = "startAutosaving" })

	if self._cleanupAutosave then
		logger:log("warn", "autosave already started")
		return
	end
	if self.closed then
		logger:log("warn", "Session is closed, not starting autosave")
		return
	end

	logger:log("trace", "starting autosave loop")
	local stop = false -- Flag to signal loop termination

	-- Spawn the loop in a separate thread
	task.spawn(function()
		while true do
			-- Wait for the configured interval
			-- This is at the top of the loop to ensure the first wait is immediate - we just loaded the session.
			task.wait(Constants.AUTOSAVE_INTERVAL_SECONDS)
			-- Check if stopped or closed during wait
			if self.closed or stop then
				logger:log("trace", "autosave loop stopping", { closed = self.closed, stop = stop })
				break
			end

			-- Attempt to save any pending changes
			logger:log("trace", "autosave triggered")
			local ok, err = self:save():await()
			if not ok then
				-- Log error but continue the loop
				logger:log("warn", "failed to autosave key", { error = err })
			else
				logger:log("trace", "autosave completed successfully")
			end
		end
	end)

	-- Store the cleanup function to stop the loop
	self._cleanupAutosave = function()
		logger:log("trace", "cleanup function called, signaling autosave loop to stop")
		stop = true
		self._cleanupAutosave = nil -- Prevent multiple calls
	end
end

--[=[
	Stops the background autosave loop if it's running.

	@within Session
]=]
function Session:stopAutosaving(): ()
	if self._cleanupAutosave then
		self.logger:log("trace", "stopping autosave loop")
		self._cleanupAutosave()
	else
		self.logger:log("trace", "autosave loop not running or already stopped")
	end
end

--[=[
	Initiates the graceful shutdown process for the session.
	Stops autosaving, queues a final save operation, and releases the lock.

	@within Session
	@return Promise -- Resolves when the unload process is complete.
]=]
function Session:unload(): Promise.Promise
	local logger = self.logger:extend({ method = "unload" })
	logger:log("trace", "unload called")

	-- If unload is already in progress, return the existing promise
	if self.unloadPromise then
		logger:log("trace", "unload already in progress, returning existing promise")
		return self.unloadPromise
	end

	-- Mark session as closed immediately
	self.closed = true
	-- Stop the autosave loop
	self:stopAutosaving()

	logger:log("trace", "queueing final save and lock release")
	-- Add the final operations to the session's queue to ensure serialization
	self.unloadPromise = self
		.queue
		:add(function()
			-- Perform a final save attempt if there are changes
			logger:log("trace", "performing final updateRecord before unloading")
			return self:updateRecord()
		end)
		:andThenReturn(nil) -- Discard result of updateRecord
		:finally(function()
			-- This block runs regardless of whether the final save succeeded or failed
			logger:log("trace", "releasing lock as part of unload")
			-- Attempt to release the lock, logging any errors but not failing unload
			return self.lockHandle.release():catch(function(e)
				logger:log("warn", "failed to release lock during unload", { error = e })
			end)
		end)

	return self.unloadPromise :: any
end

--[=[
	Gets the current data for the session. Value returned is deep frozen to prevent modification.

	@within Session
	@return Promise<T> -- Resolves immediately with the data.
]=]
function Session:get<T>(): Promise.TPromise<T>
	return Promise.resolve(self.data) :: any
end

-- Internal function to encapsulate shared logic for update and updateImmutable.
local function updateInternal(
	self: Session<any>,
	transformFunction: (data: any) -> any | false,
	immutable: boolean,
	logger: Log.Logger
): Promise.TPromise<boolean>
	-- Use Promise.new to handle potential waits for txLockPromise
	return Promise.new(function(resolve, reject)
		-- Wait if a multi-key transaction is currently holding the lock on this session
		while self.txLockPromise ~= nil do
			logger:log("trace", "waiting for txLockPromise to resolve")
			self.txLockPromise:await()
			-- Re-check if closed after waiting, as lock loss could occur during tx
			if self.closed then
				logger:log("warn", "Session closed while waiting for txLockPromise, rejecting update")
				return reject("Session is closed")
			end
		end
		logger:log("trace", `txLockPromise resolved or was nil, proceeding with update`)

		-- Store a reference to our current data - we'll need this later to
		-- check if the data changed at all
		local currentData = self.data

		local nextData
		if immutable then
			-- If immutable is true, we'll pass in `self.data` (which is frozen)
			-- and expect to get a copy-on-write result from `transformFunction`
			nextData = self.data
		else
			-- If immutable is false, we allow the transform to modify the data
			-- directly, so we need a deep copy in case we want to abandon the
			-- changes
			nextData = Tables.copyDeep(self.data)
		end

		-- Execute the transform function safely using `noYield`
		local transformOk, result = pcall(noYield, transformFunction, nextData :: any)
		if not transformOk then
			logger:log("error", "transformFunction errored", { error = result })
			return reject(`transformFunction failed: {result}`)
		end

		-- Check the return value of the transform function
		if immutable == false then
			-- If immutable is false, we expect the transform to return a boolean
			if typeof(result) ~= "boolean" then
				logger:log("error", "transformFunction did not return a boolean")
				return reject("transformFunction must return a boolean")
			end
		else
			-- If immutable is true, we expect the transform to return a new copy of data or false
			if typeof(result) ~= "table" and result ~= false then
				logger:log("error", "transformFunction returned a boolean when it should return data or false")
				return reject("transformFunction must return data or false")
			end
		end

		-- If transform returned false, abort the update
		if result == false then
			logger:log("trace", "transformFunction returned false, update aborted")
			return resolve(false)
		end

		if immutable then
			-- If immutable is true, we expect the transform to return a new
			-- copy of data
			nextData = result :: any
		end

		-- Validate the modified data against the schema
		local schemaOk, err = self.ctx.schema(nextData :: any)
		if not schemaOk then
			logger:log("error", "schema validation failed after transform", { error = err })
			return reject(`Store:update schema validation failed: {err}`)
		end

		-- Ensure the new data is frozen
		Tables.freezeDeep(nextData :: any)

		-- Check if the data actually changed
		if Tables.equalsDeep(nextData :: any, currentData :: any) then
			logger:log("trace", "transform resulted in no data change, resolving true")
			return resolve(true) -- Considered successful, but data remains same
		end

		if immutable == false then
			nextData = Tables.reconcileDeep(currentData :: any, nextData :: any)
		end

		-- Data changed and is valid, apply the mutation
		self:mutateKey(nextData)

		logger:log("trace", "update applied successfully")

		-- Resolve indicating changes were committed
		return resolve(true)
	end)
end

--[=[
	Applies updates to the session's data via a transform function.
	Ensures the transform runs without yielding and validates the result against the schema.
	Allows you to directly mutate the data in-place.

	@within Session
	@param transformFunction (data: T) -> boolean -- Function to modify data. Must return `true` to commit, `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if changes were committed, `false` if aborted by the transform.
	@error "Session is closed"
	@error "transformFunction failed: ..." -- If the transform function errors.
	@error "transformFunction must return a boolean"
	@error "Store:update schema validation failed: ..." -- If the modified data fails schema validation.
]=]
function Session:update<T>(transformFunction: (data: T) -> boolean): Promise.TPromise<boolean>
	assert(t.callback(transformFunction))

	local logger = self.logger:extend({ method = "update" })
	logger:log("trace", "update called")

	-- Reject if session is closed
	if self.closed then
		logger:log("warn", "Session is closed, rejecting update")
		return Promise.reject("Session is closed")
	end

	return updateInternal(self, transformFunction, false, logger)
end

--[=[
	Applies updates to the session's data via a transform function.
	Ensures the transform runs without yielding and validates the result against the schema.
	Requires the use of copy-on-write semantics in transformFunction, where
	the data is not directly mutated but instead a new copy is returned.

	@within Session
	@param transformFunction (data: T) -> T | false -- Function to modify data. Must return a new copy of the data with changes to commit changes, or `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if changes were committed, `false` if aborted by the transform.
	@error "Session is closed"
	@error "transformFunction failed: ..." -- If the transform function errors.
	@error "transformFunction must return a boolean"
	@error "Store:update schema validation failed: ..." -- If the modified data fails schema validation.
]=]
function Session:updateImmutable<T>(transformFunction: (data: T) -> T | false): Promise.TPromise<boolean>
	assert(t.callback(transformFunction))

	local logger = self.logger:extend({ method = "updateImmutable" })
	logger:log("trace", "updateImmutable called")

	-- Reject if session is closed
	if self.closed then
		logger:log("warn", "Session is closed, rejecting update")
		return Promise.reject("Session is closed")
	end

	return updateInternal(self, transformFunction, true, logger)
end

--[=[
	Queues a save operation for the current session state if changes are pending.
	Uses the session's PromiseQueue to serialize saves.

	@within Session
	@return Promise -- Resolves when the save operation completes (or immediately if no changes).
	@error "Session is closed"
]=]
function Session:save(): Promise.Promise
	local logger = self.logger:extend({ method = "save" })
	logger:log("trace", "save called")

	-- Reject if session is closed
	if self.closed then
		logger:log("warn", "Session is closed, rejecting save")
		return Promise.reject("Session is closed")
	end
	-- If no changes, resolve immediately
	if self:isSaved() then
		logger:log("trace", "no changes pending, resolving save immediately")
		return Promise.resolve()
	end

	-- Capture the current changeSet IDs at the time save was called
	local changesToSave = table.clone(self.changeSet)

	logger:log("trace", "queueing save operation")
	-- Add the save logic to the session's queue
	return self.queue:add(function()
		logger:log("trace", "save task running from queue")

		-- Check if the changes captured earlier (`changesToSave`) have already
		-- been saved by a *different* save task that ran before this one.
		local changesWereAlreadySaved = true
		for id in self.changeSet do -- Check the *current* changeSet
			if changesToSave[id] then -- Is an ID from *our* captured set still present?
				changesWereAlreadySaved = false -- At least one change is still pending, we need to save
				break
			end
		end

		if changesWereAlreadySaved then
			logger:log("trace", "changes were already saved by another task, skipping redundant save")
			return Promise.resolve() -- No need to save again
		end

		-- Capture the *current* changeSet again, as more changes might have occurred
		-- while this task was waiting in the queue.
		local currentChanges = table.clone(self.changeSet)

		logger:log("trace", "saving current changes", { changes = currentChanges })
		-- Perform the actual save via updateRecord
		return self:updateRecord():andThen(function()
			-- Save successful, remove the saved change IDs from the session's changeSet
			for id in currentChanges do
				self.changeSet[id] = nil
			end
			logger:log("trace", "changes saved successfully, updated changeSet", { latestChangeSet = self.changeSet })
		end)
		-- Errors from updateRecord will propagate through the queue's promise
	end)
end

return Session
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="105">
              <Properties>
                <string name="Name">Store</string>
                <string name="Source"><![CDATA[--[=[
	@class Store
	@private

	Coordinates Sessions and provides a safe, high-level API for interacting with
	persistent data stored in Roblox DataStores and MemoryStores.

	**Core Responsibilities:**
	- Manages the lifecycle of `Session` objects for individual data keys (e.g., player IDs).
	- Provides methods for loading, reading (`get`), updating (`update`), and saving data.
	- Implements atomic multi-key transactions (`tx`).
	- Handles data validation, migrations, and optional legacy data import.
	- Abstracts away underlying complexities like data sharding (`Files`), distributed
	  locking (`Locks`), and transaction coordination (`Transactions`).
	- Integrates with a configurable logging system (`Log`).

	**Usage Example:**
	```lua
	local store = Store.createStore({
		name = "PlayerData",
		template = {
			coins = 0,
			items = {},
		},
		schema = function(data)
			return typeof(data.coins) == "number" and typeof(data.items) == "table",
			"Invalid data format"
		end,
		-- ... other config options
	})

	-- Load data for a player
	store:load("player_1"):andThen(function()
		-- Get current data
		return store:get("player_1")
	end):andThen(function(data)
		print(data.coins) -- 0

		-- Update data
		return store:update("player_1", function(data)
			data.coins += 100
			return true -- Must return true to commit changes
		end)
	end)
	```
]=]

local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")
local MemoryStoreService = game:GetService("MemoryStoreService")
local RunService = game:GetService("RunService")

local Constants = require(script.Parent.Constants)
local Files = require(script.Parent.Files)
local JsonPatch = require(script.Parent.JsonPatch)
local Locks = require(script.Parent.Locks)
local Session = require(script.Parent.Session)
local Log = require(script.Parent.Log)
local MockDataStoreService = require(script.Parent.MockDataStoreService)
local MockMemoryStoreService = require(script.Parent.MockMemoryStoreService)
local PromiseQueue = require(script.Parent.PromiseQueue)
local Transactions = require(script.Parent.Transactions)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local Types = require(script.Parent.Types)
local dataStoreRetry = require(script.Parent.dataStoreRetry)
local noYield = require(script.Parent.noYield)
local t = require(script.Parent.Parent:WaitForChild("t").lib.ts).t

--[=[
	Configuration options for creating a new Store instance using `createStore`.

	@interface StoreConfig
	@within Store
	.name string -- A unique name for this store (e.g., "PlayerDataProd"). Used for logging and deriving DataStore/MemoryStore keys.

	.template T -- A deep copyable Luau table/value representing the default state for a new key.

	.schema (value: any) -> (boolean, string?) -- A validation function (e.g., created with `t`) that checks if data conforms to the expected structure. Returns `true` if valid, or `false` and an error message if invalid.

	.migrationSteps {Types.MigrationStep}? -- An optional ordered list of migration steps to apply to data loaded from the DataStore if its schema is older than the current version. See `Migrations.luau`.

	.importLegacyData ((key: string) -> any?)? -- An optional function to load data from a different, legacy storage system when a key is accessed for the first time and doesn't exist in this store.

	.dataStoreService DataStoreService? -- An optional override for the Roblox DataStoreService. Useful for testing or custom storage implementations. Defaults to `game:GetService("DataStoreService")`.

	.memoryStoreService MemoryStoreService? -- An optional override for the Roblox MemoryStoreService. Useful for testing. Defaults to `game:GetService("MemoryStoreService")`.

	.useMock boolean? -- If true (and running in Studio), uses mock in-memory implementations of DataStoreService and MemoryStoreService instead of the actual Roblox services. Useful for testing in a controlled environment. Defaults to `false`.

	.changedCallbacks { (key: string, newData: T, oldData: T?) -> () }? -- An optional list of functions called *after* data for a key has been successfully updated. Provides the key, the new data state, and the previous data state (if available).

	.logCallback ((logMessage: Log.LogMessage) -> ())? -- A function to receive log messages generated by this Store instance and its components. If omitted, logs are discarded. See [Log].

	.onLockLost ((key: string) -> ())? -- An optional callback function triggered if the distributed lock for a key's session is lost unexpectedly (e.g., due to expiration or external interference). This usually indicates the session is no longer safe to use.
]=]
export type StoreConfig<T> = {
	name: string,
	template: T,
	schema: (value: any) -> (boolean, string?),
	migrationSteps: { Types.MigrationStep }?,
	importLegacyData: ((key: string) -> any?)?,
	dataStoreService: DataStoreService?,
	memoryStoreService: MemoryStoreService?,
	changedCallbacks: { (key: string, newData: T, oldData: T?) -> () }?,
	logCallback: ((logMessage: Log.LogMessage) -> ())?,
	onLockLost: ((key: string) -> ())?,
	useMock: boolean?,
}
local storeConfigCheck = t.strictInterface({
	name = t.string,
	template = t.any,
	schema = t.callback,
	migrationSteps = t.optional(t.array(t.strictInterface({
		name = t.string,
		apply = t.callback,
	}))),
	importLegacyData = t.optional(t.callback),
	dataStoreService = t.optional(t.any),
	memoryStoreService = t.optional(t.any),
	changedCallbacks = t.optional(t.array(t.callback)),
	logCallback = t.optional(t.callback),
	onLockLost = t.optional(t.callback),
	useMock = t.optional(t.boolean),
})

-- Parameters for the listVersions method. Mirrors DataStore:ListVersionsAsync parameters.
type ListVersionParams = {
	key: string,
	sortDirection: Enum.SortDirection?,
	minDate: number?,
	maxDate: number?,
	pageSize: number?,
}

type StoreImpl<T> = {
	__index: StoreImpl<T>,

	-- Internal helper methods
	_withSession: (self: Store<T>, key: string, callback: (session: Session.Session<any>) -> ()) -> Promise.Promise,
	_getKeyInfo: (self: Store<T>, key: string) -> Promise.TPromise<DataStoreKeyInfo?>,

	-- Core public API (Promise-based)
	load: (self: Store<T>, key: string, userIds: { number }?) -> Promise.Promise,
	unload: (self: Store<T>, key: string) -> Promise.Promise,
	get: (self: Store<T>, key: string) -> Promise.TPromise<T>,
	update: (self: Store<T>, key: string, transformFunction: (data: T) -> boolean) -> Promise.TPromise<boolean>,
	updateImmutable: (
		self: Store<T>,
		key: string,
		transformFunction: (data: T) -> T | false
	) -> Promise.TPromise<boolean>,
	tx: (
		self: Store<T>,
		keys: { string },
		transformFunction: (state: { [string]: T }) -> boolean
	) -> Promise.TPromise<boolean>,
	txImmutable: (
		self: Store<T>,
		keys: { string },
		transformFunction: (state: { [string]: T }) -> { [string]: T } | false
	) -> Promise.TPromise<boolean>,
	save: (self: Store<T>, key: string) -> Promise.Promise,
	close: (self: Store<T>) -> Promise.Promise,

	-- Utility/Inspection API (Promise-based)
	peek: (self: Store<T>, key: string) -> Promise.TPromise<T?>,
	probeLockActive: (self: Store<T>, key: string) -> Promise.TPromise<boolean>,
	listVersions: (self: Store<T>, params: ListVersionParams) -> Promise.TPromise<DataStoreVersionPages>,
	readVersion: (self: Store<T>, key: string, version: string) -> Promise.TPromise<T, DataStoreKeyInfo>,

	-- Core public API (Async/Await syntactic sugar)
	loadAsync: (self: Store<T>, key: string, userIds: { number }?) -> (),
	unloadAsync: (self: Store<T>, key: string) -> (),
	getAsync: (self: Store<T>, key: string) -> T,
	updateAsync: (self: Store<T>, key: string, transformFunction: (data: T) -> boolean) -> boolean,
	updateImmutableAsync: (self: Store<T>, key: string, transformFunction: (data: T) -> T | false) -> boolean,
	txAsync: (self: Store<T>, keys: { string }, transformFunction: (state: { [string]: T }) -> boolean) -> (),
	txImmutableAsync: (
		self: Store<T>,
		keys: { string },
		transformFunction: (state: { [string]: T }) -> T | false
	) -> boolean,
	saveAsync: (self: Store<T>, key: string) -> (),
	closeAsync: (self: Store<T>) -> (),

	-- Utility/Inspection API (Async/Await syntactic sugar)
	peekAsync: (self: Store<T>, key: string) -> T?,
	probeLockActiveAsync: (self: Store<T>, key: string) -> boolean,
	listVersionsAsync: (self: Store<T>, params: ListVersionParams) -> DataStoreVersionPages,
	readVersionAsync: (self: Store<T>, key: string, version: string) -> (T, DataStoreKeyInfo),
}

type StoreProps<T> = {
	_ctx: Types.StoreContext<T>, -- Shared context containing config and dependencies.
	_closed: boolean, -- Flag indicating if the store has been closed.
	_sessions: { [string]: Session.Session<T> }, -- Map of active sessions, keyed by data key.
	_loadPromises: { [string]: Promise.Promise }, -- Tracks ongoing load operations to prevent duplicates.
	_unloadPromises: { [string]: Promise.Promise }, -- Tracks ongoing unload operations.
}

export type Store<T> = typeof(setmetatable({} :: StoreProps<T>, {} :: StoreImpl<T>))

local Store: StoreImpl<any> = {} :: StoreImpl<any>
Store.__index = Store

--[=[
	Factory function to create a new Store instance.

	Initializes the store context, sets up DataStore and MemoryStore connections
	(real or mock), validates the template schema, and returns the configured Store object.

	@within Store
	@param config StoreConfig<T> -- Configuration options for the store.
	@return Store<T> -- A new, initialized Store instance.
]=]
local function createStore<T>(config: StoreConfig<T>): Store<T>
	assert(storeConfigCheck(config))

	local logger = Log.createLogger(config.logCallback or function() end, {
		lib = "lyra",
		store = config.name,
	})

	logger:log("debug", `creating store`)

	-- Determine which DataStoreService implementation to use (real, mock, or custom).
	local dataStoreService = config.dataStoreService
	if dataStoreService == nil then
		if config.useMock then
			assert(RunService:IsStudio(), "useMock can only be true in Studio")
			logger:log("info", `using mock DataStoreService`)
			dataStoreService = (MockDataStoreService.new() :: any) :: DataStoreService
		else
			logger:log("trace", `using real DataStoreService`)
			dataStoreService = DataStoreService
		end
	end
	assert(dataStoreService, "luau") -- Forcefully narrowing type due to old type solver limitations

	-- Determine which MemoryStoreService implementation to use (real, mock, or custom).
	local memoryStoreService = config.memoryStoreService
	if memoryStoreService == nil then
		if config.useMock then
			assert(RunService:IsStudio(), "useMock can only be true in Studio")
			logger:log("info", `using mock MemoryStoreService`)
			memoryStoreService = (MockMemoryStoreService.new() :: any) :: MemoryStoreService
		else
			logger:log("trace", `using real MemoryStoreService`)
			memoryStoreService = MemoryStoreService
		end
	end
	assert(memoryStoreService, "luau") -- Forcefully narrowing type due to old type solver limitations

	local migrationSteps = config.migrationSteps or {}

	-- Assemble the StoreContext object, which bundles all dependencies and config.
	local storeContext: Types.StoreContext<T> = {
		name = config.name,
		template = config.template,
		schema = config.schema,

		migrationSteps = migrationSteps,
		importLegacyData = config.importLegacyData,

		dataStoreService = dataStoreService,
		memoryStoreService = memoryStoreService,

		changedCallbacks = config.changedCallbacks or {},
		logger = logger,
		onLockLost = config.onLockLost,

		-- Get specific DataStore/MemoryStore instances using derived names/scopes.
		recordStore = dataStoreService:GetDataStore(`{Constants.RECORD_SCOPE}/{config.name}`),
		shardStore = dataStoreService:GetDataStore(`{Constants.SHARD_SCOPE}/{config.name}`),
		txStore = dataStoreService:GetDataStore(`{Constants.TX_SCOPE}/{config.name}`),
		lockHashMap = memoryStoreService:GetHashMap(`{Constants.LOCK_SCOPE}/{config.name}`),
	}

	-- Validate that the provided template data conforms to the schema.
	local ok, err = storeContext.schema(storeContext.template)
	if not ok then
		error(`Failed to validate template for store '{config.name}': {err}`)
	end

	local self = setmetatable({
		_ctx = storeContext,
		_closed = false,
		_sessions = {},
		_loadPromises = {},
		_unloadPromises = {},
	}, Store)

	logger:log("trace", `created store`)
	return self
end

--[[
	Handling Concurrent Load and Unload Requests:

	The `load` and `unload` methods manage the state of data associated with a
	specific key (like a player ID). Because these operations can be called
	close together or even overlap for the same key, the Store implements
	specific rules to ensure data consistency and prevent conflicts:

	- **Loading a Key:**
	    - If you try to `load` a key that's *already loading*, the second `load`
	      request is rejected ("Load already in progress"). You should only
	      initiate one load at a time per key, as concurrent loads often
	      indicate a logic issue.
	    - If you try to `load` a key that's *currently unloading*, the `load`
	      request will patiently wait until the unload process is completely
	      finished before it starts acquiring the lock and loading the data.
	    - If you try to `load` a key that's *already loaded* and ready (and not
	      unloading), the request completes instantly without doing anything.

	- **Unloading a Key:**
	    - If you try to `unload` a key that's *currently loading*, the `unload`
	      request takes priority. It immediately cancels the ongoing load
	      operation (preventing the session from being fully created) and
	      finishes quickly. This avoids creating a session only to tear it down
	      immediately.
	    - If you try to `unload` a key that's *already unloading*, the second
	      `unload` request simply waits for the first one to finish.
	    - If you try to `unload` a key that's *already unloaded* (or was never
	      loaded), the request completes instantly without doing anything.

	These rules, managed internally using promise tracking (`_loadPromises`,
	`_unloadPromises`), guarantee that operations happen in a safe, predictable
	order. They prevent race conditions like those introduced by players joining
	and leaving quickly.
]]

--[=[
	Acquires a distributed lock, loads data for the given key into memory, 
	and establishes a `Session` object to manage the key's state.

	This must be called before performing operations like `get`, `update`, or `save`
	on the key. It handles concurrent load attempts and waits for any ongoing unload
	operations to complete first.

	Propagates errors from `Session.load` (e.g., lock acquisition failure, DataStore errors).
	
	@within Store
	@param key string -- The unique identifier for the data to load (e.g., "player_123").
	@param userIds {number}? -- Optional list of UserIDs for DataStore key tagging.
	@return Promise -- Resolves when the data is successfully loaded and the session is ready, or rejects on error.
	@error "Load already in progress" -- If `load` is called again for the same key while a previous load is still running.
	@error "Store is closed" -- If the store instance has been closed via `close()`.
]=]
function Store:load(key: string, userIds: { number }?): Promise.Promise
	assert(t.string(key))
	assert(t.optional(t.array(t.number))(userIds))

	local logger = self._ctx.logger:extend({ method = "load", key = key })
	logger:log("trace", "attempting to load key")

	-- Prevent operations if the store is closed.
	if self._closed then
		logger:log("warn", "attempted to load key while store is closed")
		return Promise.reject("Store is closed")
	end

	-- If a session exists and isn't currently unloading, it's already loaded.
	if self._sessions[key] and not self._unloadPromises[key] then
		logger:log("trace", "key is already loaded")
		return Promise.resolve()
	end

	-- Prevent concurrent load attempts for the same key.
	if self._loadPromises[key] then
		logger:log("trace", "key is currently being loaded")
		-- We reject instead of returning the existing promise because load
		-- being called more than once on the same key indicates a code smell or bug.
		return Promise.reject("Load already in progress")
	end

	-- If an unload is in progress, wait for it to finish before starting the load.
	local waitForUnload = Promise.try(function()
		local unloadPromise = self._unloadPromises[key]
		if unloadPromise then
			logger:log("trace", "waiting for unload to complete")
			unloadPromise:await()
		end
	end)

	local sessionLoadParams = {
		storeContext = self._ctx,
		key = key,
		userIds = userIds,
	}
	-- Chain the actual session loading after the potential unload wait.
	local loadPromise = waitForUnload:andThenCall(Session.load, sessionLoadParams):andThen(function(session)
		-- Check if the store was closed *while* this load was in progress.
		if self._closed then
			logger:log("warn", "store closed before key loaded, unloading immediately")
			-- If closed, immediately start unloading the session that was just loaded.
			self._unloadPromises[key] = session:unload():finally(function()
				logger:log("trace", "key unloaded after store closed during load")
				self._unloadPromises[key] = nil
			end)
			return Promise.reject("Store closed before key loaded")
		end

		-- Session was loaded successfully; let's store it, start autosaving,
		-- and set up lock loss handling.

		self._sessions[key] = session

		session:startAutosaving()

		session.lockHandle.onLockLost(function()
			logger:log("warn", "lock lost for key, removing session")
			if self._ctx.onLockLost then
				-- Use pcall as user callback could error.
				pcall(self._ctx.onLockLost, key)
			end
			-- Remove the session as it's no longer valid without the lock.
			self._sessions[key] = nil
		end)
		logger:log("debug", "key loaded successfully")
	end)

	-- Store the load promise to handle concurrent calls.
	self._loadPromises[key] = loadPromise

	-- Ensure the load promise is removed from the tracking table once settled,
	-- and suppress unhandled rejection warnings if the caller doesn't attach a .catch.
	loadPromise
		:finally(function()
			-- Remove the promise regardless of outcome.
			self._loadPromises[key] = nil
		end)
		:catch(function()
			-- Mark original rejection as handled to prevent "Unhandled Promise
			-- Rejection" spam if user doesn't catch. Note that this is a new
			-- promise chain - the original rejection is still propagated to the
			-- caller.
		end)

	-- Final check for cancellation after the main load logic.
	return loadPromise:finally(function(status)
		if status == (Promise :: any).Status.Cancelled then
			logger:log("trace", "load was cancelled")
			return Promise.reject("Load was cancelled")
		end
	end)
end

--[=[
	Synchronous wrapper for [Store:load]. Waits for the Promise to settle.
	Throws an error if the load fails or is cancelled.
	
	@within Store
	@param key string -- The unique identifier for the data to load.
	@param userIds {number}? -- Optional list of UserIDs for DataStore key tagging.
	@error any -- Throws any error encountered during the load process.
	@yields
]=]
function Store:loadAsync(key: string, userIds: { number }?): ()
	self:load(key, userIds):expect()
end

--[=[
	Unloads data for the given key from memory, saves any pending changes,
	releases the distributed lock, and ends the session.

	Propagates errors from `Session:unload` (e.g., save failures).
	
	@within Store
	@param key string -- The unique identifier for the data to unload.
	@return Promise -- Resolves when the data is successfully unloaded, or rejects on error.
	@error "Store is closed" -- If the store instance has been closed.
]=]
function Store:unload(key: string): Promise.Promise
	assert(t.string(key))

	local logger = self._ctx.logger:extend({ method = "unload", key = key })
	logger:log("trace", "attempting to unload key")

	-- Prevent operations if the store is closed.
	if self._closed then
		logger:log("warn", "attempted to unload key while store is closed")
		return Promise.reject("Store is closed")
	end

	-- If a load is in progress, cancel it instead of unloading.
	if self._loadPromises[key] then
		logger:log("trace", "key is being loaded, cancelling load instead of unloading")
		self._loadPromises[key]:cancel()
		-- Resolve immediately as the load cancellation handles cleanup.
		return Promise.resolve()
	end

	-- If an unload is already in progress, return the existing promise.
	if self._unloadPromises[key] then
		logger:log("trace", "key is already being unloaded")
		return self._unloadPromises[key]
	end

	-- If there's no active session, there's nothing to unload.
	local session = self._sessions[key]
	if not session then
		logger:log("warn", "key not loaded, nothing to unload")
		return Promise.resolve()
	end

	logger:log("trace", "unloading key")
	-- Store the unload promise to handle concurrent calls.
	self._unloadPromises[key] = session:unload():finally(function()
		-- Clean up regardless of unload success or failure.
		logger:log("trace", "key unload finished, cleaning up state")
		self._sessions[key] = nil
		self._unloadPromises[key] = nil
	end)

	return self._unloadPromises[key] or Promise.resolve()
end

--[=[
	Synchronous wrapper for [Store:unload]. Waits for the Promise to settle.
	Throws an error if the unload fails.
	
	@within Store
	@param key string -- The unique identifier for the data to unload.
	@error any -- Throws any error encountered during the unload process.
	@yields
]=]
function Store:unloadAsync(key: string): ()
	self:unload(key):expect()
end

--[=[
	Internal helper function to safely access the session for a given key.
	Handles waiting for load/unload operations and checks store/session state.

	@within Store
	@private
	@param key string -- The key whose session is needed.
	@param callback (session: Session.Session<any>) -> any -- The function to execute with the session object.
	@return Promise -- Resolves with the return value of the callback, or rejects if the session cannot be accessed (e.g., not loaded, store closed, load cancelled).
]=]
function Store:_withSession(key: string, callback: (session: Session.Session<any>) -> any): Promise.Promise
	local logger = self._ctx.logger:extend({ method = "_withSession", key = key })

	return Promise.new(function(resolve, reject)
		-- Check if store is closed first.
		if self._closed then
			logger:log("warn", "attempted to use key while store is closed")
			return reject("Store is closed")
		end

		-- If a load is in progress, wait for it.
		local loadPromise = self._loadPromises[key]
		if loadPromise then
			logger:log("trace", "key being loaded, waiting for load promise")
			local resolved, err = loadPromise:await()
			if not resolved then
				if loadPromise:getStatus() == Promise.Status.Cancelled then
					logger:log("trace", "load was cancelled while waiting")
					return reject("Load was cancelled")
				else
					logger:log("warn", "load failed while waiting")
					return reject(err)
				end
			end
			-- Load completed successfully while waiting.
		end

		-- Check if an unload is in progress.
		if self._unloadPromises[key] then
			logger:log("warn", "key is being unloaded")
		end

		-- Get the session; it should exist now if load succeeded or was already loaded.
		local session = self._sessions[key]
		if not session then
			logger:log("warn", "key not loaded")
			return reject("Key not loaded")
		end

		-- Session exists and is ready, execute the callback.
		-- Use Promise.try to handle potential errors within the callback itself.
		resolve(Promise.try(callback, session))
	end)
end

--[=[
	Internal helper to get the DataStoreKeyInfo for a loaded key's session.

	@within Store
	@private
	@param key string -- The key whose info is needed.
	@return Promise<DataStoreKeyInfo?> -- Resolves with the key info object, or nil if the session doesn't have key info (shouldn't normally happen for loaded sessions). Rejects if the session cannot be accessed.
]=]
function Store:_getKeyInfo(key: string): Promise.TPromise<DataStoreKeyInfo?>
	return self:_withSession(key, function(session)
		-- Access the keyInfo property stored on the session object after load.
		return session.keyInfo
	end)
end

--[=[
	Gets the current, in-memory data state for the given key.
	Requires the key to be loaded first via `load()`.
	If the key is still loading, this will wait for it to finish.

	@within Store
	@param key string -- The key whose data to retrieve.
	@return Promise<T> -- Resolves with the current data object (potentially a deep copy).
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store has been closed.
]=]
function Store:get<T>(key: string): Promise.TPromise<T>
	assert(t.string(key))

	return self:_withSession(key, function(session)
		return session:get()
	end)
end

--[=[
	Synchronous wrapper for [Store:get]. Waits for the Promise to settle.
	Throws an error if getting the data fails.
	
	@within Store
	@param key string -- The key whose data to retrieve.
	@return T -- The current data object.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store has been closed.
	@yields
]=]
function Store:getAsync<T>(key: string): T
	return self:get(key):expect()
end

--[=[
	Applies changes to the data for a given key using a transform function.

	The `transformFunction` receives the current data and can modify it directly.
	It **must** return `true` to indicate that changes were made and should be
	saved, or `false` to abort the update without saving.

	Changes are applied optimistically to the in-memory state first and then queued
	for saving to the DataStore.

	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> boolean -- A function that receives the current data and returns `true` to commit changes or `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if the transform function returned `true` and the update was successfully queued, or `false` if the transform function returned `false`. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
]=]
function Store:update<T>(key: string, transformFunction: (data: T) -> boolean): Promise.TPromise<boolean>
	assert(t.string(key))
	assert(t.callback(transformFunction))

	-- Use _withSession to safely access the session and call its update method.
	return self:_withSession(key, function(session)
		return session:update(transformFunction)
	end)
end

--[=[
	Synchronous wrapper for [Store:update]. Waits for the Promise to settle.
	Throws an error if the update fails.
	
	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> boolean -- The transformation function.
	@return boolean -- Returns the boolean value returned by the `transformFunction`.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
	@yields
]=]
function Store:updateAsync<T>(key: string, transformFunction: (data: T) -> boolean): boolean
	return self:update(key, transformFunction):expect()
end

--[=[
	Applies changes to the data for a given key using a transform function,
	with immutable copy-on-write semantics.

	The `transformFunction` receives the current data but frozen (immutable),
	and cannot modify it directly. Instead, it should return new data that
	reflects the desired changes. Otherwise it should return `false` to abort
	the update without saving.

	Changes are applied optimistically to the in-memory state first and then queued
	for saving to the DataStore.

	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> T | false -- A function that receives the current data and returns a new copy of the data with changes to commit changes, or `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if the transform function committed and the update was successfully queued, or `false` if the transform function returned `false`. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
]=]
function Store:updateImmutable<T>(key: string, transformFunction: (data: T) -> T | false): Promise.TPromise<boolean>
	assert(t.string(key))
	assert(t.callback(transformFunction))

	-- Use _withSession to safely access the session and call its updateImmutable method.
	return self:_withSession(key, function(session)
		return session:updateImmutable(transformFunction)
	end)
end

--[=[
	Synchronous wrapper for [Store:updateImmutable]. Waits for the Promise to settle.
	Throws an error if the update fails.
	
	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> T | false -- The transformation function.
	@return boolean -- Returns `true` if the update was successful, or `false` if the transform function returned `false`.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
	@yields
]=]
function Store:updateImmutableAsync<T>(key: string, transformFunction: (data: T) -> T | false): boolean
	return self:updateImmutable(key, transformFunction):expect()
end

--[=[
	Internal helper to perform transaction logic on multiple keys.
	Handles acquiring locks, validating state, and committing changes atomically
	via a two-phase commit process.
	
	Supports both immutable and mutable transactions, where `immutable` controls
	whether the data passed to the `transformFunction` is a deep copy (mutable)
	or a reference to the canonical, frozen data (immutable).

	**Implementation Details:**
	- Uses `PromiseQueue.multiQueueAdd` to ensure the transform function only runs
	  when all involved session queues are ready.
	- Uses a temporary `txLockPromise` on sessions to block concurrent `update` calls
	  while the transaction logic is executing.
	- Performs a two-phase commit using a transaction marker in the `txStore`:
		1. Write `false` to `txStore` under a unique `txId`.
		2. Update all primary `recordStore` entries with the new data and `txId`.
		3. If successful, remove the `txId` entry from `txStore`.
	- If any step fails, attempts to revert changes by rewriting records without the `txId`
	  and removing the `txId` marker.
	- Uses `JsonPatch` to calculate differences for efficient storage in `TxInfo`.

	Propagates DataStore errors encountered during the commit or revert phases.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction ((state: { [string]: any }) -> boolean) | ((state: { [string]: any }) -> { [string]: any } | false) -- A function that receives the current state of all keys and, depending on `immutable`, either modifies it directly (mutable) and returns `true` to commit, or returns a new state (immutable) to commit. Must return `false` to abort the transaction.
	@return Promise -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@error "Key not loaded" -- If any key in the `keys` array has not been loaded.
	@error "Key is already locked by another transaction" -- If any key is already involved in an ongoing `tx`.
	@error "Key is closed" -- If any involved session has been closed (e.g., due to lock loss).
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data for any key after transformation fails the schema check.
	@error "Keys changed in transaction" -- If the `transformFunction` attempts to add or remove keys from the state table it receives.
]=]
local function txInternal<T>(
	self: Store<T>,
	keys: { string },
	transformFunction: ((state: T) -> boolean) | ((state: T) -> T | false),
	immutable: boolean
): Promise.TPromise<boolean>
	-- Generate a unique ID for this transaction attempt.
	local txId = HttpService:GenerateGUID(false)
	local logger = self._ctx.logger:extend({ method = "tx", keys = keys, txId = txId, immutable = immutable })

	logger:log("trace", "starting transaction")
	if self._closed then
		logger:log("warn", "attempted to start transaction while store is closed")
		return Promise.reject("Store is closed")
	end

	-- Pre-checks: Ensure all keys are loaded and not already involved in a transaction or closed.
	for _, key in keys do
		local session = self._sessions[key]
		if not session then
			logger:log("error", `key not loaded: {key}`)
			return Promise.reject(`Key not loaded: {key}`)
		end
		-- Check if the session is already locked by another transaction.
		if session.txLockPromise then
			logger:log("error", `key is already locked by another transaction: {key}`)
			return Promise.reject(`Key is already locked by another transaction: {key}`)
		end
		-- Check if the session was closed (e.g., due to lock loss).
		if session.closed then
			logger:log("error", `key is closed: {key}`)
			return Promise.reject(`Key is closed: {key}`)
		end
	end

	-- Create a promise that acts as a lock signal for the involved sessions.
	-- It resolves only when the transaction completes (success or failure).
	local txLockResolve
	local txLockPromise = Promise.new(function(resolve)
		txLockResolve = resolve
	end)

	-- Get the PromiseQueues for all involved sessions.
	local queues = Tables.map(keys, function(key)
		return self._sessions[key].queue
	end)

	-- Helper function to manage setting and clearing the txLockPromise on sessions.
	local function withTxLock(fn: () -> Promise.Promise): Promise.Promise
		-- Set the lock promise on all involved sessions *before* executing the function.
		-- This prevents concurrent :update calls from modifying state while tx runs.
		for _, key in keys do
			local session = self._sessions[key]
			session.txLockPromise = txLockPromise
		end
		logger:log("trace", "set txLockPromise on Sessions")

		-- Execute the provided function and ensure the lock is cleared afterwards.
		return Promise.try(fn):finally(function()
			-- Clear the lock promise from all involved sessions.
			for _, key in keys do
				local session = self._sessions[key]
				-- Only clear if it's still *our* lock promise (sanity check).
				if session and session.txLockPromise == txLockPromise then
					session.txLockPromise = nil
				end
			end
			logger:log("trace", "cleared txLockPromise on Sessions")
			-- Resolve the lock promise to signal completion to any waiting operations.
			txLockResolve()
		end)
	end

	logger:log("trace", `acquiring PromiseQueue lock on keys`)
	-- Use multiQueueAdd to ensure the core transaction logic runs only when
	-- all session queues are ready (atomicity across queues).
	return PromiseQueue.multiQueueAdd(queues, function()
		logger:log("trace", `acquired PromiseQueue lock on keys`)

		-- Wrap the core transaction logic with the session tx lock mechanism.
		return withTxLock(function()
			-- 1. Get current state from all sessions.
			local currentState: { [string]: T } = {}
			for _, key in keys do
				local session = self._sessions[key]
				-- Use session.data directly as we hold the queue lock.
				currentState[key] = session.data :: T
			end

			local nextState
			if immutable then
				-- If immutable, the transformFunction has to handle
				-- copy-on-write semantics itself, and we'll pass the current
				-- state directly. The sessions' data are already frozen, but we
				-- still need to freeze the table containing them.
				table.freeze(currentState)
				nextState = currentState
			else
				-- If mutable, we allow the transform function to modify a copy.
				nextState = Tables.copyDeep(currentState)
			end

			-- 2. Execute the user's transform function.
			-- Use noYield to prevent yielding within the transform function.
			local transformOk, result = pcall(noYield, transformFunction, nextState :: any)
			if not transformOk then
				logger:log("error", "tx transformFunction failed", { error = result })
				return Promise.reject(`Store:tx transformFunction failed: {result}`)
			end

			if immutable == false then
				-- If mutable, the transform function should return a boolean.
				-- This indicates whether the changes should be committed.
				assert(typeof(result) == "boolean", "Mutable transaction transform function must return a boolean")
			else
				-- If immutable, the transform function should return a new state or false.
				-- This indicates the new state to commit or that the transaction should be aborted.
				assert(
					typeof(result) == "table" or result == false,
					"Immutable transaction transform function must return a table or false"
				)
			end

			-- If transform returned false, abort the transaction.
			if result == false then
				logger:log("trace", "tx transformFunction returned false, aborting")
				return Promise.resolve(false)
			end

			if immutable then
				nextState = result
			end

			-- We freeze the nextState to prevent further modifications.
			Tables.freezeDeep(nextState)

			-- 3. Check if the transform function illegally modified the set of keys.
			local didKeysChange = false
			for key in currentState do
				if nextState[key] == nil then
					didKeysChange = true
					break
				end
			end
			if not didKeysChange then
				for key in nextState do
					if currentState[key] == nil then
						didKeysChange = true
						break
					end
				end
			end
			if didKeysChange then
				logger:log("error", "keys changed in transaction")
				return Promise.reject("Keys changed in transaction")
			end

			-- 4. Validate the resulting state against schemas.
			for _, key in keys do
				local schemaOk, err = self._ctx.schema(nextState[key] :: any)
				if not schemaOk then
					logger:log("error", `schema validation for key {key} failed: {err}`)
					return Promise.reject(`Store:tx schema validation failed for key '{key}': {err}`)
				end
			end

			-- 5. Determine which keys actually changed.
			local changedKeys = {}
			for key in currentState do
				if not Tables.equalsDeep(currentState[key] :: any, nextState[key] :: any) then
					table.insert(changedKeys, key)
				end
			end

			-- Handle cases where no keys or only one key changed.
			if #changedKeys == 0 then
				logger:log("trace", "tx had no mutations, skipping update")
				return Promise.resolve(true) -- No changes, resolve successfully.
			elseif #changedKeys == 1 then
				-- If only one key changed, treat it as a standard single-key update for efficiency.
				logger:log("trace", `tx only changed one key ('{changedKeys[1]}'), treating as Session:update`)

				local key = changedKeys[1]
				local nextData = nextState[key]

				if immutable == false then
					-- If mutable, reconcile the data before mutating.
					local currentData = currentState[key]
					nextData = Tables.reconcileDeep(currentData, nextData)
				end

				-- Directly mutate the session state and let its normal save mechanism handle it.
				self._sessions[key]:mutateKey(nextData)

				return Promise.resolve(true)
			end

			-- 6. Multi-key change: Proceed with the two-phase commit.
			logger:log("trace", "tx changed multiple keys, beginning multi-key update")
			local patches = {}
			for key, newData in nextState do
				-- Generate JSON patches representing the changes for each key.
				patches[key] = JsonPatch.createPatch(currentState[key], newData)
			end

			-- Phase 1a: Prepare - Write the transaction status marker (`false` = pending).
			local prepareTxPromise = dataStoreRetry(function()
				return self._ctx.txStore:SetAsync(txId, false)
			end):catch(function(err)
				logger:log("error", "failed to prepare txId", { error = err })
				return Promise.reject("Failed to prepare tx") -- Abort if status marker fails.
			end)

			-- Phase 1b: Write Records - After preparing, write the new records with TxInfo.
			local keyWritePromises = prepareTxPromise:andThen(function()
				logger:log("trace", "tx status prepared, writing records with TxInfo")
				-- Create promises for writing each key's record.
				return Promise.all(Tables.map(keys, function(key)
					local txInfo: Types.TxInfo = {
						txId = txId,
						txPatch = patches[key],
						committedData = currentState[key], -- Store pre-tx data for potential reads.
					}
					return self._sessions[key]:writeRecord(txInfo)
				end))
			end)

			-- Function to handle reverting the transaction if commit fails.
			local function revert(err)
				logger:log("error", "multi-key update or tx commit failed, reverting", { error = err })

				-- Attempt to rewrite all records *without* the TxInfo.
				local cleanupPromises = Tables.map(keys, function(key)
					local txInfo = { committedData = currentState[key] } -- Revert to pre-tx state reference.
					return self._sessions[key]:writeRecord(txInfo)
				end)

				-- After attempting record reverts, try to clean up the tx
				-- status marker. It's important we use `Promise.all` instead of
				-- `Promise.allSettled` here, as we want to ensure the tx marker
				-- is scrubbed from all keys before removing it, since a `nil`
				-- tx status means the tx was committed successfully.
				return Promise.all(cleanupPromises)
					:andThen(function()
						logger:log("trace", "multi-key update reverted, cleaning up tx status")
						return dataStoreRetry(function()
							return self._ctx.txStore:RemoveAsync(txId)
						end)
					end)
					:finally(function()
						logger:log("trace", "tx status cleanup attempted after failure")
						-- Reject with the original error that triggered the revert.
						return Promise.reject(err)
					end)
			end

			-- Phase 2: Commit - If all records wrote successfully, remove the tx status marker.
			local commitPromise = keyWritePromises
				:andThen(function()
					logger:log(
						"trace",
						"multi-key records written successfully, committing transaction by removing tx status"
					)
					return dataStoreRetry(function()
						return self._ctx.txStore:RemoveAsync(txId)
					end)
				end)
				:catch(revert) -- If commit fails, trigger the revert process.

			-- Post-Commit/Revert Logic
			return commitPromise
				:andThen(function()
					-- Runs only if commit succeeded (revert path rejects).
					logger:log("debug", "transaction committed successfully")

					-- Update the in-memory session state to reflect the committed changes.
					for _, key in keys do
						local session = self._sessions[key]
						if session then -- Check if session still exists (e.g., wasn't closed due to lock loss during tx)
							local nextData = nextState[key]

							if immutable == false then
								-- If mutable, reconcile the data before mutating.
								local currentData = currentState[key]
								nextData = Tables.reconcileDeep(currentData, nextData)
							end

							session:mutateKey(nextData)
							session.changeSet = {} -- Reset changeset as data is now saved.
						end
					end

					return true
				end)
				:finally(function()
					-- Runs after commit or revert finishes.
					logger:log("trace", "tx finished")
				end)
		end) -- End of withTxLock
	end) -- End of multiQueueAdd
end

--[=[
	Performs an atomic transaction across multiple keys.
	
	Requires the keys to be loaded first via `load()`. The `transformFunction`
	is called with the current state of all involved keys and must return `true`
	to commit changes or `false` to abort.

	Propagates errors from the transaction process, including DataStore errors,
	schema validation failures, and key loading issues.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> boolean -- The transformation function.
	@return Promise<boolean> -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@error "Key not loaded" -- If any key in the `keys` array has not been loaded.
	@error "Key is already locked by another transaction" -- If any key is already involved in an ongoing `tx`.
	@error "Key is closed" -- If any involved session has been closed (e.g., due to lock loss).
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data for any key after transformation fails the schema check.
	@error "Keys changed in transaction" -- If the `transformFunction` attempts to add or remove keys from the state table it receives.
]=]
function Store:tx<T>(keys: { string }, transformFunction: (state: { [string]: T }) -> boolean): Promise.TPromise<boolean>
	assert(t.array(t.string)(keys))
	assert(t.callback(transformFunction))

	return txInternal(self, keys, transformFunction, false)
end

--[=[
	Synchronous wrapper for [Store:tx]. Waits for the Promise to settle.
	Throws an error if the transaction fails or is aborted.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> boolean -- The transformation function.
	@error any -- Throws any error encountered during the transaction.
	@yields
]=]
function Store:txAsync<T>(keys: { string }, transformFunction: (state: { [string]: T }) -> boolean): ()
	self:tx(keys, transformFunction):expect()
end

--[=[
	Performs an atomic transaction across multiple keys with immutable, copy-on-write semantics.

	The data passed to the function is frozen and cannot be modified directly.
	Instead, the function should return a new table with the desired changes.

	Requires the keys to be loaded first via `load()`. The `transformFunction`
	is called with the current state of all involved keys and must return the
	new state to commit or `false` to abort.

	Propagates errors from the transaction process, including DataStore errors,
	schema validation failures, and key loading issues.

	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> { [string]: T } | false -- The transformation function.
	@return Promise<boolean> -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@error "Key not loaded" -- If any key in the `keys` array has not been loaded.
	@error "Key is already locked by another transaction" -- If any key is already involved in an ongoing `tx`.
	@error "Key is closed" -- If any involved session has been closed (e.g., due to lock loss).
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data for any key after transformation fails the schema check.
	@error "Keys changed in transaction" -- If the `transformFunction` attempts to add or remove keys from the state table it receives.
]=]
function Store:txImmutable<T>(
	keys: { string },
	transformFunction: (state: { [string]: T }) -> { [string]: T } | false
): Promise.TPromise<boolean>
	assert(t.array(t.string)(keys))
	assert(t.callback(transformFunction))

	return txInternal(self, keys, transformFunction, true)
end

--[=[
	Synchronous wrapper for [Store:txImmutable]. Waits for the Promise to settle.
	Throws an error if the transaction fails or is aborted.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> { [string]: T } | false -- The transformation function.
	@error any -- Throws any error encountered during the transaction.
	@yields
]=]
function Store:txImmutableAsync<T>(
	keys: { string },
	transformFunction: (state: { [string]: T }) -> { [string]: T } | false
): boolean
	return self:txImmutable(keys, transformFunction):expect()
end

--[=[
	Forces an immediate save of the given key's current in-memory data state
	to the DataStore.

	:::note
	Data is automatically saved periodically by the Session's autosave mechanism.
	Manual saves are typically only needed in specific scenarios like processing
	developer product purchases (`MarketplaceService.ProcessReceipt`) where immediate
	persistence is crucial before granting benefits.
	:::

	Propagates errors from `Session:save` (e.g., DataStore write errors).
	
	@within Store
	@param key string -- The key whose data to save.
	@return Promise -- Resolves when the save operation completes successfully, rejects on error.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
]=]
function Store:save(key: string): Promise.Promise
	assert(t.string(key))

	return self:_withSession(key, function(session)
		return session:save()
	end)
end

--[=[
	Synchronous wrapper for [Store:save]. Waits for the Promise to settle.
	Throws an error if the save fails.
	
	@within Store
	@param key string -- The key whose data to save.
	@error any -- Throws any error encountered during the save operation.
	@yields
]=]
function Store:saveAsync(key: string): ()
	self:save(key):expect()
end

--[=[
	Closes the store, gracefully unloading all active sessions.

	Attempts to save any pending changes for all loaded keys before releasing locks
	and removing sessions from memory. The store instance becomes unusable as soon as this is called.

	@within Store
	@return Promise -- Resolves when all sessions have attempted to unload, or rejects if any session encountered an error during its unload process (errors are aggregated).
]=]
function Store:close(): Promise.Promise
	local logger = self._ctx.logger:extend({ method = "close" })
	logger:log("trace", "closing store")

	-- Cancel any loads that are still in progress.
	for key, loadPromise in self._loadPromises do
		logger:log("trace", "cancelling in-progress load", { key = key });
		(loadPromise :: any):cancel()
	end

	-- Collect errors encountered during individual session unloads.
	local rejections = {}

	-- Initiate unload for all currently active sessions.
	local unloadPromises = {}
	for key, session in self._sessions do
		if self._unloadPromises[key] then
			logger:log("trace", "key already being unloaded", { key = key })
			table.insert(unloadPromises, self._unloadPromises[key])
		else
			logger:log("trace", "unloading key", { key = key })
			table.insert(
				unloadPromises,
				self:unload(key):catch(function(err)
					logger:log("error", "error unloading key during close", { key = key, error = err })
					table.insert(rejections, { key = key, error = err })
					-- Don't re-throw; let Promise.allSettled handle aggregation.
				end)
			)
		end
	end

	-- Mark the store as closed immediately. Further operations will be rejected.
	self._closed = true
	logger:log("trace", "store marked as closed")

	return Promise.allSettled(unloadPromises):andThen(function()
		logger:log("debug", "store closed")
		-- If any individual unload failed, reject the main close promise with the errors.
		if #rejections > 0 then
			return Promise.reject(rejections)
		end
	end)
end

--[=[
	Synchronous wrapper for [Store:close]. Waits for the Promise to settle.
	Throws an error if closing fails (i.e., if any session failed to unload).
	
	@within Store
	@error any -- Throws an error (potentially a table of errors) if closing fails.
	@yields
]=]
function Store:closeAsync(): ()
	self:close():expect()
end

--[=[
	Reads the current data for the given key directly from the DataStore,
	bypassing the session cache and locking mechanism.

	This provides a snapshot of the last saved state but does not load the key
	into an active session. Useful for inspecting data without acquiring a lock.
	Handles potential sharding and transaction status automatically.

	Propagates DataStore errors from underlying reads.
	
	@within Store
	@param key string -- The key whose data to peek at.
	@return Promise<T?> -- Resolves with the data object, or `nil` if the key doesn't exist. Rejects on DataStore errors.
]=]
function Store:peek<T>(key: string): Promise.TPromise<T?>
	-- 1. Get the main record from the recordStore.
	return dataStoreRetry(function()
			return self._ctx.recordStore:GetAsync(key)
		end)
		:andThen(function(record: Types.DataStoreRecord?)
			-- If no record exists, the key is empty.
			if record == nil then
				return nil
			end
			assert(record, "luau") -- Forcefully narrowing type due to old type solver limitations

			local file = record.file
			if file then
				local readParams: Files.ReadParams = {
					store = self._ctx.shardStore,
					file = file,
				}
				-- Files.read handles direct data or reconstruction from shards.
				return Files.read(readParams)
			end

			return nil
		end)
		:andThen(function(txInfo: Types.TxInfo?)
			if txInfo == nil then
				return nil
			end
			assert(txInfo, "luau") -- Forcefully narrowing type due to old type solver limitations

			local readTxParams = {
				store = self._ctx.txStore,
				txInfo = txInfo,
			}
			return Transactions.readTx(readTxParams)
		end)
end

--[=[
	Synchronous wrapper for [Store:peek]. Waits for the Promise to settle.
	Returns the data for the key if it exists. Throws on any errors from underlying DataStore operations.

	@within Store
	@param key string -- The key whose data to peek at.
	@return T? -- The data object, or `nil` if the key doesn't exist.
	@error any -- May throw errors from underlying DataStore operations.
	@yields
]=]
function Store:peekAsync<T>(key: string): T?
	return self:peek(key):expect()
end

--[=[
	Checks if a distributed lock is currently active for the given key in MemoryStore.

	Propagates errors from `Locks.probeLockActive`.
	
	@within Store
	@param key string -- The key to check the lock status for.
	@return Promise<boolean> -- Resolves with `true` if a lock is active, `false` otherwise. Rejects on MemoryStore errors.
]=]
function Store:probeLockActive(key: string): Promise.TPromise<boolean>
	-- Delegate directly to the Locks module.
	return Locks.probeLockActive({
		storeContext = self._ctx,
		key = key,
	})
end

--[=[
	Synchronous wrapper for [Store:probeLockActive]. Waits for the Promise to settle.
	Throws an error if the check fails.
	
	@within Store
	@param key string -- The key to check the lock status for.
	@return boolean -- `true` if a lock is active, `false` otherwise.
	@error any -- Throws any error encountered during the probe operation.
	@yields
]=]
function Store:probeLockActiveAsync(key: string): boolean
	return self:probeLockActive(key):expect()
end

--[=[
	Lists historical versions of the data for a given key using DataStore versioning.

	Propagates errors from `DataStore:ListVersionsAsync`.
	
	@within Store
	@param params ListVersionParams -- Parameters specifying the key, sorting, date range, and page size.
	@return Promise<DataStoreVersionPages> -- Resolves with an iterator object (`DataStoreVersionPages`) that can be used to fetch pages of version history. Rejects on DataStore errors.
]=]
function Store:listVersions(params: ListVersionParams): Promise.TPromise<DataStoreVersionPages>
	-- Wrap the DataStore call with retry logic.
	return dataStoreRetry(function()
		return self._ctx.recordStore:ListVersionsAsync(
			params.key,
			params.sortDirection,
			params.minDate,
			params.maxDate,
			params.pageSize
		)
	end)
end

--[=[
	Synchronous wrapper for [Store:listVersions]. Waits for the Promise to settle.
	Throws an error if listing versions fails.
	
	@within Store
	@param params ListVersionParams -- Parameters for listing versions.
	@return DataStoreVersionPages -- An iterator for version history.
	@error any -- Throws any error encountered during the list operation.
	@yields
]=]
function Store:listVersionsAsync(params: ListVersionParams): DataStoreVersionPages
	return self:listVersions(params):expect()
end

--[=[
	Reads the data content of a specific historical version for a given key.

	Propagates DataStore errors from underlying reads.
	
	@within Store
	@param key string -- The key whose version to read.
	@param version string -- The specific version ID (obtained from `listVersions`).
	@return Promise<(T, DataStoreKeyInfo)> -- Resolves with the data object (`T`) and the `DataStoreKeyInfo` for that version. Rejects if the version doesn't exist or on DataStore/read errors.
	@error "Record not found" -- If the specified version doesn't exist.
]=]
function Store:readVersion<T>(key: string, version: string): Promise.TPromise<(T, DataStoreKeyInfo)>
	-- 1. Get the specific version record from the recordStore.
	return dataStoreRetry(function()
			return self._ctx.recordStore:GetVersionAsync(key, version)
		end)
		:andThen(function(record: Types.DataStoreRecord?, keyInfo: DataStoreKeyInfo?)
			-- Ensure both the record content and key info were returned.
			if not record or not keyInfo then
				return Promise.reject("Record not found for the specified version")
			end

			-- 2. Read the data file associated with that version record.
			local readParams: Files.ReadParams = {
				store = self._ctx.recordStore,
				file = record.file,
			}
			return Files.read(readParams):andThen(function(txInfo)
				return txInfo, keyInfo -- Pass both results to the next step.
			end)
		end)
		:andThen(function(txInfo: Types.TxInfo, keyInfo: DataStoreKeyInfo)
			local readTxParams = {
				store = self._ctx.txStore,
				txInfo = txInfo,
			}
			-- Return the final data along with the original keyInfo.
			return Transactions.readTx(readTxParams):andThen(function(finalData)
				return finalData, keyInfo
			end)
		end)
end

--[=[
	Synchronous wrapper for [Store:readVersion]. Waits for the Promise to settle.
	Throws an error if reading the version fails.
	
	@within Store
	@param key string -- The key whose version to read.
	@param version string -- The specific version ID.
	@return T -- The data object for the specified version.
	@return DataStoreKeyInfo -- The key info for the specified version.
	@error any -- Throws any error encountered during the read operation.
	@yields
]=]
function Store:readVersionAsync<T>(key: string, version: string): (T, DataStoreKeyInfo)
	return self:readVersion(key, version):expect()
end

return {
	createStore = createStore,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="106">
              <Properties>
                <string name="Name">Tables</string>
                <string name="Source"><![CDATA[local function copyDeep<T>(t: T): T
	if typeof(t) ~= "table" then
		return t
	end

	local new = table.clone(t :: any)

	for key, value in t :: any do
		if typeof(value) == "table" then
			new[key] = copyDeep(value)
		elseif typeof(value) == "buffer" then
			local copy = buffer.create(buffer.len(value))
			new[key] = buffer.copy(value, 0, copy)
		end
	end

	return new :: any
end

local function mergeDeep<T>(...: any): T
	local result = {}

	for tIndex = 1, select("#", ...) do
		local t = select(tIndex, ...)

		if typeof(t) ~= "table" then
			continue
		end

		for key, value in t do
			if typeof(value) == "table" then
				if result[key] == nil or typeof(result[key]) ~= "table" then
					result[key] = copyDeep(value)
				else
					result[key] = mergeDeep(result[key], value)
				end
			elseif typeof(value) == "buffer" then
				local copy = buffer.create(buffer.len(value))
				result[key] = buffer.copy(value, 0, copy)
			else
				result[key] = value
			end
		end
	end

	return result :: any
end

local function mergeShallow<T>(...: any): T
	local result = {}

	for tIndex = 1, select("#", ...) do
		local t = select(tIndex, ...)

		if typeof(t) ~= "table" then
			continue
		end

		for key, value in t do
			result[key] = value
		end
	end

	return result :: any
end

local function map<T, U>(array: { T }, mapper: (value: T, index: number, array: { T }) -> U?): { U }
	local mapped = {}

	for index, value in array do
		local mappedValue = mapper(value, index, array)

		if mappedValue ~= nil then
			table.insert(mapped, mappedValue)
		end
	end

	return mapped
end

local function equalsDeep(a: { [any]: any }, b: { [any]: any }): boolean
	if typeof(a) ~= "table" or typeof(b) ~= "table" then
		return a == b
	end

	for key, value in a do
		if not equalsDeep(value, b[key]) then
			return false
		end
	end

	for key, value in b do
		if not equalsDeep(value, a[key]) then
			return false
		end
	end

	return true
end

local function freezeDeep<T>(t: T): ()
	if typeof(t) ~= "table" then
		return
	end

	if table.isfrozen(t) == false then
		table.freeze(t)
	end

	for _, value in t :: any do
		if typeof(value) == "table" then
			freezeDeep(value)
		end
	end
end

-- Performs a deep reconciliation of a target table with a source table,
-- applying Copy-On-Write (COW) semantics for the target.
-- The function assumes 'target' and 'source' are non-nil tables.
--
-- Behavior:
-- - Values from 'source' overwrite corresponding values in 'target'.
--   If a value in 'source' is a table, its reference is used directly.
-- - Keys present in 'source' but not in 'target' are added to the result,
--   using 'source's values/references.
-- - Keys present in 'target' but not in 'source' (omitted) are removed from the result.
-- - If 'source' is an empty table, the result will be an empty table, unless 'target'
--   was already empty, in which case 'target' is returned.
local function reconcileDeep<T>(target: T, source: T): T
	-- 1. Handle empty source table:
	-- If 'source' is empty, it dictates that the resulting state should have no keys
	if next(source :: any) == nil then
		if next(target :: any) == nil then
			-- Both 'target' and 'source' are empty. 'target' is unchanged.
			return target
		else
			-- 'target' has keys, but 'source' (empty) dictates they should be removed.
			-- Return source.
			return source
		end
	end

	-- At this point, 'source' is guaranteed to be non-empty.
	-- 'target' can be empty or non-empty.

	-- 2. Main reconciliation logic:
	-- Start by assuming no changes; 'result' points to the original 'target'.
	local result: T = target
	-- Tracks if 'result' has been shallow copied from 'target' at the current level.
	local hasBeenCopied = false

	-- Pass 1: Iterate over 'source' keys to update or add to 'target'.
	-- This pass applies 'source's state onto 'target'.
	for key, sourceValue in source :: any do
		local targetValue = (target :: any)[key]

		if typeof(sourceValue) == "table" then
			local sourceTableValue = sourceValue :: T

			if typeof(targetValue) == "table" then
				local targetTableValue = targetValue :: T
				-- Recursively reconcile the sub-tables.
				local reconciledSubTable = reconcileDeep(targetTableValue, sourceTableValue)

				-- If the recursive call returned a new table instance for the sub-table,
				-- it means a change occurred at a deeper level.
				if reconciledSubTable ~= targetTableValue then
					if not hasBeenCopied then
						-- First change at this level requiring 'target' to be copied.
						result = table.clone(target :: any) :: any
						hasBeenCopied = true
					end
					(result :: any)[key] = reconciledSubTable
				end
			else
				-- 'targetValue' is not a table (or is nil), but 'sourceValue' is a table.
				-- This is an overwrite or an addition of a new table.
				-- Use 'sourceTableValue's reference directly.
				-- This always constitutes a change unless targetValue was already identically sourceTableValue (rare).
				if not hasBeenCopied then
					result = table.clone(target :: any) :: any
					hasBeenCopied = true
				end
				(result :: any)[key] = sourceTableValue
			end
		else
			-- 'sourceValue' is a primitive (number, string, boolean).
			-- (Note: nil sourceValue means key is absent from source, handled by Pass 2 for deletions)
			-- A change is needed if 'targetValue' is different from 'sourceValue'.
			if targetValue ~= sourceValue then
				if not hasBeenCopied then
					result = table.clone(target :: any) :: any
					hasBeenCopied = true
				end
				(result :: any)[key] = sourceValue
			end
		end
	end

	-- Pass 2: Iterate over original 'target's keys to handle deletions.
	-- If a key was in 'target' but is not in 'source', it should be removed from 'result'.
	-- ('source' is non-empty here).
	for keyInTarget in target :: any do
		if (source :: any)[keyInTarget] == nil then -- Key is in 'target' but absent in 'source'.
			if not hasBeenCopied then
				-- This deletion is the first change requiring 'target' to be copied.
				result = table.clone(target :: any) :: any
				hasBeenCopied = true
			end
			-- Remove the key from 'result' by setting its value to nil.
			(result :: any)[keyInTarget] = nil
		end
	end

	-- If 'hasBeenCopied' is false, no merging operations (updates, additions, or deletions)
	-- resulted in any change to 'target' at this level. The original 'target' is returned.
	-- Otherwise, 'result' (the shallow copy with reconciled changes) is returned.
	return result
end

return {
	copyDeep = copyDeep,
	mergeDeep = mergeDeep,
	mergeShallow = mergeShallow,
	equalsDeep = equalsDeep,
	freezeDeep = freezeDeep,
	map = map,
	reconcileDeep = reconcileDeep,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="107">
              <Properties>
                <string name="Name">Transactions</string>
                <string name="Source"><![CDATA[--[=[
	@class Transactions
	@private

	Provides functionality for reading data that might be involved in an ongoing,
	uncommitted transaction initiated by `Store:tx()`.

	:::note
	This module only contains the implementation for [Transactions.readTx]. Writing transactions is handled in [Store:tx]
	:::

	**Purpose:** When a `Store:tx()` operation begins, it might involve multiple steps
	(e.g., reading current data, applying changes, writing back). If a server crashes
	*before* the transaction is fully committed or rolled back, this module helps
	determine the correct state to return.

	It checks the status of the transaction ID (`txId`) stored separately in the DataStore.
	If the transaction is still pending (represented as `false`) or has failed, it returns the last known
	*committed* data. If the transaction has successfully committed (represented as `nil`), it applies the
	transaction's patch (`txPatch`) to the previously committed data (`committedData`)
	to return the *newly* committed state.

	This ensures that readers either get the stable state before the transaction or the
	final state after a successful transaction, avoiding inconsistent intermediate states.
]=]

local JsonPatch = require(script.Parent.JsonPatch)
local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Promise)
local dataStoreRetry = require(script.Parent.dataStoreRetry)

--[=[
	Parameters required for the `readTx` function.

	@interface ReadTxParams
	@within Transactions
	.store DataStore -- The DataStore instance where transaction status markers are stored.
	.txInfo Types.TxInfo -- The transaction information associated with the data being read.
]=]
export type ReadTxParams = {
	store: DataStore,
	txInfo: Types.TxInfo,
}

-- We never want to read a cached value for a transaction marker.
local getOptions = Instance.new("DataStoreGetOptions")
getOptions.UseCache = false

--[=[
	Reads data, considering the status of an associated transaction.

	Checks the status of the transaction ID (`txInfo.txId`) in the DataStore.
	- If `txId` is nil (meaning no transaction was associated or it was cleaned up),
	  returns the `committedData` directly.
	- If `txId` exists:
		- Fetches the status from the DataStore using the `txId` as the key.
		- **Status Convention:**
			- `nil`: The transaction successfully committed. The corresponding `txPatch`
			  should be applied to `committedData`.
			- `false`: The transaction is still in progress or failed/rolled back. The
			  `committedData` (state before the transaction) should be returned.
		- Applies the patch if the status is `nil` and a patch exists.
		- Returns `committedData` if the status is `false`.

	Using `nil` to indicate a successful transaction allows for easier cleanup of
	transaction markers in the DataStore. Instead of setting the marker to `true`
	and only removing it after the `txId` is no longer needed, we can simply delete
	the marker immediately after a successful transaction.

	@within Transactions
	@param params ReadTxParams -- The parameters for the read operation.
	@return Promise<any> -- A Promise that resolves with the appropriate data (either committed or patched).
	@error string -- Rejects if the transaction status indicates commitment (`nil`) but the `txPatch` is missing, or if DataStore operations fail (via `dataStoreRetry`). Propagates errors from `DataStore:GetAsync` via `dataStoreRetry`.
]=]
local function readTx(params: ReadTxParams): Promise.TPromise<any>
	local txInfo = params.txInfo

	-- If there's no transaction ID, the data is simply the last committed state.
	local txId = txInfo.txId
	if txId == nil then
		return Promise.resolve(txInfo.committedData)
	end

	-- Fetch the transaction status marker from the DataStore using the txId.
	return dataStoreRetry(function()
		return params.store:GetAsync(txId, getOptions)
	end):andThen(function(txStatus)
		-- Check the transaction status using the nil/false convention.
		-- `nil` means the transaction successfully committed.
		-- `false` means it's pending or failed (rolled back).
		-- This convention avoids the need to set the marker to `true` after a
		-- successful transaction, allowing for immediate cleanup of the marker.
		if txStatus == nil then
			-- Transaction committed successfully. Apply the patch.
			if txInfo.txPatch == nil then
				-- This indicates an inconsistent state - committed but no changes recorded.
				return Promise.reject(`Transaction '{txId}' is committed but has no patch`)
			end
			-- Apply the patch to the data that was committed *before* this transaction.
			return JsonPatch.applyPatch(txInfo.committedData, txInfo.txPatch)
		else
			-- Transaction is pending or failed. Return the data as it was *before* this transaction.
			return txInfo.committedData
		end
	end)
end

return {
	readTx = readTx,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="108">
              <Properties>
                <string name="Name">Types</string>
                <string name="Source"><![CDATA[--[=[
	@class Types
	@private

	Common types shared among different modules.
]=]

local Log = require(script.Parent.Log)
local t = require(script.Parent.Parent:WaitForChild("t").lib.ts).t

--[=[
	Represents a single operation within a JSON Patch array.
	Used for describing changes between data states.

	@interface PatchOperation
	@within Types
	.op "add" | "replace" | "remove" -- The operation type.
	.path string -- A JSON Pointer string indicating the target location.
	.value any? -- The value to add or replace (used for "add" and "replace"). Optional for "remove".
]=]
export type PatchOperation =
	{ op: "add", path: string, value: any }
	| { op: "replace", path: string, value: any }
	| { op: "remove", path: string }

--[=[
	An array of PatchOperation objects representing the changes made during a transaction.

	@type TxPatch { PatchOperation }
	@within Types
]=]
export type TxPatch = { PatchOperation }

--[=[
	Holds information about the state of data potentially involved in a transaction.
	Used by the `Transactions` module to determine the correct data to return during reads.

	@interface TxInfo
	@within Types
	.committedData any -- The last known data state that was successfully saved to the primary DataStore record *before* the transaction identified by `txId` began.
	.txId string? -- The unique identifier of the transaction currently attempting to modify this data. If `nil`, no transaction is active or the last one completed and was cleaned up.
	.txPatch TxPatch? -- The set of changes (JSON Patch) applied by the transaction identified by `txId`. This is used to reconstruct the final state if the transaction is confirmed as committed.
]=]
export type TxInfo = {
	committedData: any,
	txId: string?,
	txPatch: TxPatch?,
}

--[=[
	Represents the stored data, abstracting away the sharding mechanism.

	If the data was small enough, it's stored directly in the `data` field.
	If the data was large and sharded, `shard` and `count` are present instead,
	pointing to the location and number of data shards stored separately.

	@interface File
	@within Types
	.data any? -- The actual data, if it was stored directly (not sharded). Mutually exclusive with `shard` and `count`.
	.shard string? -- The unique identifier for the set of shards, if the data was sharded. Mutually exclusive with `data`.
	.count number? -- The total number of shards, if the data was sharded. Mutually exclusive with `data`.
]=]
export type File = {
	data: any,
} & {
	shard: string,
	count: number,
}

--[=[
	The structure of the primary record stored in the main DataStore for each key.
	This record contains metadata and a reference (`File`) to the actual user data.

	@interface DataStoreRecord
	@within Types
	.appliedMigrations {string} -- A list of names of migration steps that have already been successfully applied to the data associated with this record. Initialized as empty.
	.file File -- A `File` object representing the actual user data. This might contain the data directly or point to shards.
	.orphanedFiles {File} -- A list of sharded `File` objects that are no longer referenced by any active record. This is used for cleanup and garbage collection of unused data. Initialized as empty.
]=]
export type DataStoreRecord = {
	appliedMigrations: { string },
	file: File,
	orphanedFiles: { File },
}

--[=[
	Represents a migration step that can be applied to data when loading it.
	Each step has a name and an `apply` function that takes the data as input
	and returns a modified version of the data.

	@interface MigrationStep
	@within Types
	.name string -- The unique name of the migration step.
	.apply (data: { [string]: any }) -> { [string]: any } -- The function that transforms the data for this step.
]=]
export type MigrationStep = {
	name: string,
	apply: (data: { [string]: any }) -> { [string]: any },
}

--[=[
	Contains all the contextual information and dependencies required for a `Store`
	or `PlayerStore` instance to operate. This includes configuration, service instances,
	callbacks, and underlying storage objects.

	@interface StoreContext<T>
	@within Types
	.name string -- The name of the store, used for logging and potentially identifying DataStore keys.
	.template T -- A default template object representing the initial state for new data entries.
	.schema (value: any) -> (boolean, string?) -- A validation function (like one created by `t`) used to check if loaded or modified data conforms to the expected structure. Returns `true` if valid, or `false` and an error message string if invalid.

	.migrationSteps {MigrationStep} -- A list of migration steps to apply to data when it's loaded, based on the `appliedMigrations` field in the `DataStoreRecord`. Initialized as empty.
	.importLegacyData ((key: string) -> any?)? -- An optional function to load data from a legacy storage system when a key is accessed for the first time in this store.

	.dataStoreService DataStoreService -- The Roblox DataStoreService instance.
	.memoryStoreService MemoryStoreService -- The Roblox MemoryStoreService instance.

	.changedCallbacks { (key: string, newData: T, oldData: T?) -> () } -- A list of functions to call whenever data for a key is successfully changed. Provides the key, the new data state, and the previous data state (if available). Initialized as empty.
	.logger Logger -- A `Logger` instance used for internal logging within the store and its components.
	.onLockLost ((key: string) -> ())? -- An optional callback function triggered if the distributed lock for a key is lost unexpectedly (e.g., due to expiration or external interference).

	.recordStore DataStore -- The DataStore used to store `DataStoreRecord` objects.
	.shardStore DataStore -- The DataStore used to store the actual data shards for large files.
	.txStore DataStore -- The DataStore used to store transaction status markers (`txId` keys).
	.lockHashMap MemoryStoreHashMap -- The MemoryStore HashMap used for managing distributed locks.
]=]
export type StoreContext<T> = {
	name: string,
	template: T,
	schema: (value: any) -> (boolean, string?),

	migrationSteps: { MigrationStep },
	importLegacyData: ((key: string) -> any?)?,

	dataStoreService: DataStoreService,
	memoryStoreService: MemoryStoreService,

	changedCallbacks: { (key: string, newData: T, oldData: T?) -> () },
	logger: Log.Logger,
	onLockLost: ((key: string) -> ())?,

	recordStore: DataStore,
	shardStore: DataStore,
	txStore: DataStore,
	lockHashMap: MemoryStoreHashMap,
}

-- Validation check for TxInfo structure using 't' library.
local txInfoCheck = t.some(
	t.strictInterface({ committedData = t.any }),
	t.strictInterface({ committedData = t.any, txId = t.string, txPatch = t.any })
)
-- Validation check for File structure using 't' library.
local fileCheck = t.some(t.strictInterface({ data = t.any }), t.strictInterface({ shard = t.string, count = t.number }))

--[=[
	A handle returned by retry utility functions like `hashMapRetry`.
	It bundles the core Promise with a way to cancel the retry operation.

	When the `cancel` function is called, instead of cancelling the Promise itself,
	the retry mechanism is stopped, and the Promise is rejected with a cancellation error
	when the next retry attempt is made.

	@interface RetryHandle<T>
	@within Types
	.promise T -- The Promise representing the asynchronous operation being retried. This promise resolves or rejects based on the outcome of the operation after retries.
	.cancel () -> () -- A function that can be called to signal cancellation. If called, the retry mechanism will stop further attempts and reject the `promise`.
]=]
export type RetryHandle<T> = {
	promise: T,
	cancel: () -> (),
}

return {
	txInfoCheck = txInfoCheck,
	fileCheck = fileCheck,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="109">
              <Properties>
                <string name="Name">dataStoreRetry</string>
                <string name="Source"><![CDATA[--[=[
	@class dataStoreRetry
	@private

	Provides a utility function to wrap Roblox DataStore API calls with automatic
	retries for specific, commonly transient error codes.

	**Purpose:** DataStore operations can sometimes fail due to temporary service issues,
	throttling, or internal errors. This module implements a retry mechanism with
	exponential backoff to increase the likelihood of success for operations that
	encounter these transient failures.

	**Usage:**
	```lua
	local DataStoreService = game:GetService("DataStoreService")
	local dataStoreRetry = require(script.Parent.dataStoreRetry)
	local myStore = DataStoreService:GetDataStore("MyStore")

	dataStoreRetry(function()
		-- This function will be retried automatically on specific errors
		return myStore:GetAsync("MyKey")
	end):andThen(function(data)
		print("Successfully retrieved data:", data)
	end):catch(function(err)
		warn("Failed to get data after retries:", err)
	end)
	```
]=]

local Promise = require(script.Parent.Promise)

-- Maximum number of times to attempt the operation before giving up.
local MAX_RETRIES = 5

--[[
	List of DataStore error codes that are considered potentially transient and
	worth retrying. These generally indicate temporary issues like internal server
	errors, throttling, or temporary unavailability.

	Refer to the Roblox Creator Documentation for details on specific DataStore error codes:
	https://create.roblox.com/docs/cloud-services/data-stores/error-codes-and-limits
]]
local RETRY_ERROR_CODES = {
	-- 3xx: Throttling errors (indicating the request was throttled and dropped due to a full queue)
	301, -- 301: GetAsyncThrottle
	302, -- 302: SetAsyncThrottle
	303, -- 303: IncreAsyncThrottle
	304, -- 304: UpdateAsyncThrottle / TransformThrottle
	305, -- 305: GetSortedThrottle
	306, -- 306: RemoveAsyncThrottle

	-- 5xx: Server errors (most likely to be transient)
	500, -- 500: Undocumented, included for completeness.
	501, -- 501: InternalError - Can't parse response because data might be corrupted.
	502, -- 502: RequestRejected - Error occurred when processing on Roblox servers.
	503, -- 503: InternalError - Request was successful but key wasn't found.
	504, -- 504: InternalError - Request was successful but the response wasn't formatted correctly.
	505, -- 505: InternalError - OrderedDataStore request was successful but the response wasn't formatted correctly.
	-- Note: Other errors (e.g., 4xx permission errors, 1xx argument errors) are generally not transient
	-- and are not retried by default.
}

--[=[
	Wraps a function that performs a DataStore operation, automatically retrying it
	if it fails with specific transient error codes.

	Implements an exponential backoff strategy: waits 1s, 2s, 4s, 8s between retries.

	@within dataStoreRetry
	@param func () -> T -- The function to execute and potentially retry. This function should perform the desired DataStore operation (e.g., `GetAsync`, `SetAsync`, `UpdateAsync`). It should return the result of the operation on success or throw an error on failure.
	@return Promise<T> -- A Promise that resolves with the return value of `func` if it succeeds within `MAX_RETRIES` attempts.
	@error string -- Rejects with the error message if `func` fails with a non-retriable error code, or if it fails with a retriable error code `MAX_RETRIES` times.
]=]
local function dataStoreRetry<T>(func: () -> T): Promise.TPromise<T>
	return Promise.new(function(resolve, reject)
		local lastError -- Store the last retriable error encountered
		for i = 1, MAX_RETRIES do
			-- Apply exponential backoff delay before retrying (starting from the second attempt)
			if i > 1 then
				-- Wait times: 2^0=1s, 2^1=2s, 2^2=4s, 2^3=8s
				local retryAfter = 2 ^ (i - 1)
				task.wait(retryAfter)
			end

			-- Execute the provided function within a protected call
			local result = table.pack(pcall(func)) :: any -- { success: boolean, ...results | error: string }
			if result[1] == true then
				-- Success! Resolve the promise with the function's return values.
				return resolve(table.unpack(result, 2))
			end

			-- Failure. Extract the error message and attempt to parse the error code.
			local errorMessage = result[2]
			local errorCode = errorMessage:match("^(%d+):") -- Match code at the beginning (e.g., "502: API Services...")
			errorCode = if errorCode then tonumber(errorCode) else nil

			-- Check if the error code is in the list of retriable codes.
			if errorCode ~= nil and table.find(RETRY_ERROR_CODES, errorCode) then
				-- Retriable error. Store it and continue the loop for the next attempt.
				lastError = errorMessage
				continue
			else
				-- Non-retriable error or failed to parse code. Reject immediately.
				return reject(errorMessage)
			end
		end
		-- If the loop completes, it means MAX_RETRIES were reached without success.
		return reject(`DataStore error: too many retries ({MAX_RETRIES}). Last error: {lastError}`)
	end) :: any
end

return dataStoreRetry
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="110">
              <Properties>
                <string name="Name">hashMapRetry</string>
                <string name="Source"><![CDATA[--[=[
	@class hashMapRetry
	@private

	Provides a utility function to wrap Roblox MemoryStoreService HashMap API calls
	(like `GetAsync`, `SetAsync`, `UpdateAsync`) with automatic retries for specific,
	commonly transient error conditions identified by error message strings.

	**Purpose:** Similar to [dataStoreRetry], MemoryStore operations can fail due to
	temporary service issues, throttling, or internal errors. This module implements
	a retry mechanism with exponential backoff to handle these transient failures.
	It differs from [dataStoreRetry] by matching against error *strings* rather than
	numeric codes, as MemoryStore errors often manifest this way. It also includes
	a cancellation mechanism.

	**Usage:**
	```lua
	local MemoryStoreService = game:GetService("MemoryStoreService")
	local hashMapRetry = require(script.Parent.hashMapRetry)
	local myMap = MemoryStoreService:GetHashMap("MyMap")

	local handle = hashMapRetry(function()
		-- This function will be retried automatically on specific errors
		return myMap:GetAsync("MyKey")
	end)

	handle.promise:andThen(function(data)
		print("Successfully retrieved data:", data)
	end):catch(function(err)
		warn("Failed to get data after retries or cancelled:", err)
	end)

	-- To cancel the operation:
	-- handle.cancel()
	```
]=]

local Promise = require(script.Parent.Promise)
local Types = require(script.Parent.Types)

-- Maximum number of times to attempt the operation before giving up.
local MAX_RETRIES = 5

--[[
	List of error message substrings that indicate potentially transient MemoryStore
	errors worth retrying. These are based on observed errors and common failure modes
	like throttling and internal issues. Unlike DataStores, MemoryStore often reports
	errors via strings rather than distinct numeric codes.

	Refer to Roblox Creator Documentation for MemoryStore limits and potential issues:
	https://create.roblox.com/docs/cloud-services/memory-stores#observability
	(Note: Specific error message strings may not be exhaustively documented.)
]]
local RETRY_ERROR_CODES = {
	"TotalRequestsOverLimit", -- Exceeds universe-level request unit limit.
	"InternalError", -- Generic internal server error.
	"RequestThrottled", -- Recent MemoryStores requests hit one or more limits.
	"PartitionRequestsOverLimit", -- Exceeds partition request unit limit.
	"Throttled", -- Undocumented, included for completeness.
	"Timeout", -- Undocumented, included for completeness.
}

--[=[
	Wraps a function that performs a MemoryStore HashMap operation, automatically
	retrying it if it fails with specific transient error message substrings.

	Implements an exponential backoff strategy: waits 1s, 2s, 4s, 8s between retries.
	Includes a cancellation mechanism via the returned [RetryHandle].

	@within hashMapRetry
	@param func () -> any -- The function to execute and potentially retry. This function should perform the desired MemoryStore HashMap operation (e.g., `GetAsync`, `SetAsync`, `UpdateAsync`). It should return the result on success or throw an error on failure.
	@return RetryHandle<Promise<any>> -- A handle containing: `promise` (A Promise that resolves with the return value of `func` if it succeeds within `MAX_RETRIES` attempts) and `cancel` (A function that, when called, attempts to stop further retries and rejects the promise).
	@error string -- Rejects if `func` fails with a non-retriable error, if it fails with a retriable error `MAX_RETRIES` times, or if `cancel()` is called.
]=]
local function hashMapRetry(func: () -> any): Types.RetryHandle<Promise.TPromise<any>>
	local cancel = false

	local handle: Types.RetryHandle<Promise.TPromise<any>> = {
		promise = Promise.new(function(resolve, reject)
			local lastError
			for i = 1, MAX_RETRIES do
				-- Apply exponential backoff delay before retrying (starting from the second attempt)
				-- Only wait if the operation hasn't been cancelled.
				if i > 1 and not cancel then
					-- Wait times: 2^0=1s, 2^1=2s, 2^2=4s, 2^3=8s
					local retryAfter = 2 ^ (i - 1)
					task.wait(retryAfter)
				end

				if cancel then
					return reject(`HashMap error: operation cancelled`)
				end

				local result = table.pack(pcall(func)) -- { success: boolean, ...results | error: string }
				if result[1] == true then
					-- Success! Resolve the promise with the function's return values.
					return resolve(table.unpack(result, 2))
				end

				-- Failure. Store the error message.
				lastError = result[2]

				-- Check if the error message contains any of the retriable substrings.
				local retry = false
				for _, errorCodeSubstring in RETRY_ERROR_CODES do
					if lastError:find(errorCodeSubstring, 1, true) then
						retry = true
						break
					end
				end

				-- If the error is retriable, continue to the next iteration (if not cancelled).
				if retry then
					continue
				end

				-- Non-retriable error. Reject immediately.
				return reject(`HashMap error: {lastError}`)
			end
			-- If the loop completes, it means MAX_RETRIES were reached without success.
			-- Check for cancellation one last time before rejecting due to retries.
			if cancel then
				return reject(`HashMap error: operation cancelled`)
			else
				return reject(`HashMap error: too many retries ({MAX_RETRIES}). Last error: {lastError}`)
			end
		end),
		cancel = function()
			cancel = true
		end,
	}

	return handle
end

return hashMapRetry
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="111">
              <Properties>
                <string name="Name">noYield</string>
                <string name="Source"><![CDATA[--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co: thread, ok: boolean, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "attempt to yield"), 2)
	end

	return ...
end

local function noYield<Input..., Output...>(callback: (Input...) -> Output..., ...: Input...): Output...
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return noYield
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="112">
            <Properties>
              <string name="Name">maid</string>
            </Properties>
            <Item class="ModuleScript" referent="113">
              <Properties>
                <string name="Name">Maid</string>
                <string name="Source"><![CDATA[---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = {}

	self._tasks = {}

	return setmetatable(self, Maid)
end

--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (thread)           Manages a thread
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("Cannot use '%s' as a Maid key"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
        	return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif type(oldTask) == "thread" then
			local cancelled
			if coroutine.running() ~= oldTask then
				cancelled = pcall(function()
					task.cancel(oldTask)
				end)
			end

			if not cancelled then
				task.defer(function()
					task.cancel(oldTask)
				end)
			end
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in pairs(tasks) do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if type(job) == "function" then
			job()
		elseif type(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				local toCancel = job
				task.defer(function()
					task.cancel(toCancel)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif job.Destroy then
			job:Destroy()
		end
		index, job = next(tasks)
	end
end

--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="114">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	bugs = {
		url = "https://github.com/osyrisrblx/rbxts-maid/issues",
	},
	description = "Quenty's Maid class with types!",
	devDependencies = {
		["@rbxts/types"] = "^1.0.680",
	},
	files = {"Maid.d.ts", "Maid.lua"},
	homepage = "https://github.com/osyrisrblx/rbxts-maid#readme",
	keywords = {},
	license = "ISC",
	main = "Maid.lua",
	name = "@rbxts/maid",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/osyrisrblx/rbxts-maid.git",
	},
	scripts = {
	},
	types = "Maid.d.ts",
	version = "1.1.0",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="115">
            <Properties>
              <string name="Name">object-utils</string>
              <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Object = {}

function Object.keys(object)
	local result = table.create(#object)
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function Object.values(object)
	local result = table.create(#object)
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function Object.entries(object)
	local result = table.create(#object)
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function Object.assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

function Object.copy(object)
	local result = table.create(#object)
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = table.create(#object)
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

function Object.deepCopy(object)
	return deepCopyHelper(object, {})
end

function Object.deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Object.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(data)
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.fromEntries(entries)
	local entriesLen = #entries

	local result = table.create(entriesLen)
	if entries then
		for i = 1, entriesLen do
			local pair = entries[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

return Object
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="116">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	bugs = {
		url = "https://github.com/roblox-ts/rbxts-object-utils/issues",
	},
	description = "Polyfills for Object functions",
	devDependencies = {
		["@rbxts/types"] = "^1.0.423",
		["@typescript-eslint/eslint-plugin"] = "^4.8.2",
		["@typescript-eslint/parser"] = "^4.8.2",
		eslint = "^7.14.0",
		["eslint-config-prettier"] = "^6.15.0",
		["eslint-plugin-prettier"] = "^3.1.4",
		prettier = "^2.2.0",
		typescript = "^4.1.2",
	},
	files = {"init.lua", "index.d.ts"},
	homepage = "https://github.com/roblox-ts/rbxts-object-utils#readme",
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/object-utils",
	repository = {
		type = "git",
		url = "https://github.com/roblox-ts/rbxts-object-utils.git",
	},
	scripts = {
	},
	typings = "index.d.ts",
	version = "1.0.4",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="117">
            <Properties>
              <string name="Name">pretty-format</string>
            </Properties>
            <Item class="ModuleScript" referent="118">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "littensy",
	bugs = {
		url = "https://github.com/littensy/rbxts-jest/issues",
	},
	dependencies = {
		["@rbxts-js/pretty-format"] = "^3.13.2-ts.3",
	},
	description = "PrettyFormat bindings for Roblox",
	files = {"src", "default.project.json"},
	keywords = {"roblox", "typescript", "roblox-ts"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/pretty-format",
	repository = {
		type = "git",
		url = "git+https://github.com/littensy/rbxts-jest.git",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "3.13.2-alpha.1",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="119">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[return require(script.Parent.Parent.Parent:WaitForChild("@rbxts-js").PrettyFormat)
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="120">
            <Properties>
              <string name="Name">services</string>
              <string name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="121">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "",
	description = "",
	devDependencies = {
		["@rbxts/compiler-types"] = "^2.0.0-types.0",
		["@rbxts/types"] = "^1.0.804",
	},
	files = {"init.lua", "index.d.ts", "plugin.d.ts"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/services",
	scripts = {
	},
	typings = "index.d.ts",
	version = "1.5.5",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="122">
            <Properties>
              <string name="Name">signal</string>
              <string name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({ Bindable = Instance.new("BindableEvent") }, Signal)
end

function Signal:Connect(Callback)
	return self.Bindable.Event:Connect(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Once(Callback)
	return self.Bindable.Event:Once(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:ConnectParallel(Callback)
	return self.Bindable.Event:ConnectParallel(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Fire(...)
	local Arguments = { ... }
	local n = select("#", ...)

	self.Bindable:Fire(function()
		return table.unpack(Arguments, 1, n)
	end)
end

function Signal:Wait()
	return self.Bindable.Event:Wait()()
end

function Signal:Destroy()
	self.Bindable:Destroy()
end

return Signal
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="123">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	description = "BindableEvent wrapper which passes values by reference",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.3.3-types.1",
		["@rbxts/types"] = "^1.0.640",
	},
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/signal/README.md",
	keywords = {"Roblox", "TypeScript", "Signal", "BindableEvent", "Bindable", "Bind"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/signal",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/signal",
	},
	scripts = {
		test = "echo \"Error: no test specified\" &amp;&amp; exit 1",
	},
	types = "index.d.ts",
	version = "1.1.1",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="124">
            <Properties>
              <string name="Name">t</string>
            </Properties>
            <Item class="Folder" referent="125">
              <Properties>
                <string name="Name">lib</string>
              </Properties>
              <Item class="ModuleScript" referent="126">
                <Properties>
                  <string name="Name">ts</string>
                  <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is any of the given literal values

	@param literals The literals to check against

	@returns A function that will return true if the condition is passed
**--]]
function t.literalList(literals)
	-- optimization for primitive types
	local set = {}
	for _, literal in ipairs(literals) do
		set[literal] = true
	end
	return function(value)
		if set[value] then
			return true
		end
		for _, literal in ipairs(literals) do
			if literal == value then
				return true
			end
		end

		return false
	end
end

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.unionList(literals)
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param checks The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.unionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		return t.unionList({ ... })
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param checks The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersectionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		return t.intersectionList({ ... })
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="127">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "osyris",
	bugs = {
		url = "https://github.com/osyrisrblx/t/issues",
	},
	description = "A Runtime Type Checker for Roblox",
	devDependencies = {
		["@rbxts/compiler-types"] = "^3.0.0-types.0",
		["@rbxts/types"] = "^1.0.837",
	},
	files = {"lib/ts.lua", "lib/t.d.ts"},
	homepage = "https://github.com/osyrisrblx/t#readme",
	keywords = {},
	license = "ISC",
	main = "lib/ts.lua",
	name = "@rbxts/t",
	repository = {
		type = "git",
		url = "git+https://github.com/osyrisrblx/t.git",
	},
	types = "lib/t.d.ts",
	version = "3.2.1",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="128">
            <Properties>
              <string name="Name">types</string>
            </Properties>
            <Item class="Folder" referent="129">
              <Properties>
                <string name="Name">include</string>
              </Properties>
              <Item class="Folder" referent="130">
                <Properties>
                  <string name="Name">generated</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="131">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "roblox-ts",
	bugs = {
		url = "https://github.com/roblox-ts/types/issues",
	},
	dependencies = {
	},
	description = "TypeScript typings for the Roblox platform. Partially handwritten and partially automatically generated.",
	homepage = "https://github.com/roblox-ts/types#readme",
	keywords = {"types", "Roblox", "typescript"},
	license = "MIT",
	main = "include/roblox.d.ts",
	name = "@rbxts/types",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/types.git",
	},
	scripts = {
	},
	types = "include/roblox.d.ts",
	version = "1.0.864",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="132">
            <Properties>
              <string name="Name">ui-labs</string>
            </Properties>
            <Item class="ModuleScript" referent="133">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "PepeElToro",
	dependencies = {
	},
	description = "Utilities for UI-Labs, a storybook-like plugin for roblox",
	devDependencies = {
		["@rbxts/compiler-types"] = "2.1.0-types.1",
		["@rbxts/fusion"] = "*",
		["@rbxts/iris"] = "*",
		["@rbxts/react"] = "*",
		["@rbxts/react-roblox"] = "*",
		["@rbxts/roact"] = "*",
		["@rbxts/services"] = "^1.5.1",
		["@rbxts/types"] = "^1.0.704",
		["@rbxts/vide"] = "*",
		["@typescript-eslint/eslint-plugin"] = "^5.61.0",
		["@typescript-eslint/parser"] = "^5.61.0",
		eslint = "^8.44.0",
		["eslint-config-prettier"] = "^8.8.0",
		["eslint-plugin-prettier"] = "^4.2.1",
		["eslint-plugin-roblox-ts"] = "^0.0.35",
		prettier = "^2.8.8",
		["roblox-ts"] = "^2.2.0",
		typescript = "^4.9.4",
	},
	files = {"src", "!**/*.tsbuildinfo", "!**/*.spec.lua", "!build.rbxm"},
	keywords = {"uilabs", "ui-labs", "storybook", "flipbook", "hoarcekat", "ui", "gui", "roact", "react", "roblox-ts", "rbxts"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/ui-labs",
	publishConfig = {
		access = "public",
	},
	scripts = {
		serve = "rojo serve test/default.project.json",
		watch = "rbxtsc -w --type=game -p test -i test/include",
	},
	types = "src/index.d.ts",
	version = "2.4.0",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="134">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[local PrimitiveControls = require(script.Controls.PrimitiveControls)
local DatatypeControls = require(script.Controls.DatatypeControls)
local AdvancedControls = require(script.Controls.AdvancedControls)
local StoryCreators = require(script.StoryCreators)
local ControlUtils = require(script.Controls.ControlUtils)
local ControlConversion = require(script.Controls.ControlConversion)
local Utils = require(script.Utils)
local Environment = require(script.Environment)
local Types = require(script.Types)
local Version = require(script.Version)

export type Storybook = Types.Storybook
export type FunctionStory = Types.FunctionStory
export type ReactStory = Types.ReactStory
export type RoactStory = Types.RoactStory
export type FusionStory = Types.FusionStory
export type IrisStory = Types.IrisStory
export type VideStory = Types.VideStory
export type GenericStory = Types.GenericStory

export type ReactProps = Types.ReactProps
export type FusionProps = Types.FusionProps
export type IrisProps = Types.IrisProps
export type VideProps = Types.VideProps
export type GenericProps = Types.GenericProps
export type GenericInfo<T> = Types.GenericInfo<T>
export type SubscribeListener = Types.SubscribeListener

local UILabs = {
	_version = Version,
	Boolean = PrimitiveControls.Boolean,
	Number = PrimitiveControls.Number,
	String = PrimitiveControls.String,

	Choose = AdvancedControls.Choose,
	EnumList = AdvancedControls.EnumList,
	Object = AdvancedControls.Object,
	RGBA = AdvancedControls.RGBA,
	Slider = AdvancedControls.Slider,

	Primitive = PrimitiveControls.Primitive,
	Advanced = AdvancedControls,
	Datatype = DatatypeControls,

	ListenControl = Utils.ListenControl,
	CreateControlStates = Utils.CreateControlStates,
	UpdateControlStates = Utils.UpdateControlStates,

	ControlGroup = ControlUtils.ControlGroup,
	Ordered = ControlUtils.Ordered,

	ConvertControl = ControlConversion.ConvertControl,

	CreateGenericStory = StoryCreators.CreateGenericStory,
	CreateReactStory = StoryCreators.CreateReactStory,
	CreateRoactStory = StoryCreators.CreateRoactStory,
	CreateFusionStory = StoryCreators.CreateFusionStory,
	CreateIrisStory = StoryCreators.CreateIrisStory,
	CreateVideStory = StoryCreators.CreateVideStory,

	Environment = Environment,
}

return UILabs
]]></string>
              </Properties>
              <Item class="Folder" referent="135">
                <Properties>
                  <string name="Name">ControlTypings</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="136">
                <Properties>
                  <string name="Name">Controls</string>
                </Properties>
                <Item class="ModuleScript" referent="137">
                  <Properties>
                    <string name="Name">AdvancedControls</string>
                    <string name="Source"><![CDATA[type RecordList<T> = { [string]: T }

local Utils = require(script.Parent.Utils)
local CreateBaseControl = Utils.CreateBaseControl
local Controls = {}

function Controls.Choose<T>(list: { T }, def: number?): Utils.Control<T>
	if #list <= 0 then
		error("UI-Labs: Array given in a Choose control is empty")
	end
	if def and def > #list then
		error(`UI-Labs: Def index ({def}) given for the array is outside of the array size ({#list})`)
	end

	local control = CreateBaseControl("Choose", list[def or 1])
	control.List = list
	control.DefIndex = def or 1

	return control
end

function Controls.EnumList<T>(list: RecordList<T>, def: string): Utils.Control<T>
	if list[def] == nil then
		error(`UI-Labs: Key given for the EnumList list ({def}) does not exist in the list`)
	end

	local control = CreateBaseControl("EnumList", list[def])
	control.List = list
	control.DefIndex = def

	return control
end

function Controls.RGBA(def: Color3, transparency: number?): Utils.Control<{ Color: Color3, Transparency: number }>
	return CreateBaseControl("RGBA", {
		Color = def,
		Transparency = transparency or 0,
	})
end

function Controls.Slider(def: number, min: number, max: number, step: number?): Utils.Control<number>
	if max <= min then
		error(`UI-Labs: Max slider value ({max}) must be greater than the Min value ({min})`)
	end
	local control = CreateBaseControl("Slider", def)

	control.Min = min
	control.Max = max
	control.Step = step

	return control
end

type ObjectPredicator = (instance: Instance) -> boolean

function Controls.Object(className: string?, def: Instance?, predicator: ObjectPredicator?): Utils.Control<Instance?>
	local control = CreateBaseControl("Object", def)
	control.ClassName = className or "Instance"
	control.Predicator = predicator

	return control
end

-- [[ TYPES ]] --

return Controls
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="138">
                  <Properties>
                    <string name="Name">ControlConversion</string>
                    <string name="Source"><![CDATA[local Primitive = require(script.Parent.PrimitiveControls).Primitive
local Datatype = require(script.Parent.DatatypeControls)

local ControlConversion = {}

local function ConvertPrimitive(value: any, primitive: string)
	local converter = Primitive[primitive]

	assert(converter, `UI-Labs: Primitive ({primitive}) can't be converted to a control`)
	return converter(value)
end

local function ConvertDatatype(value: any, datatype: string)
	local converter = Datatype[datatype]

	assert(converter, `UI-Labs: Datatype ({datatype}) can't be converted to a control`)
	return converter(value)
end

function ControlConversion.ConvertControl(control: any)
	local controlType = typeof(control)

	if controlType == "table" then
		return control
	end

	if Primitive[controlType] then
		return ConvertPrimitive(control, controlType)
	elseif Datatype[controlType] then
		return ConvertDatatype(control, controlType)
	else
		error(`UI-Labs: Control ({control}) is not a valid control`)
	end
end

return ControlConversion
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="139">
                  <Properties>
                    <string name="Name">ControlUtils</string>
                    <string name="Source"><![CDATA[local ControlConversion = require(script.Parent.ControlConversion)
local ControlUtils = {}

function ControlUtils.ControlGroup(controls: { [string]: any })
	local group = {
		EntryType = "ControlGroup",
		Controls = controls,
	}
	return group
end

function ControlUtils.Ordered<T>(control: T, order: number): T
	local converted = ControlConversion.ConvertControl(control)
	converted.Order = order
	return converted
end

return ControlUtils
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="140">
                  <Properties>
                    <string name="Name">DatatypeControls</string>
                    <string name="Source"><![CDATA[local Utils = require(script.Parent.Utils)
local CreateBaseControl = Utils.CreateBaseControl
local Datatypes = {}

function Datatypes.Color3(def: Color3): Utils.Control<Color3>
	local fixedColor = Color3.new(math.clamp(def.R, 0, 1), math.clamp(def.G, 0, 1), math.clamp(def.B, 0, 1))
	return CreateBaseControl("Color3", fixedColor)
end

--[[
--[User Interface]--
function Datatypes.UDim2(def: UDim2)
	return CreateBaseControl("UDim2", def)
end
function Datatypes.UDim(def: UDim)
	return CreateBaseControl("UDim", def)
end

--[Space 3D]--
function Datatypes.CFrame(def: CFrame)
	return CreateBaseControl("CFrame", def)
end

function Datatypes.Vector2(def: Vector2, normalize: boolean?)
	local control = CreateBaseControl("Vector2", def)
	control.Normalize = if normalize == nil then false else normalize

	return control
end
function Datatypes.Vector3(def: Vector3, normalize: boolean?)
	local control = CreateBaseControl("Vector3", def)
	control.Normalize = if normalize == nil then false else normalize

	return CreateBaseControl("Vector3", def)
end ]]

return Datatypes
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="141">
                  <Properties>
                    <string name="Name">PrimitiveControls</string>
                    <string name="Source"><![CDATA[type Filter = (input: string, oldInput: string) -> string

local Utils = require(script.Parent.Utils)
local CreateBaseControl = Utils.CreateBaseControl
local Controls = {}

function Controls.String(def: string, filters: { Filter }?): Utils.Control<string>
	local control = CreateBaseControl("String", def)
	control.Filters = filters

	return control
end

function Controls.Number(
	def: number,
	min: number?,
	max: number?,
	step: number?,
	dragger: boolean?,
	sens: number?
): Utils.Control<number>
	local control = CreateBaseControl("Number", def)

	control.Min = min
	control.Max = max
	control.Step = step
	control.Dragger = if dragger == nil then true else dragger
	control.Sensibility = sens or (def * 10)

	return control
end

function Controls.Boolean(def: boolean): Utils.Control<boolean>
	return CreateBaseControl("Boolean", def)
end

Controls.Primitive = {
	string = Controls.String,
	number = Controls.Number,
	boolean = Controls.Boolean,
}

return Controls
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="142">
                  <Properties>
                    <string name="Name">Utils</string>
                    <string name="Source"><![CDATA[local Utils = {}

export type Control<T> = {
	ControlValue: T,
}

function Utils.CreateBaseControl(controlType: string, def)
	local control = {
		EntryType = "Control",
		Type = controlType,
		ControlValue = def,
	}
	return control
end

return Utils
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="143">
                <Properties>
                  <string name="Name">Environment</string>
                  <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local Environment = {}

Environment.EnvGlobalInjectionKey = "__hotreload_env_global_injection__" -- the longer the better

function SearchInEnv(key: string, def: any?)
	local env = Environment.GetEnvGlobalInjection()

	return (env and env[key]) or def
end

function Environment.GetEnvGlobalInjection()
	local env = getfenv()

	return env[Environment.EnvGlobalInjectionKey]
end
function Environment.IsStory()
	local env = Environment.GetEnvGlobalInjection()

	return env ~= nil
end
function UserInputFallback(userInput: any?)
	if not userInput then
		return UserInputService
	end
	if userInput == UserInputService then
		return UserInputService
	end

	local clone = table.clone(userInput)
	return setmetatable(clone, {
		__index = function(_, key)
			local value = UserInputService[key]
			if typeof(value) == "function" then
				-- Wrap the function to replace self
				return function(_, ...)
					return value(UserInputService, ...)
				end
			end
			return value
		end,
	})
end

Environment.Unmount = SearchInEnv("Unmount", function() end) :: () -> ()

Environment.Reload = SearchInEnv("Reload", function() end) :: () -> ()
Environment.CreateSnapshot = SearchInEnv("CreateSnapshot", function() end) :: (name: string?) -> ()
Environment.SetStoryHolder = SearchInEnv("SetStoryHolder", function() end) :: (holder: Instance?) -> ()
Environment.GetJanitor = function()
	local janitor = SearchInEnv("StoryJanitor")
	return janitor
end

type InputSignals = {
	InputBegan: RBXScriptSignal,
	InputEnded: RBXScriptSignal,
	InputChanged: RBXScriptSignal,
	MouseMoved: RBXScriptSignal,
	GetMouseLocation: (self: any) -> Vector2,
}

Environment.InputListener = SearchInEnv("InputListener", nil) :: InputSignals
Environment.UserInput = UserInputFallback(SearchInEnv("InputListener", UserInputService)) :: UserInputService

Environment.EnvironmentUID = SearchInEnv("EnvironmentUID", "") :: string
Environment.PreviewUID = SearchInEnv("PreviewUID", "") :: string
Environment.OriginalG = SearchInEnv("OriginalG", _G) :: any
Environment.PluginWidget = SearchInEnv("PluginWidget", nil) :: DockWidgetPluginGui
Environment.Plugin = SearchInEnv("Plugin", plugin) :: Plugin

return Environment
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="144">
                <Properties>
                  <string name="Name">Libraries</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="145">
                <Properties>
                  <string name="Name">StoryCreators</string>
                  <string name="Source"><![CDATA[local Creators = {}
local Types = require(script.Parent.Types)

type InputSignals = {
	InputBegan: RBXScriptConnection,
	InputEnded: RBXScriptConnection,
	InputChanged: RBXScriptConnection,
	MouseMoved: RBXScriptConnection,
}

local function CombineTableInfo(table1, table2)
	for key, val in pairs(table2) do
		table1[key] = val
	end
	return table1
end

function Creators.CreateRoactStory(
	info: Types.StoryBase & Types.WithRoact,
	render: Types.ReactStoryKey
): Types.RoactStory
	local returnStory = {
		use = "roact",
		story = render,
	}

	return CombineTableInfo(returnStory, info)
end

function Creators.CreateReactStory(
	info: Types.StoryBase & Types.WithReact,
	render: Types.ReactStoryKey
): Types.ReactStory
	local returnStory = {
		use = "react",
		story = render,
	}

	return CombineTableInfo(returnStory, info)
end

function Creators.CreateFusionStory(
	info: Types.StoryBase & Types.WithFusion,
	render: Types.FusionStoryKey
): Types.FusionStory
	local returnStory = {
		use = "fusion",
		story = render,
	}

	return CombineTableInfo(returnStory, info)
end

function Creators.CreateIrisStory(info: Types.StoryBase & Types.WithIris, render: Types.IrisStoryKey): Types.IrisStory
	local returnStory = {
		use = "iris",
		story = render,
	}

	return CombineTableInfo(returnStory, info)
end

function Creators.CreateVideStory(info: Types.StoryBase & Types.WithVide, render: Types.VideStoryKey): Types.VideStory
	local returnStory = {
		use = "Vide",
		story = render,
	}

	return CombineTableInfo(returnStory, info)
end

function Creators.CreateGenericStory(info: Types.StoryBase, render: Types.GenericRenderKey): Types.GenericStory
	local returnStory = {
		render = render,
	}

	return CombineTableInfo(returnStory, info)
end

return Creators
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="146">
                <Properties>
                  <string name="Name">Types</string>
                  <string name="Source"><![CDATA[export type Storybook = {
	name: string?,
	storyRoots: { Instance },
	groupRoots: boolean?,
}
type Cleanup = () -> ()
export type FunctionStory = (target: Frame) -> Cleanup

export type StoryBase = {
	name: string?,
	summary: string?,
	cleanup: Cleanup?,
	controls: StoryControls?,
}

type StoryControls = { [string]: any }

------------------------------- REACT/ROACT ------------------------------

export type ReactProps = {
	controls: { [string]: any },
}
export type WithReact = {
	use: "react"?,
	react: any,
	reactRoblox: any,
}
export type ReactStoryKey = (props: ReactProps) -> any
export type ReactStory = StoryBase & WithReact & {
	story: ReactStoryKey,
}

export type WithRoact = {
	use: "roact"?,
	roact: any,
}
export type RoactStory = StoryBase & WithRoact & {
	story: ReactStoryKey,
}

--------------------------------- FUSION ---------------------------------

export type FusionProps = {
	controls: { [string]: any },
	scope: any,
	target: GuiObject,
}

export type WithFusion = {
	use: "fusion"?,
	fusion: any,
	scoped: { any }?,
}

export type FusionStoryKey = (props: FusionProps) -> any?
export type FusionStory = StoryBase & WithFusion & {
	story: FusionStoryKey,
}

---------------------------------- IRIS ----------------------------------

export type IrisProps = {
	controls: { [string]: any },
	target: GuiObject,
}

export type WithIris = {
	use: "iris"?,
	iris: any,
}

export type IrisStoryKey = (props: IrisProps) -> Cleanup? | nil
export type IrisStory = StoryBase & WithIris & {
	story: IrisStoryKey,
}

---------------------------------- VIDE ----------------------------------

export type VideProps = {
	controls: { [string]: any },
	target: GuiObject,
}

export type WithVide = {
	use: "vide"?,
	vide: any,
}

export type VideStoryKey = (props: VideProps) -> ((...any) -> any)?
export type VideStory = StoryBase & WithVide & {
	story: VideStoryKey,
}

---------------------------------- GENERIC --------------------------------
export type GenericInfo<T> = { __old: T, __new: T }

export type SubscribeListener = (values: { [string]: any }, info: { [string]: GenericInfo<any> }) -> ()

export type GenericProps = {
	controls: { [string]: any },
	target: GuiObject,
	converted: { [string]: any },
	subscribe: (listener: SubscribeListener) -> Cleanup,
}

export type GenericRenderKey = (props: GenericProps) -> Cleanup

export type GenericStory = StoryBase & {
	render: GenericRenderKey,
}

return nil
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="147">
                <Properties>
                  <string name="Name">Typing</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="148">
                <Properties>
                  <string name="Name">Utils</string>
                  <string name="Source"><![CDATA[local Utils = {}
local Types = require(script.Parent.Types)

function Utils.ListenControl<T>(info: Types.GenericInfo<T>, callback: (newVal: T) -> ())
	local oldValue = info.__old
	local newValue = info.__new

	if oldValue ~= newValue then
		callback(newValue)
	end
end

function Utils.CreateControlStates(
	converted: { [string]: any },
	controls: { [string]: any },
	creator: (control: any) -> any
)
	local states = {}

	for key, control in pairs(converted) do
		local controlValue = controls[key]

		if control.EntryType == "ControlGroup" then -- control is a control group, we need to recurse
			states[key] = Utils.CreateControlStates(control.Controls, controlValue, creator)
			continue
		end
		states[key] = creator(controlValue)
	end

	return states
end

function Utils.UpdateControlStates(
	states: { [string]: any },
	converted: { [string]: any },
	controls: { [string]: any },
	updater: (state: any, value: any) -> ()
)
	for key, control in pairs(converted) do
		local controlValue = controls[key]

		if control.EntryType == "ControlGroup" then -- control is a control group, we need to recurse
			Utils.UpdateControlStates(states[key], control.Controls, controlValue, updater)
			continue
		end
		updater(states[key], controlValue)
	end
end

return Utils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="149">
                <Properties>
                  <string name="Name">Version</string>
                  <string name="Source">return "2.4.0"</string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="150">
            <Properties>
              <string name="Name">validate-tree</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- * Defines a Rojo-esque tree type which defines an abstract object tree.
-- * Evaluates a Rojo-esque tree and transforms it into an indexable type.
local function getService(serviceName)
	return game:GetService(serviceName)
end
--[[
	* Returns whether a given Instance matches a particular Rojo-esque InstanceTree.
	* @param object The object which needs validation
	* @param tree The tree to validate
	* @param violators
]]
local function validateTree(object, tree, violators)
	if tree["$className"] ~= nil and not object:IsA(tree["$className"]) then
		return false
	end
	local matches = true
	if object.ClassName == "DataModel" then
		for serviceName, classOrTree in pairs(tree) do
			if serviceName ~= "$className" then
				local success, value = pcall(getService, serviceName)
				if not success then
					if violators ~= nil then
						local _arg0 = 'game.GetService("' .. (serviceName .. '")')
						table.insert(violators, _arg0)
					end
					return false
				end
				if value and (type(classOrTree) == "string" or validateTree(value, classOrTree, violators)) then
					if value.Name ~= serviceName then
						value.Name = serviceName
					end
				else
					if violators == nil then
						return false
					end
					matches = false
					local _arg0 = 'game.GetService("' .. (serviceName .. '")')
					table.insert(violators, _arg0)
				end
			end
		end
	else
		local whitelistedKeys = {
			["$className"] = true,
		}
		for _, child in ipairs(object:GetChildren()) do
			local childName = child.Name
			if childName ~= "$className" then
				local classOrTree = tree[childName]
				if if type(classOrTree) == "string" then child:IsA(classOrTree) else classOrTree and validateTree(child, classOrTree, violators) then
					whitelistedKeys[childName] = true
				end
			end
		end
		for key in pairs(tree) do
			if not (whitelistedKeys[key] ~= nil) then
				if violators == nil then
					return false
				end
				matches = false
				local _arg0 = object:GetFullName() .. "." .. key
				table.insert(violators, _arg0)
			end
		end
	end
	return matches
end
--[[
	* Promises a given tree of objects exists within an object.
	* @param tree Must be an object tree similar to ones considered valid by Rojo.
	* Every tree must have a `$className` member, and can have any number of keys which represent
	* the name of a child instance, which should have a corresponding value which is this same kind of tree.
	* There is also a shorthand syntax available, where setting a key equal to a className is equivalent
	* to an object with `$className` defined. Hence `Things: "Folder"` is equivalent to `Things: { $className: "Folder" }`
]]
local function promiseTree(object, tree)
	if validateTree(object, tree) then
		return TS.Promise.resolve(object)
	end
	local connections = {}
	local warner = TS.Promise.delay(5)
	local _arg0 = function()
		local violators = {}
		if not validateTree(object, tree, violators) then
			warn("[promiseTree] Infinite wait possible. Waiting for: " .. table.concat(violators, ", "))
		end
	end
	warner:andThen(_arg0)
	local promise = TS.Promise.new(function(resolve)
		local function updateTree(violators)
			if validateTree(object, tree, violators) then
				resolve(object)
			end
		end
		for _, d in ipairs(object:GetDescendants()) do
			local _arg0_1 = d:GetPropertyChangedSignal("Name"):Connect(updateTree)
			table.insert(connections, _arg0_1)
		end
		local _arg0_1 = object.DescendantAdded:Connect(function(descendant)
			local _arg0_2 = descendant:GetPropertyChangedSignal("Name"):Connect(updateTree)
			table.insert(connections, _arg0_2)
			updateTree()
		end)
		table.insert(connections, _arg0_1)
	end)
	promise:finally(function()
		for _, connection in ipairs(connections) do
			connection:Disconnect()
		end
		warner:cancel()
	end)
	return promise
end
return {
	validateTree = validateTree,
	promiseTree = promiseTree,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="151">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	description = "Validates whether a given instance matches a given instance tree",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.2.3",
		["@rbxts/types"] = "^1.0.537",
	},
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/validate-tree/README.md",
	keywords = {"dot", "Roblox", "Player", "tree", "validate", "object", "members", "parts"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/validate-tree",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/validate-tree",
	},
	scripts = {
		build = "rbxtsc &amp; mv out/* . &amp; rm -r out",
	},
	types = "index.d.ts",
	version = "2.0.2",
}</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="152">
            <Properties>
              <string name="Name">vide</string>
            </Properties>
            <Item class="ModuleScript" referent="153">
              <Properties>
                <string name="Name">package</string>
                <string name="Source">return {
	author = "centau",
	bugs = {
		url = "https://github.com/littensy/vide/issues",
	},
	contributors = {"littensy"},
	description = "A reactive Luau library for creating UI",
	devDependencies = {
		["@rbxts/compiler-types"] = "2.3.0-types.1",
		["@rbxts/types"] = "^1.0.799",
		["@typescript-eslint/eslint-plugin"] = "^7.18.0",
		["@typescript-eslint/parser"] = "^7.18.0",
		eslint = "^8.57.0",
		["eslint-config-prettier"] = "^9.1.0",
		["eslint-plugin-prettier"] = "^5.2.1",
		["eslint-plugin-roblox-ts"] = "^0.0.36",
		prettier = "^3.3.3",
		["roblox-ts"] = "2.3.0-dev-539482e",
		typescript = "^5.5.4",
	},
	files = {"src"},
	homepage = "https://github.com/littensy/vide",
	keywords = {"roblox-ts", "ui"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/vide",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/littensy/vide",
	},
	scripts = {
		build = "rbxtsc --rojo dev.project.json",
	},
	types = "src/index.d.ts",
	version = "0.5.7",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="154">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--------------------------------------------------------------------------------
-- vide.luau
--------------------------------------------------------------------------------

local version = { major = 0, minor = 3, patch = 1 }

if not game then script = require "test/relative-string" end

local root = require(script.root)
local mount = require(script.mount)
local create = require(script.create)
local apply = require(script.apply)
local source = require(script.source)
local effect = require(script.effect)
local derive = require(script.derive)
local cleanup = require(script.cleanup)
local untrack = require(script.untrack)
local read = require(script.read)
local batch = require(script.batch)
local context = require(script.context)
local switch = require(script.switch)
local show = require(script.show)
local indexes, values = require(script.maps)()
local spring, update_springs = require(script.spring)()
local action = require(script.action)()
local changed = require(script.changed)
local components = require(script.components)
local throw = require(script.throw)
local flags = require(script.flags)
local jsx = require(script.jsx)

export type Source<T> = source.Source<T>
export type source<T> = Source<T>
export type Context<T> = context.Context<T>
export type context<T> = Context<T>

local function step(dt: number)
    if game then
        debug.profilebegin("VIDE STEP")
        debug.profilebegin("VIDE SPRING")
    end

    update_springs(dt)

    if game then
        debug.profileend()
        debug.profileend()
    end
end

local stepped = game and game:GetService("RunService").Heartbeat:Connect(function(dt: number)
    task.defer(step, dt)
end)

local vide = {
    version = version,

    -- core
    root = root,
    mount = mount,
    create = create,
    source = source,
    effect = effect,
    derive = derive,
    switch = switch,
    show = show,
    indexes = indexes,
    values = values,

    -- util
    cleanup = cleanup,
    untrack = untrack,
    read = read,
    batch = batch,
    context = context,

    -- animations
    spring = spring,

    -- actions
    action = action,
    changed = changed,

    -- flags
    strict = (nil :: any) :: boolean,

    -- temporary
    apply = function(instance: Instance)
        return function(props: { [any]: any })
            apply(instance, props)
            return instance
        end
    end,

    -- runtime
    step = function(dt: number)
        if stepped then
            stepped:Disconnect()
            stepped = nil
        end
        step(dt)
    end,

    -- typescript
    jsx = jsx,
    match = switch,
    Fragment = components.Fragment,
    Switch = components.Switch,
    Case = components.Case,
    For = components.For,
    Index = components.Index,
    Show = components.Show,
    Provider = components.Provider,
}

setmetatable(vide :: any, {
    __index = function(_, index: unknown): ()
        if index == "strict" then
            return flags.strict
        else
            throw(`{tostring(index)} is not a valid member of vide`)
        end
    end,

    __newindex = function(_, index: unknown, value: unknown)
        if index == "strict" then
            flags.strict = value :: boolean
        else
            throw(`{tostring(index)} is not a valid member of vide`)
        end
    end
})

return vide
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="155">
                <Properties>
                  <string name="Name">action</string>
                  <string name="Source"><![CDATA[type Action = {
    priority: number,
    callback: (Instance) -> ()
}

local ActionMT = table.freeze {}

local function is_action(v: any)
    return getmetatable(v) == ActionMT
end

local function action(callback: (Instance) -> (), priority: number?): Action
    local a = {
        priority = priority or 1,
        callback = callback
    }

    setmetatable(a :: any, ActionMT)

    return table.freeze(a)
end

return function()
    return action, is_action
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="156">
                <Properties>
                  <string name="Name">apply</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof :: never
local Vector2 = game and Vector2 or require "test/mock".Vector2 :: never
local UDim2 = game and UDim2 or require "test/mock".UDim2 :: never

local flags = require(script.Parent.flags)
local throw = require(script.Parent.throw)
local bind = require(script.Parent.bind)
local _, is_action = require(script.Parent.action)()
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>

type Array<V> = { V }
type ArrayOrV<V> = {ArrayOrV<V>} | V
type Map<K, V> = { [K]: V }

local free_caches: {
    -- event listeners to connect after properties are set
    events: Map<
        string, -- event name
        () -> () -- listener
    >,

    -- actions to run after events are connected
    actions: Map<
        number, -- priority
        Array<(Instance) -> ()> -- action callbacks
    >,

    -- cache to detect duplicate property setting at same nesting depth
    nested_debug: Map<
        number, -- depth
        Map<string, true> -- set of property names
    >,

    -- use stack instead of recursive function to process nesting layers one at time
    -- deeper-nested properties take precedence over shallower-nested ones
    -- each nested layer occupies two indexes: 1. table ref 2. nested depth
    -- e.g. { t1 = { t3 = {} }, t2 = {} } -> { t1, 1, t2, 1, t3, 2 }
    nested_stack: { {} | number }
}?

local function borrow_caches(): typeof(assert(free_caches))
    if free_caches then
        local caches = free_caches :: typeof(assert(free_caches))
        free_caches = nil
        return caches
    else
        return {
            events = {},
            actions = setmetatable({} :: any, { -- lazy init
                __index = function(self, i) self[i] = {}; return self[i] end
            }),
            nested_debug = setmetatable({} :: any, {
                __index = function(self, i: number) self[i] = {}; return self[i] end
            }),
            nested_stack = {}
        }
    end
end

local function return_caches(caches: typeof(free_caches) )
    free_caches = caches
end

-- map of datatype names to class default constructor for aggregate init
local aggregates = {}
for name, class in {
    CFrame = CFrame,
    Color3 = Color3,
    UDim = UDim,
    UDim2 = UDim2,
    Vector2 = Vector2,
    Vector3 = Vector3,
    Rect = Rect
} :: Map<string, { [string]: any }> do
    aggregates[name] = class.new
end

-- applies table of nested properties to an instance using full vide semantics
local function apply<T>(instance: T & Instance, properties: { [unknown]: unknown }): T
    if not properties then
        throw("attempt to call a constructor returned by create() with no properties")
    end

    local strict = flags.strict

    -- queue parent assignment if any for last
    local parent: unknown = properties.Parent 

    local caches = borrow_caches()
    local events = caches.events
    local actions = caches.actions
    local nested_debug = caches.nested_debug
    local nested_stack = caches.nested_stack

    -- process all properties
    local depth = 1
    repeat
        for property, value in properties do
            if property == "Parent" then continue end

            if type(property) == "string" then
                if strict then -- check for duplicate prop assignment at nesting depth
                    if nested_debug[depth][property] then
                        throw(`duplicate property {property} at depth {depth}`)
                    end
                    nested_debug[depth][property] = true
                end

                if type(value) == "table" then -- attempt aggregate init
                    local ctor = aggregates[typeof((instance :: any)[property])]
                    if ctor == nil then
                        throw(`cannot aggregate type {typeof(value)} for property {property}`)
                    end
                    (instance :: any)[property] = ctor(unpack(value :: {}))
                elseif type(value) == "function" then 
                    if typeof((instance :: any)[property]) == "RBXScriptSignal" then
                        events[property] = value  :: () -> () -- add event to buffer
                    else
                        bind.property(instance, property, value :: () -> ()) -- bind property
                    end
                else
                    (instance :: any)[property] = value -- set property
                end    
            elseif type(property) == "number" then
                if type(value) == "function" then
                    bind.children(instance, value :: () -> ArrayOrV<Instance>) -- bind children
                elseif type(value) == "table" then
                    if is_action(value) then
                        table.insert(actions[(value :: any).priority], (value :: any).callback :: () -> ()) -- add action to buffer
                    else
                        table.insert(nested_stack, value :: {})
                        table.insert(nested_stack, depth + 1) -- push table to stack for later processing
                    end
                else
                    (value :: Instance).Parent = instance -- parent child
                end
            end
        end

        depth = table.remove(nested_stack) :: number
        properties = table.remove(nested_stack) :: {}

    until not properties

    for event, listener in next, events do
        (instance :: any)[event]:Connect(listener)   
    end

    for _, queued in next, actions do
        for _, callback in next, queued do
            callback(instance)
        end
    end

    -- finally set parent if any
    if parent then
        if type(parent) == "function" then
            bind.parent(instance, parent :: () -> Instance)
        else
            instance.Parent = parent :: Instance
        end
    end

    -- clear caches
    table.clear(events)
    for _, queued in next, actions do table.clear(queued) end
    if strict then table.clear(nested_debug) end
    table.clear(nested_stack)

    return_caches(caches)

    return instance
end

return apply
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="157">
                <Properties>
                  <string name="Name">batch</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local flags = require(script.Parent.flags)
local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)

local function batch(setter: () -> ())
    local already_batching = flags.batch
    local from

    if not already_batching then
        flags.batch = true
        from = graph.get_update_queue_length()
    end

    local ok, err: string? = pcall(setter)

    if not already_batching then
        flags.batch = false
        graph.flush_update_queue(from)
    end

    if not ok then throw(`error occured while batching updates: {err}`) end
end

return batch
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="158">
                <Properties>
                  <string name="Name">bind</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

function create_implicit_effect<T>(updater: (T) -> T, binding: T)
    evaluate_node(create_node(assert_stable_scope(), updater, binding))
end

type PropertyBinding = {
    instance: Instance,
    property: string,
    source: () -> unknown
}

local function update_property_effect(p: PropertyBinding)
    (p.instance :: any)[p.property] = p.source()
    return p
end

type ParentBinding = {
    instance: Instance,
    parent: () -> Instance
}

local function update_parent_effect(p: ParentBinding)
    p.instance.Parent = p.parent()
    return p
end

type ChildrenBinding = {
    instance: Instance,
    cur_children_set: { [Instance]: true },
    new_children_set: { [Instance]: true },
    children: () -> Instance | { Instance }
}

type ArrayOrV<V> = V | { V }
local function update_children_effect(p: ChildrenBinding)
    local cur_children_set: { [Instance]: true } = p.cur_children_set -- cache of all children parented before update
    local new_child_set: { [Instance]: true } = p.new_children_set -- cache of all children parented after update

    local new_children = p.children() -- all (and only) children that should be parented after this update
    
    if type(new_children) ~= "table" then
        new_children = { new_children }
    end

    local function process_child(child: ArrayOrV<Instance>)
        if type(child) == "table" then
            for _, child in next, child do
                process_child(child)
            end
        else
            if new_child_set[child] then return end -- stops redundant reparenting

            new_child_set[child] = true -- record child set from this update
            if not cur_children_set[child] then
                child.Parent = p.instance -- if child wasn't already parented then parent it
            else 
                cur_children_set[child] = nil -- remove child from cache if it was already in cache
            end
        end
    end

    process_child(new_children)

    for child in next, cur_children_set do
        child.Parent = nil -- unparent all children that weren't in the new children set
    end

    table.clear(cur_children_set) -- clear cache, preserve capacity
    p.cur_children_set, p.new_children_set = new_child_set, cur_children_set

    return p
end

return {
    property = function(instance, property, source)
        return create_implicit_effect(update_property_effect, {
            instance = instance,
            property = property,
            source = source
        })
    end,

    parent = function(instance, parent)
        return create_implicit_effect(update_parent_effect, {
            instance = instance,
            parent = parent
        })
    end,

    children = function(instance, children)
        return create_implicit_effect(update_children_effect, {
            instance = instance,
            cur_children_set = {},
            new_children_set = {},
            children = children
        })
    end
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="159">
                <Properties>
                  <string name="Name">changed</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local action = require(script.Parent.action)()
local cleanup = require(script.Parent.cleanup)

local function changed<T>(property: string, callback: (T) -> ())
    return action(function(instance)
        local con = instance:GetPropertyChangedSignal(property):Connect(function()
            callback((instance :: any)[property])
        end)

        cleanup(function()
            con:Disconnect()
        end)

        callback((instance :: any)[property])
    end)
end

return changed
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="160">
                <Properties>
                  <string name="Name">cleanup</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof :: never

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
local get_scope = graph.get_scope
local push_cleanup = graph.push_cleanup

local function helper(obj: any)
    return
        if typeof(obj) == "RBXScriptConnection" then function() obj:Disconnect() end
        elseif typeof(obj) == "Instance" then function() obj:Destroy() end
        elseif obj.destroy then function() obj:destroy() end
        elseif obj.disconnect then function() obj:disconnect() end
        elseif obj.Destroy then function() obj:Destroy() end
        elseif obj.Disconnect then function() obj:Disconnect() end
        else throw("cannot cleanup given object")
end

local function cleanup(value: unknown)
    local scope = get_scope()

    if not scope then
        throw "cannot cleanup outside a stable or reactive scope"
    end; assert(scope)

    if type(value) == "function" then
        push_cleanup(scope, value :: () -> ())
    else
        push_cleanup(scope, helper(value))
    end
end

type Destroyable = { destroy: (any) -> () } | { Destroy: (any) -> () }
type Disconnectable = { disconnect: (any) -> () } | { Disconnect: (any) -> () }

return cleanup ::
    ( (callback: () -> ()) -> () ) &
    ( (instance: Destroyable) -> () ) &
    ( (connection: Disconnectable) -> () ) &
    ( (instance: Instance) -> () ) &
    ( (connection: RBXScriptConnection) -> () )

]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="161">
                <Properties>
                  <string name="Name">components</string>
                  <string name="Source"><![CDATA[local context = require(script.Parent.context)
local indexes, values = require(script.Parent.maps)()
local show = require(script.Parent.show)
local switch = require(script.Parent.switch)

type Context<T> = context.Context<T>

type Case = {
    match: any,
    children: () -> any,
}

local function Fragment(props: { children: any })
    return props.children
end

local function For<K, VI, VO>(props: {
    each: () -> { [K]: VI },
    children: (VI, () -> K) -> VO,
}): () -> { VO }
    return values(props.each, props.children)
end

local function Index<K, VI, VO>(props: {
    each: () -> { [K]: VI },
    children: (() -> VI, K) -> VO,
}): () -> { VO }
    return indexes(props.each, props.children)
end

local function Switch(props: {
    condition: () -> any,
    children: { Case },
})
    local children = props.children :: { [any]: any }
    local map = {}

    if children.match then
        map[children.match] = children.children
    else
        for _, node in children do
            map[node.match] = node.children
        end
    end

    return switch(props.condition)(map)
end

local function Case(props: Case): Case
    return props
end

local function Show(props: {
    when: any,
    children: () -> any,
    fallback: () -> any,
})
    return show(props.when, props.children, props.fallback)
end

local function Provider<T>(props: {
    context: Context<T>,
    value: T,
    children: () -> any,
})
    return props.context(props.value, props.children)
end

return {
    Fragment = Fragment,
    Switch = Switch,
    Case = Case,
    For = For,
    Index = Index,
    Show = Show,
    Provider = Provider,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="162">
                <Properties>
                  <string name="Name">context</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local get_scope = graph.get_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local set_context = graph.set_context

export type Context<T> = (() -> T) & (<U>(T, () -> U) -> U)

local nil_symbol = newproxy()
local count = 0

local function context<T>(...: T): Context<T>
    count += 1
    local id = count

    local has_default = select("#", ...) > 0
    local default_value = ...

    return function<T>(...): any -- todo: fix type error
        local scope: Node<unknown>? | false = get_scope()

        if select("#", ...) == 0 then -- get
            while scope do
                local ctx = scope.context
    
                if not ctx then
                    scope = scope.owner
                    continue
                end

                local value = (ctx :: { unknown })[id]

                if value == nil then
                    scope = scope.owner
                    continue
                end
                
                return (if value ~= nil_symbol then value else nil) :: T
            end

            if has_default ~= nil then
                return default_value
            else
                throw("attempt to get context when no context is set and no default context is set")
            end
        else -- set
            if not scope then return throw("attempt to set context outside of a vide scope") end

            local value, component = ...
            
            local new_scope = create_node(scope, false, false)
            set_context(new_scope, id, if value == nil then nil_symbol else value)

            push_scope(new_scope)

            local function efn(err: string) return debug.traceback(err, 3) end
            local ok, result = xpcall(component, efn)

            pop_scope()

            if not ok then
                throw(`error while running context:\n\n{result}`)
            end

            return result
        end

        return nil :: any
    end
end

return context
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="163">
                <Properties>
                  <string name="Name">create</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof:: never
local Instance = game and Instance or require "test/mock".Instance :: never

local throw = require(script.Parent.throw)
local defaults = require(script.Parent.defaults)
local apply = require(script.Parent.apply)

local ctor_cache = {} :: { [string]: () -> Instance }

setmetatable(ctor_cache :: any, {
    __index = function(self, class)
        local ok, instance: Instance = pcall(Instance.new, class :: any)
        if not ok then throw(`invalid class name, could not create instance of class { class }`) end

        local default: { [string]: unknown }? = defaults[class]
        if default then
            for i, v in next, default do
                (instance :: any)[i] = v
            end
        end

        local function ctor(properties: Props): Instance
            return apply(instance:Clone(), properties)    
        end  

        self[class] = ctor
        return ctor
    end
})

local function create_instance(class: string)
    return ctor_cache[class]
end

local function clone_instance(instance: Instance)
    return function(properties: Props): Instance
        local clone = instance:Clone()
        if not clone then throw "attempt to clone a non-archivable instance" end
        return apply(clone, properties)
    end
end

local function create(class_or_instance: string|Instance): (Props) -> Instance
    if type(class_or_instance) == "string" then
        return create_instance(class_or_instance)
    elseif typeof(class_or_instance) == "Instance" then
        return clone_instance(class_or_instance)
    else
        throw("bad argument #1, expected string or instance, got " .. typeof(class_or_instance))
        return nil :: never
    end
end

type Props = { [any]: any }
return (create :: any) :: 
( <T>(T & Instance) -> (Props) -> T ) &
( ("Folder") -> (Props) -> Folder ) &
( ("BillboardGui") -> (Props) -> BillboardGui ) &
( ("CanvasGroup") -> (Props) -> CanvasGroup ) &
( ("Frame") -> (Props) -> Frame ) &
( ("ImageButton") -> (Props) -> ImageButton ) &
( ("ImageLabel") -> (Props) -> ImageLabel ) &
( ("ScreenGui") -> (Props) -> ScreenGui ) &
( ("ScrollingFrame") -> (Props) -> ScrollingFrame ) &
( ("SurfaceGui") -> (Props) -> SurfaceGui ) &
( ("TextBox") -> (Props) -> TextBox ) &
( ("TextButton") -> (Props) -> TextButton ) &
( ("TextLabel") -> (Props) -> TextLabel ) &
( ("UIAspectRatioConstraint") -> (Props) -> UIAspectRatioConstraint ) &
( ("UICorner") -> (Props) -> UICorner ) &
( ("UIGradient") -> (Props) -> UIGradient ) &
( ("UIGridLayout") -> (Props) -> UIGridLayout ) &
( ("UIListLayout") -> (Props) -> UIListLayout ) &
( ("UIPadding") -> (Props) -> UIPadding ) &
( ("UIPageLayout") -> (Props) -> UIPageLayout ) &
( ("UIScale") -> (Props) -> UIScale ) &
( ("UISizeConstraint") -> (Props) -> UISizeConstraint ) &
( ("UIStroke") -> (Props) -> UIStroke ) &
( ("UITableLayout") -> (Props) -> UITableLayout ) &
( ("UITextSizeConstraint") -> (Props) -> UITextSizeConstraint ) &
( ("VideoFrame") -> (Props) -> VideoFrame ) &
( ("ViewportFrame") -> (Props) -> ViewportFrame ) &
( (string) -> (Props) -> Instance )
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="164">
                <Properties>
                  <string name="Name">defaults</string>
                  <string name="Source"><![CDATA[local Enum = game and Enum or require "test/mock".Enum :: never
local Color3 = game and Color3 or require "test/mock".Color3 :: never
local Vector3 = game and Vector3 or require "test/mock".Vector3 :: never

return {
    Part = {
        Material = Enum.Material.SmoothPlastic,
        Size = Vector3.new(1, 1, 1),
        Anchored = true
    },

    BillboardGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    },

    CanvasGroup = nil,

    Frame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    },

    ImageButton = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        AutoButtonColor = false
    },

    ImageLabel = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
    },

    ScreenGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    },

    ScrollingFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        ScrollBarImageColor3 = Color3.new(0, 0, 0)
    },
    
    SurfaceGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

        PixelsPerStud = 50,
        SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
    },
    
    TextBox = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        ClearTextOnFocus = false,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },

    TextButton = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        AutoButtonColor = false,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },
    
    TextLabel = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },
    
    UIListLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },
   
    UIGridLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },

    UITableLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },

    UIPageLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },
    
    VideoFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    },
    
    ViewportFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    }
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="165">
                <Properties>
                  <string name="Name">derive</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
local create_node = graph.create_node
local push_child_to_scope = graph.push_child_to_scope
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

local function derive<T>(source: () -> T): () -> T
    local node = create_node(assert_stable_scope(), source, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

return derive
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="166">
                <Properties>
                  <string name="Name">effect</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
local create_node = graph.create_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

local function effect<T>(callback: (T) -> T, initial_value: T)
    local node = create_node(assert_stable_scope(), callback, initial_value)

    evaluate_node(node)
end

return effect :: (<T>(callback: (T) -> T, initial_value: T) -> ()) & ((callback: () -> ()) -> ())
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="167">
                <Properties>
                  <string name="Name">flags</string>
                  <string name="Source"><![CDATA[local function inline_test(): string
    return debug.info(1, "n")
end

local is_O2 = inline_test() ~= "inline_test"

return { strict = not is_O2, batch = false }
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="168">
                <Properties>
                  <string name="Name">graph</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local flags = require(script.Parent.flags)

export type SourceNode<T> = {
    cache: T,
    [number]: Node<T>
}

export type Node<T> =  {
    cache: T,
    effect:  ((T) -> T) | false,
    cleanups: { () -> () } | false,

    context: { [number]: unknown } | false,

    owned: { Node<T> } | false,
    owner: Node<T> | false,

    parents: { SourceNode<T> },
    [number]: Node<T> -- children
}

local scopes = { n = 0 } :: { [number]: Node<any>, n: number } -- scopes stack

local function ycall<T, U>(fn: (T) -> U, arg: T): (boolean, string|U)
    local thread = coroutine.create(xpcall)
    local function efn(err: string) return debug.traceback(err, 3) end
    local resume_ok, run_ok, result = coroutine.resume(thread, fn, efn, arg)

    assert(resume_ok)
        
    if coroutine.status(thread) ~= "dead" then
        return false, debug.traceback(thread, "attempt to yield in reactive scope")
    end

    return run_ok, result
end

local function get_scope(): Node<unknown>?
    return scopes[scopes.n]
end

local function assert_stable_scope(): Node<unknown>
    local scope = get_scope()

    if not scope then
        local caller_name = debug.info(2, "n")
        return throw(`cannot use {caller_name}() outside a stable or reactive scope`)
    elseif scope.effect then
        throw("cannot create a new reactive scope inside another reactive scope")
    end

    return scope
end

local function push_child<T>(parent: SourceNode<any>, child: Node<any>)
    table.insert(parent, child)
    table.insert(child.parents, parent)
end

local function push_scope<T>(node: Node<T>)
    local n = scopes.n + 1
    scopes.n = n
    scopes[n] = node
end

local function pop_scope()
    local n = scopes.n
    scopes.n = n - 1
    scopes[n] = nil
end

local function push_cleanup<T>(node: Node<T>, cleanup: () -> ())
    if node.cleanups then
        table.insert(node.cleanups, cleanup)
    else
        node.cleanups = { cleanup }
    end
end

local function flush_cleanups<T>(node: Node<T>)
    if node.cleanups then
        for _, fn in next, node.cleanups do
            local ok, err: string? = pcall(fn)
            if not ok then throw(`cleanup error: {err}`) end
        end

        table.clear(node.cleanups)
    end
end

local function find_and_swap_pop<T>(t: { T }, v: T)
    local i = table.find(t, v) :: number
    local n = #t
    t[i] = t[n]
    t[n] = nil
end

local function unparent<T>(node: Node<T>)
    local parents = node.parents

    for i, parent in parents do
        find_and_swap_pop(parent, node)
        parents[i] = nil
    end
end

local function destroy<T>(node: Node<T>)
    flush_cleanups(node)
    unparent(node)
    
    if node.owner then
        find_and_swap_pop(node.owner.owned :: { Node<T> }, node)
        node.owner = false
    end

    if node.owned then
        local owned = node.owned
        while owned[1] do destroy(owned[1]) end
    end
end

local function destroy_owned<T>(node: Node<T>)
    if node.owned then
        local owned = node.owned
        while owned[1] do destroy(owned[1]) end
    end
end

local update_queue = { n = 0 } :: { n: number, [number]: Node<any> }

local function evaluate_node<T>(node: Node<T>)
    if flags.strict then
        local initial_value = node.cache

        for i = 1, 2 do
            local cur_value = node.cache

            flush_cleanups(node)
            destroy_owned(node)
    
            push_scope(node)
            local ok, new_value = ycall(node.effect :: (T) -> T, cur_value)
            pop_scope()
            
            if not ok then
                table.clear(update_queue)
                update_queue.n = 0
                throw(`effect stacktrace:\n{new_value :: string}`)
            end

            node.cache = new_value :: T
        end

        return initial_value ~= node.cache
    else
        local cur_value = node.cache

        flush_cleanups(node)
        destroy_owned(node)

        push_scope(node)
        local ok, new_value = pcall(node.effect :: (T) -> T, node.cache)
        pop_scope()

        if not ok then
            table.clear(update_queue)
            update_queue.n = 0
            throw(`effect stacktrace:\n{new_value}\n`)
        end
    
        node.cache = new_value
        return cur_value ~= new_value
    end
end

local function queue_children_for_update<T>(node: SourceNode<T>)
    local i = update_queue.n
    while node[1] do
        i += 1
        update_queue[i] = node[1]
        unparent(node[1])
    end
    update_queue.n = i
end

local function get_update_queue_length()
    return update_queue.n
end

local function flush_update_queue(from: number)
    local i = from + 1
    while i <= update_queue.n do
        local node = update_queue[i]
        --assert(node.effect)

        if node.owner and evaluate_node(node) then
            queue_children_for_update(node)
        end

        update_queue[i] = false :: any
        i += 1
    end
    
    update_queue.n = from
end

local function update_descendants<T>(root: SourceNode<T>)
    local n0 = update_queue.n
    queue_children_for_update(root)

    if flags.batch then return end

    local i = n0 + 1
    while i <= update_queue.n do
        local node = update_queue[i]
        --assert(node.effect)

        -- check if node is still owned in case destroyed after queued
        if node.owner and evaluate_node(node) then
            queue_children_for_update(node)
        end

        update_queue[i] = false :: any -- false instead of nil to avoid sparse
        i += 1
    end

    update_queue.n = n0
end

local function push_child_to_scope<T>(node: SourceNode<T>)
    local scope = get_scope()
    if scope and scope.effect then -- do not track nodes with no effect
        push_child(node, scope)
    end
end

local function create_node<T>(owner: false | Node<any>, effect: false | (T) -> T, value: T): Node<T>
    local node: Node<T> = {
        cache = value,
        effect = effect,
        cleanups = false,

        context = false,

        owner = owner,
        owned = false,

        parents = {},
    }

    if owner then
        if owner.owned then
            table.insert(owner.owned, node)
        else
            owner.owned = { node }
        end
    end

    return node
end

local function create_source_node<T>(value: T): SourceNode<T>
    return { cache = value }
end

local function get_children<T>(node: Node<T>): { Node<unknown> }
    return { unpack(node) } :: { Node<any> }
end

local function set_context<T>(node: Node<T>, key: number, value: unknown)
    if node.context then
        node.context[key] = value
    else
        node.context = { [key] = value }
    end
end

return table.freeze {
    push_scope = push_scope,
    pop_scope = pop_scope,
    evaluate_node = evaluate_node,
    get_scope = get_scope,
    assert_stable_scope = assert_stable_scope,
    push_cleanup = push_cleanup,
    destroy = destroy,
    flush_cleanups = flush_cleanups,
    push_child_to_scope = push_child_to_scope,
    update_descendants = update_descendants,
    push_child = push_child,
    create_node = create_node,
    create_source_node = create_source_node,
    get_children = get_children,
    flush_update_queue = flush_update_queue,
    get_update_queue_length = get_update_queue_length,
    set_context = set_context,
    scopes = scopes
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="169">
                <Properties>
                  <string name="Name">jsx</string>
                  <string name="Source"><![CDATA[local action = require(script.Parent.action)()
local changed = require(script.Parent.changed)
local create = require(script.Parent.create)
local tags = require(script.Parent.tags)
local untrack = require(script.Parent.untrack)

type Props = { [any]: any }

local IGNORED_CHANGE_PROPS = {
    AncestryChanged = true,
    AttributeChanged = true,
    AxisChanged = true,
    ButtonChanged = true,
    ControlPointChanged = true,
    EmotesChanged = true,
    HealthChanged = true,
    InputChanged = true,
    LightingChanged = true,
    SelectionChanged = true,
    StateChanged = true,
    ThemeChanged = true,
    ViewportChanged = true,
}

local function jsx(tag: string | (Props) -> any, props: Props, ...): any
    props = props or {}

    if type(tag) == "string" then
        tag = tags[tag] or tag

        local actions = {}

        for key, value in props do
            if type(key) ~= "string" or IGNORED_CHANGE_PROPS[key] then
                continue
            end

            local property = string.match(key, "^(.+)Changed$")

            if property then
                table.insert(actions, changed(property, value))
                props[key] = nil
            end
        end

        for _, action in actions do
            table.insert(props, action)
        end

        if props.action then
            table.insert(props, action(props.action))
            props.action = nil
        end

        for index = 1, select("#", ...) do
            local child = select(index, ...)
            table.insert(props, child)
        end

        return create(tag)(props)
    end

    local count = select("#", ...)

    if count > 1 then
        props.children = { ... }
    elseif count == 1 then
        props.children = ...
    end

    return untrack(function()
        return tag(props)
    end)
end

return jsx
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="170">
                <Properties>
                  <string name="Name">maps</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local flags = require(script.Parent.flags)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local create_source_node = graph.create_source_node
local push_child_to_scope = graph.push_child_to_scope
local update_descendants = graph.update_descendants
local assert_stable_scope = graph.assert_stable_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local evaluate_node = graph.evaluate_node
local destroy = graph.destroy

type Map<K, V> = { [K]: V }

local function check_primitives(t: {})
    if not flags.strict then return end

    for _, v in next, t do
        if type(v) == "table" or type(v) == "userdata" or type(v) == "function" then continue end
        throw("table source map cannot return primitives")
    end
end

local function indexes<K, VI, VO>(input: () -> Map<K, VI>, transform: (() -> VI, K) -> VO): () -> { VO }
    local owner = assert_stable_scope()
    local subowner = create_node(owner, false, false)

    local input_cache = {} :: Map<K, VI>
    local output_cache = {} :: Map<K, VO>
    local input_nodes = {} :: Map<K, SourceNode<VI>>
    local remove_queue = {} :: { K }
    local scopes = {} :: Map<K, Node<unknown>>

    local function update_children(data)
        -- queue removed values
        for i in next, input_cache do
            if data[i] == nil then
                table.insert(remove_queue, i)
            end
        end

        -- remove queued values
        for _, i in next, remove_queue do
            destroy(scopes[i])

            input_cache[i] = nil
            output_cache[i] = nil
            input_nodes[i] = nil
            scopes[i] = nil
        end

        table.clear(remove_queue)

        push_scope(subowner)

        -- process new or changed values
        for i, v in next, data do
            local cv = input_cache[i]

            if cv ~= v then
                if cv == nil then -- create new scope and run transform
                    local scope = create_node(subowner, false, false)
                    scopes[i] = scope :: Node<any>

                    local node = create_source_node(v)

                    push_scope(scope)

                    local ok, result = pcall(transform, function()
                        push_child_to_scope(node)
                        return node.cache
                    end, i)
                    
                    pop_scope()

                    if not ok then
                        pop_scope() -- subowner scope
                        error(result, 0)
                    end
                    
                    input_nodes[i] = node
                    output_cache[i] = result
                else -- update source
                    input_nodes[i].cache = v
                    update_descendants(input_nodes[i])
                end

                input_cache[i] = v
            end
        end

        pop_scope()

        local output_array = table.create(#scopes)
        for _, v in next, output_cache do
            table.insert(output_array, v)
        end
        check_primitives(output_array)
        
        return output_array
    end

    local node = create_node(owner, function()
        return update_children(input())
    end, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

local function values<K, VI, VO>(input: () -> Map<K, VI>, transform: (VI, () -> K) -> VO): () -> { VO }
    local owner  = assert_stable_scope()
    local subowner = create_node(owner, false, false)
    
    local cur_input_cache_up = {} :: Map<VI, K>
    local new_input_cache_up = {} :: Map<VI, K>
    local output_cache = {} :: Map<VI, VO>
    local input_nodes = {} :: Map<VI, SourceNode<K>>
    local scopes = {} :: Map<VI, Node<unknown>>

    local function update_children(data: Map<K, VI>)
        local cur_input_cache, new_input_cache = cur_input_cache_up, new_input_cache_up

        if flags.strict then
            local cache = {}
            for _, v in next, data do
                if cache[v] ~= nil then
                    throw "duplicate table value detected"
                end
                cache[v] = true
            end
        end

        push_scope(subowner)
    
        -- process data
        for i, v in next, data do
            new_input_cache[v] = i

            local cv = cur_input_cache[v]
            
            if cv == nil then -- create new scope and run transform
                local scope = create_node(subowner, false, false)
                scopes[v] = scope :: Node<any>

                local node = create_source_node(i)
    
                push_scope(scope)
                
                local ok, result = pcall(transform, v, function()
                    push_child_to_scope(node)
                    return node.cache
                end)
                
                pop_scope()

                if not ok then
                    pop_scope() -- subowner scope
                    error(result, 0)
                end

                input_nodes[v] = node
                output_cache[v] = result
            else -- update source
                if cv ~= i then
                    input_nodes[v].cache = i
                    update_descendants(input_nodes[v])
                end

                cur_input_cache[v] = nil
            end
        end

        pop_scope()

        -- remove old values
        for v in next, cur_input_cache do
            destroy(scopes[v])

            output_cache[v] = nil
            input_nodes[v] = nil
            scopes[v] = nil
        end

        -- update buffer cache
        table.clear(cur_input_cache)
        cur_input_cache_up, new_input_cache_up = new_input_cache, cur_input_cache

        local output_array = table.create(#scopes)
        for _, v in next, output_cache do
            table.insert(output_array, v)
        end
        check_primitives(output_array)

        return output_array
    end

    local node = create_node(owner, function()
        return update_children(input())
    end, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

return function() return indexes, values end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="171">
                <Properties>
                  <string name="Name">mount</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local root = require(script.Parent.root)
local apply = require(script.Parent.apply)

local function mount<T>(component: () -> T, target: Instance?): () -> ()
    return root(function()
        local result = component()
        if target then apply(target, { result }) end
    end)
end

return mount :: (<T>(component: () -> T, target: Instance) -> () -> ()) & ((component: () -> ()) -> () -> ())
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="172">
                <Properties>
                  <string name="Name">read</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local function read<T>(value: T | () -> T): T
    return if type(value) == "function" then value() else value
end

return read
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="173">
                <Properties>
                  <string name="Name">root</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local destroy = graph.destroy

local refs = {}

local function root<T...>(fn: (destroy: () -> ()) -> T...): (() -> (), T...)
    local node = create_node(false, false, false)

    refs[node] = true -- prevent gc of root node

    local destroy = function()
        if not refs[node] then throw "root already destroyed" end
        refs[node] = nil
        destroy(node)
    end

    push_scope(node)

    local function efn(err: string) return debug.traceback(err, 3) end
    local result = { xpcall(fn, efn, destroy) }

    pop_scope()

    if not result[1] then
        destroy()
        throw(`error while running root():\n\n{result[2]}`)
    end

    return destroy, unpack(result :: any, 2)
end

return root :: <T...>(fn: (destroy: () -> ()) -> T...) -> (() -> (), T...)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="174">
                <Properties>
                  <string name="Name">show</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local switch = require(script.Parent.switch)

local function show<T>(source: () -> any, component: () -> T, fallback: (() -> T)?): () -> T?
    local function truthy()
        return not not source()
    end

    return switch(truthy) {
        [true] = component,
        [false] = fallback,
    }
end

return show ::
    (<T>(source: () -> any, component: () -> T) -> () -> T?) &
    (<T, U>(source: () -> any, component: () -> T, fallback: () -> U) -> () -> (T | U)?)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="175">
                <Properties>
                  <string name="Name">source</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_source_node = graph.create_source_node
local push_child_to_scope = graph.push_child_to_scope
local update_descendants = graph.update_descendants

export type Source<T> = (() -> T) & ((value: T) -> T)

local function source<T>(initial_value: T): Source<T>
    local node = create_source_node(initial_value)

    return function(...): T
        if select("#", ...) == 0 then -- no args were given
            push_child_to_scope(node)
            return node.cache
        end

        local v = ... :: T
        if node.cache == v and (type(v) ~= "table" or table.isfrozen(v)) then 
            return v
        end

        node.cache = v
        update_descendants(node)
        return v
    end
end

return source :: (<T>(initial_value: T) -> Source<T>) & (<T>() -> Source<T>)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="176">
                <Properties>
                  <string name="Name">spring</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local Vector3 = game and Vector3 or require "test/mock".Vector3 :: never

--[[

Supported datatypes:
- number
- CFrame
- Color3
- UDim
- UDim2
- Vector2
- Vector3
- Rect

Unsupported datatypes:
- bool
- Vector2int16
- Vector3int16
- EnumItem

]]

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local create_source_node = graph.create_source_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node
local update_descendants = graph.update_descendants
local push_child_to_scope = graph.push_child_to_scope

local UPDATE_RATE = 120
local TOLERANCE = 0.0001

type Vec3 = Vector3

local function Vec3(x: number?, y: number?, z: number?)
    return Vector3.new(x, y, z)
end

local ZERO = Vec3(0, 0, 0)

type Animatable = number | CFrame | Color3 | UDim | UDim2 | Vector2 | Vector3

type SpringData<T> = {
    k: number, -- spring constant
    c: number, -- damping coeff

    -- dimensions 1-3
    x0_123: Vec3,
    x1_123: Vec3,
    v_123: Vec3,

    -- dimensions 4-6
    x0_456: Vec3,
    x1_456: Vec3,
    v_456: Vec3,

    source_value: T -- current value of spring input source
}

type TypeToVec6<T> = (T) -> (Vec3, Vec3)
type Vec6ToType<T> = (Vec3, Vec3) -> T

local type_to_vec6 = {
    number = function(v)
        return Vec3(v, 0, 0), ZERO
    end :: TypeToVec6<number>,

    CFrame = function(v)
        return v.Position, Vec3(v:ToEulerAnglesXYZ())
    end :: TypeToVec6<CFrame>,

    Color3 = function(v)
        -- todo: hsv, oklab?
        return Vec3(v.R, v.G, v.B), ZERO
    end :: TypeToVec6<Color3>,

    UDim = function(v)
        return Vec3(v.Scale, v.Offset, 0), ZERO
    end :: TypeToVec6<UDim>,
    
    UDim2 = function(v)
        return Vec3(v.X.Scale, v.X.Offset, v.Y.Scale), Vec3(v.Y.Offset, 0, 0)
    end :: TypeToVec6<UDim2>,

    Vector2 = function(v)
        return Vec3(v.X, v.Y, 0), ZERO
    end :: TypeToVec6<Vector2>,

    Vector3 = function(v)
        return v, ZERO
    end :: TypeToVec6<Vector3>,

    Rect = function(v)
        return Vec3(v.Min.X, v.Min.Y, v.Max.X), Vec3(v.Max.Y, 0, 0)
    end :: TypeToVec6<Rect>
}

local vec6_to_type = {
    number = function(a, b)
        return a.X
    end :: Vec6ToType<number>,

    CFrame = function(a, b)
        return CFrame.new(a) * CFrame.fromEulerAnglesXYZ(b.X, b.Y, b.Z)
    end :: Vec6ToType<CFrame>,

    Color3 = function(v)
        return Color3.new(math.clamp(v.X, 0, 1), math.clamp(v.Y, 0, 1), math.clamp(v.Z, 0, 1))
    end :: Vec6ToType<Color3>,

    UDim = function(v)
        return UDim.new(v.X, math.round(v.Y))
    end :: Vec6ToType<UDim>,
    
    UDim2 = function(a, b)
        return UDim2.new(a.X, math.round(a.Y), a.Z, math.round(b.X))
    end :: Vec6ToType<UDim2>,

    Vector2 = function(v)
        return Vector2.new(v.X, v.Y)
    end :: Vec6ToType<Vector2>,

    Vector3 = function(v)
        return v
    end :: Vec6ToType<Vector3>,

    Rect = function(a, b)
        return Rect.new(a.X, a.Y, a.Z, b.X)
    end :: Vec6ToType<Rect>
}

local invalid_type = {
    __index = function(_, t: string)
        throw(`cannot spring type {t}`)
    end
}

setmetatable(type_to_vec6, invalid_type)
setmetatable(vec6_to_type, invalid_type)

-- maps spring data to its corresponding output node
-- lifetime of spring data is tied to output node
local springs: { [SpringData<any>]: SourceNode<any> } = {}
setmetatable(springs, { __mode = "v" })

local function spring<T>(source: () -> T, period: number?, damping_ratio: number?): () -> T
    local owner = assert_stable_scope()

    -- https://en.wikipedia.org/wiki/Damping

    local w_n = 2*math.pi / (period or 1)
    local z = damping_ratio or 1

    local k = w_n^2
    local c_c = 2*w_n
    local c = z * c_c

    -- todo: is there a solution other than reducing step size?
    -- todo: this does not catch all solver exploding cases
    if c > UPDATE_RATE*2 then -- solver will explode if this is true
        throw("spring damping too high, consider reducing damping or increasing period")
    end

    local data: SpringData<T> = {
        k = k,
        c = c,

        x0_123 = ZERO,
        x1_123 = ZERO,
        v_123 = ZERO,

        x0_456 = ZERO,
        x1_456 = ZERO,
        v_456 = ZERO,

        source_value = false :: any,
    }
    
    local output = create_source_node(false :: any)

    local function updater_effect()
        local value = source()
        data.x1_123, data.x1_456 = type_to_vec6[typeof(value)](value)
        data.source_value = value
        springs[data] = output -- todo: investigate why insertion is not O(1) at ~20k springs
        return value
    end

    local updater = create_node(owner, updater_effect, false :: any)

    evaluate_node(updater)

    -- set initial position to goal
    data.x0_123, data.x0_456 = data.x1_123, data.x1_456

    -- set output to goal
    output.cache = data.source_value

    return function(...)
        if select("#", ...) == 0 then -- no args were given
            push_child_to_scope(output)
            return output.cache
        end

        -- set current position to value
        local v = ... :: T
        data.x0_123, data.x0_456 = type_to_vec6[typeof(v)](v)

        -- reset velocity
        data.v_123 = ZERO
        data.v_456 = ZERO

        -- schedule spring
        springs[data] = output

        -- set output to value
        output.cache = v

        return v
    end
end

local function step_springs(dt: number)
    for data in next, springs do
        local k, c,
        x0_123, x1_123, u_123,
        x0_456, x1_456, u_456 =
            data.k, data.c,
            data.x0_123, data.x1_123, data.v_123,
            data.x0_456, data.x1_456, data.v_456

        -- calculate displacement from target
        local dx_123 = x0_123 - x1_123
        local dx_456 = x0_456 - x1_456

        -- calculate spring force
        local fs_123 = dx_123*-k
        local fs_456 = dx_456*-k

        -- calculate friction force
        local ff_123 = u_123*-c
        local ff_456 = u_456*-c

        -- calculate acceleration step
        local dv_123 = (fs_123 + ff_123)*dt
        local dv_456 = (fs_456 + ff_456)*dt

        -- apply acceleration step
        local v_123 = u_123 + dv_123
        local v_456 = u_456 + dv_456

        -- calculate new position
        local x_123 = x0_123 + v_123*dt
        local x_456 = x0_456 + v_456*dt

        data.x0_123, data.x0_456 = x_123, x_456
        data.v_123, data.v_456 = v_123, v_456
    end
end

local remove_queue = {}

local function update_spring_sources()
    for data, output in next, springs do
        local x0_123, x1_123, v_123,
        x0_456, x1_456, v_456 =
            data.x0_123, data.x1_123, data.v_123,
            data.x0_456, data.x1_456, data.v_456
    
        local dx_123, dx_456 =
            x0_123 - x1_123,
            x0_456 - x1_456

        -- todo: can this false positive?
        if (v_123 + v_456 + dx_123 + dx_456).Magnitude < TOLERANCE then
            -- close enough to target, unshedule spring and set value to target
            table.insert(remove_queue, data)
            output.cache = data.source_value
        else
            output.cache = vec6_to_type[typeof(data.source_value)](x0_123, x0_456)
        end

        update_descendants(output)
    end

    for _, data in next, remove_queue do
        springs[data] = nil
    end

    table.clear(remove_queue)
end

return function()
    local time_elapsed = 0

    return spring, function(dt: number)
        time_elapsed += dt

        while time_elapsed > 1 / UPDATE_RATE do
            time_elapsed -= 1 / UPDATE_RATE
            step_springs(1 / UPDATE_RATE)
        end

        update_spring_sources()
    end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="177">
                <Properties>
                  <string name="Name">switch</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local evaluate_node = graph.evaluate_node
local push_child_to_scope = graph.push_child_to_scope
local destroy = graph.destroy
local assert_stable_scope = graph.assert_stable_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope

type Map<K, V> = { [K]: V }

local function switch<T, U>(source: () -> T): (map: Map<T, ((() -> U)?)>) -> () -> U?
    local owner = assert_stable_scope()

    return function(map)
        local last_scope: Node<false>?
        local last_component: (() -> U)?

        local function update(cached): U?
            local component = map[source()]
            if component == last_component then return cached end
            last_component = component

            if last_scope then
                destroy(last_scope :: Node<any>)
                last_scope = nil
            end

            if component == nil then return nil end

            if type(component) ~= "function" then
                throw "map must map a value to a function"
            end

            local new_scope = create_node(owner, false, false)
            last_scope = new_scope :: Node<any>
            
            push_scope(new_scope)
        
            local ok, result = pcall(component)

            pop_scope()

            if not ok then error(result, 0) end

            return result
        end

        local node = create_node(owner, update, nil)

        evaluate_node(node)

        return function()
            push_child_to_scope(node)
            return node.cache
        end
    end
end

return switch
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="178">
                <Properties>
                  <string name="Name">tags</string>
                  <string name="Source"><![CDATA[local classNames = {
	"Accessory",
	"AccessoryDescription",
	"Accoutrement",
	"Actor",
	"AdGui",
	"AdPortal",
	"AirController",
	"AlignOrientation",
	"AlignPosition",
	"AngularVelocity",
	"Animation",
	"AnimationConstraint",
	"AnimationController",
	"AnimationRigData",
	"Animator",
	"ArcHandles",
	"Atmosphere",
	"Attachment",
	"AudioAnalyzer",
	"AudioChorus",
	"AudioCompressor",
	"AudioDeviceInput",
	"AudioDeviceOutput",
	"AudioDistortion",
	"AudioEcho",
	"AudioEmitter",
	"AudioEqualizer",
	"AudioFader",
	"AudioFlanger",
	"AudioListener",
	"AudioPitchShifter",
	"AudioPlayer",
	"AudioReverb",
	"AudioSearchParams",
	"Backpack",
	"BallSocketConstraint",
	"Beam",
	"BillboardGui",
	"BindableEvent",
	"BindableFunction",
	"BlockMesh",
	"BloomEffect",
	"BlurEffect",
	"BodyAngularVelocity",
	"BodyColors",
	"BodyForce",
	"BodyGyro",
	"BodyPartDescription",
	"BodyPosition",
	"BodyThrust",
	"BodyVelocity",
	"Bone",
	"BoolValue",
	"BoxHandleAdornment",
	"Breakpoint",
	"BrickColorValue",
	"BubbleChatMessageProperties",
	"BuoyancySensor",
	"Camera",
	"CanvasGroup",
	"CFrameValue",
	"CharacterMesh",
	"ChorusSoundEffect",
	"ClickDetector",
	"ClimbController",
	"Clouds",
	"Color3Value",
	"ColorCorrectionEffect",
	"CompressorSoundEffect",
	"ConeHandleAdornment",
	"Configuration",
	"ControllerManager",
	"ControllerPartSensor",
	"CornerWedgePart",
	"CurveAnimation",
	"CylinderHandleAdornment",
	"CylinderMesh",
	"CylindricalConstraint",
	"DataStoreGetOptions",
	"DataStoreIncrementOptions",
	"DataStoreOptions",
	"DataStoreSetOptions",
	"Decal",
	"DepthOfFieldEffect",
	"Dialog",
	"DialogChoice",
	"DistortionSoundEffect",
	"DoubleConstrainedValue",
	"DragDetector",
	"Dragger",
	"EchoSoundEffect",
	"EditableImage",
	"EditableMesh",
	"EqualizerSoundEffect",
	"EulerRotationCurve",
	"ExperienceInviteOptions",
	"Explosion",
	"FaceControls",
	"FileMesh",
	"Fire",
	"FlangeSoundEffect",
	"FloatCurve",
	"FloorWire",
	"Folder",
	"ForceField",
	"Frame",
	"GetTextBoundsParams",
	"Glue",
	"GroundController",
	"Handles",
	"Hat",
	"HiddenSurfaceRemovalAsset",
	"Highlight",
	"HingeConstraint",
	"Hole",
	"Humanoid",
	"HumanoidController",
	"HumanoidDescription",
	"IKControl",
	"ImageButton",
	"ImageHandleAdornment",
	"ImageLabel",
	"IntConstrainedValue",
	"InternalSyncItem",
	"IntersectOperation",
	"IntValue",
	"Keyframe",
	"KeyframeMarker",
	"KeyframeSequence",
	"LinearVelocity",
	"LineForce",
	"LineHandleAdornment",
	"LocalizationTable",
	"LocalScript",
	"ManualGlue",
	"ManualWeld",
	"MarkerCurve",
	"MaterialVariant",
	"MeshPart",
	"Model",
	"ModuleScript",
	"Motor",
	"Motor6D",
	"MotorFeature",
	"NegateOperation",
	"NoCollisionConstraint",
	"NumberPose",
	"NumberValue",
	"ObjectValue",
	"OperationGraph",
	"Pants",
	"Part",
	"ParticleEmitter",
	"PartOperation",
	"Path2D",
	"PathfindingLink",
	"PathfindingModifier",
	"PitchShiftSoundEffect",
	"Plane",
	"PlaneConstraint",
	"PluginCapabilities",
	"PointLight",
	"Pose",
	"PrismaticConstraint",
	"ProximityPrompt",
	"RayValue",
	"RemoteEvent",
	"RemoteFunction",
	"ReverbSoundEffect",
	"RigidConstraint",
	"RobloxEditableImage",
	"RocketPropulsion",
	"RodConstraint",
	"RopeConstraint",
	"Rotate",
	"RotateP",
	"RotateV",
	"RotationCurve",
	"ScreenGui",
	"Script",
	"ScrollingFrame",
	"Seat",
	"SelectionBox",
	"SelectionPartLasso",
	"SelectionPointLasso",
	"SelectionSphere",
	"Shirt",
	"ShirtGraphic",
	"SkateboardController",
	"SkateboardPlatform",
	"Sky",
	"Smoke",
	"Snap",
	"Sound",
	"SoundGroup",
	"Sparkles",
	"SpawnLocation",
	"SpecialMesh",
	"SphereHandleAdornment",
	"SpotLight",
	"SpringConstraint",
	"StarterGear",
	"StringValue",
	"StudioAttachment",
	"StudioCallout",
	"StyleDerive",
	"StyleLink",
	"StyleRule",
	"StyleSheet",
	"SunRaysEffect",
	"SurfaceAppearance",
	"SurfaceGui",
	"SurfaceLight",
	"SurfaceSelection",
	"SwimController",
	"Team",
	"TeleportOptions",
	"TerrainDetail",
	"TerrainRegion",
	"TextBox",
	"TextButton",
	"TextChannel",
	"TextChatCommand",
	"TextChatMessageProperties",
	"TextLabel",
	"Texture",
	"Tool",
	"Torque",
	"TorsionSpringConstraint",
	"TrackerStreamAnimation",
	"Trail",
	"TremoloSoundEffect",
	"TrussPart",
	"UIAspectRatioConstraint",
	"UICorner",
	"UIDragDetector",
	"UIFlexItem",
	"UIGradient",
	"UIGridLayout",
	"UIListLayout",
	"UIPadding",
	"UIPageLayout",
	"UIScale",
	"UISizeConstraint",
	"UIStroke",
	"UITableLayout",
	"UITextSizeConstraint",
	"UnionOperation",
	"UniversalConstraint",
	"UnreliableRemoteEvent",
	"UserNotification",
	"UserNotificationPayload",
	"UserNotificationPayloadAnalyticsData",
	"UserNotificationPayloadJoinExperience",
	"UserNotificationPayloadParameterValue",
	"Vector3Curve",
	"Vector3Value",
	"VectorForce",
	"VehicleController",
	"VehicleSeat",
	"VelocityMotor",
	"VideoFrame",
	"ViewportFrame",
	"WedgePart",
	"Weld",
	"WeldConstraint",
	"Wire",
	"WireframeHandleAdornment",
	"WorldModel",
	"WrapLayer",
	"WrapTarget",
}

local tags = {}

for _, className in classNames do
	tags[string.lower(className)] = className
end

return tags
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="179">
                <Properties>
                  <string name="Name">throw</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local function VIDE_ASSERT(msg): any
    error(msg, 0)
end

return VIDE_ASSERT
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="180">
                <Properties>
                  <string name="Name">untrack</string>
                  <string name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local get_scope = graph.get_scope

local function untrack<T>(source: () -> T): T
    local scope = get_scope()
    
    if scope then
        -- sources are only tracked if the node in scope has an effect
        local effect = scope.effect
        scope.effect = false

        local ok, result = pcall(source)

        scope.effect = effect :: () -> ()

        if not ok then error(result, 0) end

        return result
    else
        return source()
    end
end

return untrack
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="181">
          <Properties>
            <string name="Name">@rbxts-js</string>
          </Properties>
          <Item class="ModuleScript" referent="182">
            <Properties>
              <string name="Name">Boolean</string>
              <string name="Source"><![CDATA[--!strict
return {
	toJSBoolean = require(script.toJSBoolean),
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="183">
              <Properties>
                <string name="Name">toJSBoolean</string>
                <string name="Source"><![CDATA[--!strict
local Packages = script.Parent.Parent
local Number = require(Packages.Number)

-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean
return function(val: any): boolean
	return not not val and val ~= 0 and val ~= "" and not Number.isNaN(val)
end
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="184">
            <Properties>
              <string name="Name">ChalkLua</string>
              <string name="Source"><![CDATA[-- ROBLOX NOTE: inline stringReplaceAll to keep ChalkLua as one file
local function stringReplaceAll(string_, substring, replacer)
	local index = string.find(string_, substring, 1, true)
	if index == nil then
		return string_
	end
	local substringLength = #substring
	local endIndex = 1
	local returnValue = ""
	repeat
		returnValue ..= string.sub(string_, endIndex, index - 1) .. substring .. replacer
		endIndex = index + substringLength
		index = string.find(string_, substring, endIndex, true)
	until not (index ~= nil)
	returnValue ..= string.sub(string_, endIndex)
	return returnValue
end

-- ROBLOX NOTE: inline stringEncaseCRLFWithFirstIndex to keep ChalkLua as one file
local function stringEncaseCRLFWithFirstIndex(string_, prefix, postfix, index)
	local endIndex = 1
	local returnValue = ""
	repeat
		local gotCR = string.sub(string_, index - 1, index - 1) == "\r"
		returnValue ..= string.sub(string_, endIndex, if gotCR then index - 2 else index - 1) .. prefix .. (if gotCR
			then "\r\n"
			else "\n") .. postfix
		endIndex = index + 1
		index = string.find(string_, "\n", endIndex)
	until not (index ~= nil)
	returnValue ..= string.sub(string_, endIndex)
	return returnValue
end

local ansiStyles = {
	modifier = {
		reset = { 0, 0 },
		bold = { 1, 22 },
		dim = { 2, 22 },
		italic = { 3, 23 },
		underline = { 4, 24 },
		overline = { 53, 55 },
		inverse = { 7, 27 },
		hidden = { 8, 28 },
		strikethrough = { 9, 29 },
	},

	color = {
		black = { 30, 39 },
		red = { 31, 39 },
		green = { 32, 39 },
		yellow = { 33, 39 },
		blue = { 34, 39 },
		magenta = { 35, 39 },
		cyan = { 36, 39 },
		white = { 37, 39 },

		-- bright color
		blackBright = { 90, 39 },
		gray = { 90, 39 },
		grey = { 90, 39 },
		redBright = { 91, 39 },
		greenBright = { 92, 39 },
		yellowBright = { 93, 39 },
		blueBright = { 94, 39 },
		magentaBright = { 95, 39 },
		cyanBright = { 96, 39 },
		whiteBright = { 97, 39 },
	},

	bgColor = {
		bgBlack = { 40, 49 },
		bgRed = { 41, 49 },
		bgGreen = { 42, 49 },
		bgYellow = { 43, 49 },
		bgBlue = { 44, 49 },
		bgMagenta = { 45, 49 },
		bgCyan = { 46, 49 },
		bgWhite = { 47, 49 },

		-- bright color
		bgBlackBright = { 100, 49 },
		bgGray = { 100, 49 },
		bgGrey = { 100, 49 },
		bgRedBright = { 101, 49 },
		bgGreenBright = { 102, 49 },
		bgYellowBright = { 103, 49 },
		bgBlueBright = { 104, 49 },
		bgMagentaBright = { 105, 49 },
		bgCyanBright = { 106, 49 },
		bgWhiteBright = { 107, 49 },
	},
}

local ansi16 = "%c[%dm"
local ansi256 = "%c[%d;5;%dm"
local ESC = 27
local ANSI_SET_FOREGROUND = 38
local ANSI_SET_BACKGROUND = 48

local styles = {}

for groupName, group in pairs(ansiStyles) do
	for styleName, style in pairs(group) do
		styles[styleName] = {
			open = string.format(ansi16, ESC, style[1]),
			close = string.format(ansi16, ESC, style[2]),
		}
	end
end

local createStyler
local applyStyle

local function compositeStyler(style, otherStyle)
	return createStyler(style.open .. otherStyle.open, otherStyle.close .. style.close)
end

local function foundProcessService()
	local success = pcall(function()
		game:GetService("ProcessService")
	end)
	return success
end

local Chalk = { level = 2 }
if _G.NOCOLOR or not foundProcessService() then
	Chalk.level = 0
end

setmetatable(Chalk, {
	__call = function(_, str)
		if str == nil or type(str) == "string" and #str == 0 then
			return ""
		end
		return tostring(str)
	end,
})

function createStyler(open, close)
	local styler = {
		open = open,
		close = close,
	}

	setmetatable(styler, {
		__call = function(self, str)
			return applyStyle(self, str)
		end,
		__concat = function(self, other)
			return compositeStyler(self, other)
		end,
	})

	return styler
end

function applyStyle(self, str)
	if str == nil or type(str) == "string" and #str == 0 then
		return ""
	end
	if Chalk.level == 0 then
		return tostring(str)
	end

	local styler = self

	local openAll, closeAll = styler.open, styler.close
	if string.match(str, "\u{001B}") then
		-- ROBLOX deviation START: no parent styles support yet
		-- Replace any instances already present with a re-opening code
		-- otherwise only the part of the string until said closing code
		-- will be colored, and the rest will simply be 'plain'.
		str = stringReplaceAll(str, styler.close, styler.open)
		-- ROBLOX deviation END
	end

	-- We can move both next actions out of loop, because remaining actions in loop won't have
	-- any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	-- after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	local lfIndex = string.find(str, "\n")
	if lfIndex ~= nil then
		str = stringEncaseCRLFWithFirstIndex(str, closeAll, openAll, lfIndex)
	end

	return self.open .. tostring(str) .. self.close
end

local function noStyle()
	return createStyler("", "")
end

local close = string.format(ansi16, ESC, 39)
local bgClose = string.format(ansi16, ESC, 49)
local reset = string.format(ansi16, ESC, 0)

for styleName, style in pairs(styles) do
	Chalk[styleName] = createStyler(style.open, style.close)
end

Chalk["reset"] = createStyler(reset, reset)

local function rgbToAnsi256(red, green, blue)
	if red == green and green == blue then
		if red < 8 then
			return 16
		end
		if red > 248 then
			return 231
		end

		return math.round((((red - 8) / 247) * 24) + 232)
	end

	local ansi = 16
		+ (36 * math.round(red / 255 * 5))
		+ (6 * math.round(green / 255 * 5))
		+ math.round(blue / 255 * 5)
	return ansi
end

Chalk["rgb"] = function(red, green, blue)
	if
		type(red) ~= "number"
		or type(green) ~= "number"
		or type(blue) ~= "number"
		or red > 255
		or red < 0
		or green > 255
		or green < 0
		or blue > 255
		or blue < 0
	then
		return noStyle()
	end
	local open = string.format(ansi256, ESC, ANSI_SET_FOREGROUND, rgbToAnsi256(red, green, blue))
	return createStyler(open, close)
end

Chalk["bgRgb"] = function(red, green, blue)
	if
		type(red) ~= "number"
		or type(green) ~= "number"
		or type(blue) ~= "number"
		or red > 255
		or red < 0
		or green > 255
		or green < 0
		or blue > 255
		or blue < 0
	then
		return noStyle()
	end
	local open = string.format(ansi256, ESC, ANSI_SET_BACKGROUND, rgbToAnsi256(red, green, blue))
	return createStyler(open, bgClose)
end

local function hexToRgb(hex)
	local red = tonumber(string.sub(hex, 2, 3), 16)
	local blue = tonumber(string.sub(hex, 4, 5), 16)
	local green = tonumber(string.sub(hex, 6, 7), 16)

	return rgbToAnsi256(red, blue, green)
end

Chalk["hex"] = function(hex)
	if type(hex) ~= "string" or string.find(hex, "#%X") ~= nil or #hex ~= 7 then
		return noStyle()
	end
	local open = string.format(ansi256, ESC, ANSI_SET_FOREGROUND, hexToRgb(hex))
	return createStyler(open, close)
end

Chalk["bgHex"] = function(hex)
	if type(hex) ~= "string" or string.find(hex, "#%X") ~= nil or #hex ~= 7 then
		return noStyle()
	end
	local open = string.format(ansi256, ESC, ANSI_SET_BACKGROUND, hexToRgb(hex))
	return createStyler(open, bgClose)
end

Chalk["ansi"] = function(ansi)
	if type(ansi) ~= "number" or ansi < 30 or (ansi > 37 and ansi < 90) or ansi > 97 then
		return noStyle()
	end
	local open = string.format(ansi16, ESC, ansi)
	return createStyler(open, close)
end

Chalk["bgAnsi"] = function(ansi)
	if type(ansi) ~= "number" or ansi < 40 or (ansi > 47 and ansi < 100) or ansi > 107 then
		return noStyle()
	end
	local open = string.format(ansi16, ESC, ansi)
	return createStyler(open, bgClose)
end

Chalk["ansi256"] = function(ansi)
	if type(ansi) ~= "number" or ansi < 0 or ansi > 255 then
		return noStyle()
	end
	local open = string.format(ansi256, ESC, ANSI_SET_FOREGROUND, ansi)
	return createStyler(open, close)
end

Chalk["bgAnsi256"] = function(ansi)
	if type(ansi) ~= "number" or ansi < 0 or ansi > 255 then
		return noStyle()
	end
	local open = string.format(ansi256, ESC, ANSI_SET_BACKGROUND, ansi)
	return createStyler(open, bgClose)
end

return Chalk
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="185">
            <Properties>
              <string name="Name">Collections</string>
              <string name="Source"><![CDATA[--!strict
local Packages = script.Parent

local Array = require(script.Array)
local Map = require(script.Map)
local Object = require(script.Object)
local Set = require(script.Set)
local WeakMap = require(script.WeakMap)
local inspect = require(script.inspect)

local types = require(Packages.ES7Types)

export type Array<T> = types.Array<T>
export type Map<T, V> = types.Map<T, V>
export type Object = types.Object
export type Set<T> = types.Set<T>
export type WeakMap<T, V> = types.WeakMap<T, V>

return {
	Array = Array,
	Object = Object,
	Map = Map.Map,
	coerceToMap = Map.coerceToMap,
	coerceToTable = Map.coerceToTable,
	Set = Set,
	WeakMap = WeakMap,
	inspect = inspect,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="186">
              <Properties>
                <string name="Name">Array</string>
                <string name="Source"><![CDATA[--!strict
local Packages = script.Parent.Parent
local ES7Types = require(Packages.ES7Types)

export type Array<T> = ES7Types.Array<T>

return {
	concat = require(script.concat),
	every = require(script.every),
	filter = require(script.filter),
	find = require(script.find),
	findIndex = require(script.findIndex),
	flat = require(script.flat),
	flatMap = require(script.flatMap),
	forEach = require(script.forEach),
	from = require(script.from),
	includes = require(script.includes),
	indexOf = require(script.indexOf),
	isArray = require(script.isArray),
	join = require(script.join),
	map = require(script.map),
	reduce = require(script.reduce),
	reverse = require(script.reverse),
	shift = require(script.shift),
	slice = require(script.slice),
	some = require(script.some),
	sort = require(script.sort),
	splice = require(script.splice),
	unshift = require(script.unshift),
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="187">
                <Properties>
                  <string name="Name">concat</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

local RECEIVED_OBJECT_ERROR = "Array.concat(...) only works with array-like tables but "
	.. "it received an object-like table.\nYou can avoid this error by wrapping the "
	.. "object-like table into an array. Example: `concat({1, 2}, {a = true})` should "
	.. "be `concat({1, 2}, { {a = true} }`"

-- capture two separate generic arguments so that the type error in abuse cases is actionable, but needs CLI-49876 to avoid a false negative
local function concat<T, S>(source: Array<T> | T, ...: Array<S> | S): Array<T> & Array<S>
	local array
	local elementCount = 0

	if isArray(source) then
		array = table.clone(source :: Array<T>)
		elementCount = #(source :: Array<T>)
	else
		elementCount += 1
		array = {}
		array[elementCount] = source :: T
	end

	for i = 1, select("#", ...) do
		local value = select(i, ...)
		local valueType = typeof(value)
		if value == nil then
			-- do not insert nil
		elseif valueType == "table" then
			-- deviation: assume that table is an array, to avoid the expensive
			-- `isArray` check. In DEV mode, we throw if it is given an object-like
			-- table.
			if __DEV__ then
				if not isArray(value) then
					error(RECEIVED_OBJECT_ERROR)
				end
			end
			for k = 1, #value do
				elementCount += 1
				array[elementCount] = value[k]
			end
		else
			elementCount += 1
			array[elementCount] = value
		end
	end

	return (array :: any) :: Array<T> & Array<S>
end

return concat
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="188">
                <Properties>
                  <string name="Name">every</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> boolean
type callbackFnWithThisArg<T, U> = (self: U, element: T, index: number, array: Array<T>) -> boolean

-- Implements Javascript's `Array.prototype.every` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): boolean
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.every called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local k = 1

	while k <= len do
		local kValue = t[k]
		local testResult

		if kValue ~= nil then
			if thisArg ~= nil then
				testResult = (callback :: callbackFnWithThisArg<T, U>)(thisArg, kValue, k, t)
			else
				testResult = (callback :: callbackFn<T>)(kValue, k, t)
			end

			if not testResult then
				return false
			end
		end
		k += 1
	end
	return true
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="189">
                <Properties>
                  <string name="Name">filter</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> boolean
type callbackFnWithThisArg<T, U> = (thisArg: U, element: T, index: number, array: Array<T>) -> boolean

-- Implements Javascript's `Array.prototype.filter` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): Array<T>
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.filter called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local res = {}
	local index = 1

	if thisArg == nil then
		for i = 1, len do
			local kValue = t[i]
			if kValue ~= nil then
				if (callback :: callbackFn<T>)(kValue, i, t) then
					res[index] = kValue
					index += 1
				end
			end
		end
	else
		for i = 1, len do
			local kValue = t[i]
			if kValue ~= nil then
				if (callback :: callbackFnWithThisArg<T, U>)(thisArg, kValue, i, t) then
					res[index] = kValue
					index += 1
				end
			end
		end
	end

	return res
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="190">
                <Properties>
                  <string name="Name">find</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type PredicateFunction<T> = (value: T, index: number, array: Array<T>) -> boolean

return function<T>(array: Array<T>, predicate: PredicateFunction<T>): T | nil
	for i = 1, #array do
		local element = array[i]
		if predicate(element, i, array) then
			return element
		end
	end
	return nil
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="191">
                <Properties>
                  <string name="Name">findIndex</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type PredicateFunction<T> = (T, number, Array<T>) -> boolean

return function<T>(array: Array<T>, predicate: PredicateFunction<T>): number
	for i = 1, #array do
		local element = array[i]
		if predicate(element, i, array) then
			return i
		end
	end
	return -1
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="192">
                <Properties>
                  <string name="Name">flat</string>
                  <string name="Source"><![CDATA[local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local function flat<T>(array: Array<T>, depth_: number?): Array<T>
	if __DEV__ then
		if typeof(array) ~= "table" then
			error(string.format("Array.flat called on %s", typeof(array)))
		end
		if depth_ ~= nil and typeof(depth_) ~= "number" then
			error("depth is not a number or nil")
		end
	end
	local depth = depth_ or 1
	local newArray = {}

	for _, v in array do
		if isArray(v) then
			local vArray = (v :: any) :: Array<T>
			local innerArrFlat: Array<T> = if depth > 1 then flat(vArray, depth - 1) else vArray
			for _, innerValue in innerArrFlat do
				table.insert(newArray, innerValue)
			end
		else
			table.insert(newArray, v)
		end
	end

	return newArray
end

return flat
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="193">
                <Properties>
                  <string name="Name">flatMap</string>
                  <string name="Source"><![CDATA[local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local flat = require(Array.flat)
local map = require(Array.map)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type callbackFn<T, U> = (element: T, index: number, array: Array<T>) -> U
type callbackFnWithThisArg<T, U, V> = (thisArg: V, element: T, index: number, array: Array<T>) -> U

local function flatMap<T, U, V>(
	array: Array<T>,
	callback: callbackFn<T, U> | callbackFnWithThisArg<T, U, V>,
	thisArg: V?
): Array<U>
	if __DEV__ then
		if typeof(array) ~= "table" then
			error(string.format("Array.flatMap called on %s", typeof(array)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end
	return flat(map(array, callback, thisArg))
end

return flatMap
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="194">
                <Properties>
                  <string name="Name">forEach</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> ()
type callbackFnWithThisArg<T, U> = (thisArg: U, element: T, index: number, array: Array<T>) -> ()

-- Implements Javascript's `Array.prototype.forEach` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): ()
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.forEach called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local k = 1

	while k <= len do
		local kValue = t[k]

		if thisArg ~= nil then
			(callback :: callbackFnWithThisArg<T, U>)(thisArg, kValue, k, t)
		else
			(callback :: callbackFn<T>)(kValue, k, t)
		end

		if #t < len then
			-- don't iterate on removed items, don't iterate more than original length
			len = #t
		end
		k += 1
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="195">
                <Properties>
                  <string name="Name">from</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Collections = Array.Parent
local Packages = Collections.Parent
local Set = require(Collections.Set)
local Map = require(Collections.Map.Map)
local isArray = require(Array.isArray)
local instanceof = require(Packages.InstanceOf)
local types = require(Packages.ES7Types)

local fromString = require(script.fromString)
local fromSet = require(script.fromSet)
local fromMap = require(script.fromMap)
local fromArray = require(script.fromArray)

type Array<T> = types.Array<T>
type Object = types.Object
type Set<T> = types.Set<T>
type Map<K, V> = types.Map<K, V>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: string | Array<T> | Set<T> | Map<any, any>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	if value == nil then
		error("cannot create array from a nil value")
	end
	local valueType = typeof(value)

	local array: Array<U> | Array<T> | Array<string>

	if valueType == "table" and isArray(value) then
		array = fromArray(value :: Array<T>, mapFn, thisArg)
	elseif instanceof(value, Set) then
		array = fromSet(value :: Set<T>, mapFn, thisArg)
	elseif instanceof(value, Map) then
		array = fromMap(value :: Map<any, any>, mapFn, thisArg)
	elseif valueType == "string" then
		array = fromString(value :: string, mapFn, thisArg)
	else
		array = {}
	end

	return array
end
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="196">
                  <Properties>
                    <string name="Name">fromArray</string>
                    <string name="Source"><![CDATA[--!strict
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object

type Array<T> = types.Array<T>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: Array<T>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	if mapFn then
		local arrayLength = #(value :: Array<T>)
		array = table.create(arrayLength)
		for i = 1, arrayLength do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, (value :: Array<T>)[i], i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)((value :: Array<T>)[i], i)
			end
		end
	else
		array = table.clone(value :: Array<T>)
	end

	return array
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="197">
                  <Properties>
                    <string name="Name">fromMap</string>
                    <string name="Source"><![CDATA[--!strict
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>
type Map<K, V> = types.Map<K, V>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: Map<any, any>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	if mapFn then
		array = {}
		for i, v in value :: any do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, v, i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)(v, i)
			end
		end
	else
		array = {}
		for i, v in value :: any do
			(array :: Array<T>)[i] = v
		end
	end

	return array
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="198">
                  <Properties>
                    <string name="Name">fromSet</string>
                    <string name="Source"><![CDATA[--!strict
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>
type Set<T> = types.Set<T>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: Set<T>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	if mapFn then
		array = {}
		for i, v in value :: any do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, v, i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)(v, i)
			end
		end
	else
		array = table.clone((value :: any)._array)
	end

	return array
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="199">
                  <Properties>
                    <string name="Name">fromString</string>
                    <string name="Source"><![CDATA[--!strict
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>

type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: string,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	local valueStringLength = #value
	array = table.create(valueStringLength)
	if mapFn then
		for i = 1, valueStringLength do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, string.sub(value, i, i) :: any, i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)(string.sub(value, i, i) :: any, i)
			end
		end
	else
		for i = 1, valueStringLength do
			(array :: Array<string>)[i] = string.sub(value, i, i)
		end
	end

	return array
end
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="200">
                <Properties>
                  <string name="Name">includes</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local indexOf = require(script.Parent.indexOf)

return function<T>(array: Array<T>, searchElement: T, fromIndex: number?): boolean
	return indexOf(array, searchElement, fromIndex) ~= -1
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="201">
                <Properties>
                  <string name="Name">indexOf</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- Implements equivalent functionality to JavaScript's `array.indexOf`,
-- implementing the interface and behaviors defined at:
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
--
-- This implementation is loosely based on the one described in the polyfill
-- source in the above link
return function<T>(array: Array<T>, searchElement: T, fromIndex: number?): number
	local fromIndex_ = fromIndex or 1
	local length = #array

	-- In the JS impl, a negative fromIndex means we should use length - index;
	-- with Lua, of course, this means that 0 is still valid, but refers to the
	-- end of the array the way that '-1' would in JS
	if fromIndex_ < 1 then
		fromIndex_ = math.max(length - math.abs(fromIndex_), 1)
	end

	for i = fromIndex_, length do
		if array[i] == searchElement then
			return i
		end
	end

	return -1
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="202">
                <Properties>
                  <string name="Name">isArray</string>
                  <string name="Source"><![CDATA[--!strict
return function(value: any): boolean
	if typeof(value) ~= "table" then
		return false
	end
	if next(value) == nil then
		-- an empty table is an empty array
		return true
	end

	local length = #value

	if length == 0 then
		return false
	end

	local count = 0
	local sum = 0
	for key in pairs(value) do
		if typeof(key) ~= "number" then
			return false
		end
		if key % 1 ~= 0 or key < 1 then
			return false
		end
		count += 1
		sum += key
	end

	return sum == (count * (count + 1) / 2)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="203">
                <Properties>
                  <string name="Name">join</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local map = require(Array.map)

return function<T>(arr: Array<T>, separator: string?): string
	if #arr == 0 then
		return ""
	end
	-- JS does tostring conversion implicitely but in Lua we need to do that explicitely
	local stringifiedArray = map(arr, function(item)
		return tostring(item)
	end)

	return table.concat(stringifiedArray, separator or ",")
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="204">
                <Properties>
                  <string name="Name">map</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T, U> = (element: T, index: number, array: Array<T>) -> U
type callbackFnWithThisArg<T, U, V> = (thisArg: V, element: T, index: number, array: Array<T>) -> U

-- Implements Javascript's `Array.prototype.map` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
return function<T, U, V>(t: Array<T>, callback: callbackFn<T, U> | callbackFnWithThisArg<T, U, V>, thisArg: V?): Array<U>
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.map called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local A = {}
	local k = 1

	while k <= len do
		local kValue = t[k]

		if kValue ~= nil then
			local mappedValue

			if thisArg ~= nil then
				mappedValue = (callback :: callbackFnWithThisArg<T, U, V>)(thisArg, kValue, k, t)
			else
				mappedValue = (callback :: callbackFn<T, U>)(kValue, k, t)
			end

			A[k] = mappedValue
		end
		k += 1
	end

	return A
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="205">
                <Properties>
                  <string name="Name">reduce</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type reduceFn<T, U> = (previousValue: U, currentValue: T, currentIndex: number, array: Array<T>) -> U

-- Implements Javascript's `Array.prototype.reduce` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce
-- TODO Luau: when Luau supports overloads, use them here so that reduceFn can correctly use T when initialValue (U) isn't supplied
return function<T, U>(array: Array<T>, callback: reduceFn<T, U>, initialValue: U?): U
	if __DEV__ then
		if typeof(array) ~= "table" then
			error(string.format("Array.reduce called on %s", typeof(array)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local length = #array

	local value: T | U
	local initial = 1

	if initialValue ~= nil then
		value = initialValue
	else
		initial = 2
		if length == 0 then
			error("reduce of empty array with no initial value")
		end
		value = array[1]
	end

	for i = initial, length do
		value = callback(value :: U, array[i], i, array)
	end

	return value :: U
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="206">
                <Properties>
                  <string name="Name">reverse</string>
                  <string name="Source"><![CDATA[--!strict
-- https://programming-idioms.org/idiom/19/reverse-a-list/1314/lua
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

return function<T>(t: Array<T>): Array<T>
	local n = #t
	local i = 1
	while i < n do
		t[i], t[n] = t[n], t[i]
		i = i + 1
		n = n - 1
	end
	return t
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="207">
                <Properties>
                  <string name="Name">shift</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

return function<T>(value: Array<T>): T?
	if __DEV__ then
		if not isArray(value) then
			error(string.format("Array.shift called on non-array %s", typeof(value)))
		end
	end

	if #value > 0 then
		return table.remove(value, 1)
	else
		return nil
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="208">
                <Properties>
                  <string name="Name">slice</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- Implements Javascript's `Array.prototype.slice` as defined below, but with 1-indexing
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
return function<T>(t: Array<T>, start_idx: number?, end_idx: number?): Array<T>
	if typeof(t) ~= "table" then
		error(string.format("Array.slice called on %s", typeof(t)))
	end
	local length = #t

	local start_idx_ = start_idx or 1
	local end_idx_
	if end_idx == nil or end_idx > length + 1 then
		end_idx_ = length + 1
	else
		end_idx_ = end_idx
	end

	if start_idx_ > length + 1 then
		return {}
	end

	local slice = {}

	if start_idx_ < 1 then
		start_idx_ = math.max(length - math.abs(start_idx_), 1)
	end
	if end_idx_ < 1 then
		end_idx_ = math.max(length - math.abs(end_idx_), 1)
	end

	local idx = start_idx_
	local i = 1
	while idx < end_idx_ do
		slice[i] = t[idx]
		idx = idx + 1
		i = i + 1
	end

	return slice
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="209">
                <Properties>
                  <string name="Name">some</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

-- note: JS version can return anything that's truthy, but that won't work for us since Lua deviates (0 is truthy)
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> boolean
type callbackFnWithThisArg<T, U> = (thisArg: U, element: T, index: number, array: Array<T>) -> boolean

-- Implements Javascript's `Array.prototype.map` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): boolean
	if typeof(t) ~= "table" then
		error(string.format("Array.some called on %s", typeof(t)))
	end
	if typeof(callback) ~= "function" then
		error("callback is not a function")
	end

	for i, value in t do
		if thisArg ~= nil then
			if value ~= nil and (callback :: callbackFnWithThisArg<T, U>)(thisArg, value, i, t) then
				return true
			end
		else
			if value ~= nil and (callback :: callbackFn<T>)(value, i, t) then
				return true
			end
		end
	end
	return false
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="210">
                <Properties>
                  <string name="Name">sort</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Collections = Array.Parent
local Packages = Collections.Parent
local None = require(Collections.Object.None)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Comparable = (any, any) -> number
local defaultSort = function<T>(a: T, b: T): boolean
	return type(a) .. tostring(a) < type(b) .. tostring(b)
end

return function<T>(array: Array<T>, compare: Comparable?): Array<T>
	-- wrapperCompare interprets compare return value to be compatible with Lua's table.sort
	local wrappedCompare = defaultSort
	if compare ~= nil and compare ~= None then
		if typeof(compare :: any) ~= "function" then
			error("invalid argument to Array.sort: compareFunction must be a function")
		end
		wrappedCompare = function<T>(a: T, b: T)
			local result = compare(a, b)
			if typeof(result) ~= "number" then
				-- deviation: throw an error because
				-- it's not clearly defined what is
				-- the behavior when the compare function
				-- does not return a number
				error(("invalid result from compare function, expected number but got %s"):format(typeof(result)))
			end
			return result < 0
		end
	end
	table.sort(array, wrappedCompare)
	return array
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="211">
                <Properties>
                  <string name="Name">splice</string>
                  <string name="Source"><![CDATA[--!strict
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- Implements equivalent functionality to JavaScript's `array.splice`, including
-- the interface and behaviors defined at:
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
return function<T>(array: Array<T>, start: number, deleteCount: number?, ...: T): Array<T>
	-- Append varargs without removing anything
	if start > #array then
		local varargCount = select("#", ...)
		for i = 1, varargCount do
			local toInsert = select(i, ...)
			table.insert(array, toInsert)
		end
		return {}
	else
		local length = #array
		-- In the JS impl, a negative fromIndex means we should use length -
		-- index; with Lua, of course, this means that 0 is still valid, but
		-- refers to the end of the array the way that '-1' would in JS
		if start < 1 then
			start = math.max(length - math.abs(start), 1)
		end

		local deletedItems = {} :: Array<T>
		-- If no deleteCount was provided, we want to delete the rest of the
		-- array starting with `start`
		local deleteCount_: number = deleteCount or length
		if deleteCount_ > 0 then
			local lastIndex = math.min(length, start + math.max(0, deleteCount_ - 1))

			for i = start, lastIndex do
				local deleted = table.remove(array, start) :: T
				table.insert(deletedItems, deleted)
			end
		end

		local varargCount = select("#", ...)
		-- Do this in reverse order so we can always insert in the same spot
		for i = varargCount, 1, -1 do
			local toInsert = select(i, ...)
			table.insert(array, start, toInsert)
		end

		return deletedItems
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="212">
                <Properties>
                  <string name="Name">unshift</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

return function<T>(array: Array<T>, ...: T): number
	if __DEV__ then
		if not isArray(array) then
			error(string.format("Array.unshift called on non-array %s", typeof(array)))
		end
	end

	local numberOfItems = select("#", ...)
	if numberOfItems > 0 then
		for i = numberOfItems, 1, -1 do
			local toInsert = select(i, ...)
			table.insert(array, 1, toInsert)
		end
	end

	return #array
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="213">
              <Properties>
                <string name="Name">Map</string>
                <string name="Source"><![CDATA[local Packages = script.Parent.Parent

local ES7Types = require(Packages.ES7Types)

local Map = require(script.Map)
local coerceToMap = require(script.coerceToMap)
local coerceToTable = require(script.coerceToTable)

export type Map<K, V> = ES7Types.Map<K, V>

return {
	Map = Map,
	coerceToMap = coerceToMap,
	coerceToTable = coerceToTable,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="214">
                <Properties>
                  <string name="Name">Map</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Collections = script.Parent.Parent
local Packages = Collections.Parent

local arrayForEach = require(Collections.Array.forEach)
local arrayMap = require(Collections.Array.map)
local isArray = require(Collections.Array.isArray)
local instanceof = require(Packages.InstanceOf)
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>
type Table<T, V> = types.Table<T, V>
type Tuple<T, V> = types.Tuple<T, V>
type mapCallbackFn<K, V> = types.mapCallbackFn<K, V>
type mapCallbackFnWithThisArg<K, V> = types.mapCallbackFnWithThisArg<K, V>
type Map<K, V> = types.Map<K, V>

type Map_Statics = {
	new: <K, V>(iterable: Array<Array<any>>?) -> Map<K, V>,
}

local Map: Map<any, any> & Map_Statics = ({} :: any) :: Map<any, any> & Map_Statics

function Map.new<K, V>(iterable: (Array<Array<any>> | Map<K, V>)?): Map<K, V>
	local array
	local map
	if iterable == nil then
		array = {}
		map = {}
	elseif isArray(iterable) then
		if __DEV__ then
			if #(iterable :: Array<Array<any>>) > 0 and typeof((iterable :: Array<Array<any>>)[1]) ~= "table" then
				error(
					"Value `"
						.. typeof((iterable :: Array<Array<any>>)[1])
						.. "` is not an entry object.\n "
						.. "Cannot create Map from {K, V} form, it must be { {K, V}... }"
				)
			end
		end
		array = table.create(#(iterable :: Array<Array<any>>))
		map = {}
		for _, entry in iterable :: Array<Array<any>> do
			local key = entry[1]
			if __DEV__ then
				if key == nil then
					error("cannot create Map from a table that isn't an array.")
				end
			end
			local val = entry[2]
			-- only add to array if new
			if map[key] == nil then
				table.insert(array, key)
			end
			-- always assign
			map[key] = val
		end
	elseif instanceof(iterable, Map) then
		array = table.clone((iterable :: Map<K, V>)._array)
		map = table.clone((iterable :: Map<K, V>)._map)
	else
		error(("`%s` `%s` is not iterable, cannot make Map using it"):format(typeof(iterable), tostring(iterable)))
	end

	return (setmetatable({
		size = #array,
		_map = map,
		_array = array,
	}, Map) :: any) :: Map<K, V>
end

-- TODO Luau: annoying type erasure here, probably needs the new Records language feature
function Map:set(key: any, value: any): Map<any, any>
	-- preserve initial insertion order
	if self._map[key] == nil then
		-- Luau FIXME: analyze should know self is Map<K, V> which includes size as a number
		self.size = self.size :: number + 1
		table.insert(self._array, key)
	end
	-- always update value
	self._map[key] = value
	return self
end

function Map:get(key)
	return self._map[key]
end

function Map:clear()
	local table_: any = table
	self.size = 0
	table_.clear(self._map)
	table_.clear(self._array)
end

function Map:delete(key): boolean
	if self._map[key] == nil then
		return false
	end
	-- Luau FIXME: analyze should know self is Map<K, V> which includes size as a number
	self.size = self.size :: number - 1
	self._map[key] = nil
	local index = table.find(self._array, key)
	if index then
		table.remove(self._array, index)
	end
	return true
end

-- Implements Javascript's `Map.prototype.forEach` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach
function Map:forEach(callback: mapCallbackFn<any, any> | mapCallbackFnWithThisArg<any, any>, thisArg: Object?): ()
	if __DEV__ then
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end
	-- note: we can't turn this into a simple for-in loop, because the callbacks can modify the table and React, GQL, and Jest rely on JS behavior in that scenario
	arrayForEach(self._array, function(key)
		local value = self._map[key]

		if thisArg ~= nil then
			(callback :: mapCallbackFnWithThisArg<any, any>)(thisArg, value, key, self)
		else
			(callback :: mapCallbackFn<any, any>)(value, key, self)
		end
	end)
end

function Map:has(key): boolean
	return self._map[key] ~= nil
end

function Map:keys()
	return self._array
end

function Map:values()
	return arrayMap(self._array, function(key)
		return self._map[key]
	end)
end

function Map:entries()
	return arrayMap(self._array, function(key)
		return { key, self._map[key] }
	end)
end

function Map:ipairs()
	if __DEV__ then
		warn(
			debug.traceback(
				"`for _,_ in myMap:ipairs() do` is deprecated and will be removed in a future release, please use `for _,_ in myMap do` instead\n",
				2
			)
		)
	end
	return ipairs(self:entries())
end

function Map.__iter(self: Map<any, any>)
	return next, self:entries()
end

function Map.__index(self: Map<any, any>, key)
	local mapProp = rawget(Map, key)
	if mapProp ~= nil then
		return mapProp
	end
	if __DEV__ then
		assert(
			-- FIXME Luau: shouldn't need this cast, the self param is annotated already
			rawget(self :: any, "_map"),
			"Map has been corrupted, and is missing private state! Did you accidentally call table.clear() instead of map:clear()?"
		)
	end

	return Map.get(self, key)
end

function Map.__newindex(self: Map<any, any>, key, value)
	self:set(key, value)
end

return Map
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="215">
                <Properties>
                  <string name="Name">coerceToMap</string>
                  <string name="Source"><![CDATA[local MapModule = script.Parent
local Collections = MapModule.Parent
local Packages = Collections.Parent

local Map = require(MapModule.Map)
local Object = require(Collections.Object)
local instanceOf = require(Packages.InstanceOf)
local types = require(Packages.ES7Types)

type Map<K, V> = types.Map<K, V>
type Table<K, V> = types.Table<K, V>

local function coerceToMap(mapLike: Map<any, any> | Table<any, any>): Map<any, any>
	return instanceOf(mapLike, Map) and mapLike :: Map<any, any> -- ROBLOX: order is preserved
		or Map.new(Object.entries(mapLike)) -- ROBLOX: order is not preserved
end

return coerceToMap
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="216">
                <Properties>
                  <string name="Name">coerceToTable</string>
                  <string name="Source"><![CDATA[local MapModule = script.Parent
local Collections = MapModule.Parent
local Packages = Collections.Parent

local Map = require(MapModule.Map)
local instanceOf = require(Packages.InstanceOf)
local arrayReduce = require(Collections.Array.reduce)
local types = require(Packages.ES7Types)

type Map<K, V> = types.Map<K, V>
type Table<K, V> = types.Table<K, V>

local function coerceToTable(mapLike: Map<any, any> | Table<any, any>): Table<any, any>
	if not instanceOf(mapLike, Map) then
		return mapLike :: Table<any, any>
	end

	-- create table from map
	return arrayReduce(mapLike:entries(), function(tbl, entry)
		tbl[entry[1]] = entry[2]
		return tbl
	end, {})
end

return coerceToTable
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="217">
              <Properties>
                <string name="Name">Object</string>
                <string name="Source"><![CDATA[--!strict

return {
	assign = require(script.assign),
	entries = require(script.entries),
	freeze = require(script.freeze),
	is = require(script.is),
	isFrozen = require(script.isFrozen),
	keys = require(script.keys),
	preventExtensions = require(script.preventExtensions),
	seal = require(script.seal),
	values = require(script.values),
	-- Special marker type used in conjunction with `assign` to remove values
	-- from tables, since nil cannot be stored in a table
	None = require(script.None),
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="218">
                <Properties>
                  <string name="Name">None</string>
                  <string name="Source"><![CDATA[--!nonstrict
-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = newproxy(true)
local mt = getmetatable(None)
mt.__tostring = function()
	return "Object.None"
end

return None
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="219">
                <Properties>
                  <string name="Name">assign</string>
                  <string name="Source"><![CDATA[--!strict
local Object = script.Parent
local Packages = Object.Parent.Parent

local None = require(Object.None)
local types = require(Packages.ES7Types)
type Object = types.Object

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
-- Luau TODO: no way to strongly type this accurately, it doesn't eliminate deleted keys of T, and Luau won't do intersections of type packs: <T, ...U>(T, ...: ...U): T & ...U
return function<T, U, V, W>(target: T, source0: U?, source1: V?, source2: W?, ...): T & U & V & W
	if source0 ~= nil and typeof(source0 :: any) == "table" then
		for key, value in pairs(source0 :: any) do
			if value == None then
				(target :: any)[key] = nil
			else
				(target :: any)[key] = value
			end
		end
	end

	if source1 ~= nil and typeof(source1 :: any) == "table" then
		for key, value in pairs(source1 :: any) do
			if value == None then
				(target :: any)[key] = nil
			else
				(target :: any)[key] = value
			end
		end
	end

	if source2 ~= nil and typeof(source2 :: any) == "table" then
		for key, value in pairs(source2 :: any) do
			if value == None then
				(target :: any)[key] = nil
			else
				(target :: any)[key] = value
			end
		end
	end

	for index = 1, select("#", ...) do
		local rest = select(index, ...)

		if rest ~= nil and typeof(rest) == "table" then
			for key, value in pairs(rest) do
				if value == None then
					(target :: any)[key] = nil
				else
					(target :: any)[key] = value
				end
			end
		end
	end

	-- TODO? we can add & Object to this, if needed by real-world code, once CLI-49825 is fixed
	return (target :: any) :: T & U & V & W
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="220">
                <Properties>
                  <string name="Name">entries</string>
                  <string name="Source"><![CDATA[--!strict
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Map<K, V> = types.Map<K, V>
type Tuple<T, V> = types.Tuple<T, V>

return function<T>(value: string | { [string]: T } | Array<T> | Map<any, T>): Array<Tuple<string, T>>
	assert(value :: any ~= nil, "cannot get entries from a nil value")
	local valueType = typeof(value)

	local entries: Array<Tuple<string, T>> = {}
	if valueType == "table" then
		for key, keyValue in pairs(value :: { [string]: T } | Array<T>) do
			-- Luau FIXME: Luau should see entries as Array<any>, given object is [string]: any, but it sees it as Array<Array<string>> despite all the manual annotation
			table.insert(entries, { key, keyValue })
		end
	elseif valueType == "string" then
		-- TODO: should we be using utf8.len?
		for i = 1, string.len(value :: string) do
			entries[i] = { tostring(i), string.sub(value :: string, i, i) }
		end
	end

	return entries
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="221">
                <Properties>
                  <string name="Name">freeze</string>
                  <string name="Source"><![CDATA[--!strict
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

return function<T>(t: T & (Object | Array<any>)): T
	-- Luau FIXME: model freeze better so it passes through the type constraint and doesn't erase
	return (table.freeze(t :: any) :: any) :: T
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="222">
                <Properties>
                  <string name="Name">is</string>
                  <string name="Source"><![CDATA[-- Implements Javascript's `Object.is` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
return function(value1: any, value2: any): boolean
	if value1 == value2 then
		return value1 ~= 0 or 1 / value1 == 1 / value2
	else
		return value1 ~= value1 and value2 ~= value2
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="223">
                <Properties>
                  <string name="Name">isFrozen</string>
                  <string name="Source"><![CDATA[--!strict
local __DEV__ = _G.__DEV__
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

return function(t: Object | Array<any>): boolean
	if __DEV__ then
		print("Luau now has a direct table.isfrozen call that can save the overhead of this library function call")
	end
	return table.isfrozen(t)
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="224">
                <Properties>
                  <string name="Name">keys</string>
                  <string name="Source"><![CDATA[local Object = script.Parent
local Collections = Object.Parent
local Packages = Object.Parent.Parent

local Set = require(Collections.Set)
local types = require(Packages.ES7Types)
local instanceOf = require(Packages.InstanceOf)
type Array<T> = types.Array<T>
type Set<T> = types.Set<T>
type Table = { [any]: any }

return function(value: Set<any> | Table | string): Array<string>
	if value == nil then
		error("cannot extract keys from a nil value")
	end

	local valueType = typeof(value)

	local keys
	if valueType == "table" then
		keys = {}
		if instanceOf(value, Set) then
			return keys
		end

		for key in pairs(value :: Table) do
			table.insert(keys, key)
		end
	elseif valueType == "string" then
		local length = (value :: string):len()
		keys = table.create(length)
		for i = 1, length do
			keys[i] = tostring(i)
		end
	end

	return keys
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="225">
                <Properties>
                  <string name="Name">preventExtensions</string>
                  <string name="Source"><![CDATA[--!strict
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

-- FIXME: This should be updated to be closer to the actual
-- `Object.preventExtensions` functionality in JS. This requires additional
-- support from the VM
local function preventExtensions<T>(t: T & (Object | Array<any>)): T
	local name = tostring(t)

	return (
		setmetatable(t :: any, {
			__newindex = function(self, key, value)
				local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), name)

				error(message, 2)
			end,
			__metatable = false,
		}) :: any
	) :: T
end

return preventExtensions
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="226">
                <Properties>
                  <string name="Name">seal</string>
                  <string name="Source"><![CDATA[--!strict
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

return function<T>(t: T & (Object | Array<any>)): T
	-- Luau FIXME: model freeze better so it passes through the type constraint and doesn't erase
	return (table.freeze(t :: any) :: any) :: T
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="227">
                <Properties>
                  <string name="Name">values</string>
                  <string name="Source"><![CDATA[--!strict
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- TODO Luau: needs overloads to model this more correctly
return function<T>(value: { [string]: T } | Array<T> | string): Array<T> | Array<string>
	if value == nil then
		error("cannot extract values from a nil value")
	end
	local valueType = typeof(value)

	local array: Array<T> | Array<string>
	if valueType == "table" then
		array = {} :: Array<T>
		for _, keyValue in pairs(value :: { [string]: T } | Array<T>) do
			table.insert(array, keyValue)
		end
	elseif valueType == "string" then
		-- optimization to avoid rehashing/growth
		local valueStringLength = (value :: string):len()
		array = table.create(valueStringLength)
		for i = 1, valueStringLength do
			(array :: Array<string>)[i] = (value :: string):sub(i, i)
		end
	end

	return array
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="228">
              <Properties>
                <string name="Name">Set</string>
                <string name="Source"><![CDATA[--!nonstrict
local __DEV__ = _G.__DEV__
local Collections = script.Parent
local Packages = Collections.Parent

local inspect = require(Collections.inspect)
local isArray = require(Collections.Array.isArray)
local arrayForEach = require(Collections.Array.forEach)
local arrayFromString = require(Collections.Array.from.fromString)

local types = require(Packages.ES7Types)

type Array<T> = types.Array<T>
type Object = types.Object
type setCallbackFn<T> = types.setCallbackFn<T>
type setCallbackFnWithThisArg<T> = types.setCallbackFnWithThisArg<T>
export type Set<T> = types.Set<T>

type Set_Statics = {
	new: <T>(iterable: Array<T> | Set<T> | string | nil) -> Set<T>,
}

local Set: Set<any> & Set_Statics = (
	{
		__iter = function(self)
			return next, self._array
		end,
		__tostring = function(self)
			local result = "Set "
			if #self._array > 0 then
				result ..= "(" .. tostring(#self._array) .. ") "
			end
			result ..= inspect(self._array)
			return result
		end,
	} :: any
) :: Set<any> & Set_Statics;
(Set :: any).__index = Set

function Set.new<T>(iterable: Array<T> | Set<T> | string | nil): Set<T>
	local array
	local map = {}
	if iterable ~= nil then
		local arrayIterable

		if typeof(iterable) == "table" then
			if isArray(iterable) then
				arrayIterable = table.clone(iterable)
			else
				local mt = getmetatable(iterable :: any)
				if mt and rawget(mt, "__iter") then
					arrayIterable = iterable :: Set<T>
				elseif __DEV__ then
					error("cannot create array from an object-like table")
				end
			end
		elseif typeof(iterable) == "string" then
			-- TODO Luau: need overloads for `from` to avoid needing the manual cast
			arrayIterable = arrayFromString(iterable :: string) :: Array<string>
		else
			error(("cannot create array from value of type `%s`"):format(typeof(iterable)))
		end

		if arrayIterable then
			array = table.create(#arrayIterable)
			for _, element in arrayIterable do
				if not map[element] then
					map[element] = true
					table.insert(array, element)
				end
			end
		else
			array = {}
		end
	else
		array = {}
	end

	return (setmetatable({
		size = #array,
		_map = map,
		_array = array,
	}, Set) :: any) :: Set<T>
end

function Set:add(value)
	if not self._map[value] then
		-- Luau FIXME: analyze should know self is Set<T> which includes size as a number
		self.size = self.size :: number + 1
		self._map[value] = true
		table.insert(self._array, value)
	end
	return self
end

function Set:clear()
	self.size = 0
	table.clear(self._map)
	table.clear(self._array)
end

function Set:delete(value): boolean
	if not self._map[value] then
		return false
	end
	-- Luau FIXME: analyze should know self is Map<K, V> which includes size as a number
	self.size = self.size :: number - 1
	self._map[value] = nil
	local index = table.find(self._array, value)
	if index then
		table.remove(self._array, index)
	end
	return true
end

-- Implements Javascript's `Map.prototype.forEach` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach
function Set:forEach(callback: setCallbackFn<any> | setCallbackFnWithThisArg<any>, thisArg: Object?): ()
	if typeof(callback) ~= "function" then
		error("callback is not a function")
	end

	-- note: we can't turn this into a simple for-in loop, because the callbacks can modify the table and React, GQL, and Jest rely on JS behavior in that scenario
	arrayForEach(self._array, function(value)
		if thisArg ~= nil then
			(callback :: setCallbackFnWithThisArg<any>)(thisArg, value, value, self)
		else
			(callback :: setCallbackFn<any>)(value, value, self)
		end
	end)
end

function Set:has(value): boolean
	return self._map[value] ~= nil
end

function Set:ipairs()
	if __DEV__ then
		warn(
			debug.traceback(
				"`for _,_ in mySet:ipairs() do` is deprecated and will be removed in a future release, please use `for _,_ in mySet do` instead\n",
				2
			)
		)
	end
	return ipairs(self._array)
end

return Set
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="229">
              <Properties>
                <string name="Name">WeakMap</string>
                <string name="Source"><![CDATA[--!strict
local Collections = script.Parent
local Packages = Collections.Parent

local ES7Types = require(Packages.ES7Types)

type WeakMap<K, V> = ES7Types.WeakMap<K, V>

type WeakMapPrivate<K, V> = {
	_weakMap: { [K]: V },
	-- method definitions
	get: (self: WeakMapPrivate<K, V>, K) -> V,
	set: (self: WeakMapPrivate<K, V>, K, V) -> WeakMapPrivate<K, V>,
	has: (self: WeakMapPrivate<K, V>, K) -> boolean,
}
type WeakMap_Statics = {
	new: <K, V>() -> WeakMap<K, V>,
}

local WeakMap: WeakMapPrivate<any, any> & WeakMap_Statics = {} :: any;
(WeakMap :: any).__index = WeakMap

function WeakMap.new<K, V>(): WeakMap<K, V>
	local weakMap = setmetatable({}, { __mode = "k" })
	return setmetatable({ _weakMap = weakMap }, WeakMap) :: any
end

function WeakMap:get(key)
	return self._weakMap[key]
end

function WeakMap:set(key, value)
	self._weakMap[key] = value
	return self
end

function WeakMap:has(key): boolean
	return self._weakMap[key] ~= nil
end

return WeakMap :: WeakMap<any, any> & WeakMap_Statics
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="230">
              <Properties>
                <string name="Name">inspect</string>
                <string name="Source"><![CDATA[-- derived from these upstream sources:
-- https://github.com/graphql/graphql-js/blob/1951bce42092123e844763b6a8e985a8a3327511/src/jsutils/inspect.js
local HttpService = game:GetService("HttpService")

local Collections = script.Parent
local Packages = Collections.Parent

local isArray = require(Collections.Array.isArray)
local ES7Types = require(Packages.ES7Types)

type Array<T> = ES7Types.Array<T>
-- local NULL = require(srcWorkspace.luaUtils.null)

-- Support for options partial implementation
-- see: https://nodejs.org/dist/latest-v16.x/docs/api/util.html#utilinspectobject-options
export type InspectOptions = {
	depth: number?,
}

type FormatOptions = {
	depth: number,
}

local MAX_ARRAY_LENGTH = 10
local DEFAULT_RECURSIVE_DEPTH = 2

-- deviation: pre-declare functions
local formatValue
local formatObjectValue
local formatArray
local formatObject
local getObjectTag

--[[
 * Used to print values in error messages.
 ]]
local function inspect(value, options: InspectOptions?): string
	local inspectOptions: InspectOptions = options or { depth = DEFAULT_RECURSIVE_DEPTH }
	local depth = inspectOptions.depth or DEFAULT_RECURSIVE_DEPTH
	inspectOptions.depth = if depth >= 0 then depth else DEFAULT_RECURSIVE_DEPTH
	return formatValue(value, {}, inspectOptions :: FormatOptions)
end

local function isIndexKey(k, contiguousLength)
	return type(k) == "number"
		and k <= contiguousLength -- nothing out of bounds
		and 1 <= k -- nothing illegal for array indices
		and math.floor(k) == k -- no float keys
end

local function getTableLength(tbl)
	local length = 1
	local value = rawget(tbl, length)
	while value ~= nil do
		length += 1
		value = rawget(tbl, length)
	end
	return length - 1
end

local function sortKeysForPrinting(a: any, b)
	local typeofA = type(a)
	local typeofB = type(b)

	-- strings and numbers are sorted numerically/alphabetically
	if typeofA == typeofB and (typeofA == "number" or typeofA == "string") then
		return a < b
	end

	-- sort the rest by type name
	return typeofA < typeofB
end

local function rawpairs(t)
	return next, t, nil
end

local function getFragmentedKeys(tbl)
	local keys = {}
	local keysLength = 0
	local tableLength = getTableLength(tbl)
	for key, _ in rawpairs(tbl) do
		if not isIndexKey(key, tableLength) then
			keysLength = keysLength + 1
			keys[keysLength] = key
		end
	end
	table.sort(keys, sortKeysForPrinting)
	return keys, keysLength, tableLength
end

function formatValue(value, seenValues, options: FormatOptions)
	local valueType = typeof(value)
	if valueType == "string" then
		return HttpService:JSONEncode(value)
		-- deviation: format numbers like in JS
	elseif valueType == "number" then
		if value ~= value then
			return "NaN"
		elseif value == math.huge then
			return "Infinity"
		elseif value == -math.huge then
			return "-Infinity"
		else
			return tostring(value)
		end
	elseif valueType == "function" then
		local result = "[function"
		local functionName = debug.info(value :: (any) -> any, "n")
		if functionName ~= nil and functionName ~= "" then
			result ..= " " .. functionName
		end
		return result .. "]"
	elseif valueType == "table" then
		-- ROBLOX TODO: parameterize inspect with the library-specific NULL sentinel. maybe function generics?
		-- if value == NULL then
		-- 	return 'null'
		-- end
		return formatObjectValue(value, seenValues, options)
	else
		return tostring(value)
	end
end

function formatObjectValue(value, previouslySeenValues, options: FormatOptions)
	if table.find(previouslySeenValues, value) ~= nil then
		return "[Circular]"
	end

	local seenValues = { unpack(previouslySeenValues) }
	table.insert(seenValues, value)

	if typeof(value.toJSON) == "function" then
		local jsonValue = value:toJSON(value)

		if jsonValue ~= value then
			if typeof(jsonValue) == "string" then
				return jsonValue
			else
				return formatValue(jsonValue, seenValues, options)
			end
		end
	elseif isArray(value) then
		return formatArray(value, seenValues, options)
	end

	return formatObject(value, seenValues, options)
end

function formatObject(object, seenValues, options: FormatOptions)
	local result = ""
	local mt = getmetatable(object)
	if mt and rawget(mt, "__tostring") then
		return tostring(object)
	end

	local fragmentedKeys, fragmentedKeysLength, keysLength = getFragmentedKeys(object)

	if keysLength == 0 and fragmentedKeysLength == 0 then
		result ..= "{}"
		return result
	end
	if #seenValues > options.depth then
		result ..= "[" .. getObjectTag(object) .. "]"
		return result
	end

	local properties = {}
	for i = 1, keysLength do
		local value = formatValue(object[i], seenValues, options)

		table.insert(properties, value)
	end

	for i = 1, fragmentedKeysLength do
		local key = fragmentedKeys[i]
		local value = formatValue(object[key], seenValues, options)

		table.insert(properties, key .. ": " .. value)
	end

	result ..= "{ " .. table.concat(properties, ", ") .. " }"
	return result
end

function formatArray(array: Array<any>, seenValues: Array<any>, options: FormatOptions): string
	local length = #array
	if length == 0 then
		return "[]"
	end
	if #seenValues > options.depth then
		return "[Array]"
	end

	local len = math.min(MAX_ARRAY_LENGTH, length)
	local remaining = length - len
	local items = {}

	for i = 1, len do
		items[i] = (formatValue(array[i], seenValues, options))
	end

	if remaining == 1 then
		table.insert(items, "... 1 more item")
	elseif remaining > 1 then
		table.insert(items, ("... %s more items"):format(tostring(remaining)))
	end

	return "[" .. table.concat(items, ", ") .. "]"
end

function getObjectTag(_object): string
	-- local tag = Object.prototype.toString
	-- 	.call(object)
	-- 	.replace("")
	-- 	.replace("")

	-- if tag == "Object" and typeof(object.constructor) == "function" then
	-- 	local name = object.constructor.name

	-- 	if typeof(name) == "string" and name ~= "" then
	-- 		return name
	-- 	end
	-- end

	-- return tag
	return "Object"
end

return inspect
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="231">
            <Properties>
              <string name="Name">Console</string>
              <string name="Source"><![CDATA[--!strict
local makeConsoleImpl = require(script.makeConsoleImpl)

return makeConsoleImpl()
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="232">
              <Properties>
                <string name="Name">makeConsoleImpl</string>
                <string name="Source"><![CDATA[--!strict
local root = script.Parent
local Packages = root.Parent
local inspect = require(Packages.Collections).inspect

local INDENT = "  "

return function()
	local console = {}
	local indentDepth = 0

	local function indent()
		return string.rep(INDENT, indentDepth)
	end

	function console.log(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
	end

	function console.debug(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
	end

	function console.info(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
	end

	function console.warn(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		warn(indent() .. message)
	end

	function console.error(content, ...)
		-- JS' `console.error` doesn't interrupt execution like Lua's `error`,
		-- which is more similar to throwing an exception in JS.
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		warn(indent() .. message)
	end

	function console.group(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
		indentDepth = indentDepth + 1
	end

	function console.groupCollapsed(content, ...)
		-- There's no smart console, so this is equivalent to `console.group`
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
		indentDepth = indentDepth + 1
	end

	function console.groupEnd()
		if indentDepth > 0 then
			indentDepth = indentDepth - 1
		end
	end

	return console
end
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="233">
            <Properties>
              <string name="Name">DiffSequences</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/diff-sequences/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */
local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Number = LuauPolyfill.Number
type Array<T> = LuauPolyfill.Array<T>

-- This diff-sequences package implements the linear space variation in
-- An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers

-- Relationship in notation between Myers paper and this package:
-- A is a
-- N is aLength, aEnd - aStart, and so on
-- x is aIndex, aFirst, aLast, and so on
-- B is b
-- M is bLength, bEnd - bStart, and so on
-- y is bIndex, bFirst, bLast, and so on
-- Δ = N - M is negative of baDeltaLength = bLength - aLength
-- D is d
-- k is kF
-- k + Δ is kF = kR - baDeltaLength
-- V is aIndexesF or aIndexesR (see comment below about Indexes type)
-- index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
-- starting point in forward direction (0, 0) is (-1, -1)
-- starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)

-- The “edit graph” for sequences a and b corresponds to items:
-- in a on the horizontal axis
-- in b on the vertical axis
--
-- Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
--
-- Forward diagonals kF:
-- zero diagonal intersects top left corner
-- positive diagonals intersect top edge
-- negative diagonals insersect left edge
--
-- Reverse diagonals kR:
-- zero diagonal intersects bottom right corner
-- positive diagonals intersect right edge
-- negative diagonals intersect bottom edge

-- The graph contains a directed acyclic graph of edges:
-- horizontal: delete an item from a
-- vertical: insert an item from b
-- diagonal: common item in a and b
--
-- The algorithm solves dual problems in the graph analogy:
-- Find longest common subsequence: path with maximum number of diagonal edges
-- Find shortest edit script: path with minimum number of non-diagonal edges

-- Input callback function compares items at indexes in the sequences.
type IsCommon = (
	number, -- caller can assume: 0 <= aIndex && aIndex < aLength
	number -- caller can assume: 0 <= bIndex && bIndex < bLength
) -> boolean

-- Output callback function receives the number of adjacent items
-- and starting indexes of each common subsequence.
type FoundSubsequence = (
	number, -- caller can assume: 0 < nCommon
	number, -- caller can assume: 0 <= aCommon && aCommon < aLength
	number -- caller can assume: 0 <= bCommon && bCommon < bLength
) -> ()

-- ROBLOX deviation: omitted since Luau doesn't have mixed type arrays
-- Either original functions or wrapped to swap indexes if graph is transposed.
-- export type Callbacks = {
-- 	FoundSubsequence;
-- 	IsCommon;
-- };
export type Callbacks = Array<any>

-- Indexes in sequence a of last point of forward or reverse paths in graph.
-- Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
-- This package indexes by iF and iR which are greater than or equal to zero.
-- and also updates the index arrays in place to cut memory in half.
-- kF = 2 * iF - d
-- kR = d - 2 * iR
type Indexes = Array<number>

-- Division of index intervals in sequences a and b at the middle change.
-- Invariant: intervals do not have common items at the start or end.
type Division = {
	-- The end of interval preceding division is open like array slice method.
	nChangePreceding: number, -- number of change items
	aEndPreceding: number,
	bEndPreceding: number,

	nCommonPreceding: number, -- 0 if no common items preceding middle change
	aCommonPreceding: number, -- ignore prop value if nCommonPreceding === 0
	bCommonPreceding: number, -- ignore prop value if nCommonPreceding === 0

	nCommonFollowing: number, -- 0 if no common items following middle change
	aCommonFollowing: number, -- ignore prop value if nCommonFollowing === 0
	bCommonFollowing: number, -- ignore prop value if nCommonFollowing === 0

	-- The start of interval following division is closed like array slice method.
	nChangeFollowing: number, -- number of change items
	aStartFollowing: number,
	bStartFollowing: number,
}

local pkg = "diff-sequences" -- for error messages
local NOT_YET_SET = 0 -- small int instead of undefined to avoid deopt in V8

-- Return the number of common items that follow in forward direction.
-- The length of what Myers paper calls a “snake” in a forward path.
local function countCommonItemsF(aIndex: number, aEnd: number, bIndex: number, bEnd: number, isCommon: IsCommon): number
	local nCommon = 0
	while aIndex < aEnd and bIndex < bEnd and isCommon(aIndex, bIndex) do
		aIndex += 1
		bIndex += 1
		nCommon += 1
	end
	return nCommon
end

-- Return the number of common items that precede in reverse direction.
-- The length of what Myers paper calls a “snake” in a reverse path.
local function countCommonItemsR(
	aStart: number,
	aIndex: number,
	bStart: number,
	bIndex: number,
	isCommon: IsCommon
): number
	local nCommon = 0
	while aStart <= aIndex and bStart <= bIndex and isCommon(aIndex, bIndex) do
		aIndex = aIndex - 1
		bIndex = bIndex - 1
		nCommon = nCommon + 1
	end
	return nCommon
end

-- A simple function to extend forward paths from (d - 1) to d changes
-- when forward and reverse paths cannot yet overlap.
local function extendPathsF(
	d: number,
	aEnd: number,
	bEnd: number,
	bF: number,
	isCommon: IsCommon,
	aIndexesF: Indexes,
	iMaxF: number
): number
	-- Unroll the first iteration.
	local iF = 0
	local kF = -d -- kF = 2 * iF - d
	-- ROBLOX FIXME? should the values inserted into aIndexesF be 1-based so we don't have to adjust in several places here?
	local aFirst = aIndexesF[iF + 1] -- in first iteration always insert
	local aIndexPrev1 = aFirst -- prev value of [iF - 1] in next iteration
	aIndexesF[iF + 1] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon)

	-- Optimization: skip diagonals in which paths cannot ever overlap.
	local nF = d < iMaxF and d or iMaxF

	-- The diagonals kF are odd when d is odd and even when d is even.
	iF += 1
	kF += 2
	while iF <= nF do
		-- To get first point of path segment, move one change in forward direction
		-- from last point of previous path segment in an adjacent diagonal.
		-- In last possible iteration when iF === d and kF === d always delete.
		-- ROBLOX deviation: add one to index for Lua 1-based arrays
		if iF ~= d and aIndexPrev1 < aIndexesF[iF + 1] then
			aFirst = aIndexesF[iF + 1] -- vertical to insert from b
		else
			aFirst = aIndexPrev1 + 1 -- horizontal to delete from a

			if aEnd <= aFirst then
				-- Optimization: delete moved past right of graph.
				return iF - 1
			end
		end

		-- To get last point of path segment, move along diagonal of common items.
		-- ROBLOX deviation: add one to index for Lua 1-based arrays
		aIndexPrev1 = aIndexesF[iF + 1]
		aIndexesF[iF + 1] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon)

		iF += 1
		kF += 2
	end

	return iMaxF
end

-- A simple function to extend reverse paths from (d - 1) to d changes
-- when reverse and forward paths cannot yet overlap.
local function extendPathsR(
	d: number,
	aStart: number,
	bStart: number,
	bR: number,
	isCommon: IsCommon,
	aIndexesR: Indexes,
	iMaxR: number
): number
	-- Unroll the first iteration.
	local iR = 0
	local kR = d -- kR = d - 2 * iR
	-- ROBLOX FIXME? should the values inserted into aIndexesR be 1-based so we don't have to adjust in several places here?
	local aFirst = aIndexesR[iR + 1] -- in first iteration always insert
	local aIndexPrev1 = aFirst -- prev value of [iR - 1] in next iteration
	aIndexesR[iR + 1] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon)

	-- Optimization: skip diagonals in which paths cannot ever overlap.
	local nR = d < iMaxR and d or iMaxR

	-- The diagonals kR are odd when d is odd and even when d is even.
	iR += 1
	kR -= 2
	while iR <= nR do
		-- To get first point of path segment, move one change in reverse direction
		-- from last point of previous path segment in an adjacent diagonal.
		-- In last possible iteration when iR === d and kR === -d always delete.
		if iR ~= d and aIndexesR[iR + 1] < aIndexPrev1 then
			aFirst = aIndexesR[iR + 1] -- vertical to insert from b
		else
			aFirst = aIndexPrev1 - 1 -- horizontal to delete from a

			if aFirst < aStart then
				-- Optimization: delete moved past left of graph.
				return iR - 1
			end
		end

		-- To get last point of path segment, move along diagonal of common items.
		aIndexPrev1 = aIndexesR[iR + 1]
		aIndexesR[iR + 1] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon)
		iR += 1
		kR -= 2
	end

	return iMaxR
end

-- A complete function to extend forward paths from (d - 1) to d changes.
-- Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.
local function extendOverlappablePathsF(
	d: number,
	aStart: number,
	aEnd: number,
	bStart: number,
	bEnd: number,
	isCommon: IsCommon,
	aIndexesF: Indexes, -- update indexes in sequence a of paths in diagonals kF
	iMaxF: number,
	aIndexesR: Indexes,
	iMaxR: number,
	division: Division -- update prop values if return true
): boolean
	local bF = bStart - aStart -- bIndex = bF + aIndex - kF
	local aLength = aEnd - aStart
	local bLength = bEnd - bStart
	local baDeltaLength = bLength - aLength -- kF = kR + baDeltaLength

	-- Range of diagonals in which forward and reverse paths might overlap.
	local kMinOverlapF = -baDeltaLength - (d - 1) -- -(d - 1) <= kR
	local kMaxOverlapF = -baDeltaLength + (d - 1) -- kR <= (d - 1)

	local aIndexPrev1 = 0 -- prev value of [iF - 1] in next iteration

	-- Optimization: skip diagonals in which paths cannot ever overlap.
	local nF = d < iMaxF and d or iMaxF

	-- The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.
	-- ROBLOX FIXME? why aren't we just starting iF at 1?
	local iF = 0
	local kF: number = -d
	while iF <= nF do
		-- To get first point of path segment, move one change in forward direction
		-- from last point of previous path segment in an adjacent diagonal.
		-- In first iteration when iF === 0 and kF === -d always insert.
		-- In last possible iteration when iF === d and kF === d always delete.
		local insert = iF == 0 or (iF ~= d and aIndexPrev1 < aIndexesF[iF + 1])
		-- ROBLOX FIXME? should the values inserted into aIndexesF be 1-based so we don't have to adjust in several places here?
		local aLastPrev = insert and aIndexesF[iF + 1] or aIndexPrev1
		local aFirst: number = insert and aLastPrev -- vertical to insert from b
			or aLastPrev + 1 -- horizontal to delete from a

		-- To get last point of path segment, move along diagonal of common items.
		local bFirst = bF + aFirst - kF
		local nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon)
		local aLast = aFirst + nCommonF

		aIndexPrev1 = aIndexesF[iF + 1]
		aIndexesF[iF + 1] = aLast

		if kMinOverlapF <= kF and kF <= kMaxOverlapF then
			-- Solve for iR of reverse path with (d - 1) changes in diagonal kF:
			-- kR = kF + baDeltaLength
			-- kR = (d - 1) - 2 * iR
			local iR = (d - 1 - (kF + baDeltaLength)) / 2

			-- If this forward path overlaps the reverse path in this diagonal,
			-- then this is the middle change of the index intervals.
			if iR <= iMaxR and aIndexesR[iR + 1] - 1 <= aLast then
				-- Unlike the Myers algorithm which finds only the middle “snake”
				-- this package can find two common subsequences per division.
				-- Last point of previous path segment is on an adjacent diagonal.
				local bLastPrev = bF + aLastPrev - (insert and kF + 1 or kF - 1)

				-- Because of invariant that intervals preceding the middle change
				-- cannot have common items at the end,
				-- move in reverse direction along a diagonal of common items.
				local nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon)

				local aIndexPrevFirst = aLastPrev - nCommonR
				local bIndexPrevFirst = bLastPrev - nCommonR

				local aEndPreceding = aIndexPrevFirst + 1
				local bEndPreceding = bIndexPrevFirst + 1

				division.nChangePreceding = d - 1
				if d - 1 == aEndPreceding + bEndPreceding - aStart - bStart then
					-- Optimization: number of changes in reverse direction
					-- is equal to number of items in preceding interval,
					-- therefore it cannot contain any common items.
					division.aEndPreceding = aStart
					division.bEndPreceding = bStart
				else
					division.aEndPreceding = aEndPreceding
					division.bEndPreceding = bEndPreceding
				end

				division.nCommonPreceding = nCommonR
				if nCommonR ~= 0 then
					division.aCommonPreceding = aEndPreceding
					division.bCommonPreceding = bEndPreceding
				end

				division.nCommonFollowing = nCommonF
				if nCommonF ~= 0 then
					division.aCommonFollowing = aFirst + 1
					division.bCommonFollowing = bFirst + 1
				end

				local aStartFollowing = aLast + 1
				local bStartFollowing = bFirst + nCommonF + 1

				division.nChangeFollowing = d - 1
				if d - 1 == aEnd + bEnd - aStartFollowing - bStartFollowing then
					-- Optimization: number of changes in reverse direction
					-- is equal to number of items in following interval,
					-- therefore it cannot contain any common items.
					division.aStartFollowing = aEnd
					division.bStartFollowing = bEnd
				else
					division.aStartFollowing = aStartFollowing
					division.bStartFollowing = bStartFollowing
				end

				return true
			end
		end
		iF = iF + 1
		kF = kF + 2
	end

	return false
end

-- A complete function to extend reverse paths from (d - 1) to d changes.
-- Return true if a path overlaps forward path of d changes in its diagonal.
local function extendOverlappablePathsR(
	d: number,
	aStart: number,
	aEnd: number,
	bStart: number,
	bEnd: number,
	isCommon: IsCommon,
	aIndexesF: Indexes,
	iMaxF: number,
	aIndexesR: Indexes, -- update indexes in sequence a of paths in diagonals kR
	iMaxR: number,
	division: Division -- update prop values if return true
): boolean
	local bR = bEnd - aEnd -- bIndex = bR + aIndex - kR
	local aLength = aEnd - aStart
	local bLength = bEnd - bStart
	local baDeltaLength = bLength - aLength -- kR = kF + baDeltaLength

	-- Range of diagonals in which forward and reverse paths might overlap.
	local kMinOverlapR = baDeltaLength - d -- -d <= kF
	local kMaxOverlapR = baDeltaLength + d -- kF <= d

	local aIndexPrev1 = NOT_YET_SET -- prev value of [iR - 1] in next iteration

	-- Optimization: skip diagonals in which paths cannot ever overlap.
	local nR = d < iMaxR and d or iMaxR

	-- The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.
	local iR = 0
	local kR = d
	while iR <= nR do
		-- To get first point of path segment, move one change in reverse direction
		-- from last point of previous path segment in an adjacent diagonal.
		-- In first iteration when iR === 0 and kR === d always insert.
		-- In last possible iteration when iR === d and kR === -d always delete.
		-- ROBLOX FIXME? should the values inserted into aIndexesF be 1-based so we don't have to adjust in several places here?
		local insert = iR == 0 or (iR ~= d and aIndexesR[iR + 1] < aIndexPrev1)
		local aLastPrev = insert and aIndexesR[iR + 1] or aIndexPrev1
		local aFirst: number = insert and aLastPrev -- vertical to insert from b
			or aLastPrev - 1 -- horizontal to delete from a

		-- To get last point of path segment, move along diagonal of common items.
		local bFirst = bR + aFirst - kR
		local nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon)
		local aLast = aFirst - nCommonR

		aIndexPrev1 = aIndexesR[iR + 1]
		aIndexesR[iR + 1] = aLast

		if kMinOverlapR <= kR and kR <= kMaxOverlapR then
			-- Solve for iF of forward path with d changes in diagonal kR:
			-- kF = kR - baDeltaLength
			-- kF = 2 * iF - d
			local iF = (d + (kR - baDeltaLength)) / 2

			-- If this reverse path overlaps the forward path in this diagonal,
			-- then this is a middle change of the index intervals.
			if iF <= iMaxF and aLast - 1 <= aIndexesF[iF + 1] then
				local bLast = bFirst - nCommonR

				division.nChangePreceding = d
				if d == aLast + bLast - aStart - bStart then
					-- Optimization: number of changes in reverse direction
					-- is equal to number of items in preceding interval,
					-- therefore it cannot contain any common items.
					division.aEndPreceding = aStart
					division.bEndPreceding = bStart
				else
					division.aEndPreceding = aLast
					division.bEndPreceding = bLast
				end

				division.nCommonPreceding = nCommonR
				if nCommonR ~= 0 then
					-- The last point of reverse path segment is start of common subsequence.
					division.aCommonPreceding = aLast
					division.bCommonPreceding = bLast
				end

				division.nChangeFollowing = d - 1
				if d == 1 then
					-- There is no previous path segment.
					division.nCommonFollowing = 0
					division.aStartFollowing = aEnd
					division.bStartFollowing = bEnd
				else
					-- Unlike the Myers algorithm which finds only the middle “snake”
					-- this package can find two common subsequences per division.
					-- Last point of previous path segment is on an adjacent diagonal.
					local bLastPrev = bR + aLastPrev - (insert and kR - 1 or kR + 1)

					-- Because of invariant that intervals following the middle change
					-- cannot have common items at the start,
					-- move in forward direction along a diagonal of common items.
					local nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon)

					division.nCommonFollowing = nCommonF
					if nCommonF ~= 0 then
						-- The last point of reverse path segment is start of common subsequence.
						division.aCommonFollowing = aLastPrev
						division.bCommonFollowing = bLastPrev
					end

					local aStartFollowing = aLastPrev + nCommonF -- aFirstPrev
					local bStartFollowing = bLastPrev + nCommonF -- bFirstPrev

					if d - 1 == aEnd + bEnd - aStartFollowing - bStartFollowing then
						-- Optimization: number of changes in forward direction
						-- is equal to number of items in following interval,
						-- therefore it cannot contain any common items.
						division.aStartFollowing = aEnd
						division.bStartFollowing = bEnd
					else
						division.aStartFollowing = aStartFollowing
						division.bStartFollowing = bStartFollowing
					end
				end

				return true
			end
		end
		iR += 1
		kR -= 2
	end

	return false
end

-- Given index intervals and input function to compare items at indexes,
-- divide at the middle change.
--
-- DO NOT CALL if start === end, because interval cannot contain common items
-- and because this function will throw the “no overlap” error.
local function divide(
	nChange: number,
	aStart: number,
	aEnd: number,
	bStart: number,
	bEnd: number,
	isCommon: IsCommon,
	aIndexesF: Indexes, -- temporary memory, not input nor output
	aIndexesR: Indexes, -- temporary memory, not input nor output
	division: Division -- output
): ()
	local bF = bStart - aStart -- bIndex = bF + aIndex - kF
	local bR = bEnd - aEnd -- bIndex = bR + aIndex - kR
	local aLength = aEnd - aStart
	local bLength = bEnd - bStart

	-- Because graph has square or portrait orientation,
	-- length difference is minimum number of items to insert from b.
	-- Corresponding forward and reverse diagonals in graph
	-- depend on length difference of the sequences:
	-- kF = kR - baDeltaLength
	-- kR = kF + baDeltaLength
	local baDeltaLength = bLength - aLength

	-- Optimization: max diagonal in graph intersects corner of shorter side.
	local iMaxF = aLength
	local iMaxR = aLength

	-- Initialize no changes yet in forward or reverse direction:
	aIndexesF[1] = aStart - 1 -- at open start of interval, outside closed start
	aIndexesR[1] = aEnd -- at open end of interval

	if baDeltaLength % 2 == 0 then
		-- The number of changes in paths is 2 * d if length difference is even.
		-- ROBLOX deviation: lua treats 0 as a true value
		local dMin = (nChange ~= 0 and nChange or baDeltaLength) / 2
		local dMax = (aLength + bLength) / 2

		for d = 1, dMax do
			iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF)

			if d < dMin then
				iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR)
				-- If a reverse path overlaps a forward path in the same diagonal,
				-- return a division of the index intervals at the middle change.
			elseif
				extendOverlappablePathsR(
					d,
					aStart,
					aEnd,
					bStart,
					bEnd,
					isCommon,
					aIndexesF,
					iMaxF,
					aIndexesR,
					iMaxR,
					division
				)
			then
				return
			end
		end
	else
		-- The number of changes in paths is 2 * d - 1 if length difference is odd.
		local dMin = ((nChange ~= 0 and nChange or baDeltaLength) + 1) / 2
		local dMax = (aLength + bLength + 1) / 2

		-- Unroll first half iteration so loop extends the relevant pairs of paths.
		-- Because of invariant that intervals have no common items at start or end,
		-- and limitation not to call divide with empty intervals,
		-- therefore it cannot be called if a forward path with one change
		-- would overlap a reverse path with no changes, even if dMin === 1.
		local d = 1
		iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF)

		d = d + 1
		while d <= dMax do
			iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR)

			if d < dMin then
				iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF)
				-- If a forward path overlaps a reverse path in the same diagonal,
				-- return a division of the index intervals at the middle change.
			elseif
				extendOverlappablePathsF(
					d,
					aStart,
					aEnd,
					bStart,
					bEnd,
					isCommon,
					aIndexesF,
					iMaxF,
					aIndexesR,
					iMaxR,
					division
				)
			then
				return
			end
			d = d + 1
		end
	end

	error(string.format("%s: no overlap aStart=%i aEnd=%i bStart=%i bEnd=%i", pkg, aStart, aEnd, bStart, bEnd))
end

-- Given index intervals and input function to compare items at indexes,
-- return by output function the number of adjacent items and starting indexes
-- of each common subsequence. Divide and conquer with only linear space.
--
-- The index intervals are half open [start, end) like array slice method.
-- DO NOT CALL if start === end, because interval cannot contain common items
-- and because divide function will throw the “no overlap” error.
local function findSubsequences(
	nChange: number,
	aStart: number,
	aEnd: number,
	bStart: number,
	bEnd: number,
	transposed: boolean,
	callbacks,
	aIndexesF: Indexes, -- temporary memory, not input nor output
	aIndexesR: Indexes, -- temporary memory, not input nor output
	division: Division -- temporary memory, not input nor output
): ()
	if bEnd - bStart < aEnd - aStart then
		-- Transpose graph so it has portrait instead of landscape orientation.
		-- Always compare shorter to longer sequence for consistency and optimization.
		transposed = not transposed
		if transposed and #callbacks == 1 then
			-- Lazily wrap callback functions to swap args if graph is transposed.
			local foundSubsequence, isCommon = unpack(callbacks[1])
			callbacks[2] = {
				function(nCommon, bCommon, aCommon)
					return foundSubsequence(nCommon, aCommon, bCommon)
				end,
				function(bIndex, aIndex)
					return isCommon(aIndex, bIndex)
				end,
			}
		end

		local tStart = aStart
		local tEnd = aEnd
		aStart = bStart
		aEnd = bEnd
		bStart = tStart
		bEnd = tEnd
	end
	local foundSubsequence, isCommon = unpack(callbacks[transposed and 2 or 1])

	-- Divide the index intervals at the middle change.
	divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division)
	local nChangePreceding = division.nChangePreceding
	local aEndPreceding = division.aEndPreceding
	local bEndPreceding = division.bEndPreceding
	local nCommonPreceding = division.nCommonPreceding
	local aCommonPreceding = division.aCommonPreceding
	local bCommonPreceding = division.bCommonPreceding
	local nCommonFollowing = division.nCommonFollowing
	local aCommonFollowing = division.aCommonFollowing
	local bCommonFollowing = division.bCommonFollowing
	local nChangeFollowing = division.nChangeFollowing
	local aStartFollowing = division.aStartFollowing
	local bStartFollowing = division.bStartFollowing

	-- Unless either index interval is empty, they might contain common items.
	if aStart < aEndPreceding and bStart < bEndPreceding then
		-- Recursely find and return common subsequences preceding the division.
		findSubsequences(
			nChangePreceding,
			aStart,
			aEndPreceding,
			bStart,
			bEndPreceding,
			transposed,
			callbacks,
			aIndexesF,
			aIndexesR,
			division
		)
	end

	-- Return common subsequences that are adjacent to the middle change.
	if nCommonPreceding ~= 0 then
		foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding)
	end
	if nCommonFollowing ~= 0 then
		foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing)
	end

	-- Unless either index interval is empty, they might contain common items.
	if aStartFollowing < aEnd and bStartFollowing < bEnd then
		-- Recursely find and return common subsequences following the division.
		findSubsequences(
			nChangeFollowing,
			aStartFollowing,
			aEnd,
			bStartFollowing,
			bEnd,
			transposed,
			callbacks,
			aIndexesF,
			aIndexesR,
			division
		)
	end
end

local function validateLength(name: string, arg: any): ()
	if typeof(arg) ~= "number" then
		error(string.format("%s: %s type %s is not a number", pkg, name, type(arg)))
	end
	if not Number.isSafeInteger(arg) then
		error(string.format("%s: %s type %s is not a safe integer", pkg, name, type(arg)))
	end
	if arg < 0 then
		error(string.format("%s: %s type %s is a negative integer", pkg, name, type(arg)))
	end
end

local function validateCallback(name: string, arg: any): ()
	if typeof(arg) ~= "function" then
		error(string.format("%s: %s type %s is not a function", pkg, name, type(arg)))
	end
end

-- Compare items in two sequences to find a longest common subsequence.
-- Given lengths of sequences and input function to compare items at indexes,
-- return by output function the number of adjacent items and starting indexes
-- of each common subsequence.
return function(aLength: number, bLength: number, isCommon: IsCommon, foundSubsequence: FoundSubsequence): ()
	validateLength("aLength", aLength)
	validateLength("bLength", bLength)
	validateCallback("isCommon", isCommon)
	validateCallback("foundSubsequence", foundSubsequence)

	-- Count common items from the start in the forward direction.
	local nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon)

	if nCommonF ~= 0 then
		foundSubsequence(nCommonF, 0, 0)
	end

	-- Unless both sequences consist of common items only,
	-- find common items in the half-trimmed index intervals.
	if aLength ~= nCommonF or bLength ~= nCommonF then
		-- Invariant: intervals do not have common items at the start.
		-- The start of an index interval is closed like array slice method.
		local aStart = nCommonF
		local bStart = nCommonF

		-- Count common items from the end in the reverse direction.
		local nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon)

		-- Invariant: intervals do not have common items at the end.
		-- The end of an index interval is open like array slice method.
		local aEnd = aLength - nCommonR
		local bEnd = bLength - nCommonR

		-- Unless one sequence consists of common items only,
		-- therefore the other trimmed index interval consists of changes only,
		-- find common items in the trimmed index intervals.
		local nCommonFR = nCommonF + nCommonR
		if aLength ~= nCommonFR and bLength ~= nCommonFR then
			local nChange = 0 -- number of change items is not yet known
			local transposed = false -- call the original unwrapped functions
			local callbacks = { { foundSubsequence, isCommon } }

			-- Indexes in sequence a of last points in furthest reaching paths
			-- from outside the start at top left in the forward direction:
			local aIndexesF = { NOT_YET_SET }
			-- from the end at bottom right in the reverse direction:
			local aIndexesR = { NOT_YET_SET }

			-- Initialize one object as output of all calls to divide function.
			local division = {
				aCommonFollowing = NOT_YET_SET,
				aCommonPreceding = NOT_YET_SET,
				aEndPreceding = NOT_YET_SET,
				aStartFollowing = NOT_YET_SET,
				bCommonFollowing = NOT_YET_SET,
				bCommonPreceding = NOT_YET_SET,
				bEndPreceding = NOT_YET_SET,
				bStartFollowing = NOT_YET_SET,
				nChangeFollowing = NOT_YET_SET,
				nChangePreceding = NOT_YET_SET,
				nCommonFollowing = NOT_YET_SET,
				nCommonPreceding = NOT_YET_SET,
			}

			-- Find and return common subsequences in the trimmed index intervals.
			findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division)
		end

		if nCommonR ~= 0 then
			foundSubsequence(nCommonR, aEnd, bEnd)
		end
	end
end
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="234">
            <Properties>
              <string name="Name">Emittery</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/sindresorhus/emittery/blob/v0.11.0/index.js
-- ROBLOX upstream types: https://github.com/sindresorhus/emittery/blob/v0.11.0/index.d.ts
--[[
	MIT License

	Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
]]
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set
local Symbol = LuauPolyfill.Symbol
local WeakMap = LuauPolyfill.WeakMap
local console = LuauPolyfill.console
local TypeError = Error
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type Symbol = LuauPolyfill.Symbol

local Promise = require(Packages.Promise)
type Promise<T> = LuauPolyfill.Promise<T>

type PropertyKey = string | number | Symbol
type EventName = PropertyKey

local HttpService = game:GetService("HttpService")

-- ROBLOX deviation START: predefine variables
local isMetaEvent
-- ROBLOX deviation END

-- ROBLOX deviation: adding a special marker to as { nil } is equivalent to empty array and won't be iterated over
local NIL = Object.None

local exports = {}

local anyMap = WeakMap.new()
local eventsMap = WeakMap.new()
local producersMap = WeakMap.new()
local anyProducer = Symbol("anyProducer")
local resolvedPromise = Promise.resolve()

-- Define symbols for "meta" events.
local listenerAdded = Symbol("listenerAdded")
local listenerRemoved = Symbol("listenerRemoved")

-- Define a symbol that allows internal code to emit meta events, but prevents userland from doing so.
local metaEventsAllowed = Symbol("metaEventsAllowed")

local isGlobalDebugEnabled = false

-- ROBLOX deviation START: additional isSymbol function as Luau doesn't support symbols natively
local function isSymbol(value: any): boolean
	return typeof(value) == "userdata" and tostring(value):match("Symbol%(.*%)") ~= nil
end
-- ROBLOX deviation END

--[[
	ROBLOX deviation START:
	additional checking function to allow for both functions and callable tables to be passed as arguments
]]
local function isCallable(f: any): boolean
	return typeof(f) == "function"
		or (
			typeof(f) == "table"
			and typeof(getmetatable(f)) == "table"
			and typeof(getmetatable(f).__call) == "function"
		)
end
-- ROBLOX deviation END

local function assertEventName(eventName, allowMetaEvents)
	if
		typeof(eventName) ~= "string"
		-- ROBLOX deviation: using isSymbol as Luau doesn't support symbols natively
		and not isSymbol(eventName)
		and typeof(eventName) ~= "number"
	then
		error(TypeError.new("`eventName` must be a string, symbol, or number"))
	end
	if isMetaEvent(eventName) and allowMetaEvents ~= metaEventsAllowed then
		error(TypeError.new("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`"))
	end
end

local function assertListener(listener)
	-- ROBLOX deviation: using isCallable to allow for callable tables being passed
	if not isCallable(listener) then
		error(TypeError.new("listener must be a function"))
	end
end

local function getListeners(instance, eventName)
	local events = eventsMap:get(instance)
	if not events:has(eventName) then
		events:set(eventName, Set.new())
	end
	return events:get(eventName)
end

local function getEventProducers(instance, eventName)
	local key = if typeof(eventName) == "string"
			-- ROBLOX deviation: using isSymbol as Luau doesn't support symbols natively
			or isSymbol(eventName)
			or typeof(eventName) == "number"
		then eventName
		else anyProducer
	local producers = producersMap:get(instance)
	if not producers:has(key) then
		producers:set(key, Set.new())
	end
	return producers:get(key)
end

local function enqueueProducers(instance, eventName, eventData)
	local producers = producersMap:get(instance)
	if producers:has(eventName) then
		for _, producer in producers:get(eventName):ipairs() do
			producer:enqueue(eventData)
		end
	end
	if producers:has(anyProducer) then
		local item = Promise.all({
			-- ROBLOX deviation START: eventName and eventData aren't necessarily Promises
			Promise.resolve(eventName),
			Promise.resolve(eventData),
			-- ROBLOX deviation END
		})
		for _, producer in producers:get(anyProducer):ipairs() do
			producer:enqueue(item)
		end
	end
end

local function iterator(instance, eventNames)
	-- ROBLOX deviation: adding a special marker as { nil } is equivalent to empty array and won't be iterated over
	eventNames = if Array.isArray(eventNames) then eventNames elseif eventNames ~= nil then { eventNames } else { NIL }
	local isFinished = false
	local function flush() end
	-- ROBLOX deviation: casting to Array<any>? to allow assigning nil later
	local queue = {} :: Array<any>?

	local producer = {
		enqueue = function(self, item)
			table.insert(queue, item)
			flush()
		end,
		finish = function(self)
			isFinished = true
			flush()
		end,
	}

	for _, eventName in eventNames do
		getEventProducers(instance, eventName):add(producer)
	end

	return {
		next = function(self)
			return Promise.resolve():andThen(function()
				if queue == nil then
					return { done = true }
				end
				if #queue == 0 then
					if isFinished then
						queue = nil
						return self:next()
					end

					Promise.new(function(resolve)
						flush = resolve
					end):expect()

					return self:next()
				end
				return {
					done = false,
					-- ROBLOX deviation: values in queue are not necessarily Promises
					value = Promise.resolve(table.remove(queue, 1) :: any):expect(),
				}
			end)
		end,
		["return"] = function(self, ...)
			local value = ...
			local arguments = { ... }
			return Promise.resolve():andThen(function()
				queue = nil

				for _, eventName in eventNames do
					getEventProducers(instance, eventName):delete(producer)
				end

				flush()

				return if #arguments > 0 then { done = true, value = value:expect() } else { done = true }
			end)
		end,
		-- ROBLOX deviation START: Symbol.asyncIterator is not supported
		-- [Symbol.asyncIterator] = function(self)
		-- 	return self
		-- end,
		-- ROBLOX deviation END
	}
end

-- ROBLOX deviation START: defaultMethodNamesOrAssert is not used right now
-- local function defaultMethodNamesOrAssert(methodNames)
-- 	if methodNames == nil then
-- 		return allEmitteryMethods
-- 	end

-- 	if not Array.isArray(methodNames) then
-- 		error(TypeError.new("`methodNames` must be an array of strings"))
-- 	end

-- 	for _, methodName in methodNames do
-- 		if not Array.includes(allEmitteryMethods, methodName) then
-- 			if typeof(methodName) ~= "string" then
-- 				error(TypeError.new("`methodNames` element must be a string"))
-- 			end
-- 			error(Error.new(("%s is not Emittery method"):format(tostring(methodName))))
-- 		end
-- 	end

-- 	return methodNames
-- end
-- ROBLOX deviation END

function isMetaEvent(eventName)
	return eventName == listenerAdded or eventName == listenerRemoved
end

export type Emittery = {
	new: (options: Object?) -> Emittery,
	logIfDebugEnabled: (self: Emittery, type_: any, eventName: any, eventData: any) -> any,
	on: (self: Emittery, eventNames: any, listener: any) -> Emittery_UnsubscribeFn,
	off: (self: Emittery, eventNames: any, listener: any) -> any,
	once: (self: Emittery, eventNames: any) -> any,
	events: (self: Emittery, eventNames: any) -> any,
	emit: (self: Emittery, eventName: any, eventData: any, allowMetaEvents: any?) -> any,
	emitSerial: (self: Emittery, eventName: any, eventData: any, allowMetaEvents: any) -> any,
	onAny: (self: Emittery, listener: any) -> any,
	anyEvent: (self: Emittery) -> any,
	offAny: (self: Emittery, listener: any) -> Emittery_UnsubscribeFn,
	clearListeners: (self: Emittery, eventNames: any) -> any,
	listenerCount: (self: Emittery, eventNames: any) -> any,
	bindMethods: (self: Emittery, target: any, methodNames: any) -> any,
}
local Emittery = {} :: Emittery;
(Emittery :: any).__index = Emittery
function Emittery.new(options_: Object?): Emittery
	local self = setmetatable({}, Emittery)
	local options = if options_ ~= nil then options_ else {}
	anyMap:set(self, Set.new())
	eventsMap:set(self, Map.new())
	producersMap:set(self, Map.new())
	self.debug = Boolean.toJSBoolean(options.debug) and options.debug or {}

	if self.debug.enabled == nil then
		self.debug.enabled = false
	end

	if not Boolean.toJSBoolean(self.debug.logger) then
		self.debug.logger = function(_self: any, type_, debugName, eventName, eventData)
			xpcall(function()
				-- TODO: Use https://github.com/sindresorhus/safe-stringify when the package is more mature. Just copy-paste the code.
				eventData = HttpService:JSONEncode(eventData)
			end, function()
				eventData = ("Object with the following keys failed to stringify: %s"):format(
					Array.join(Object.keys(eventData), ",")
				)
			end)

			if
				-- ROBLOX deviation: using isSymbol as Luau doesn't support symbols natively
				isSymbol(eventName) or typeof(eventName) == "number"
			then
				eventName = tostring(eventName)
			end

			-- ROBLOX deviation START: modified logic for extracting time from a DateTime object
			local currentTime = DateTime.now():ToUniversalTime()
			local logTime = ("%d:%d:%d.%d"):format(
				currentTime.Hour,
				currentTime.Minute,
				currentTime.Second,
				currentTime.Millisecond
			)
			-- ROBLOX deviation END
			console.log(
				("[%s][emittery:%s][%s] Event Name: %s\n\tdata: %s"):format(
					logTime,
					tostring(type_),
					tostring(debugName),
					tostring(eventName),
					tostring(eventData)
				)
			)
		end
	end
	return (self :: any) :: Emittery
end

-- ROBLOX deviation START: not supporting Emittery.mixin for now
-- function Emittery.mixin(emitteryPropertyName, methodNames)
-- 	methodNames = defaultMethodNamesOrAssert(methodNames)
-- 	return function(target)
-- 		if typeof(target) ~= "function" then
-- 			error(TypeError.new("`target` must be function"))
-- 		end
-- 		for _, methodName in
-- 			ipairs(methodNames) --[[ ROBLOX CHECK: check if 'methodNames' is an Array ]]
-- 		do
-- 			if target.prototype[tostring(methodName)] ~= nil then
-- 				error(
-- 					Error.new(
-- 						("The property `%s` already exists on `target`"):format(
-- 							tostring(methodName)
-- 						)
-- 					)
-- 				)
-- 			end
-- 		end
-- 		local function getEmitteryProperty()
-- 			Object.defineProperty(
-- 				self,
-- 				emitteryPropertyName,
-- 				{ enumerable = false, value = Emittery.new() }
-- 			)
-- 			return self[tostring(emitteryPropertyName)]
-- 		end
-- 		Object.defineProperty(
-- 			target.prototype,
-- 			emitteryPropertyName,
-- 			{ enumerable = false, get = getEmitteryProperty }
-- 		)
-- 		local function emitteryMethodCaller(methodName)
-- 			return function(
-- 				...: any --[[ ROBLOX CHECK: check correct type of elements. ]]
-- 			)
-- 				local args = { ... }
-- 				return self[tostring(emitteryPropertyName)][tostring(methodName)](
-- 					self[tostring(emitteryPropertyName)],
-- 					table.unpack(args)
-- 				)
-- 			end
-- 		end
-- 		for _, methodName in
-- 			ipairs(methodNames) --[[ ROBLOX CHECK: check if 'methodNames' is an Array ]]
-- 		do
-- 			Object.defineProperty(
-- 				target.prototype,
-- 				methodName,
-- 				{ enumerable = false, value = emitteryMethodCaller(methodName) }
-- 			)
-- 		end
-- 		return target
-- 	end
-- end
-- ROBLOX deviation END

-- ROBLOX deviation: mocking process
local process = nil

-- ROBLOX deviation: getIsDebugEnabled instead of a getter
function Emittery.getIsDebugEnabled(): boolean
	if typeof(process) ~= "table" then
		return isGlobalDebugEnabled
	end
	local env = (Boolean.toJSBoolean(process) and process or { env = {} }).env
	return env.DEBUG == "emittery" or env.DEBUG == "*" or isGlobalDebugEnabled
end

-- ROBLOX deviation: setIsDebugEnabled instead of a setter
function Emittery.setIsDebugEnabled(newValue: boolean)
	isGlobalDebugEnabled = newValue
end

function Emittery:logIfDebugEnabled(type_, eventName, eventData)
	if
		-- ROBLOX deviation: getIsDebugEnabled instead of a setter
		Emittery.getIsDebugEnabled() or self.debug.enabled
	then
		self.debug:logger(type_, self.debug.name, eventName, eventData)
	end
end

function Emittery:on(eventNames, listener)
	assertListener(listener)

	eventNames = if Array.isArray(eventNames) then eventNames else { eventNames }
	for _, eventName in eventNames do
		assertEventName(eventName, metaEventsAllowed)
		getListeners(self, eventName):add(listener)

		self:logIfDebugEnabled("subscribe", eventName, nil)

		if not isMetaEvent(eventName) then
			self:emit(listenerAdded, { eventName = eventName, listener = listener }, metaEventsAllowed)
		end
	end
	return function()
		return self:off(eventNames, listener)
	end
end

function Emittery:off(eventNames, listener)
	assertListener(listener)

	eventNames = if Array.isArray(eventNames) then eventNames else { eventNames }
	for _, eventName in eventNames do
		assertEventName(eventName, metaEventsAllowed)
		getListeners(self, eventName):delete(listener)

		self:logIfDebugEnabled("unsubscribe", eventName, nil)

		if not isMetaEvent(eventName) then
			self:emit(listenerRemoved, { eventName = eventName, listener = listener }, metaEventsAllowed)
		end
	end
end

function Emittery:once(eventNames)
	return Promise.new(function(resolve)
		local off
		off = self:on(eventNames, function(data)
			off()
			resolve(data)
		end)
	end)
end

function Emittery:events(eventNames)
	eventNames = if Array.isArray(eventNames) then eventNames else { eventNames }

	for _, eventName in eventNames do
		assertEventName(eventName, metaEventsAllowed)
	end

	return iterator(self, eventNames)
end

function Emittery:emit(eventName, eventData, allowMetaEvents)
	return Promise.resolve():andThen(function()
		assertEventName(eventName, allowMetaEvents)

		self:logIfDebugEnabled("emit", eventName, eventData)

		enqueueProducers(self, eventName, eventData)

		local listeners = getListeners(self, eventName)
		local anyListeners = anyMap:get(self)
		local staticListeners = Array.concat({}, Array.from(listeners))
		local staticAnyListeners = if Boolean.toJSBoolean(isMetaEvent(eventName))
			then {}
			else Array.concat({}, Array.from(anyListeners))

		-- ROBLOX deviation START: need to delay a promise as awaited promises are deferred in JS
		resolvedPromise
			:andThen(function(...)
				return Promise.delay(0):andThenReturn(...)
			end)
			:expect()
		-- ROBLOX deviation END
		Promise.all(Array.concat(
			{},
			Array.map(staticListeners, function(listener)
				return Promise.resolve():andThen(function()
					if listeners:has(listener) then
						return listener(eventData)
					end
					return
				end)
			end),
			Array.map(staticAnyListeners, function(listener)
				return Promise.resolve():andThen(function()
					if anyListeners:has(listener) then
						return listener(eventName, eventData)
					end
					return
				end)
			end)
		)):expect()
	end)
end

function Emittery:emitSerial(eventName, eventData, allowMetaEvents)
	return Promise.resolve():andThen(function()
		assertEventName(eventName, allowMetaEvents)

		self:logIfDebugEnabled("emitSerial", eventName, eventData)

		local listeners = getListeners(self, eventName)
		local anyListeners = anyMap:get(self)
		local staticListeners = Array.concat({}, Array.from(listeners))
		local staticAnyListeners = Array.concat({}, Array.from(anyListeners))

		-- ROBLOX deviation START: need to delay a promise as awaited promises are deferred in JS
		resolvedPromise
			:andThen(function(...)
				return Promise.delay(0):andThenReturn(...)
			end)
			:expect()
		-- ROBLOX deviation END
		--[[ eslint-disable no-await-in-loop ]]
		for _, listener in staticListeners do
			if listeners:has(listener) then
				-- ROBLOX deviation: listener doesn't necessarily return a Promise
				Promise.resolve(listener(eventData)):expect()
			end
		end

		for _, listener in staticAnyListeners do
			if anyListeners:has(listener) then
				-- ROBLOX deviation: listener doesn't necessarily return a Promise
				Promise.resolve(listener(eventName, eventData)):expect()
			end
		end
		--[[ eslint-enable no-await-in-loop ]]
	end)
end

function Emittery:onAny(listener)
	assertListener(listener)

	self:logIfDebugEnabled("subscribeAny", nil, nil)

	anyMap:get(self):add(listener)
	self:emit(listenerAdded, { listener = listener }, metaEventsAllowed)
	return function()
		self:offAny(listener)
	end
end

function Emittery:anyEvent()
	return iterator(self)
end

function Emittery:offAny(listener)
	assertListener(listener)

	self:logIfDebugEnabled("unsubscribeAny", nil, nil)

	self:emit(listenerRemoved, { listener = listener }, metaEventsAllowed)
	anyMap:get(self):delete(listener)
end

function Emittery:clearListeners(eventNames)
	-- ROBLOX deviation: adding a special marker as { nil } is equivalent to empty array and won't be iterated over
	eventNames = if Array.isArray(eventNames) then eventNames elseif eventNames ~= nil then { eventNames } else { NIL }

	for _, eventName in eventNames do
		self:logIfDebugEnabled("clear", eventName, nil)

		if
			typeof(eventName) == "string"
			-- ROBLOX deviation: using isSymbol as Luau doesn't support symbols natively
			or isSymbol(eventName)
			or typeof(eventName) == "number"
		then
			getListeners(self, eventName):clear()

			local producers = getEventProducers(self, eventName)

			for _, producer in producers:ipairs() do
				producer:finish()
			end

			producers:clear()
		else
			anyMap:get(self):clear()

			for _, listeners in eventsMap:get(self):values() do
				listeners:clear()
			end

			for _, producers in producersMap:get(self):values() do
				for _, producer in producers:ipairs() do
					producer:finish()
				end

				producers:clear()
			end
		end
	end
end

function Emittery:listenerCount(eventNames)
	-- ROBLOX deviation: adding a special marker as { nil } is equivalent to empty array and won't be iterated over
	eventNames = if Array.isArray(eventNames) then eventNames elseif eventNames ~= nil then { eventNames } else { NIL }
	local count = 0

	for _, eventName in eventNames do
		if typeof(eventName) == "string" then
			count += anyMap:get(self).size + getListeners(self, eventName).size + getEventProducers(self, eventName).size + getEventProducers(
				self
			).size
			continue
		end

		-- ROBLOX deviation: adding a special marker as { nil } is equivalent to empty array and won't be iterated over
		if eventName ~= nil and eventName ~= NIL then
			assertEventName(eventName, metaEventsAllowed)
		end

		count += anyMap:get(self).size

		for _, value in eventsMap:get(self):values() do
			count += value.size
		end

		for _, value in producersMap:get(self):values() do
			count += value.size
		end
	end

	return count
end

-- ROBLOX deviation START: not supporting Emittery:bindMethods for now
-- function Emittery:bindMethods(target, methodNames)
-- 	if typeof(target) ~= "table" or target == nil then
-- 		error(TypeError.new("`target` must be an object"))
-- 	end
-- 	methodNames = defaultMethodNamesOrAssert(methodNames)
-- 	for _, methodName in
-- 		ipairs(methodNames) --[[ ROBLOX CHECK: check if 'methodNames' is an Array ]]
-- 	do
-- 		if target[tostring(methodName)] ~= nil then
-- 			error(Error.new(("The property `%s` already exists on `target`"):format(tostring(methodName))))
-- 		end
-- 		Object.defineProperty(target, methodName, { enumerable = false, value = self[tostring(methodName)]:bind(self) })
-- 	end
-- end

-- local allEmitteryMethods = Array.filter(Object.getOwnPropertyNames(Emittery.prototype), function(v)
-- 	return v ~= "constructor"
-- end)
-- ROBLOX deviation END

--[[
	ROBLOX deviation START:
	defining properties directly on a class object instead of using Object.defineProperty
	original code:
	Object.defineProperty(
		Emittery,
		"listenerAdded",
		{ value = listenerAdded, writable = false, enumerable = true, configurable = false }
	)
	Object.defineProperty(
		Emittery,
		"listenerRemoved",
		{ value = listenerRemoved, writable = false, enumerable = true, configurable = false }
	)
]]
Emittery.listenerAdded = listenerAdded
Emittery.listenerRemoved = listenerRemoved
-- ROBLOX deviation END
exports.default = Emittery

--[[*
Removes an event subscription.
]]
export type Emittery_UnsubscribeFn = () -> ()

--[[*
The data provided as `eventData` when listening for `Emittery.listenerAdded` or `Emittery.listenerRemoved`.
]]
export type Emittery_ListenerChangedData = {
	--[[*
	The listener that was added or removed.
	]]
	listener: (eventData: unknown?) -> ...Promise<nil>,

	--[[*
	The name of the event that was added or removed if `.on()` or `.off()` was used, or `undefined` if `.onAny()` or `.offAny()` was used.
	]]
	eventName: EventName?,
}

return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="235">
            <Properties>
              <string name="Name">ES7Types</string>
              <string name="Source"><![CDATA[--!strict
export type Object = { [string]: any }
export type Array<T> = { [number]: T }
export type Function = (...any) -> ...any
export type Table<T, V> = { [T]: V }
export type Tuple<T, V> = Array<T | V>
export type mapCallbackFn<K, V> = (element: V, key: K, map: Map<K, V>) -> ()
export type mapCallbackFnWithThisArg<K, V> = (thisArg: Object, value: V, key: K, map: Map<K, V>) -> ()

export type Map<K, V> = typeof(setmetatable(
	{} :: {
		size: number,
		-- method definitions
		set: (self: Map<K, V>, K, V) -> Map<K, V>,
		get: (self: Map<K, V>, K) -> V | nil,
		clear: (self: Map<K, V>) -> (),
		delete: (self: Map<K, V>, K) -> boolean,
		forEach: (
			self: Map<K, V>,
			callback: mapCallbackFn<K, V> | mapCallbackFnWithThisArg<K, V>,
			thisArg: Object?
		) -> (),
		[K]: V,
		has: (self: Map<K, V>, K) -> boolean,
		keys: (self: Map<K, V>) -> Array<K>,
		values: (self: Map<K, V>) -> Array<V>,
		entries: (self: Map<K, V>) -> Array<Tuple<K, V>>,
		ipairs: (self: Map<K, V>) -> any,
		_map: { [K]: V },
		_array: { [number]: K },
		__index: (self: Map<K, V>, key: K) -> V,
		__iter: (self: Map<K, V>) -> (<K, V>({ [K]: V }, K?) -> (K?, V), V),
		__newindex: (self: Map<K, V>, key: K, value: V) -> (),
	},
	{} :: {
		__index: Map<K, V>,
		__iter: (self: Map<K, V>) -> (<K, V>({ [K]: V }, K?) -> (K, V), V),
		__newindex: (self: Map<K, V>, key: K, value: V) -> (),
	}
))

export type WeakMap<K, V> = {
	-- method definitions
	get: (self: WeakMap<K, V>, K) -> V,
	set: (self: WeakMap<K, V>, K, V) -> WeakMap<K, V>,
	has: (self: WeakMap<K, V>, K) -> boolean,
}

export type setCallbackFn<T> = (value: T, key: T, set: Set<T>) -> ()
export type setCallbackFnWithThisArg<T> = (thisArg: Object, value: T, key: T, set: Set<T>) -> ()

export type Set<T> = typeof(setmetatable(
	{} :: {
		size: number,
		-- method definitions
		add: (self: Set<T>, T) -> Set<T>,
		clear: (self: Set<T>) -> (),
		delete: (self: Set<T>, T) -> boolean,
		forEach: (self: Set<T>, callback: setCallbackFn<T> | setCallbackFnWithThisArg<T>, thisArg: Object?) -> (),
		has: (self: Set<T>, T) -> boolean,
		ipairs: (self: Set<T>) -> any,
	},
	{} :: {
		__index: Set<T>,
		__iter: (self: Set<T>) -> (<K, V>({ [K]: V }, K?) -> (K, V), T),
	}
))
return {}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="236">
            <Properties>
              <string name="Name">Expect</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/index.ts

-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local Promise = require(Packages.Promise)
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>

local matcherUtils = require(Packages.JestMatcherUtils)

local AsymmetricMatchers = require(CurrentModule.asymmetricMatchers)
local any = AsymmetricMatchers.any
local anything = AsymmetricMatchers.anything
local arrayContaining = AsymmetricMatchers.arrayContaining
local arrayNotContaining = AsymmetricMatchers.arrayNotContaining
-- ROBLOX deviation START: Luau-specific callable object matching
local callable = AsymmetricMatchers.callable
local notCallable = AsymmetricMatchers.notCallable
-- ROBLOX deviation END
local closeTo = AsymmetricMatchers.closeTo
local notCloseTo = AsymmetricMatchers.notCloseTo
local nothing = AsymmetricMatchers.nothing
local objectContaining = AsymmetricMatchers.objectContaining
local objectNotContaining = AsymmetricMatchers.objectNotContaining
local stringContaining = AsymmetricMatchers.stringContaining
local stringMatching = AsymmetricMatchers.stringMatching
local stringNotContaining = AsymmetricMatchers.stringNotContaining
local stringNotMatching = AsymmetricMatchers.stringNotMatching
local extractExpectedAssertionsErrors = require(CurrentModule.extractExpectedAssertionsErrors).default
local JasmineUtils = require(CurrentModule.jasmineUtils)
local equals = JasmineUtils.equals

local JestMatchersObject = require(CurrentModule.jestMatchersObject)
--local INTERNAL_MATCHER_FLAG = JestMatchersObject.INTERNAL_MATCHER_FLAG
local getMatchers = JestMatchersObject.getMatchers
local getState = JestMatchersObject.getState
local setMatchers = JestMatchersObject.setMatchers
local setState = JestMatchersObject.setState
local matchers = require(CurrentModule.matchers)
local spyMatchers = require(CurrentModule.spyMatchers)
local toThrowMatchersModule = require(CurrentModule.toThrowMatchers)
local toThrowMatchers = toThrowMatchersModule.matchers
local createThrowMatcher = toThrowMatchersModule.createMatcher

local Types = require(CurrentModule.types)
type AsyncExpectationResult = Types.AsyncExpectationResult
export type Expect = Types.Expect_
export type ExpectObj = Types.ExpectObj<any>
type ExpectationResult = Types.ExpectationResult
-- ROBLOX deviation START: favour exported type so Rotriever can see them
-- type JestMatcherState = Types.MatcherState -- replaced with MatcherState
-- type MatcherInterface<R> = Types.Matchers_<R> -- replaced with Matcher<R>
-- ROBLOX deviation END
type MatchersObject = Types.MatchersObject
type PromiseMatcherFn = Types.PromiseMatcherFn
type RawMatcherFn = Types.RawMatcherFn_
type SyncExpectationResult = Types.SyncExpectationResult
type ThrowingMatcherFn = Types.ThrowingMatcherFn

-- ROBLOX deviation START: exporting types without a namespace prefix
export type MatcherState = Types.MatcherState
export type Matcher<R> = Types.Matchers_<R>
-- ROBLOX deviation END

-- ROBLOX deviation START: add additional type exports
export type ExpectExtended<E, State = MatcherState> = Types.ExpectExtended<E, State>
-- ROBLOX deviation END

local utils = require(CurrentModule.utils)
local iterableEquality = utils.iterableEquality
local subsetEquality = utils.subsetEquality
-- ROBLOX deviation: Roblox Instance matchers
-- local instanceSubsetEquality = utils.instanceSubsetEquality

local makeThrowingMatcher, _validateResult

--[[
	ROBLOX deviation START: inline type as Lua doesn't support Omit utility type
	original code: Omit<SyncExpectationResult, 'message'>
]]
type Omit_SyncExpectationResult_message = {
	pass: boolean,
}

type JestAssertionError = Error & {
	matcherResult: Omit_SyncExpectationResult_message & { message: string },
}
-- ROBLOX deviation END
type JestAssertionError_statics = { new: (message: string?) -> JestAssertionError }
local JestAssertionError = (
	setmetatable({}, { __index = Error }) :: any
) :: JestAssertionError & JestAssertionError_statics;
(JestAssertionError :: any).__index = JestAssertionError
function JestAssertionError.new(message: string?): JestAssertionError
	local self = setmetatable(Error.new(message), JestAssertionError)
	return (self :: any) :: JestAssertionError
end

local function isPromise<T>(
	obj: any
): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ obj is PromiseLike<T> ]]
	return not not Boolean.toJSBoolean(obj)
		and (typeof(obj) == "table" or typeof(obj) == "function")
		and typeof(obj.andThen) == "function"
end

local function createToThrowErrorMatchingSnapshotMatcher(matcher: RawMatcherFn)
	-- ROBLOX deviation: deduplicate JestMatcherState -> MatcherState
	return function(self: MatcherState, received: any, testNameOrInlineSnapshot: string?)
		return matcher(self, table.unpack({ received, testNameOrInlineSnapshot, true }))
	end
end

local function getPromiseMatcher(name: string, matcher: any)
	if name == "toThrow" or name == "toThrowError" then
		return createThrowMatcher(name, true)
	elseif name == "toThrowErrorMatchingSnapshot" or name == "toThrowErrorMatchingInlineSnapshot" then
		return createToThrowErrorMatchingSnapshotMatcher(matcher)
	end
	return nil
end

-- ROBLOX deviation: Declaring this here because hoisting is not available in lua
local makeResolveMatcher, makeRejectMatcher

local function expect_(_self, actual: any, ...)
	local rest: Array<any> = { ... }

	if #rest ~= 0 then
		error("Expect takes at most one argument.")
	end

	local allMatchers = getMatchers()
	local expectation = {
		never = {},
		rejects = { never = {} },
		resolves = { never = {} },
	}

	local err = JestAssertionError.new()

	for name, matcher in pairs(allMatchers) do
		local ref = getPromiseMatcher(name, matcher)
		local promiseMatcher = Boolean.toJSBoolean(ref) and ref or matcher
		expectation[name] = makeThrowingMatcher(matcher, false, "", actual)
		expectation.never[name] = makeThrowingMatcher(matcher, true, "", actual)

		expectation.resolves[name] = makeResolveMatcher(name, promiseMatcher, false, actual, err)
		expectation.resolves.never[name] = makeResolveMatcher(name, promiseMatcher, true, actual, err)
		expectation.rejects[name] = makeRejectMatcher(name, promiseMatcher, false, actual, err)
		expectation.rejects.never[name] = makeRejectMatcher(name, promiseMatcher, true, actual, err)
	end

	return expectation
end

local function getMessage(message: (() -> string)?)
	return if message then message() else matcherUtils.RECEIVED_COLOR("No message was specified for this matcher.")
end

function makeResolveMatcher(
	matcherName: string,
	matcher: RawMatcherFn,
	isNot: boolean,
	actual: Promise<any>,
	outerErr: JestAssertionError
): PromiseMatcherFn
	return function(...)
		local args = { ... }
		local options = { isNot = isNot, promise = "resolves" }
		if not isPromise(actual) then
			error(
				JestAssertionError.new(
					matcherUtils.matcherErrorMessage(
						matcherUtils.matcherHint(matcherName, nil, "", options),
						("%s value must be a promise"):format(tostring(matcherUtils.RECEIVED_COLOR("received"))),
						matcherUtils.printWithType("Received", actual, matcherUtils.printReceived)
					)
				)
			)
		end
		local innerErr = JestAssertionError.new()
		return actual:andThen(function(result)
			return makeThrowingMatcher(matcher, isNot, "resolves", result, innerErr)(table.unpack(args))
		end, function(reason)
			outerErr.message = tostring(matcherUtils.matcherHint(matcherName, nil, "", options))
				.. "\n\n"
				.. "Received promise rejected instead of resolved\n"
				.. ("Rejected to value: %s"):format(matcherUtils.printReceived(reason))
			return Promise.reject(outerErr)
		end)
	end
end

function makeRejectMatcher(
	matcherName: string,
	matcher: RawMatcherFn,
	isNot: boolean,
	actual: Promise<any> | any --[[ ROBLOX TODO: Unhandled node for type: TSParenthesizedType ]] --[[ (() => Promise<any>) ]],
	outerErr: JestAssertionError
): PromiseMatcherFn
	return function(...)
		local args = { ... }
		local options = { isNot = isNot, promise = "rejects" }
		local actualWrapper: Promise<any> = if typeof(actual) == "function" then actual() else actual
		if not isPromise(actualWrapper) then
			error(
				JestAssertionError.new(
					matcherUtils.matcherErrorMessage(
						matcherUtils.matcherHint(matcherName, nil, "", options),
						("%s value must be a promise or a function returning a promise"):format(
							tostring(matcherUtils.RECEIVED_COLOR("received"))
						),
						matcherUtils.printWithType("Received", actual, matcherUtils.printReceived)
					)
				)
			)
		end
		local innerErr = JestAssertionError.new()
		return actualWrapper:andThen(function(result)
			outerErr.message = tostring(matcherUtils.matcherHint(matcherName, nil, "", options))
				.. "\n\n"
				.. "Received promise resolved instead of rejected\n"
				.. ("Resolved to value: %s"):format(matcherUtils.printReceived(result))
			return Promise.reject(outerErr)
		end, function(reason)
			return makeThrowingMatcher(matcher, isNot, "rejects", reason, innerErr)(table.unpack(args))
		end)
	end
end

-- ROBLOX deviation: matcher does not have RawMatcherFn type annotation and the
-- the function return is not annotated with ThrowingMatcherFn
function makeThrowingMatcher(
	matcher: RawMatcherFn,
	isNot: boolean,
	promise: string,
	actual: any,
	err: JestAssertionError?
): ThrowingMatcherFn
	local function throwingMatcher(...)
		local throws = true
		local utils = Object.assign({
			iterableEquality = iterableEquality,
			subsetEquality = subsetEquality,
			-- ROBLOX deviation: Roblox Instance matchers
			-- instanceSubsetEquality = instanceSubsetEquality
		}, matcherUtils)

		local matcherContext = {
			-- When throws is disabled, the matcher will not throw errors during test
			-- execution but instead add them to the global matcher state. If a
			-- matcher throws, test execution is normally stopped immediately. The
			-- snapshot matcher uses it because we want to log all snapshot
			-- failures in a test.
			dontThrow = function()
				throws = false
			end,
			equals = equals,
			error = err,
			isNot = isNot,
			promise = promise,
			utils = utils,
		}
		Object.assign(matcherContext, getState())

		local function processResult(result: SyncExpectationResult, asyncError: JestAssertionError?)
			_validateResult(result)

			getState().assertionCalls = (getState().assertionCalls :: number) + 1

			if (result.pass and isNot) or (not result.pass and not isNot) then
				-- XOR
				local message = getMessage(result.message)
				local error_

				if err then
					error_ = err
					error_.message = message
				elseif asyncError then
					-- ROBLOX deviation START: Currently async is not implemented
					error("Currently async is not implemented")
					-- ROBLOX deviation END
				else
					error_ = JestAssertionError.new(message)

					--[[
						ROBLOX deviation: skipped code
						original code lines 291 - 295
					]]
				end

				-- Passing the result of the matcher with the error so that a custom
				-- reporter could access the actual and expected objects of the result
				-- for example in order to display a custom visual diff
				error_.matcherResult = Object.assign({}, result, { message = message })

				if throws then
					error(error_)
				else
					table.insert(getState().suppressedErrors, error_)
				end
			end
		end

		local function handleError(error_)
			if
				-- ROBLOX deviation START: adjusted condition
				-- matcher[INTERNAL_MATCHER_FLAG] == true
				-- and not instanceof(error_, JestAssertionError)
				-- and error_.name ~= "PrettyFormatPluginError"
				-- -- Guard for some environments (browsers) that do not support this feature.
				-- and
				Error.captureStackTrace and typeof(error_) == "table"
				-- ROBLOX deviation END
			then
				-- Try to remove this and deeper functions from the stack trace frame.
				Error.captureStackTrace(error_, throwingMatcher)
			end
			error(error_)
		end

		local ok, result = pcall(function(...)
			-- ROBLOX TODO: Implement INTERNAL_MATCHER_FLAG cases
			local potentialResult = matcher(matcherContext, actual, ...)

			local syncResult = potentialResult :: SyncExpectationResult

			processResult(syncResult)
		end, ...)

		if not ok then
			handleError(result)
		end
	end
	return throwingMatcher
end

function _validateResult(result: any)
	if
		typeof(result) ~= "table"
		or typeof(result.pass) ~= "boolean"
		or (result.message and typeof(result.message) ~= "string" and typeof(result.message) ~= "function")
	then
		error(
			"Unexpected return from a matcher function.\n"
				.. "Matcher functions should "
				.. "return an object in the following format:\n"
				.. "  {message?: string | function, pass: boolean}\n"
				.. matcherUtils.stringify(result)
				.. " was returned"
		)
	end
end

local Expect = {} :: Expect

--[[
	ROBLOX FIXME: add extends and default generic param when supported
	original code:
	-- ROBLOX deviation: deduplicate JestMatcherState -> MatcherState
	expect.extend = <T extends MatcherState = MatcherState>(
]]
Expect.extend = function(matchers: MatchersObject): ()
	setMatchers(matchers, false, Expect)
end

Expect.anything = anything
Expect.any = any
Expect.nothing = nothing

-- ROBLOX deviation: not is a reserved keyword in Lua, we use never instead
Expect.never = {
	arrayContaining = arrayNotContaining,
	closeTo = notCloseTo,
	objectContaining = objectNotContaining,
	stringContaining = stringNotContaining,
	stringMatching = stringNotMatching,
	-- ROBLOX deviation: Luau-specific callable object matching
	callable = notCallable,
}

Expect.objectContaining = objectContaining
Expect.arrayContaining = arrayContaining
Expect.closeTo = closeTo
Expect.stringContaining = stringContaining
Expect.stringMatching = stringMatching
-- ROBLOX deviation: Luau-specific callable object matching
Expect.callable = callable

--[[
	ROBLOX deviation: skipped code
	original code lines: 376 - 392
]]

local function assertions(expected: number)
	local error_ = Error.new()
	if Error.captureStackTrace then
		Error.captureStackTrace(error_, assertions)
	end
	setState({ expectedAssertionsNumber = expected, expectedAssertionsNumberError = error_ })
end
local function hasAssertions(...: any)
	local args = { ... }
	local error_ = Error.new()
	if Error.captureStackTrace then
		Error.captureStackTrace(error_, hasAssertions)
	end
	matcherUtils.ensureNoExpected(args[1], ".hasAssertions")
	setState({ isExpectingAssertions = true, isExpectingAssertionsError = error_ })
end

-- add default jest matchers
setMatchers(matchers, true, Expect)
setMatchers(spyMatchers, true, Expect)
setMatchers(toThrowMatchers, true, Expect)

-- ROBLOX deviation START: defining addSnapshotSerializer override here
local plugins = require(Packages.JestSnapshot).plugins
Expect.addSnapshotSerializer = plugins.addSerializer
-- ROBLOX deviation END
Expect.assertions = assertions
Expect.hasAssertions = hasAssertions
Expect.getState = getState
Expect.setState = setState
Expect.extractExpectedAssertionsErrors = extractExpectedAssertionsErrors

-- ROBLOX TODO: ADO-1554 clean up the following deviations and move them to the
-- appropriate locations
-- ROBLOX deviation START: for now we extend the snapshot matchers in the Expect file instead
-- of jest-jasmine2/jestExpect
local JestSnapshot = require(Packages.JestSnapshot)
local toMatchSnapshot = JestSnapshot.toMatchSnapshot
local toThrowErrorMatchingSnapshot = JestSnapshot.toThrowErrorMatchingSnapshot
setMatchers({
	toMatchSnapshot = toMatchSnapshot,
	toThrowErrorMatchingSnapshot = toThrowErrorMatchingSnapshot,
}, false, Expect)
-- ROBLOX deviation END

setmetatable(Expect, { __call = expect_ })
local expectExport = (Expect :: any) :: Expect

return expectExport
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="237">
              <Properties>
                <string name="Name">asymmetricMatchers</string>
                <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/asymmetricMatchers.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local Symbol = LuauPolyfill.Symbol
local instanceof = LuauPolyfill.instanceof

type Array<T> = LuauPolyfill.Array<T>
local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp

local getType = require(Packages.JestGetType).getType

-- ROBLOX TODO: import jest-matcher-utils when available
-- import * as matcherUtils from 'jest-matcher-utils';
local matcherUtils = {} :: any
local pluralize = require(Packages.JestUtil).pluralize
local JasmineUtils = require(CurrentModule.jasmineUtils)
local equals = JasmineUtils.equals
local hasProperty = JasmineUtils.hasProperty
local isA = JasmineUtils.isA
local isUndefined = JasmineUtils.isUndefined

local getState = require(CurrentModule.jestMatchersObject_extracted).getState
local Types = require(CurrentModule.types)
-- ROBLOX TODO: import correct types
type AssymetricMatcherInterface = any
type MatcherState = Types.MatcherState
local Utils = require(CurrentModule.utils)
local iterableEquality = Utils.iterableEquality
local subsetEquality = Utils.subsetEquality
-- local emptyObject = require(CurrentModule.utils).emptyObject

local utils = Object.freeze(Object.assign({}, matcherUtils, {
	iterableEquality = iterableEquality,
	subsetEquality = subsetEquality,
}))

-- ROBLOX deviation START: use old class scheme
-- type AsymmetricMatcher<T> = {
-- 	getMatcherContext: (self: AsymmetricMatcher<T>) -> State_,
-- 	asymmetricMatch: (self: AsymmetricMatcher<T>, other: unknown) -> boolean,
-- 	toString: (self: AsymmetricMatcher<T>) -> string,
-- 	getExpectedType: ((self: AsymmetricMatcher<T>) -> string)?,
-- 	toAsymmetricMatcher: ((self: AsymmetricMatcher<T>) -> string)?,
-- }
-- local AsymmetricMatcher = {}
-- AsymmetricMatcher.__index = AsymmetricMatcher
-- ROBLOX deviation END

export type AsymmetricMatcher<T> = {
	-- ROBLOX deviation START: use '$' characters in typeof
	-- __typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]]: any,
	["$$typeof"]: any,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: add missing generic parameters
	-- asymmetricMatch: (self: AsymmetricMatcher, other: unknown) -> boolean,
	-- toString: (self: AsymmetricMatcher) -> string,
	-- getExpectedType: (self: AsymmetricMatcher) -> string,
	-- toAsymmetricMatcher: (self: AsymmetricMatcher) -> string,
	asymmetricMatch: (self: AsymmetricMatcher<T>, other: unknown) -> boolean,
	toString: (self: AsymmetricMatcher<T>) -> string,
	getExpectedType: (self: AsymmetricMatcher<T>) -> string,
	toAsymmetricMatcher: (self: AsymmetricMatcher<T>) -> string,
	-- ROBLOX deviation END
}
type AsymmetricMatcher_private<T> = { --
	-- *** PUBLIC ***
	--
	-- ROBLOX deviation START: use '$' characters in typeof
	-- __typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]]: any,
	["$$typeof"]: any,
	-- ROBLOX deviation END

	-- ROBLOX deviation START: add missing generic parameters
	-- asymmetricMatch: (self: AsymmetricMatcher_private, other: unknown) -> boolean,
	-- toString: (self: AsymmetricMatcher_private) -> string,
	-- getExpectedType: (self: AsymmetricMatcher_private) -> string,
	-- toAsymmetricMatcher: (self: AsymmetricMatcher_private) -> string,
	asymmetricMatch: (self: AsymmetricMatcher_private<T>, other: unknown) -> boolean,
	toString: (self: AsymmetricMatcher_private<T>) -> string,
	getExpectedType: (self: AsymmetricMatcher_private<T>) -> string,
	toAsymmetricMatcher: (self: AsymmetricMatcher_private<T>) -> string,
	-- ROBLOX deviation END

	--
	-- *** PROTECTED ***
	--
	sample: T,
	inverse: boolean,

	-- ROBLOX deviation START: add missing generic parameters
	-- getMatcherContext: (self: AsymmetricMatcher_private) -> MatcherState,
	getMatcherContext: (self: AsymmetricMatcher_private<T>) -> MatcherState,
	-- ROBLOX deviation END
}
type AsymmetricMatcher_statics = { new: <T>(sample: T, inverse_: boolean?) -> AsymmetricMatcher<T> }
local AsymmetricMatcher = {} :: AsymmetricMatcher<any> & AsymmetricMatcher_statics
local AsymmetricMatcher_private = AsymmetricMatcher :: AsymmetricMatcher_private<any> & AsymmetricMatcher_statics;
(AsymmetricMatcher :: any).__index = AsymmetricMatcher

function AsymmetricMatcher_private.new<T>(sample: T, inverse_: boolean?): AsymmetricMatcher<T>
	-- ROBLOX deviation START: define self differently so typeof can be set
	-- local self = setmetatable({}, AsymmetricMatcher)
	-- ROBLOX deviation END
	local inverse: boolean = if inverse_ ~= nil then inverse_ else false

	-- ROBLOX deviation START: define self differently so typeof can be set
	-- self.sample = sample
	-- self.inverse = inverse
	-- self.__typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]] =
	-- 	Symbol:for_("jest.asymmetricMatcher")
	local self = {
		sample = sample,
		inverse = if inverse == nil then false else inverse,
		["$$typeof"] = Symbol.for_("jest.asymmetricMatcher"),
	}
	setmetatable(self, AsymmetricMatcher)
	-- ROBLOX deviation END

	return (self :: any) :: AsymmetricMatcher<T>
end

function AsymmetricMatcher_private:getMatcherContext(): MatcherState
	return Object.assign({}, getState(), { equals = equals, isNot = self.inverse, utils = utils })
end

-- ROBLOX deviation START: abstract methods that cannot be implemented
-- function AsymmetricMatcher_private:asymmetricMatch(other: unknown): boolean
-- 	error("not implemented abstract method")
-- end
-- function AsymmetricMatcher_private:toString(): string
-- 	error("not implemented abstract method")
-- end
-- function AsymmetricMatcher_private:getExpectedType(): string
-- 	error("not implemented method")
-- end
-- function AsymmetricMatcher_private:toAsymmetricMatcher(): string
-- 	error("not implemented method")
-- end
-- ROBLOX deviation END

-- ROBLOX deviation: our implementation of any has significant deviations, check README for more info
-- > any("number"):asymmetricMatch(1) -- true
-- > any("number"):toAsymmetricMatcher() -- "Any<number>"
-- > any(ClassA):asymmetricMatch(ClassA.new()) -- true
-- > any(ClassA):asymmetricMatch(ClassB.new()) -- false
-- > any(ClassA):asymmetricMatch(DerivedClassA.new()) -- true
local Any = {}
Any.__index = Any
setmetatable(Any, AsymmetricMatcher)
function Any.new(sample: any)
	if typeof(sample) ~= "table" and typeof(sample) ~= "string" then
		error(
			"any() expects to be passed a typename string or a prototype class. "
				.. "Please pass one or use anything() to match any object."
		)
	end
	local self = AsymmetricMatcher.new(sample)
	setmetatable(self, Any)
	return self
end

function Any:asymmetricMatch(other: any): boolean
	-- ROBLOX deviation: simplified since this covers all the cases in Lua
	local selfType = getType(self.sample)
	local otherType = getType(other)
	-- compare metatable to check instance of Lua prototypical class
	if (selfType == "table" and otherType == "table") or (selfType == "error" and otherType == "error") then
		return instanceof(other, self.sample)
		-- check type matches type provided by string
	elseif selfType == "string" and self.sample == otherType then
		return true
	end
	return false
end

function Any:toString(): string
	return "Any"
end

function Any:getExpectedType(): string
	-- ROBLOX deviation: simplified since this already covers all the cases in Lua
	return tostring(self.sample)
end

function Any:toAsymmetricMatcher(): string
	return "Any<" .. tostring(self.sample) .. ">"
end

local Anything = {}
Anything.__index = Anything
setmetatable(Anything, AsymmetricMatcher)
function Anything.new(sample: any)
	local self = AsymmetricMatcher.new(sample)
	setmetatable(self, Anything)
	return self
end

function Anything:asymmetricMatch(other: any): boolean
	-- ROBLOX deviation: other !== null is redundant since Lua doesn't distinguish undefined/nil
	return not isUndefined(other)
end

function Anything:toString(): string
	return "Anything"
end

-- No getExpectedType method, because it matches either null or undefined.

function Anything:toAsymmetricMatcher(): string
	return "Anything"
end

-- ROBLOX deviation START: asymmetric matcher that matches undefined/nil
local Nothing = {}
Nothing.__index = Nothing
setmetatable(Nothing, AsymmetricMatcher)
function Nothing.new(sample: any)
	local self = AsymmetricMatcher.new(sample)
	setmetatable(self, Nothing)
	return self
end

function Nothing:asymmetricMatch(other: any): boolean
	return isUndefined(other)
end

function Nothing:toString(): string
	return "Nothing"
end

function Nothing:getExpectedType(): string
	return "nil"
end

function Nothing:toAsymmetricMatcher(): string
	return "Nothing"
end
-- ROBLOX deviation END

local ArrayContaining = {}
ArrayContaining.__index = ArrayContaining
setmetatable(ArrayContaining, AsymmetricMatcher)
function ArrayContaining.new(sample: { any }, inverse: boolean?)
	inverse = if inverse ~= nil then inverse else false
	local self = AsymmetricMatcher.new(sample, inverse)
	setmetatable(self, ArrayContaining)
	return self
end

function ArrayContaining:asymmetricMatch(other: { any })
	if not Array.isArray(self.sample) then
		error(string.format("You must provide an array to %s, not '%s'.", self:toString(), typeof(self.sample)))
	end

	local result = false
	if #self.sample == 0 then
		result = true
	elseif
		Array.isArray(other)
		and Array.every(self.sample, function(item)
			return Array.some(other, function(another)
				return equals(item, another)
			end)
		end)
	then
		result = true
	end

	if self.inverse then
		return not result
	end
	return result
end

function ArrayContaining:toString(): string
	if self.inverse then
		return "ArrayNotContaining"
	end
	return "ArrayContaining"
end

function ArrayContaining:getExpectedType(): string
	return "array"
end

local ObjectContaining = {}
ObjectContaining.__index = ObjectContaining
setmetatable(ObjectContaining, AsymmetricMatcher)
function ObjectContaining.new(sample: { any }, inverse: boolean?)
	inverse = if inverse ~= nil then inverse else false
	local self = AsymmetricMatcher.new(sample, inverse)
	setmetatable(self, ObjectContaining)
	return self
end

function ObjectContaining:asymmetricMatch(other: { any })
	-- ROBLOX deviation: check for type table instead of object
	if typeof(self.sample) ~= "table" then
		error(string.format("You must provide an object to %s, not '%s'.", self:toString(), typeof(self.sample)))
	end

	local result = true

	for property, value in pairs(self.sample) do
		if not hasProperty(other, property) or not equals(value, other[property]) then
			result = false
			break
		end
	end

	return if self.inverse then not result else result
end

function ObjectContaining:toString(): string
	if self.inverse then
		return "ObjectNotContaining"
	end
	return "ObjectContaining"
end

function ObjectContaining:getExpectedType(): string
	return "object"
end

local StringContaining = {}
StringContaining.__index = StringContaining
setmetatable(StringContaining, AsymmetricMatcher)
function StringContaining.new(sample: string, inverse: boolean?)
	inverse = if inverse ~= nil then inverse else false
	if not isA("string", sample) then
		error("Expected is not a String")
	end
	local self = AsymmetricMatcher.new(sample, inverse)
	setmetatable(self, StringContaining)
	return self
end

function StringContaining:asymmetricMatch(other: string): boolean
	local result = isA("string", other) and other:find(self.sample, 1, true)

	if self.inverse then
		return not result
	end
	return not not result
end

function StringContaining:toString(): string
	if self.inverse then
		return "StringNotContaining"
	end
	return "StringContaining"
end

function StringContaining:getExpectedType(): string
	return "string"
end

local StringMatching = {}
StringMatching.__index = StringMatching
setmetatable(StringMatching, AsymmetricMatcher)
function StringMatching.new(sample: string | RegExp, inverse: boolean?)
	inverse = if inverse ~= nil then inverse else false
	-- ROBLOX deviation: we accept matches against a Lua string pattern or RegExp polyfill
	if not isA("string", sample) and not isA("regexp", sample) then
		error("Expected is not a String")
	end
	local self = AsymmetricMatcher.new(sample, inverse)
	setmetatable(self, StringMatching)
	return self
end

function StringMatching:asymmetricMatch(other: string): boolean
	local result = false
	if isA("string", other) then
		-- Lua pattern case
		if isA("string", self.sample) then
			-- ROBLOX deviation: escape chalk sequences if necessary
			self.sample = string.gsub(self.sample, string.char(27) .. "%[", string.char(27) .. "%%[")
			result = other:find(self.sample)
			-- Regex case
		else
			result = self.sample:test(other)
		end
	end

	if self.inverse then
		return not result
	end
	return not not result
end

function StringMatching:toString(): string
	if self.inverse then
		return "StringNotMatching"
	end
	return "StringMatching"
end

function StringMatching:getExpectedType(): string
	return "string"
end

type CloseTo = AsymmetricMatcher<number> & {
	asymmetricMatch: (self: CloseTo, other: number) -> any,
	toString: (self: CloseTo) -> any,
	getExpectedType: (self: CloseTo) -> any,
	toAsymmetricMatcher: (self: CloseTo) -> string,
}

type CloseTo_private = AsymmetricMatcher<number> & { --
	-- *** PUBLIC ***
	--
	asymmetricMatch: (self: CloseTo_private, other: number) -> any,
	toString: (self: CloseTo_private) -> any,
	getExpectedType: (self: CloseTo_private) -> any,
	toAsymmetricMatcher: (self: CloseTo_private) -> string,
	--
	-- *** PRIVATE ***
	--
	precision: number,
}

type CloseTo_statics = { new: (sample: number, precision_: number?, inverse_: boolean?) -> CloseTo }

local CloseTo = (setmetatable({}, { __index = AsymmetricMatcher }) :: any) :: CloseTo & CloseTo_statics
local CloseTo_private = CloseTo :: CloseTo_private & CloseTo_statics;
(CloseTo :: any).__index = CloseTo

function CloseTo.new(sample: number, precision_: number?, inverse_: boolean?): CloseTo
	local precision: number = if precision_ ~= nil then precision_ else 2
	local inverse: boolean = if inverse_ ~= nil then inverse_ else false
	if not Boolean.toJSBoolean(isA("number", sample)) then
		error(Error.new("Expected is not a Number"))
	end
	if not Boolean.toJSBoolean(isA("number", precision)) then
		error(Error.new("Precision is not a Number"))
	end

	local self = AsymmetricMatcher.new(sample)
	setmetatable(self, CloseTo)
	self.inverse = inverse
	self.precision = precision

	return (self :: any) :: CloseTo
end

function CloseTo_private:asymmetricMatch(other: number)
	if not Boolean.toJSBoolean(isA("number", other)) then
		return false
	end
	local result = false
	if other == math.huge and self.sample == math.huge then
		result = true -- Infinity - Infinity is NaN
	elseif other == -math.huge and self.sample == -math.huge then
		result = true -- -Infinity - -Infinity is NaN
	else
		result = math.abs(self.sample - other) < math.pow(10, -self.precision) / 2 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
	end
	return if Boolean.toJSBoolean(self.inverse) then not Boolean.toJSBoolean(result) else result
end

function CloseTo_private:toString()
	return ("Number%sCloseTo"):format(if Boolean.toJSBoolean(self.inverse) then "Not" else "")
end

function CloseTo_private:getExpectedType()
	return "number"
end

function CloseTo_private:toAsymmetricMatcher(): string
	return Array.join({
		self:toString(),
		self.sample,
		("(%s)"):format(tostring(pluralize("digit", self.precision))),
	}, " ")
end

-- ROBLOX deviation START: Luau-specific callable object matching
local Callable = {}
Callable.__index = Callable
setmetatable(Callable, AsymmetricMatcher)
function Callable.new(inverse: boolean?)
	local self = AsymmetricMatcher.new(nil, inverse)
	setmetatable(self, Callable)
	return self
end

function Callable:asymmetricMatch(other: any): boolean
	local result
	if typeof(other) == "function" then
		result = true
	elseif typeof(other) == "table" or typeof(other) == "userdata" then
		-- ROBLOX TODO: this won't work if __metatable is defined to be
		-- something other than the object's metatable. Not sure that it's
		-- possible to check an object is callable any other way though, not
		-- without trying to call it and seeing if it fails, which could have
		-- observable side effects...
		local metatable = getmetatable(other)
		result = typeof(metatable) == "table" and typeof(metatable.__call) == "function"
	else
		result = false
	end
	return if self.inverse then not result else result
end

function Callable:toString(): string
	return (if self.inverse then "Not " else "") .. "Callable"
end

function Callable:getExpectedType(): string
	return "function"
end

function Callable:toAsymmetricMatcher(): string
	return self:toString()
end
-- ROBLOX deviation END

return {
	AsymmetricMatcher = AsymmetricMatcher,
	any = function(expectedObject: any)
		return Any.new(expectedObject)
	end,
	anything = function()
		return Anything.new()
	end,
	nothing = function()
		return Nothing.new()
	end,
	arrayContaining = function(sample: { any })
		return ArrayContaining.new(sample)
	end,
	arrayNotContaining = function(sample: { any })
		return ArrayContaining.new(sample, true)
	end,
	objectContaining = function(sample: any)
		return ObjectContaining.new(sample)
	end,
	objectNotContaining = function(sample: any)
		return ObjectContaining.new(sample, true)
	end,
	stringContaining = function(expected: string)
		return StringContaining.new(expected)
	end,
	stringNotContaining = function(expected: string)
		return StringContaining.new(expected, true)
	end,
	stringMatching = function(expected: string | RegExp)
		return StringMatching.new(expected)
	end,
	stringNotMatching = function(expected: string | RegExp)
		return StringMatching.new(expected, true)
	end,
	closeTo = function(expected: number, precision: number?): CloseTo
		return CloseTo.new(expected, precision)
	end,
	notCloseTo = function(expected: number, precision: number?): CloseTo
		return CloseTo.new(expected, precision, true)
	end,
	-- ROBLOX deviation START: Luau-specific callable object matching
	callable = function()
		return Callable.new()
	end,
	notCallable = function()
		return Callable.new(true)
	end,
	-- ROBLOX deviation END
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="238">
              <Properties>
                <string name="Name">extractExpectedAssertionsErrors</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/extractExpectedAssertionsErrors.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local exports = {}
local jest_matcher_utilsModule = require(Packages.JestMatcherUtils)
local EXPECTED_COLOR = jest_matcher_utilsModule.EXPECTED_COLOR
local RECEIVED_COLOR = jest_matcher_utilsModule.RECEIVED_COLOR
local matcherHint = jest_matcher_utilsModule.matcherHint
local pluralize = jest_matcher_utilsModule.pluralize
local jestMatchersObjectModule = require(script.Parent.jestMatchersObject)
local getState = jestMatchersObjectModule.getState
local setState = jestMatchersObjectModule.setState
local typesModule = require(script.Parent.types)
type Expect = typesModule.Expect
type ExpectedAssertionsErrors = typesModule.ExpectedAssertionsErrors
local function resetAssertionsLocalState()
	-- ROBLOX deviation START: Using Object.None instead of nil to actually clear the expect assertions number
	setState({ assertionCalls = 0, expectedAssertionsNumber = Object.None, isExpectingAssertions = false })
	-- ROBLOX deviation END
end
-- Create and format all errors related to the mismatched number of `expect`
-- calls and reset the matcher's state.
local extractExpectedAssertionsErrors: typeof((({} :: any) :: Expect).extractExpectedAssertionsErrors)
function extractExpectedAssertionsErrors()
	local result: ExpectedAssertionsErrors = {}
	local assertionCalls, expectedAssertionsNumber, expectedAssertionsNumberError, isExpectingAssertions, isExpectingAssertionsError
	do
		local ref = getState()
		assertionCalls, expectedAssertionsNumber, expectedAssertionsNumberError, isExpectingAssertions, isExpectingAssertionsError =
			ref.assertionCalls,
			ref.expectedAssertionsNumber,
			ref.expectedAssertionsNumberError,
			ref.isExpectingAssertions,
			ref.isExpectingAssertionsError
	end
	resetAssertionsLocalState()
	if typeof(expectedAssertionsNumber) == "number" and assertionCalls ~= expectedAssertionsNumber then
		local numOfAssertionsExpected = EXPECTED_COLOR(pluralize("assertion", expectedAssertionsNumber));
		(expectedAssertionsNumberError :: any).message = (
			matcherHint(".assertions", "", tostring(expectedAssertionsNumber), { isDirectExpectCall = true })
		)
			.. "\n\n"
			.. ("Expected %s to be called but received "):format(tostring(numOfAssertionsExpected))
			.. tostring(
				RECEIVED_COLOR(pluralize("assertion call", Boolean.toJSBoolean(assertionCalls) and assertionCalls or 0))
			)
			.. "."
		-- ROBLOX deviation START: add call to Error.__recalculateStacktrace until Error polyfill calculates the stacktrace on first access to the property
		if typeof(Error.__recalculateStacktrace) == "function" then
			Error.__recalculateStacktrace(expectedAssertionsNumberError)
		end
		-- ROBLOX deviation END
		table.insert(result, {
			actual = tostring(assertionCalls),
			error = expectedAssertionsNumberError :: any,
			expected = tostring(expectedAssertionsNumber),
		})
	end
	if isExpectingAssertions and assertionCalls == 0 then
		local expected = EXPECTED_COLOR("at least one assertion")
		local received = RECEIVED_COLOR("received none");
		(isExpectingAssertionsError :: any).message = tostring(
			matcherHint(".hasAssertions", "", "", { isDirectExpectCall = true })
		) .. "\n\n" .. ("Expected %s to be called but %s."):format(tostring(expected), tostring(received))
		-- ROBLOX deviation START: add call to Error.__recalculateStacktrace until Error polyfill calculates the stacktrace on first access to the property
		if typeof(Error.__recalculateStacktrace) == "function" then
			Error.__recalculateStacktrace(isExpectingAssertionsError)
		end
		-- ROBLOX deviation END
		table.insert(result, {
			actual = "none",
			error = isExpectingAssertionsError :: any,
			expected = "at least one",
		})
	end
	return result
end
exports.default = extractExpectedAssertionsErrors
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="239">
              <Properties>
                <string name="Name">jasmineUtils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/jasmineUtils.ts
-- /*
-- Copyright (c) 2008-2016 Pivotal Labs
-- Permission is hereby granted, free of charge, to any person obtaining
-- a copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so, subject to
-- the following conditions:
-- The above copyright notice and this permission notice shall be
-- included in all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-- OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-- WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-- */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local RobloxShared = require(Packages.RobloxShared)

local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX deviation: Tester type defined in file since type imports are not yet
-- supported
-- making Tester return type 'any' due to error with type narrowing (CLI-37948)

-- Extracted out of jasmine 2.5.2

type Tester = (any, any) -> any

local equals = RobloxShared.expect.equals

-- ROBLOX deviation: omitted functionToString since we don't use it

-- ROBLOX deviation: moved to RobloxShared to avoid reaching into internals with rotriever workspaces
-- local isAsymmetric = RobloxShared.expect.isAsymmetric
-- local asymmetricMatch = RobloxShared.expect.asymmetricMatch
-- local eq = RobloxShared.expect.eq
-- local keys = RobloxShared.expect.keys

-- ROBLOX deviation: we have no concept of undefined so hasDefinedKey is the same as hasKey
-- local hasDefinedKey = RobloxShared.expect.hasDefinedKey
-- local hasKey = RobloxShared.expect.hasKey
local isA = RobloxShared.expect.isA

-- DOM code omitted for now but translated below:
--[[
	function isDomNode(obj: any): boolean
	return obj ~= nil and
		typeof(obj) == "table" and
		typeof(obj.nodeType) == "number" and
		typeof(obj.nodeName) == "string" and
		typeof(obj.isEqualNode) == "function"
	end
--]]

-- ROBLOX deviation: Function annotation for func omitted
local function fnNameFor(func)
	-- Upstream code omitted for now but translated below:
	--[[
		if func.name then
			return func.name
		end
	]]

	-- ROBLOX TODO: (ADO-1258) Return more advanced function information, if
	-- possible, by using traceback
	return "[Function]"
end

local function isUndefined(obj: any)
	return obj == nil
end

local function getPrototype(obj)
	if getmetatable(obj) ~= nil then
		return getmetatable(obj).__index
	end

	return nil
end

local function hasProperty(obj: any, property: string): boolean
	if not obj then
		return false
	end

	local ok, result = pcall(function()
		return obj[property]
	end)

	if ok then
		return result ~= nil
	else
		error(result)
	end
end

return {
	equals = equals,
	isA = isA,
	fnNameFor = fnNameFor,
	isUndefined = isUndefined,
	getPrototype = getPrototype,
	hasProperty = hasProperty,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="240">
              <Properties>
                <string name="Name">jestMatchersObject</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/jestMatchersObject.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */
local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol
local Object = LuauPolyfill.Object
local Error = LuauPolyfill.Error
type Partial<T> = any

local getType = require(Packages.JestGetType).getType
local AsymmetricMatcher = require(CurrentModule.asymmetricMatchers).AsymmetricMatcher

local Types = require(CurrentModule.types)
type Expect = Types.Expect
type MatcherState = Types.MatcherState
type MatchersObject = Types.MatchersObject

local jestMatchersObject_extracted = require(CurrentModule.jestMatchersObject_extracted)
-- Global matchers object holds the list of available matchers and
-- the state, that can hold matcher specific values that change over time.
-- ROBLOX deviation: extracted JEST_MATCHERS_OBJECT to jestMatchersObject_extracted to avoid circular dependency
local JEST_MATCHERS_OBJECT = jestMatchersObject_extracted.JEST_MATCHERS_OBJECT

-- Notes a built-in/internal Jest matcher.
-- Jest may override the stack trace of Errors thrown by internal matchers.
local INTERNAL_MATCHER_FLAG = Symbol.for_("$$jest-internal-matcher")

-- ROBLOX deviation START: add type alias to reduce deviations
local TypeError = Error
-- ROBLOX deviation END

if not _G[JEST_MATCHERS_OBJECT] then
	local defaultState = {
		assertionCalls = 0,
		expectedAssertionsNumber = nil, -- doesn't have significance in Lua but kept for translation
		isExpectingAssertions = false,
		suppressedErrors = {},
	}

	_G[JEST_MATCHERS_OBJECT] = {
		matchers = {},
		state = defaultState,
	}
end

-- ROBLOX deviation: extracted getState to jestMatchersObject_extracted to avoid circular dependency
local getState = jestMatchersObject_extracted.getState

--[[
	ROBLOX TODO: add default generic param when possible
	original code:
	export const setState = <State extends MatcherState = MatcherState>(
]]
local function setState<State>(state: Partial<State>): ()
	Object.assign(_G[JEST_MATCHERS_OBJECT].state, state)
end

--[[
	ROBLOX TODO: add default generic param when possible
	original code:
	export const getMatchers = <
	  State extends MatcherState = MatcherState,
	>(): MatchersObject<State> => (global as any)[JEST_MATCHERS_OBJECT].matchers;
]]
local function getMatchers(): MatchersObject
	return _G[JEST_MATCHERS_OBJECT].matchers
end

-- ROBLOX deviation: matchers does not have MatchersObject type annotation and expect
-- does not have Expect type annotation
--[[
	ROBLOX TODO: add default generic param when possible
	original code:
	export const setMatchers = <State extends MatcherState = MatcherState>(
]]
local function setMatchers(matchers: MatchersObject, isInternal: boolean, expect: Expect): ()
	for key, matcher in pairs(matchers) do
		-- ROBLOX TODO: assign INTERNAL_MATCHER_FLAG to matchers
		if not isInternal then
			if typeof(matcher) ~= "function" then
				error(
					TypeError.new(
						('expect.extend: `%s` is not a valid matcher. Must be a function, is "%s"'):format(
							tostring(key),
							tostring(getType(matcher))
						)
					)
				)
			end

			local CustomMatcher = {}
			CustomMatcher.__index = CustomMatcher
			setmetatable(CustomMatcher, AsymmetricMatcher)

			CustomMatcher.new = function(inverse: boolean?, ...)
				inverse = if inverse ~= nil then inverse else false
				local self = AsymmetricMatcher.new({ ... }, inverse)
				setmetatable(self, CustomMatcher)
				return self
			end

			CustomMatcher.asymmetricMatch = function(self, other: any)
				local pass = matcher(self:getMatcherContext(), other, unpack(self.sample)).pass

				return if self.inverse then not pass else pass
			end

			CustomMatcher.toString = function(self)
				if self.inverse then
					return string.format("never.%s", key)
				end
				return tostring(key)
			end

			CustomMatcher.getExpectedType = function(self)
				return "any"
			end

			CustomMatcher.toAsymmetricMatcher = function(self)
				local sample = self.sample
				local i = 1
				local printval = ""
				while i < #sample do
					printval = printval .. tostring(sample[i]) .. ", "
					i += 1
				end
				printval = printval .. tostring(sample[i])
				return string.format("%s<%s>", self:toString(), printval)
			end;

			-- ROBLOX deviation start: there is not Object.defineProperty equivalent in Lua
			(expect :: any)[key] = function(...)
				return CustomMatcher.new(false, ...)
			end
			if not expect.never then
				expect.never = {} :: any
			end
			expect.never[key] = function(...)
				return CustomMatcher.new(true, ...)
			end
			-- ROBLOX deviation end
		end
	end

	Object.assign(_G[JEST_MATCHERS_OBJECT].matchers, matchers)
end

return {
	INTERNAL_MATCHER_FLAG = INTERNAL_MATCHER_FLAG,
	getState = getState,
	setState = setState,
	getMatchers = getMatchers,
	setMatchers = setMatchers,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="241">
              <Properties>
                <string name="Name">jestMatchersObject_extracted</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/jestMatchersObject.ts
-- ROBLOX NOTE: extracted from jestMatchersObject.lua to avoid circular dependencies
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol

local Types = require(CurrentModule.types)
type MatcherState = Types.MatcherState

-- Global matchers object holds the list of available matchers and
-- the state, that can hold matcher specific values that change over time.
local JEST_MATCHERS_OBJECT = Symbol.for_("$$jest-matchers-object")

--[[
	ROBLOX TODO: add default generic param when possible
	original code:
	export const getState = <State extends MatcherState = MatcherState>(): State =>
]]
local function getState<State>(): State
	return _G[JEST_MATCHERS_OBJECT].state
end

return {
	JEST_MATCHERS_OBJECT = JEST_MATCHERS_OBJECT,
	getState = getState,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="242">
              <Properties>
                <string name="Name">matchers</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/matchers.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Number = LuauPolyfill.Number
local Object = LuauPolyfill.Object
local instanceof = LuauPolyfill.instanceof

local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp

local JestGetType = require(Packages.JestGetType)
local getType = JestGetType.getType
local isPrimitive = JestGetType.isPrimitive

local JestMatcherUtils = require(Packages.JestMatcherUtils)
local DIM_COLOR = JestMatcherUtils.DIM_COLOR
local EXPECTED_COLOR = JestMatcherUtils.EXPECTED_COLOR
type MatcherHintOptions = JestMatcherUtils.MatcherHintOptions
local RECEIVED_COLOR = JestMatcherUtils.RECEIVED_COLOR
local SUGGEST_TO_CONTAIN_EQUAL = JestMatcherUtils.SUGGEST_TO_CONTAIN_EQUAL
local ensureExpectedIsNonNegativeInteger = JestMatcherUtils.ensureExpectedIsNonNegativeInteger
local ensureNoExpected = JestMatcherUtils.ensureNoExpected
local ensureNumbers = JestMatcherUtils.ensureNumbers
local getLabelPrinter = JestMatcherUtils.getLabelPrinter
local matcherErrorMessage = JestMatcherUtils.matcherErrorMessage
local matcherHint = JestMatcherUtils.matcherHint
local printDiffOrStringify = JestMatcherUtils.printDiffOrStringify
local printExpected = JestMatcherUtils.printExpected
local printReceived = JestMatcherUtils.printReceived
local printWithType = JestMatcherUtils.printWithType
local stringify = JestMatcherUtils.stringify

local equals = require(CurrentModule.jasmineUtils).equals

local Print = require(CurrentModule.print)
local printCloseTo = Print.printCloseTo
local printExpectedConstructorName = Print.printExpectedConstructorName
local printExpectedConstructorNameNot = Print.printExpectedConstructorNameNot
local printReceivedArrayContainExpectedItem = Print.printReceivedArrayContainExpectedItem
local printReceivedConstructorName = Print.printReceivedConstructorName
local printReceivedConstructorNameNot = Print.printReceivedConstructorNameNot
local printReceivedStringContainExpectedResult = Print.printReceivedStringContainExpectedResult
local printReceivedStringContainExpectedSubstring = Print.printReceivedStringContainExpectedSubstring

local Types = require(CurrentModule.types)
type MatcherState = Types.MatcherState
type MatchersObject = Types.MatchersObject

local Utils = require(CurrentModule.utils)
-- ROBLOX deviation: skipped as Lua doesn't support ArrayBuffer
-- local arrayBufferEquality = Utils.arrayBufferEquality
local getObjectSubset = Utils.getObjectSubset
local getPath = Utils.getPath
local iterableEquality = Utils.iterableEquality
local pathAsArray = Utils.pathAsArray
-- ROBLOX deviation: omitted imports for sparseArrayEquality
local subsetEquality = Utils.subsetEquality
local typeEquality = Utils.typeEquality

-- ROBLOX deviation: Roblox Instance matchers
local RobloxShared = require(Packages.RobloxShared)
local instanceSubsetEquality = RobloxShared.RobloxInstance.instanceSubsetEquality
local getInstanceSubset = RobloxShared.RobloxInstance.getInstanceSubset

-- Omit colon and one or more spaces, so can call getLabelPrinter.
local EXPECTED_LABEL = "Expected"
local RECEIVED_LABEL = "Received"
local EXPECTED_VALUE_LABEL = "Expected value"
local RECEIVED_VALUE_LABEL = "Received value"

-- The optional property of matcher context is true if undefined.
-- ROBLOX deviation: upstream injects expand: false by default so we actually set to true if undefined
local function isExpand(expand: boolean?): boolean
	return not not expand
end

-- ROBLOX deviation: don't need any of the strict equality testers since we don't have added constraints for
-- strict equality in Lua compared to deep equality
local toStrictEqualTesters = {
	-- 	iterableEquality,
	typeEquality,
	-- 	sparseArrayEquality,
	--  arrayBufferEquality,
}
-- ROBLOX deviation: we can't handle iterable with a type constraint in the same way
-- type ContainIterable =
--   | Array<unknown>
--   | Set<unknown>
--   | NodeListOf<Node>
--   | DOMTokenList
--   | HTMLCollectionOf<any>;

-- ROBLOX deviation: upstream defines matchers as a single monolithic object but we split it up for readability
local function toBe(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toBe"
	local options: MatcherHintOptions = {
		comment = "Object.is equality",
		isNot = self.isNot,
		promise = self.promise,
	}

	local pass = Object.is(received, expected)

	local message
	if pass then
		message = function()
			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: never %s", printExpected(expected))
		end
	else
		message = function()
			local deepEqualityName = nil
			-- ROBLOX deviation: no map or set types for now so this check is always true so we omit it
			-- if expectedType ~= 'map' and expectedType ~= 'set' then
			-- If deep equality passes when referential identity fails,
			-- but exclude map and set until review of their equality logic.
			-- ROBLOX deviation: no strict equality in lua
			if equals(received, expected, { iterableEquality }) then
				deepEqualityName = "toEqual"
			end
			-- end

			local retval = matcherHint(matcherName, nil, nil, options) .. "\n\n"
			if deepEqualityName ~= nil then
				retval = retval
					.. DIM_COLOR(
						string.format(
							'If it should pass with deep equality, replace "%s" with "%s"',
							matcherName,
							deepEqualityName
						)
					)
					.. "\n\n"
			end
			return retval
				.. printDiffOrStringify(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(self.expand))
		end
	end

	-- Passing the actual and expected objects so that a custom reporter
	-- could access them, for example in order to display a custom visual diff,
	-- or create a different error message
	return { actual = received, expected = expected, message = message, name = matcherName, pass = pass }
end

local function toBeCloseTo(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: number,
	expected: number,
	precision: number
)
	-- ROBLOX deviation: instead of getting argument count, just see if last arg is nil
	local secondArgument
	if precision then
		secondArgument = "precision"
	else
		precision = 2
	end
	local matcherName = "toBeCloseTo"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
		secondArgument = secondArgument,
		secondArgumentColor = function(arg: string)
			return arg
		end,
	}

	if typeof(expected) ~= "number" then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a number", EXPECTED_COLOR("expected")),
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end

	if typeof(received) ~= "number" then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a number", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	local pass = false
	local expectedDiff = 0
	local receivedDiff = 0

	if received == math.huge and expected == math.huge then
		pass = true -- Infinity - Infinity is NaN
	elseif received == -math.huge and expected == -math.huge then
		pass = true -- -Infinity - -Infinity is NaN
	else
		expectedDiff = (10 ^ -precision) / 2
		receivedDiff = math.abs(expected - received)
		pass = receivedDiff < expectedDiff
	end

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: never %s\n", printExpected(expected))
			if receivedDiff == 0 then
				return retval
			end
			return retval
				.. string.format("Received:       %s\n", printReceived(received))
				.. "\n"
				.. printCloseTo(receivedDiff, expectedDiff, precision, isNot)
		end
	else
		message = function()
			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: %s\n", printExpected(expected))
				.. string.format("Received: %s\n", printReceived(received))
				.. "\n"
				.. printCloseTo(receivedDiff, expectedDiff, precision, isNot)
		end
	end

	return { message = message, pass = pass }
end

-- ROBLOX deviation: toBeDefined equivalent to never.toBeNil
local function toBeDefined(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: nil
)
	local matcherName = "toBeDefined"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}
	ensureNoExpected(expected, matcherName, options)

	local pass = received ~= nil

	local message = function()
		return matcherHint(matcherName, nil, "", options)
			.. "\n\n"
			.. string.format("Received: %s", printReceived(received))
	end

	return { message = message, pass = pass }
end

-- ROBLOX deviation: toBeFalsy checks for Lua falsy values, not JS falsy values
local function toBeFalsy(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: nil
)
	local matcherName = "toBeFalsy"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}
	ensureNoExpected(expected, matcherName, options)

	local pass = not received

	local message = function()
		return matcherHint(matcherName, nil, "", options)
			.. "\n\n"
			.. string.format("Received: %s", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toBeGreaterThan(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: number,
	expected: number
)
	local matcherName = "toBeGreaterThan"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
	}
	ensureNumbers(received, expected, matcherName, options)

	local pass = received > expected

	local message = function()
		return matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("Expected:%s > %s\n", isNot and " never" or "", printExpected(expected))
			.. string.format("Received:%s   %s", isNot and "      " or "", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toBeGreaterThanOrEqual(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: number,
	expected: number
)
	local matcherName = "toBeGreaterThanOrEqual"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
	}
	ensureNumbers(received, expected, matcherName, options)

	local pass = received >= expected

	local message = function()
		return matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("Expected:%s >= %s\n", isNot and " never" or "", printExpected(expected))
			.. string.format("Received:%s    %s", isNot and "      " or "", printReceived(received))
	end

	return { message = message, pass = pass }
end

-- ROBLOX deviation: toBeInstanceOf checks for Lua prototypical classes, major deviation from upstream
local function toBeInstanceOf(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toBeInstanceOf"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
	}

	if typeof(expected) ~= "table" then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a prototype class", EXPECTED_COLOR("expected")),
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end

	local pass = instanceof(received, expected)
	local receivedPrototype = nil
	if typeof(getmetatable(received)) == "table" and typeof(getmetatable(received).__index) == "table" then
		receivedPrototype = getmetatable(received).__index
	end

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printExpectedConstructorNameNot("Expected constructor", expected)

			if receivedPrototype and receivedPrototype ~= expected then
				retval = retval .. printReceivedConstructorNameNot("Received constructor", receivedPrototype, expected)
			end

			return retval
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printExpectedConstructorName("Expected constructor", expected)
			if isPrimitive(received) or receivedPrototype == nil then
				retval = retval
					.. string.format("\nReceived value has no prototype\nReceived value: %s", printReceived(received))
			else
				retval = retval .. printReceivedConstructorName("Received constructor", receivedPrototype)
			end

			return retval
		end
	end

	return { message = message, pass = pass }
end

local function toBeLessThan(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: number,
	expected: number
)
	local matcherName = "toBeLessThan"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
	}
	ensureNumbers(received, expected, matcherName, options)

	local pass = received < expected

	local message = function()
		return matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("Expected:%s < %s\n", isNot and " never" or "", printExpected(expected))
			.. string.format("Received:%s   %s", isNot and "      " or "", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toBeLessThanOrEqual(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: number,
	expected: number
)
	local matcherName = "toBeLessThanOrEqual"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
	}
	ensureNumbers(received, expected, matcherName, options)

	local pass = received <= expected

	local message = function()
		return matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("Expected:%s <= %s\n", isNot and " never" or "", printExpected(expected))
			.. string.format("Received:%s    %s", isNot and "      " or "", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toBeNan(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: nil
)
	local matcherName = "toBeNan"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}
	ensureNoExpected(expected, matcherName, options)

	local pass = Number.isNaN(received)

	local message = function()
		return matcherHint(matcherName, nil, "", options)
			.. "\n\n"
			.. string.format("Received: %s", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toBeNil(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: nil
)
	local matcherName = "toBeNil"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}
	ensureNoExpected(expected, matcherName, options)

	local pass = received == nil

	local message = function()
		return matcherHint(matcherName, nil, "", options)
			.. "\n\n"
			.. string.format("Received: %s", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toBeTruthy(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: nil
)
	local matcherName = "toBeTruthy"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}
	ensureNoExpected(expected, matcherName, options)

	local pass = not not received

	local message = function()
		return matcherHint(matcherName, nil, "", options)
			.. "\n\n"
			.. string.format("Received: %s", printReceived(received))
	end

	return { message = message, pass = pass }
end

-- ROBLOX deviation: toBeUndefined equivalent to toBeNil
local function toBeUndefined(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: nil
)
	local matcherName = "toBeUndefined"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}
	ensureNoExpected(expected, matcherName, options)

	local pass = received == nil

	local message = function()
		return matcherHint(matcherName, nil, "", options)
			.. "\n\n"
			.. string.format("Received: %s", printReceived(received))
	end

	return { message = message, pass = pass }
end

local function toContain(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toContain"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		comment = "string.find or table.find",
		isNot = isNot,
		promise = self.promise,
	}

	if received == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must not be nil", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	if typeof(received) == "string" then
		local wrongTypeErrorMessage = ("%s value must be a string if %s value is a string"):format(
			EXPECTED_COLOR("expected"),
			RECEIVED_COLOR("received")
		)
		if typeof(expected) ~= "string" then
			error(
				Error.new(
					matcherErrorMessage(
						matcherHint(matcherName, received, tostring(expected), options),
						wrongTypeErrorMessage,
						tostring(printWithType("Expected", expected, printExpected))
							.. "\n"
							.. tostring(printWithType("Received", received, printReceived))
					)
				)
			)
		end

		local index = received:find(tostring(expected), 1, true)
		local pass = index ~= nil

		local message = function()
			local labelExpected = string.format("Expected %s", typeof(expected) == "string" and "substring" or "value")
			local labelReceived = "Received string"
			local printLabel = getLabelPrinter(labelExpected, labelReceived)

			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format(
					"%s%s%s\n",
					printLabel(labelExpected),
					isNot and "never " or "",
					printExpected(expected)
				)
				.. string.format(
					"%s%s%s",
					printLabel(labelReceived),
					isNot and "      " or "",
					isNot
							and printReceivedStringContainExpectedSubstring(
								received,
								index :: number,
								#tostring(expected)
							)
						or printReceived(received)
				)
		end

		return { message = message, pass = pass }
	end

	local indexable = Array.from(received)
	local index = table.find(indexable, expected)
	local pass = index ~= nil

	local message = function()
		local labelExpected = "Expected value"
		local labelReceived = string.format("Received %s", getType(received))
		local printLabel = getLabelPrinter(labelExpected, labelReceived)

		local retval = matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("%s%s%s\n", printLabel(labelExpected), isNot and "never " or "", printExpected(expected))
			.. string.format("%s%s", printLabel(labelReceived), isNot and "      " or "")
		if isNot and Array.isArray(received) then
			retval = retval .. printReceivedArrayContainExpectedItem(received, index :: number)
		else
			retval = retval .. printReceived(received)
		end
		if
			not isNot
			and Array.findIndex(received, function(item)
					return equals(item, expected, { iterableEquality })
				end)
				~= -1
		then
			retval = retval .. string.format("\n\n%s", SUGGEST_TO_CONTAIN_EQUAL)
		end

		return retval
	end

	return { message = message, pass = pass }
end

local function toContainEqual(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toContainEqual"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		comment = "deep equality",
		isNot = isNot,
		promise = self.promise,
	}

	if received == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must not be nil", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	local index = Array.findIndex(Array.from(received), function(item)
		return equals(item, expected, { iterableEquality })
	end)
	local pass = index ~= -1

	local message = function()
		local labelExpected = "Expected value"
		local labelReceived = string.format("Received %s", getType(received))
		local printLabel = getLabelPrinter(labelExpected, labelReceived)

		local retval = matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("%s%s%s\n", printLabel(labelExpected), isNot and "never " or "", printExpected(expected))
			.. string.format("%s%s", printLabel(labelReceived), isNot and "      " or "")
		if isNot and Array.isArray(received) then
			retval = retval .. printReceivedArrayContainExpectedItem(received, index)
		else
			retval = retval .. printReceived(received)
		end

		return retval
	end

	return { message = message, pass = pass }
end

local function toEqual(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toEqual"
	local options: MatcherHintOptions = {
		comment = "deep equality",
		isNot = self.isNot,
		promise = self.promise,
	}

	local pass = equals(received, expected, { iterableEquality })

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: never %s\n", printExpected(expected))
			if stringify(expected) ~= stringify(received) then
				retval = retval .. string.format("Received:       %s", printReceived(received))
			end
			return retval
		end
	else
		message = function()
			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printDiffOrStringify(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(self.expand))
		end
	end

	-- Passing the actual and expected objects so that a custom reporter
	-- could access them, for example in order to display a custom visual diff,
	-- or create a different error message
	return { actual = received, expected = expected, message = message, name = matcherName, pass = pass }
end

local function toHaveLength(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: number
)
	local matcherName = "toHaveLength"
	local isNot = self.isNot
	local options: MatcherHintOptions = {
		isNot = isNot,
		promise = self.promise,
	}

	-- ROBLOX deviation: only strings and array-like tables have a well defined built in length in Lua
	-- we also allow for objects that have a length property
	local hasLengthProperty = typeof(received) == "table" and typeof(received.length) == "number"
	if not Array.isArray(received) and typeof(received) ~= "string" and not hasLengthProperty then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format(
						"%s value must have a length property whose value must be a number",
						RECEIVED_COLOR("received")
					),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	ensureExpectedIsNonNegativeInteger(expected, matcherName, options)

	local pass
	local receivedLength
	if received.length ~= nil then
		receivedLength = received.length
		pass = receivedLength == expected
	else
		receivedLength = #received
		pass = receivedLength == expected
	end

	local message = function()
		local labelExpected = "Expected length"
		local labelReceivedLength = "Received length"
		local labelReceivedValue = string.format("Received %s", getType(received))
		local printLabel = getLabelPrinter(labelExpected, labelReceivedLength, labelReceivedValue)

		local retval = matcherHint(matcherName, nil, nil, options)
			.. "\n\n"
			.. string.format("%s%s%s\n", printLabel(labelExpected), isNot and "never " or "", printExpected(expected))
		if not isNot then
			retval = retval .. string.format("%s%s\n", printLabel(labelReceivedLength), printReceived(receivedLength))
		end

		return retval
			.. string.format(
				"%s%s%s",
				printLabel(labelReceivedValue),
				isNot and "      " or "",
				printReceived(received)
			)
	end

	return { message = message, pass = pass }
end

local function toHaveProperty(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expectedPath: any,
	expectedValue: any?
)
	local matcherName = "toHaveProperty"
	local expectedArgument = "path"
	local hasValue = expectedValue ~= nil
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
		secondArgument = hasValue and "value" or "",
	}

	if received == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, expectedArgument, options),
					string.format("%s value must not be nil", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	local expectedPathType = getType(expectedPath)

	if expectedPathType ~= "string" and expectedPathType ~= "table" then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, expectedArgument, options),
					string.format("%s path must be a string or array", EXPECTED_COLOR("expected")),
					printWithType("Expected", expectedPath, printExpected)
				)
			)
		)
	end

	local expectedPathLength
	if typeof(expectedPath) == "string" then
		expectedPathLength = #pathAsArray(expectedPath)
	else
		expectedPathLength = #expectedPath
	end

	if expectedPathType == "table" and expectedPathLength == 0 then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, expectedArgument, options),
					string.format("%s path must not be an empty array", EXPECTED_COLOR("expected")),
					printWithType("Expected", expectedPath, printExpected)
				)
			)
		)
	end

	local result = getPath(received, expectedPath)
	local lastTraversedObject = result.lastTraversedObject
	local hasEndProp = result.hasEndProp
	local receivedPath = result.traversedPath
	local hasCompletePath = #receivedPath == expectedPathLength

	local receivedValue
	if hasCompletePath then
		receivedValue = result.value
	else
		receivedValue = lastTraversedObject
	end

	local pass
	if hasValue then
		pass = equals(result.value, expectedValue, { iterableEquality })
	else
		pass = not not hasEndProp -- theoretically undefined if empty path
	end
	-- Remove type cast if we rewrite getPath as iterative algorithm.

	-- ROBLOX deviation: omit code block for dealing with upstream edge case with undefined expectedValues

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, expectedArgument, options) .. "\n\n"
			if hasValue then
				retval = retval
					.. string.format("Expected path: %s\n\n", printExpected(expectedPath))
					.. string.format("Expected value: never %s", printExpected(expectedValue))
				if stringify(expectedValue) ~= stringify(receivedValue) then
					return retval .. string.format("\nReceived value:       %s", printReceived(receivedValue))
				end
				return retval
			else
				return retval
					.. string.format("Expected path: never %s\n\n", printExpected(expectedPath))
					.. string.format("Received value: %s", printReceived(receivedValue))
			end
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, expectedArgument, options)
				.. "\n\n"
				.. string.format("Expected path: %s\n", printExpected(expectedPath))
			if hasCompletePath then
				return retval
					.. "\n"
					.. printDiffOrStringify(
						expectedValue,
						receivedValue,
						EXPECTED_VALUE_LABEL,
						RECEIVED_VALUE_LABEL,
						isExpand(self.expand)
					)
			end
			retval = retval .. "Received path: "

			if expectedPathType == "table" or #receivedPath == 0 then
				retval = retval .. string.format("%s\n\n", printReceived(receivedPath))
			else
				retval = retval .. string.format("%s\n\n", printReceived(table.concat(receivedPath, ".")))
			end

			if hasValue then
				retval = retval .. string.format("Expected value: %s\n", printExpected(expectedValue))
			end

			return retval .. string.format("Received value: %s", printReceived(receivedValue))
		end
	end

	return { message = message, pass = pass }
end

-- FIXME: After CLI-39007, change expected to have type string | RegExp type
-- ROBLOX deviation: toMatch accepts Lua string patterns or RegExp polyfill but not simple substring
local function toMatch(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: string,
	expected: any
)
	local matcherName = "toMatch"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}

	if typeof(received) ~= "string" then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a string", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	if typeof(expected) ~= "string" and getType(expected) ~= "regexp" then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a string or regular expression", EXPECTED_COLOR("expected")),
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end

	local pass
	if typeof(expected) == "string" then
		-- ROBLOX deviation: escape chalk sequences if necessary
		expected = string.gsub(expected, string.char(27) .. "%[", string.char(27) .. "%%[")
		pass = received:find(expected) ~= nil
	else
		pass = expected:test(received)
	end

	-- ROBLOX deviation: We print "expected pattern" in both cases because this function
	-- treats strings as Lua patterns
	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected pattern: never %s\n", printExpected(expected))
			if typeof(expected) == "string" then
				retval = retval
					.. string.format(
						"Received string:        %s",
						printReceivedStringContainExpectedSubstring(
							received,
							received:find(expected) :: number,
							#expected
						)
					)
			else
				retval = retval
					.. string.format(
						"Received string:        %s",
						printReceivedStringContainExpectedResult(received, expected:exec(received))
					)
			end

			return retval
		end
	else
		message = function()
			local labelExpected = "Expected pattern"
			local labelReceived = "Received string"
			local printLabel = getLabelPrinter(labelExpected, labelReceived)

			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("%s%s\n", printLabel(labelExpected), printExpected(expected))
				.. string.format("%s%s", printLabel(labelReceived), printReceived(received))
		end
	end

	return { message = message, pass = pass }
end

local function toMatchObject(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toMatchObject"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}

	if typeof(received) ~= "table" or received == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a non-nil object", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	if typeof(expected) ~= "table" or expected == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a non-nil object", EXPECTED_COLOR("expected")),
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end

	-- ROBLOX TODO: Revisit usage of subsetEquality
	local pass = equals(received, expected, { iterableEquality, subsetEquality })

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: never %s", printExpected(expected))
			if stringify(expected) ~= stringify(received) then
				return retval .. string.format("\nReceived:       %s", printReceived(received))
			end
			return retval
		end
	else
		message = function()
			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printDiffOrStringify(
					expected,
					getObjectSubset(received, expected),
					EXPECTED_LABEL,
					RECEIVED_LABEL,
					isExpand(self.expand)
				)
		end
	end

	return { message = message, pass = pass }
end

--[[
	deviation: the toStrictEqual matcher in Jest adds three features beyond
	that of the toEqual matcher:
		1) Checking for undefined properties
		2) Checking array sparseness
		3) Type checking

	Of these, Jest-Roblox's version of the toStrictEqual matcher only
	applies type checking
]]
local function toStrictEqual(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toStrictEqual"
	local options: MatcherHintOptions = {
		comment = "deep equality",
		isNot = self.isNot,
		promise = self.promise,
	}

	local pass = equals(received, expected, toStrictEqualTesters, true)

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: not %s\n", printExpected(expected))

			if stringify(expected) ~= stringify(received) then
				retval = retval .. string.format("Received:     %s", printReceived(received))
			end

			return retval
		end
	else
		message = function()
			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printDiffOrStringify(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(self.expand))
		end
	end
	-- Passing the actual and expected objects so that a custom reporter
	-- could access them, for example in order to display a custom visual diff,
	-- or create a different error message
	return { actual = received, expected = expected, message = message, name = matcherName, pass = pass }
end

-- ROBLOX deviation: Roblox Instance matchers
local function toMatchInstance(
	-- ROBLOX deviation: self param in Lua needs to be explicitely defined
	self: MatcherState,
	received: any,
	expected: any
)
	local matcherName = "toMatchInstance"
	local options: MatcherHintOptions = {
		isNot = self.isNot,
		promise = self.promise,
	}

	if getType(received) ~= "Instance" or received == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a Roblox Instance", RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end

	if typeof(expected) ~= "table" or expected == nil then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, nil, options),
					string.format("%s value must be a table", EXPECTED_COLOR("expected")),
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end

	local pass = equals(received, expected, { instanceSubsetEquality })

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. string.format("Expected: never %s", printExpected(expected))
			if stringify(expected) ~= stringify(received) then
				return retval .. string.format("\nReceived:       %s", printReceived(received))
			end
			return retval
		end
	else
		local receivedSubset, expectedSubset = getInstanceSubset(received, expected)
		message = function()
			return matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printDiffOrStringify(
					expectedSubset,
					receivedSubset,
					EXPECTED_LABEL,
					RECEIVED_LABEL,
					isExpand(self.expand)
				)
		end
	end

	return { message = message, pass = pass }
end

local matchers: MatchersObject = {
	toBe = toBe,
	toBeCloseTo = toBeCloseTo,
	toBeDefined = toBeDefined,
	toBeFalsy = toBeFalsy,
	toBeGreaterThan = toBeGreaterThan,
	toBeGreaterThanOrEqual = toBeGreaterThanOrEqual,
	toBeInstanceOf = toBeInstanceOf,
	toBeLessThan = toBeLessThan,
	toBeLessThanOrEqual = toBeLessThanOrEqual,
	toBeNan = toBeNan,
	toBeNaN = toBeNan, -- ROBLOX deviation: aliased to toBeNan
	toBeNil = toBeNil,
	toBeNull = toBeNil, -- ROBLOX deviation: aliased to toBeNil
	toBeTruthy = toBeTruthy,
	toBeUndefined = toBeUndefined,
	toContain = toContain,
	toContainEqual = toContainEqual,
	toEqual = toEqual,
	toHaveLength = toHaveLength,
	toHaveProperty = toHaveProperty,
	toMatch = toMatch,
	toMatchObject = toMatchObject,
	toStrictEqual = toStrictEqual,

	-- ROBLOX deviation: Roblox Instance matchers
	toMatchInstance = toMatchInstance,
}

return matchers
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="243">
              <Properties>
                <string name="Name">print</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/print.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Number = LuauPolyfill.Number

local JestMatcherUtils = require(Packages.JestMatcherUtils)
local EXPECTED_COLOR = JestMatcherUtils.EXPECTED_COLOR
local INVERTED_COLOR = JestMatcherUtils.INVERTED_COLOR
local RECEIVED_COLOR = JestMatcherUtils.RECEIVED_COLOR
local printReceived = JestMatcherUtils.printReceived
local stringify = JestMatcherUtils.stringify

type Array<T> = LuauPolyfill.Array<T>

-- Format substring but do not enclose in double quote marks.
-- The replacement is compatible with pretty-format package.
local function printSubstring(val: string): string
	val = val:gsub("(\\)", "\\%1")
	val = val:gsub('(")', "\\%1")
	return val
end

local function printReceivedStringContainExpectedSubstring(
	received: string,
	start: number,
	length: number -- not end
): string
	return RECEIVED_COLOR('"' .. printSubstring(received:sub(0, start - 1)))
		.. INVERTED_COLOR(printSubstring(received:sub(start, start + length - 1)))
		.. RECEIVED_COLOR(printSubstring(received:sub(start + length, #received)))
		.. '"'
end

local function printReceivedStringContainExpectedResult(received: string, result): string
	-- result passed in should be the result of making a call to RegExp:exec
	if result == nil then
		return printReceived(received)
	else
		return printReceivedStringContainExpectedSubstring(received, result.index, #result[1])
	end
end

-- The serialized array is compatible with pretty-format package min option.
-- However, items have default stringify depth (instead of depth - 1)
-- so expected item looks consistent by itself and enclosed in the array.
local function printReceivedArrayContainExpectedItem(received: Array<any>, index: number): string
	local receivedMap = {}
	for i, item in ipairs(received) do
		local stringified = stringify(item)
		if i == index then
			receivedMap[i] = INVERTED_COLOR(stringified)
		else
			receivedMap[i] = RECEIVED_COLOR(stringified)
		end
	end

	return RECEIVED_COLOR("{") .. table.concat(receivedMap, RECEIVED_COLOR(", ")) .. RECEIVED_COLOR("}")
end

local function printCloseTo(receivedDiff: number, expectedDiff: number, precision: number, isNot: boolean): string
	local receivedDiffString = stringify(receivedDiff)
	local expectedDiffString

	if receivedDiffString:find("e") then
		receivedDiffString = receivedDiffString:gsub("%+0", "+")
		receivedDiffString = receivedDiffString:gsub("%-0", "-")

		expectedDiffString = Number.toExponential(expectedDiff, 0)
	else
		if 0 <= precision and precision < 20 then
			local stringFormat = "%." .. precision + 1 .. "f"
			expectedDiffString = string.format(stringFormat, expectedDiff)
		else
			expectedDiffString = stringify(expectedDiff)
		end
	end

	if isNot then
		return string.format(
			"Expected precision:  %s  %s\n" .. "Expected difference: %s< %s\n" .. "Received difference: %s  %s",
			"      ",
			stringify(precision),
			"never ",
			EXPECTED_COLOR(expectedDiffString),
			"      ",
			RECEIVED_COLOR(receivedDiffString)
		)
	else
		return string.format(
			"Expected precision:  %s  %s\n" .. "Expected difference: %s< %s\n" .. "Received difference: %s  %s",
			"",
			stringify(precision),
			"",
			EXPECTED_COLOR(expectedDiffString),
			"",
			RECEIVED_COLOR(receivedDiffString)
		)
	end
end

local function printExpectedConstructorName(label: string, expected): string
	return printConstructorName(label, expected, false, true) .. "\n"
end

local function printExpectedConstructorNameNot(label: string, expected): string
	return printConstructorName(label, expected, true, true) .. "\n"
end

local function printReceivedConstructorName(label: string, received): string
	return printConstructorName(label, received, false, false) .. "\n"
end

--[[
	deviation: printable function not present in upstream
	Function that determines if an object is printable i.e. if the object
	doesn't have tostring output that is its memory address
]]
local function printable(obj)
	if typeof(obj) == "table" then
		return tostring(obj):find("table: 0x") == nil
	elseif typeof(obj) == "function" then
		return tostring(obj):find("function: 0x") == nil
	elseif typeof(obj) == "userdata" then
		return tostring(obj):find("userdata: 0x") == nil
	elseif typeof(obj) == "thread" then
		return tostring(obj):find("thread: 0x") == nil
	end

	return true
end

-- Do not call function if received is equal to expected.
local function printReceivedConstructorNameNot(label: string, received, expected): string
	local retval
	if
		typeof(tostring(expected)) == "string"
		and #tostring(expected) ~= 0
		and typeof(tostring(received)) == "string"
		and #tostring(received) ~= 0
	then
		if printable(expected) and printable(received) then
			retval = printConstructorName(label, received, true, false)

			if getmetatable(received) and getmetatable(received).__index == expected then
				retval = retval .. " extends "
			else
				retval = retval .. " extends … extends "
			end
			retval = retval .. EXPECTED_COLOR(tostring(expected)) .. "\n"
			return retval
		else
			return printConstructorName(label, received, true, false) .. "\n"
		end
	else
		return printConstructorName(label, received, false, false) .. "\n"
	end
end

--[[
	deviation: upstream would print stuff like
		"YourClass name is not a string"
		"YourClass name is an empty string"
	but we omit the "name" in the result since we don't have a name property

	deviation: constructor does not have Function type annotation
]]
function printConstructorName(label: string, constructor: any, isNot: boolean, isExpected: boolean): string
	-- ROBLOX deviation: omitted handling for tostring() returning non-string as
	-- tostring() always returns string
	local retval = label .. ": "
	if not isNot then
		retval = retval .. ""
	else
		if isExpected then
			retval = retval .. "never "
		else
			retval = retval .. "      "
		end
	end

	if printable(constructor) then
		if #tostring(constructor) == 0 then
			return string.format("%s name is an empty string", label)
		end

		if isExpected then
			retval = retval .. EXPECTED_COLOR(tostring(constructor))
		else
			retval = retval .. RECEIVED_COLOR(tostring(constructor))
		end

		return retval
	else
		local obj = "{ "

		local finished = true
		local started = false

		for key, value in pairs(constructor) do
			-- if we find that we can't print the first few key value pairs
			-- because they aren't nicely printable, we default to
			-- printing the table address with the original retval
			-- the only exception we make is if the key is a __ metamethod

			local kv_pair = nil
			if printable(key) and printable(value) then
				kv_pair = string.format("%s: %s, ", stringify(key), stringify(value))
				-- We don't print key values for metamethods since they don't
				-- provide us with any additional information
			elseif printable(key) and key:find("__") ~= 1 then
				kv_pair = string.format("%s, ", stringify(key))
			end

			-- stop printing key value pairs and append an ellipsis if it exceeds a specific length
			if kv_pair then
				if #obj + #kv_pair > 64 then
					finished = false
					break
				end

				started = true
				obj = obj .. kv_pair
			end
		end

		-- if we were never able to actually create an obj with the
		-- content of the table because the first #kv_pair was too big,
		-- we default to printing the table address with original retval
		if started == false then
			if isExpected then
				return retval .. EXPECTED_COLOR(tostring(constructor))
			end
			return retval .. RECEIVED_COLOR(tostring(constructor))
		end

		if finished then
			-- get rid of trailing comma
			obj = obj:sub(1, -3)
			obj = obj .. " }"
		else
			obj = obj .. "... }"
		end

		if isExpected then
			return retval .. EXPECTED_COLOR(obj)
		end
		return retval .. RECEIVED_COLOR(obj)
	end
end

return {
	printReceivedStringContainExpectedSubstring = printReceivedStringContainExpectedSubstring,
	printReceivedStringContainExpectedResult = printReceivedStringContainExpectedResult,
	printReceivedArrayContainExpectedItem = printReceivedArrayContainExpectedItem,
	printCloseTo = printCloseTo,
	printExpectedConstructorName = printExpectedConstructorName,
	printExpectedConstructorNameNot = printExpectedConstructorNameNot,
	printReceivedConstructorName = printReceivedConstructorName,
	printReceivedConstructorNameNot = printReceivedConstructorNameNot,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="244">
              <Properties>
                <string name="Name">spyMatchers</string>
                <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/spyMatchers.ts
-- /**
-- * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
-- *
-- * This source code is licensed under the MIT license found in the
-- * LICENSE file in the root directory of this source tree.
-- */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Number = LuauPolyfill.Number
local String = LuauPolyfill.String
local Symbol = LuauPolyfill.Symbol

local getType = require(Packages.JestGetType).getType
local isPrimitive = require(Packages.JestGetType).isPrimitive

local JestMatcherUtils = require(Packages.JestMatcherUtils)
local DIM_COLOR = JestMatcherUtils.DIM_COLOR
local EXPECTED_COLOR = JestMatcherUtils.EXPECTED_COLOR
local RECEIVED_COLOR = JestMatcherUtils.RECEIVED_COLOR
local diff = JestMatcherUtils.diff
local ensureExpectedIsNonNegativeInteger = JestMatcherUtils.ensureExpectedIsNonNegativeInteger
local ensureNoExpected = JestMatcherUtils.ensureNoExpected
local matcherErrorMessage = JestMatcherUtils.matcherErrorMessage
local matcherHint = JestMatcherUtils.matcherHint
local printExpected = JestMatcherUtils.printExpected
local printReceived = JestMatcherUtils.printReceived
local printWithType = JestMatcherUtils.printWithType
local stringify = JestMatcherUtils.stringify

type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX deviation: omitted type imports from types file and defined MatcherState as any for now
type MatcherHintOptions = JestMatcherUtils.MatcherHintOptions
type MatcherState = any
type SyncExpectationResult = (any, any, any) -> {
	pass: boolean,
	message: () -> string,
}

local jasmineUtils = require(CurrentModule.jasmineUtils)
local equals = jasmineUtils.equals

local utils = require(CurrentModule.utils)
local iterableEquality = utils.iterableEquality

local isExpand, printExpectedArgs, printReceivedArgs, printCommon, isEqualValue, isEqualCall, isEqualReturn, countReturns, printNumberOfReturns, getRightAlignedPrinter, printReceivedCallsNegative, printExpectedReceivedCallsPositive, printDiffCall, isLineDiffableCall, isLineDiffableArg, printResult, printReceivedResults, isMock, isSpy, ensureMockOrSpy, ensureMock

-- The optional property of matcher context is true if undefined.
function isExpand(expand: boolean?)
	return expand ~= false
end

local PRINT_LIMIT = 3

local NO_ARGUMENTS = "called with 0 arguments"

function printExpectedArgs(expected: Array<any>): string
	if #expected == 0 then
		return NO_ARGUMENTS
	else
		return Array.join(
			Array.map(expected, function(arg)
				return printExpected(arg)
			end),
			", "
		)
	end
end

function printReceivedArgs(received: Array<any>, expected_: Array<any>?): string
	local expected = expected_ or {}
	if #received == 0 then
		return NO_ARGUMENTS
	else
		return Array.join(
			Array.map(received, function(arg, i)
				if Array.isArray(expected) and i <= #expected and isEqualValue(expected[i], arg) then
					return printCommon(arg)
				else
					return printReceived(arg)
				end
			end),
			", "
		)
	end
end

function printCommon(val: any)
	return DIM_COLOR(stringify(val))
end

function isEqualValue(expected: any, received: any): boolean
	return equals(expected, received, { iterableEquality })
end

function isEqualCall(expected: Array<any>, received: Array<any>): boolean
	return isEqualValue(expected, received)
end

function isEqualReturn(expected, result): boolean
	return result.type == "return" and isEqualValue(expected, result.value)
end

function countReturns(results: Array<any>): number
	return Array.reduce(results, function(n: number, result: any)
		if result.type == "return" then
			return n + 1
		else
			return n
		end
	end, 0)
end

function printNumberOfReturns(countReturns_: number, countCalls: number): string
	local retval = string.format("\nNumber of returns: %s", printReceived(countReturns_))
	if countCalls ~= countReturns_ then
		retval = retval .. string.format("\nNumber of calls:   %s", printReceived(countCalls))
	end

	return retval
end

type PrintLabel = (string, boolean) -> string

-- Given a label, return a function which given a string,
-- right-aligns it preceding the colon in the label.
function getRightAlignedPrinter(label: string): PrintLabel
	-- Assume that the label contains a colon.
	local index = label:find(":")
	local suffix = label:sub(index)

	return function(string_: string, isExpectedCall: boolean)
		local retval
		if isExpectedCall then
			retval = "->" .. string.rep(" ", math.max(0, index - 3 - #string_))
		else
			retval = string.rep(" ", math.max(0, index - 1 - #string_))
		end

		return retval .. string_ .. suffix
	end
end

-- ROBLOX deviation: IndexedCall annotated as any for now since we don't have tuple support in luau
type IndexedCall = any

function printReceivedCallsNegative(
	expected: Array<any>,
	indexedCalls: Array<IndexedCall>,
	isOnlyCall: boolean,
	iExpectedCall: number?
)
	if #indexedCalls == 0 then
		return ""
	end

	local label = "Received:       "

	if isOnlyCall then
		return label .. printReceivedArgs(indexedCalls[1], expected) .. "\n"
	end

	local printAligned = getRightAlignedPrinter(label)

	return "Received\n"
		.. Array.reduce(indexedCalls, function(printed: string, iCall: IndexedCall)
			local i = iCall[1]
			local args = iCall[2]

			return printed .. printAligned(tostring(i), i == iExpectedCall) .. printReceivedArgs(args, expected) .. "\n"
		end, "")
end

function printExpectedReceivedCallsPositive(
	expected: Array<any>,
	indexedCalls: Array<IndexedCall>,
	expand: boolean,
	isOnlyCall: boolean,
	iExpectedCall: number?
)
	local expectedLine = string.format("Expected: %s\n", printExpectedArgs(expected))

	if #indexedCalls == 0 then
		return expectedLine
	end

	local label = "Received: "

	if isOnlyCall and (iExpectedCall == 1 or iExpectedCall == nil) then
		local received = indexedCalls[1][2]
		if isLineDiffableCall(expected, received) then
			-- Display diff without indentation.
			local lines = {
				EXPECTED_COLOR("- Expected"),
				RECEIVED_COLOR("+ Received"),
				"",
			}

			local length = math.max(#expected, #received)
			for i = 1, length do
				local added = false

				if i <= #expected and i <= #received then
					if isEqualValue(expected[i], received[i]) then
						table.insert(lines, "  " .. printCommon(received[i]) .. ",")
						added = true
					end
					if not added and isLineDiffableArg(expected[i], received[i]) then
						local difference = diff(expected[i], received[i], { expand })

						if
							typeof(difference) == "string"
							and difference:find("%- Expected")
							and difference:find("%+ Received")
						then
							-- Omit annotation in case multiple args have diff.
							local splitLines = {}
							for s in difference:gmatch("[^\n]+") do
								table.insert(splitLines, s)
							end

							splitLines = Array.slice(splitLines, 3)
							table.insert(lines, Array.join(splitLines, "\n") .. ",")
							added = true
						end
					end
				end
				if not added then
					if i <= #expected then
						table.insert(lines, EXPECTED_COLOR("- " .. stringify(expected[i])) .. ",")
					end
					if i <= #received then
						table.insert(lines, RECEIVED_COLOR("+ " .. stringify(received[i])) .. ",")
					end
				end
				i = i + 1
			end

			return table.concat(lines, "\n") .. "\n"
		end
		return expectedLine .. label .. printReceivedArgs(received, expected) .. "\n"
	end

	local printAligned = getRightAlignedPrinter(label)

	return expectedLine
		.. "Received\n"
		.. Array.reduce(indexedCalls, function(printed: string, indexedCall: IndexedCall)
			local i = indexedCall[1]
			local received = indexedCall[2]

			local aligned = printAligned(tostring(i), i == iExpectedCall)

			if (i == iExpectedCall or iExpectedCall == nil) and isLineDiffableCall(expected, received) then
				return printed
					.. aligned:sub(1, aligned:find(":") - 1)
					.. "\n"
					.. aligned:sub(aligned:find(":") + 1, #aligned)
					.. printDiffCall(expected, received, expand)
					.. "\n"
			else
				return printed .. aligned .. printReceivedArgs(received, expected) .. "\n"
			end
		end, "")
end

local indentation = string.gsub("Received", "[a-zA-Z0-9_]", " ")

function printDiffCall(expected: Array<any>, received: Array<any>, expand: boolean)
	return Array.join(
		Array.map(received, function(arg, i)
			if i <= #expected then
				if isEqualValue(expected[i], arg) then
					return indentation .. "  " .. printCommon(arg) .. ","
				end

				if isLineDiffableArg(expected[i], arg) then
					local difference = diff(expected[i], arg, { expand = expand })

					if
						typeof(difference) == "string"
						and difference:find("%- Expected")
						and difference:find("%+ Received")
					then
						-- Display diff with indentation.
						-- Omit annotation in case multiple args have diff.
						local splitLines = {}
						for s in difference:gmatch("[^\n]+") do
							table.insert(splitLines, s)
						end

						return Array.join(
							Array.map(Array.slice(splitLines, 3), function(line)
								return indentation .. line
							end),
							"\n"
						) .. ","
					end
				end
			end

			-- Display + only if received arg has no corresponding expected arg.
			return indentation
				.. (function()
					if i <= #expected then
						return "  " .. printReceived(arg)
					end

					return RECEIVED_COLOR("+ " .. stringify(arg))
				end)()
				.. ","
		end),
		"\n"
	)
end

function isLineDiffableCall(expected: Array<any>, received: Array<any>): boolean
	return Array.some(expected, function(arg, i)
		return i <= #received and isLineDiffableArg(arg, received[i])
	end)
end

-- Almost redundant with function in jest-matcher-utils,
-- except no line diff for any strings.
function isLineDiffableArg(expected: any, received: any): boolean
	local expectedType = getType(expected)
	local receivedType = getType(received)

	if expectedType ~= receivedType then
		return false
	end

	if isPrimitive(expected) then
		return false
	end

	if expectedType == "date" or expectedType == "function" or expectedType == "regexp" or expectedType == "error" then
		return false
	end

	-- ROBLOX TODO: Change this and other similar indexing as part of ADO-1372
	if expectedType == "table" and typeof(expected.asymmetricMatch) == "function" then
		return false
	end

	if receivedType == "table" and typeof(received.asymmetricMatch) == "function" then
		return false
	end

	return true
end

-- ROBLOX deviation: IndexedResult annotated as any for now since we don't have tuple support in luau
type IndexedResult = any

function printResult(result: any, expected: any)
	if result.type == "throw" then
		return "function call threw an error"
	end

	if result.type == "incomplete" then
		return "function call has not returned yet"
	end

	if isEqualValue(expected, result.value) then
		return printCommon(result.value)
	end

	return printReceived(result.value)
end

-- Return either empty string or one line per indexed result,
-- so additional empty line can separate from `Number of returns` which follows.
function printReceivedResults(
	label: string,
	expected: any,
	indexedResults: Array<IndexedResult>,
	isOnlyCall: boolean,
	iExpectedCall: number?
)
	if #indexedResults == 0 then
		return ""
	end

	if isOnlyCall and (iExpectedCall == 1 or iExpectedCall == nil) then
		return label .. printResult(indexedResults[1][2], expected) .. "\n"
	end

	local printAligned = getRightAlignedPrinter(label)

	-- ROBLOX TODO: the following (label:find(':') or 1) can be changed to label:find(':') if
	-- roblox-cli eventually won't complain?
	local colonIndex = label:find(":") or 1

	return String.trim(label:sub(1, colonIndex - 1) .. label:sub(colonIndex + 1, #label))
		.. "\n"
		.. Array.reduce(indexedResults, function(printed: string, indexedResult: IndexedResult)
			local i = indexedResult[1]
			local result = indexedResult[2]
			return printed .. printAligned(tostring(i), i == iExpectedCall) .. printResult(result, expected) .. "\n"
		end, "")
end

local function createToBeCalledMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, expected: any)
		local expectedArgument = ""
		local options: MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureNoExpected(expected, matcherName, options)
		ensureMockOrSpy(received, matcherName, expectedArgument, options)

		local receivedIsSpy = isSpy(received)
		local receivedName
		if receivedIsSpy then
			receivedName = "spy"
		else
			receivedName = received.getMockName()
		end

		local count
		if receivedIsSpy then
			count = received.calls:count()
		else
			count = #received.mock.calls
		end

		local calls
		if receivedIsSpy then
			calls = Array.map(received.calls:all(), function(x: any)
				return x.args
			end)
		else
			calls = received.mock.calls
		end

		local pass = count > 0
		local message
		if pass then
			message = function()
				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of calls: %s\n"):format(printExpected(0))
					.. ("Received number of calls: %s\n\n"):format(printReceived(count))
					.. Array.join(
						Array.reduce(calls, function(lines: Array<string>, args: any, i: number)
							if #lines < PRINT_LIMIT then
								table.insert(lines, ("%s: %s"):format(tostring(i), printReceivedArgs(args)))
							end

							return lines
						end, {}),
						"\n"
					)
			end
		else
			message = function()
				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of calls: >= %s\n"):format(printExpected(1))
					.. ("Received number of calls:    %s"):format(printReceived(count))
			end
		end

		return { message = message, pass = pass }
	end
end

local function createToReturnMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, expected: any)
		local expectedArgument = ""
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureNoExpected(expected, matcherName, options)
		ensureMock(received, matcherName, expectedArgument, options)

		local receivedName = received.getMockName()

		-- Count return values that correspond only to calls that returned
		local count = Array.reduce(received.mock.results, function(n: number, result: any)
			if result.type == "return" then
				return n + 1
			else
				return n
			end
		end, 0)

		local pass = count > 0
		local message
		if pass then
			message = function()
				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of returns: %s\n"):format(printExpected(0))
					.. ("Received number of returns: %s\n\n"):format(printReceived(count))
					.. Array.join(
						Array.reduce(received.mock.results, function(lines: Array<string>, result: any, i: number)
							if result.type == "return" and #lines < PRINT_LIMIT then
								table.insert(lines, ("%s: %s"):format(tostring(i), printReceived(result.value)))
							end

							return lines
						end, {}),
						"\n"
					)

				if #received.mock.calls ~= count then
					retval = retval .. "\n\nReceived number of calls:   " .. printReceived(#received.mock.calls)
				end

				return retval
			end
		else
			message = function()
				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of returns: >= %s\n"):format(printExpected(1))
					.. ("Received number of returns:    %s"):format(printReceived(count))
				if #received.mock.calls ~= count then
					retval = retval
						.. ("\nReceived number of calls:      %s"):format(printReceived(#received.mock.calls))
				end

				return retval
			end
		end

		return { message = message, pass = pass }
	end
end

local function createToBeCalledTimesMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, expected: number)
		local expectedArgument = "expected"
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureExpectedIsNonNegativeInteger(expected, matcherName, options)
		ensureMockOrSpy(received, matcherName, expectedArgument, options)

		local receivedIsSpy = isSpy(received)
		local receivedName
		if receivedIsSpy then
			receivedName = "spy"
		else
			receivedName = received.getMockName()
		end

		local count
		if receivedIsSpy then
			count = received.calls:count()
		else
			count = #received.mock.calls
		end

		local pass = count == expected

		local message
		if pass then
			message = function()
				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of calls: never %s"):format(printExpected(expected))
			end
		else
			message = function()
				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of calls: %s\n"):format(printExpected(expected))
					.. ("Received number of calls: %s"):format(printReceived(count))
			end
		end

		return { message = message, pass = pass }
	end
end

local function createToReturnTimesMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, expected: number)
		local expectedArgument = "expected"
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureExpectedIsNonNegativeInteger(expected, matcherName, options)
		ensureMock(received, matcherName, expectedArgument, options)

		local receivedName = received.getMockName()

		-- Count return values that correspond only to calls that returned
		local count = Array.reduce(received.mock.results, function(n: number, result: any)
			if result.type == "return" then
				return n + 1
			else
				return n
			end
		end, 0)

		local pass = count == expected

		local message
		if pass then
			message = function()
				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of returns: never %s"):format(printExpected(expected))

				if #received.mock.calls ~= count then
					retval = retval
						.. ("\n\nReceived number of calls:         %s"):format(printReceived(#received.mock.calls))
				end

				return retval
			end
		else
			message = function()
				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected number of returns: %s\n"):format(printExpected(expected))
					.. ("Received number of returns: %s"):format(printReceived(count))

				if #received.mock.calls ~= count then
					retval = retval .. ("\nReceived number of calls:   %s"):format(printReceived(#received.mock.calls))
				end

				return retval
			end
		end

		return { message = message, pass = pass }
	end
end

local function createToBeCalledWithMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, ...)
		local expected = { ... }
		local expectedLength = select("#", ...)
		for i = 1, expectedLength do
			-- ROBLOX deviation: We add this if statement to deal with our internal symbol
			-- that represents nil
			if expected[i] == nil then
				expected[i] = Symbol.for_("$$nil")
			end
		end
		local expectedArgument = "...expected"
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureMockOrSpy(received, matcherName, expectedArgument, options)

		local receivedIsSpy = isSpy(received)
		local receivedName
		if receivedIsSpy then
			receivedName = "spy"
		else
			receivedName = received.getMockName()
		end

		local calls
		if receivedIsSpy then
			calls = Array.map(received.calls:all(), function(x: any)
				return x.args
			end)
		else
			calls = received.mock.calls
		end

		local pass = Array.some(calls, function(call)
			return isEqualCall(expected, call)
		end)

		local message
		if pass then
			message = function()
				-- Some examples of calls that are equal to expected value.
				local indexedCalls: Array<IndexedCall> = {}
				local i = 1
				while i <= #calls and #indexedCalls < PRINT_LIMIT do
					if isEqualCall(expected, calls[i]) then
						table.insert(indexedCalls, { i, calls[i] })
					end
					i = i + 1
				end

				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected: never %s\n"):format(printExpectedArgs(expected))

				if not (#calls == 1 and stringify(calls[1]) == stringify(expected)) then
					retval = retval .. printReceivedCallsNegative(expected, indexedCalls, #calls == 1)
				end

				retval = retval .. ("\nNumber of calls: %s"):format(printReceived(#calls))
				return retval
			end
		else
			message = function()
				-- Some examples of calls that are not equal to expected value.
				local indexedCalls: Array<IndexedCall> = {}
				local i = 1
				while i <= #calls and #indexedCalls < PRINT_LIMIT do
					table.insert(indexedCalls, { i, calls[i] })
					i = i + 1
				end
				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(this.expand), #calls == 1)
					.. ("\nNumber of calls: %s"):format(printReceived(#calls))
			end
		end

		return { message = message, pass = pass }
	end
end

local function createToReturnWithMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, expected: any)
		local expectedArgument = "expected"
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}
		ensureMock(received, matcherName, expectedArgument, options)

		local receivedName = received.getMockName()
		local receivedMock = received.mock
		local calls = receivedMock.calls
		local results = receivedMock.results

		local pass = Array.some(results, function(result: any)
			return isEqualReturn(expected, result)
		end)

		local message
		if pass then
			message = function()
				-- Some examples of results that are equal to expected value.
				local indexedResults: Array<IndexedResult> = {}
				local i = 1
				while i <= #results and #indexedResults < PRINT_LIMIT do
					if isEqualReturn(expected, results[i]) then
						table.insert(indexedResults, { i, results[i] })
					end
					i = i + 1
				end

				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected: never %s\n"):format(printExpected(expected))

				if
					not (
						#results == 1
						and results[1].type == "return"
						and stringify(results[1].value) == stringify(expected)
					)
				then
					retval = retval .. printReceivedResults("Received:       ", expected, indexedResults, #results == 1)
				end

				retval = retval .. printNumberOfReturns(countReturns(results), #calls)

				return retval
			end
		else
			message = function()
				-- Some examples of results that are not equal to expected value.
				local indexedResults: Array<IndexedResult> = {}
				local i = 1
				while i <= #results and #indexedResults < PRINT_LIMIT do
					table.insert(indexedResults, { i, results[i] })
					i = i + 1
				end

				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected: %s\n"):format(printExpected(expected))
					.. printReceivedResults("Received: ", expected, indexedResults, #results == 1)
					.. printNumberOfReturns(countReturns(results), #calls)
			end
		end

		return { message = message, pass = pass }
	end
end

local function createLastCalledWithMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, ...)
		local expected: Array<any> = { ... }
		local expectedLength = select("#", ...)
		for i = 1, expectedLength do
			-- ROBLOX deviation: We add this if statement to deal with our internal symbol
			-- that represents nil
			if expected[i] == nil then
				expected[i] = Symbol.for_("$$nil")
			end
		end
		local expectedArgument = "...expected"
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureMockOrSpy(received, matcherName, expectedArgument, options)

		local receivedIsSpy = isSpy(received)
		local receivedName
		if receivedIsSpy then
			receivedName = "spy"
		else
			receivedName = received.getMockName()
		end

		local calls
		if receivedIsSpy then
			calls = Array.map(received.calls:all(), function(x: any)
				return x.args
			end)
		else
			calls = received.mock.calls
		end

		local iLast = #calls

		local pass = iLast >= 1 and isEqualCall(expected, calls[iLast])

		local message
		if pass then
			message = function()
				local indexedCalls: Array<IndexedCall> = {}
				if iLast > 1 then
					-- Display preceding call as context.
					table.insert(indexedCalls, { iLast - 1, calls[iLast - 1] })
				end

				table.insert(indexedCalls, { iLast, calls[iLast] })

				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected: never %s\n"):format(printExpectedArgs(expected))

				if not (#calls == 1 and stringify(calls[1]) == stringify(expected)) then
					retval = retval .. printReceivedCallsNegative(expected, indexedCalls, #calls == 1, iLast)
				end

				retval = retval .. ("\nNumber of calls: %s"):format(printReceived(#calls))

				return retval
			end
		else
			message = function()
				local indexedCalls: Array<IndexedCall> = {}
				if iLast >= 1 then
					if iLast > 1 then
						local i = iLast - 1
						-- Is there a preceding call that is equal to expected args?
						while i >= 1 and not isEqualCall(expected, calls[i]) do
							i = i - 1
						end
						if i < 1 then
							i = iLast - 1 -- otherwise, preceding call
						end

						table.insert(indexedCalls, { i, calls[i] })
					end

					table.insert(indexedCalls, { iLast, calls[iLast] })
				end

				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. printExpectedReceivedCallsPositive(
						expected,
						indexedCalls,
						isExpand(this.expand),
						#calls == 1,
						iLast
					)
					.. ("\nNumber of calls: %s"):format(printReceived(#calls))
			end
		end

		return { message = message, pass = pass }
	end
end

local function createLastReturnedMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, expected: any)
		local expectedArgument = "expected"
		local options: JestMatcherUtils.MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		ensureMock(received, matcherName, expectedArgument, options)

		local receivedName = received.getMockName()

		local receivedMock = received.mock
		local calls = receivedMock.calls
		local results = receivedMock.results
		local iLast = #results

		local pass = iLast >= 1 and isEqualReturn(expected, results[iLast])

		local message
		if pass then
			message = function()
				local indexedResults: Array<IndexedResult> = {}

				if iLast > 1 then
					-- Display preceding result as context.
					table.insert(indexedResults, { iLast - 1, results[iLast - 1] })
				end
				table.insert(indexedResults, { iLast, results[iLast] })

				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected: never %s\n"):format(printExpected(expected))

				if
					not (
						#results == 1
						and results[1].type == "return"
						and stringify(results[1].value) == stringify(expected)
					)
				then
					retval = retval
						.. printReceivedResults("Received:       ", expected, indexedResults, #results == 1, iLast)
				end

				retval = retval .. printNumberOfReturns(countReturns(results), #calls)

				return retval
			end
		else
			message = function()
				local indexedResults: Array<IndexedResult> = {}

				if iLast >= 1 then
					if iLast > 1 then
						local i = iLast - 1
						-- Is there a preceding result that is equal to expected value?
						while i >= 1 and not isEqualReturn(expected, results[i]) do
							i = i - 1
						end

						if i < 1 then
							i = iLast - 1 -- otherwise, preceding result
						end

						table.insert(indexedResults, { i, results[i] })
					end

					table.insert(indexedResults, { iLast, results[iLast] })
				end

				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("Expected: %s\n"):format(printExpected(expected))
					.. printReceivedResults("Received: ", expected, indexedResults, #results == 1, iLast)
					.. printNumberOfReturns(countReturns(results), #calls)
			end
		end

		return { message = message, pass = pass }
	end
end

local function createNthCalledWithMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, nth: number, ...)
		local expected = { ... }
		local expectedLength = select("#", ...)
		for i = 1, expectedLength do
			-- ROBLOX deviation: We add this if statement to deal with our internal symbol
			-- that represents nil
			if expected[i] == nil then
				expected[i] = Symbol.for_("$$nil")
			end
		end
		local expectedArgument = "n"
		local options: JestMatcherUtils.MatcherHintOptions = {
			expectedColor = function(arg)
				return arg
			end,
			isNot = this.isNot,
			promise = this.promise,
			secondArgument = "...expected",
		}

		ensureMockOrSpy(received, matcherName, expectedArgument, options)

		if not Number.isSafeInteger(nth) or nth < 1 then
			-- ROBLOX deviation: we don't use the Error polyfill because we encounter an error with TestEZ
			error(
				Error(
					matcherErrorMessage(
						matcherHint(matcherName, nil, expectedArgument, options),
						("%s must be a positive integer"):format(expectedArgument),
						printWithType(expectedArgument, nth, stringify)
					)
				)
			)
		end

		local receivedIsSpy = isSpy(received)
		local receivedName
		if receivedIsSpy then
			receivedName = "spy"
		else
			receivedName = received.getMockName()
		end

		local calls
		if receivedIsSpy then
			calls = Array.map(received.calls:all(), function(x: any)
				return x.args
			end)
		else
			calls = received.mock.calls
		end
		local length = #calls
		local iNth = nth

		local pass = iNth <= length and isEqualCall(expected, calls[iNth])

		local message
		if pass then
			message = function()
				-- Display preceding and following calls,
				-- in case assertions fails because index is off by one.
				local indexedCalls: Array<IndexedCall> = {}

				if iNth - 1 >= 1 then
					table.insert(indexedCalls, { iNth - 1, calls[iNth - 1] })
				end
				table.insert(indexedCalls, { iNth, calls[iNth] })

				if iNth + 1 <= length then
					table.insert(indexedCalls, { iNth + 1, calls[iNth + 1] })
				end

				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("n: %s\n"):format(tostring(nth))
					.. ("Expected: never %s\n"):format(printExpectedArgs(expected))

				if not (#calls == 1 and stringify(calls[1]) == stringify(expected)) then
					retval = retval .. printReceivedCallsNegative(expected, indexedCalls, #calls == 1, iNth)
				end

				retval = retval .. ("\nNumber of calls: %s"):format(printReceived(#calls))

				return retval
			end
		else
			message = function()
				-- Display preceding and following calls:
				-- * nearest call that is equal to expected args
				-- * otherwise, adjacent call
				-- in case assertions fails because of index, especially off by one.
				local indexedCalls: Array<IndexedCall> = {}

				if iNth <= length then
					if iNth - 1 >= 1 then
						local i = iNth - 1
						-- Is there a preceding call that is equal to expected args?
						while i >= 1 and not isEqualCall(expected, calls[i]) do
							i = i - 1
						end

						if i < 1 then
							i = iNth - 1 -- otherwise, adjacent call
						end

						table.insert(indexedCalls, { i, calls[i] })
					end
					table.insert(indexedCalls, { iNth, calls[iNth] })

					if iNth + 1 <= length then
						local i = iNth + 1
						-- Is there a following call that is equal to expected args?
						while i <= length and not isEqualCall(expected, calls[i]) do
							i = i + 1
						end

						if i >= length then
							i = iNth + 1 -- otherwise, adjacent call
						end

						table.insert(indexedCalls, { i, calls[i] })
					end
				elseif length > 1 then
					-- Is there a call that is equal to expected args?
					local i = length - 1
					-- Is there a call that is equal to expected args?
					while i >= 1 and not isEqualCall(expected, calls[i]) do
						i = i - 1
					end

					if i < 1 then
						i = length - 1
					end

					table.insert(indexedCalls, { i, calls[i] })
				end

				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("n: %s\n"):format(tostring(nth))
					.. printExpectedReceivedCallsPositive(
						expected,
						indexedCalls,
						isExpand(this.expand),
						#calls == 1,
						iNth
					)
					.. ("\nNumber of calls: %s"):format(printReceived(#calls))
			end
		end

		return { message = message, pass = pass }
	end
end

local function createNthReturnedWithMatcher(matcherName: string): SyncExpectationResult
	return function(this: MatcherState, received: any, nth: number, expected: any)
		local expectedArgument = "n"
		local options: JestMatcherUtils.MatcherHintOptions = {
			expectedColor = function(arg)
				return arg
			end,
			isNot = this.isNot,
			promise = this.promise,
			secondArgument = "expected",
		}

		ensureMock(received, matcherName, expectedArgument, options)

		if not Number.isSafeInteger(nth) or nth < 1 then
			-- ROBLOX deviation: we don't use the Error polyfill because we encounter an error with TestEZ
			error(
				Error(
					matcherErrorMessage(
						matcherHint(matcherName, nil, expectedArgument, options),
						("%s must be a positive integer"):format(expectedArgument),
						printWithType(expectedArgument, nth, stringify)
					)
				)
			)
		end

		local receivedName = received.getMockName()
		local receivedMock = received.mock
		local calls = receivedMock.calls
		local results = receivedMock.results
		local length = #results
		local iNth = nth

		local pass = iNth <= length and isEqualReturn(expected, results[iNth])

		local message
		if pass then
			message = function()
				-- Display preceding and following results,
				-- in case assertions fails because index is off by one.
				local indexedResults: Array<IndexedResult> = {}
				if iNth - 1 >= 1 then
					table.insert(indexedResults, { iNth - 1, results[iNth - 1] })
				end
				table.insert(indexedResults, { iNth, results[iNth] })
				if iNth + 1 <= length then
					table.insert(indexedResults, { iNth + 1, results[iNth + 1] })
				end

				local retval = matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("n: %s\n"):format(tostring(nth))
					.. ("Expected: never %s\n"):format(printExpected(expected))

				if
					not (
						#results == 1
						and results[1].type == "return"
						and stringify(results[1].value) == stringify(expected)
					)
				then
					retval = retval
						.. printReceivedResults("Received:       ", expected, indexedResults, #results == 1, iNth)
				end
				retval = retval .. printNumberOfReturns(countReturns(results), #calls)

				return retval
			end
		else
			message = function()
				-- Display preceding and following results:
				-- * nearest result that is equal to expected value
				-- * otherwise, adjacent result
				-- in case assertions fails because of index, especially off by one.
				local indexedResults: Array<IndexedResult> = {}

				if iNth <= length then
					if iNth - 1 >= 1 then
						local i = iNth - 1
						-- Is there a preceding result that is equal to expected value?
						while i >= 1 and not isEqualReturn(expected, results[i]) do
							i = i - 1
						end

						if i < 1 then
							i = iNth - 1
						end

						table.insert(indexedResults, { i, results[i] })
					end

					table.insert(indexedResults, { iNth, results[iNth] })
					if iNth + 1 <= length then
						local i = iNth + 1
						-- Is there a following result that is equal to expected value?
						while i <= length and not isEqualReturn(expected, results[i]) do
							i = i + 1
						end

						if i > length then
							i = iNth + 1
						end

						table.insert(indexedResults, { i, results[i] })
					end
				elseif length > 0 then
					-- The number of received calls is fewer than the expected number.
					local i = length
					-- Is there a result that is equal to expected value?
					while i >= 1 and not isEqualReturn(expected, results[i]) do
						i = i - 1
					end

					if i < 1 then
						i = length - 1 -- otherwise, last result
					end

					table.insert(indexedResults, { i, results[i] })
				end

				return matcherHint(matcherName, receivedName, expectedArgument, options)
					.. "\n\n"
					.. ("n: %s\n"):format(tostring(nth))
					.. ("Expected: %s\n"):format(printExpected(expected))
					.. printReceivedResults("Received: ", expected, indexedResults, #results == 1, iNth)
					.. printNumberOfReturns(countReturns(results), #calls)
			end
		end

		return { message = message, pass = pass }
	end
end

-- ROBLOX deviation: matchersObject annotated as { [string]: any } for now rather than { [string]: RawMatcherFn }
-- because we cannot currently express RawMatcherFn as tuple
type MatchersObject = { [string]: any }

local spyMatchers: MatchersObject = {
	lastCalledWith = createLastCalledWithMatcher("lastCalledWith"),
	lastReturnedWith = createLastReturnedMatcher("lastReturnedWith"),
	nthCalledWith = createNthCalledWithMatcher("nthCalledWith"),
	nthReturnedWith = createNthReturnedWithMatcher("nthReturnedWith"),
	toBeCalled = createToBeCalledMatcher("toBeCalled"),
	toBeCalledTimes = createToBeCalledTimesMatcher("toBeCalledTimes"),
	toBeCalledWith = createToBeCalledWithMatcher("toBeCalledWith"),
	toHaveBeenCalled = createToBeCalledMatcher("toHaveBeenCalled"),
	toHaveBeenCalledTimes = createToBeCalledTimesMatcher("toHaveBeenCalledTimes"),
	toHaveBeenCalledWith = createToBeCalledWithMatcher("toHaveBeenCalledWith"),
	toHaveBeenLastCalledWith = createLastCalledWithMatcher("toHaveBeenLastCalledWith"),
	toHaveBeenNthCalledWith = createNthCalledWithMatcher("toHaveBeenNthCalledWith"),
	toHaveLastReturnedWith = createLastReturnedMatcher("toHaveLastReturnedWith"),
	toHaveNthReturnedWith = createNthReturnedWithMatcher("toHaveNthReturnedWith"),
	toHaveReturned = createToReturnMatcher("toHaveReturned"),
	toHaveReturnedTimes = createToReturnTimesMatcher("toHaveReturnedTimes"),
	toHaveReturnedWith = createToReturnWithMatcher("toHaveReturnedWith"),
	toReturn = createToReturnMatcher("toReturn"),
	toReturnTimes = createToReturnTimesMatcher("toReturnTimes"),
	toReturnWith = createToReturnWithMatcher("toReturnWith"),
}

function isMock(received: any)
	return received ~= nil and typeof(received) == "table" and received._isMockFunction == true
end

function isSpy(received: any)
	return received ~= nil
		and typeof(received) == "table"
		and received.calls ~= nil
		and typeof(received.calls.all) == "function"
		and typeof(received.calls.count) == "function"
end

-- ROBLOX deviation: we don't use the Error polyfill because we encounter an error with TestEZ
function ensureMockOrSpy(
	received: any,
	matcherName: string,
	expectedArgument: string,
	options: JestMatcherUtils.MatcherHintOptions
)
	if not isMock(received) and not isSpy(received) then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, expectedArgument, options),
					("%s value must be a mock or spy function"):format(RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end
end

-- ROBLOX deviation: we don't use the Error polyfill because we encounter an error with TestEZ
function ensureMock(
	received: any,
	matcherName: string,
	expectedArgument: string,
	options: JestMatcherUtils.MatcherHintOptions
)
	if not isMock(received) then
		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherName, nil, expectedArgument, options),
					("%s value must be a mock function"):format(RECEIVED_COLOR("received")),
					printWithType("Received", received, printReceived)
				)
			)
		)
	end
end

return spyMatchers
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="245">
              <Properties>
                <string name="Name">toThrowMatchers</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/toThrowMatchers.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local getType = require(Packages.JestGetType).getType

local LuauPolyfill = require(Packages.LuauPolyfill)
local instanceof = LuauPolyfill.instanceof
local Error = LuauPolyfill.Error
type Function = (...any) -> any?
local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp
type Object = LuauPolyfill.Object
type Error = LuauPolyfill.Error

local JestMatcherUtils = require(Packages.JestMatcherUtils)
local EXPECTED_COLOR = JestMatcherUtils.EXPECTED_COLOR
local RECEIVED_COLOR = JestMatcherUtils.RECEIVED_COLOR
local matcherErrorMessage = JestMatcherUtils.matcherErrorMessage
local matcherHint = JestMatcherUtils.matcherHint
local printDiffOrStringify = JestMatcherUtils.printDiffOrStringify
local printExpected = JestMatcherUtils.printExpected
local printReceived = JestMatcherUtils.printReceived
local printWithType = JestMatcherUtils.printWithType
local stringify = JestMatcherUtils.stringify
type MatcherHintOptions = JestMatcherUtils.MatcherHintOptions

local JestMessageUtil = require(Packages.JestMessageUtil)
local formatStackTrace = JestMessageUtil.formatStackTrace

local Print = require(CurrentModule.print)
local printExpectedConstructorName = Print.printExpectedConstructorName
local printExpectedConstructorNameNot = Print.printExpectedConstructorNameNot
local printReceivedConstructorName = Print.printReceivedConstructorName
local printReceivedConstructorNameNot = Print.printReceivedConstructorNameNot
local printReceivedStringContainExpectedResult = Print.printReceivedStringContainExpectedResult
local printReceivedStringContainExpectedSubstring = Print.printReceivedStringContainExpectedSubstring

local Types = require(CurrentModule.types)
type ExpectationResult = Types.ExpectationResult
type MatcherState = Types.MatcherState
type MatchersObject = Types.MatchersObject
type RawMatcherFn = Types.RawMatcherFn_
type SyncExpectationResult = Types.SyncExpectationResult

local isError = require(CurrentModule.utils).isError

local DID_NOT_THROW = "Received function never threw"

type Thrown = {
	hasMessage: boolean,
	isError: boolean,
	message: string,
	value: any,
}

local toThrowExpectedRegExp, toThrowExpectedAsymmetric, toThrowExpectedObject, toThrowExpectedClass
local toThrowExpectedString, toThrow, formatExpected, formatReceived, formatStack

local function getThrown(e: any): Thrown
	-- ROBLOX deviation: hasMessage is also considered true if message is a table
	local hasMessage = e ~= nil and (typeof(e.message) == "string" or typeof(e.message) == "table")

	if hasMessage and typeof(e.name) == "string" and typeof(e.stack) == "string" then
		return {
			hasMessage = hasMessage,
			isError = true,
			message = e.message,
			value = e,
		}
	end

	-- We include the following cases for completeness but based on our
	-- ROBLOX deviation of always printing the stack trace even for non-errors
	-- we should always be in the case above
	if hasMessage then
		return {
			hasMessage = hasMessage,
			isError = false,
			message = e.message,
			value = e,
		}
	else
		return {
			hasMessage = hasMessage,
			isError = false,
			message = tostring(e),
			value = e,
		}
	end
end

local function createMatcher(matcherName: string, fromPromise: boolean?): RawMatcherFn
	return function(this: MatcherState, received: any, expected: any): ExpectationResult
		local options: MatcherHintOptions = {
			isNot = this.isNot,
			promise = this.promise,
		}

		local thrown = nil

		if fromPromise and isError(received) then
			thrown = getThrown(received)
		else
			-- ROBLOX deviation: we also allow received to be a table with a __call metamethod
			if
				typeof(received) ~= "function"
				and not (typeof(received) == "table" and getmetatable(received) and getmetatable(received).__call)
			then
				if not fromPromise then
					local placeholder

					if expected == nil then
						placeholder = ""
					else
						placeholder = "expected"
					end

					error(
						Error(
							matcherErrorMessage(
								matcherHint(matcherName, nil, placeholder, options),
								RECEIVED_COLOR("received") .. " value must be a function",
								printWithType("Received", received, printReceived)
							)
						)
					)
				end
			else
				--[[[
					deviation: error handling in Lua requires us to set the
					stack manually as opposed to relying on the Error object
					to automatically set it.

					deviation: we print the stack for more cases than just
					throwing an Error object since a typical use case in Lua
					would be error("string") and it would be useful to have
					stack trace information for such a case
				]]

				local function getTopStackEntry(stack)
					return string.match(stack, "[^\n]+")
				end
				-- Function used to compare stack traces and cut out unnecessary
				-- information of function calls that are internal to the testing
				-- framework
				local function diffStack(compareStack, currentStack): string?
					local relevantStack = ""
					local lastRelevantStack = ""
					local topCompareStackLine = getTopStackEntry(compareStack)
					for line in string.gmatch(currentStack, "[^\n]+") do
						if line == topCompareStackLine then
							-- we need to exclude the last thing in Stack since
							-- we have a call for the received() function in the
							-- xpcall above so we return lastRelevantStack
							return lastRelevantStack
						end
						lastRelevantStack = relevantStack
						relevantStack = relevantStack .. "\n" .. line
					end

					return nil
				end

				local compareStack
				local ok, e = xpcall(function()
					compareStack = debug.traceback(nil :: any, 2)
					received()
				end, function(error_)
					if error_ == nil then
						error_ = "nil"
						-- if they specify a table with a message field we treat
						-- that as something they wanted to use to compare their error
						-- message against
					elseif getType(error_) == "error" or (typeof(error_) == "table" and error_.message) then
						-- Set the stack if it has not been given a value by the user
						if error_.stack == nil then
							error_.stack = diffStack(compareStack, debug.traceback())
						else
							if not error_.stack:find("ThrowMatchers%-test%.js") then
								error_.stack = diffStack(compareStack, error_.stack)
							end
						end
						return error_
					elseif typeof(error_) == "string" then
						-- This regex strips out the first part of the error message which typically
						-- looks like LoadedCode....:line_number
						-- The reason we do this is because that information is already reported
						-- as part of the stack trace for a failing error

						-- Important note:
						--[[
							If we had code where we do

								error("Error1")

							but this error is later handled in a typical lua way of using a pcall
							that sets ok, err such as

								if not ok then
									error(string.format('Error2: %s', err))
								end

							then we would have a resulting error message that is something like

								LoadedCode...:line_number1: Error2: LoadedCode...:line_number2: Error1

							in this case, the purpose of the regex is simply to strip out the outermost
							LoadedCode...:line_number string and leave

								Error2: LoadedCode...:line_number2: Error1

							The reason we leave this in is because that LoadedCode...line_number2 string
							is not reported as part of the stack trace anywhere since it was captured and
							re-errored
						]]
						local errorRegex = "[%S+\\.]+:[0-9]+:%s(.*)"
						local _, _, result = error_:find(errorRegex)
						if result ~= nil then
							error_ = result
						end
					elseif typeof(error_) == "table" then
						error_ = stringify(error_)
					end

					local errorObject = Error.new(error_)
					-- ROBLOX NOTE: using LuauPolyfill's private method to capture the stacktrace without this function
					Error.__captureStackTrace(errorObject, 3)
					local _, end_ = string.find(
						errorObject.stack :: string,
						getTopStackEntry(errorObject.stack :: string) :: string,
						1,
						true
					)
					errorObject.stack = string.sub(errorObject.stack :: string, (end_ :: number) + 1 + string.len("\n"))
					errorObject.stack = diffStack(compareStack, errorObject.stack :: string)
					errorObject["$$robloxInternalJestError"] = true

					-- ROBLOX FIXME: can we return from xpcall error handler?
					return (errorObject :: any) :: never
				end)

				if not ok then
					thrown = getThrown(e)
				end
			end
		end

		if expected == nil then
			return toThrow(matcherName, options, thrown)
		elseif typeof(expected) == "table" and typeof(expected.asymmetricMatch) == "function" then
			return toThrowExpectedAsymmetric(matcherName, options, thrown, expected)
		elseif typeof(expected) == "string" then
			return toThrowExpectedString(matcherName, options, thrown, expected)
		elseif getType(expected) == "regexp" then
			return toThrowExpectedRegExp(matcherName, options, thrown, expected)
		elseif
			typeof(expected) == "table"
			and typeof(expected.test) == "function"
			and typeof(expected.exec) == "function"
		then
			return toThrowExpectedRegExp(matcherName, options, thrown, expected)
			-- ROBLOX deviation: we have different logic for determining if expected is an Error class
		elseif typeof(expected) == "table" and not expected.message then
			return toThrowExpectedClass(matcherName, options, thrown, expected)
		elseif typeof(expected) == "table" then
			return toThrowExpectedObject(matcherName, options, thrown, expected)
		else
			error(
				Error(
					matcherErrorMessage(
						matcherHint(matcherName, nil, nil, options),
						EXPECTED_COLOR("expected") .. " value must be a string or regular expression or class or error",
						printWithType("Expected", expected, printExpected)
					)
				)
			)
		end
	end
end

local matchers = {
	toThrow = createMatcher("toThrow"),
	toThrowError = createMatcher("toThrowError"),
}

--[[
	deviation: In all of the following toThrow functions,
	we have checks to see if we captured an internal error.
	We need to do this because we are returning an error/table
	every time from our error handler but we don't always want to treat the
	result as having thrown an Error. i.e. we don't want to treat error('simple')
	as error(Error('simple'))
]]

-- ROBLOX deviation: expected does not have RegExp type annotation
function toThrowExpectedRegExp(
	matcherName: string,
	options: JestMatcherUtils.MatcherHintOptions,
	thrown: Thrown | nil,
	expected: RegExp
): SyncExpectationResult
	local pass = thrown ~= nil and expected:test(thrown.message)

	local message
	if pass then
		-- ROBLOX deviation START: assertion to help analyze
		assert(thrown ~= nil)
		-- ROBLOX deviation END
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected pattern: never ", expected)

			if thrown ~= nil and thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
				retval = retval
					.. formatReceived("Received message:       ", thrown, "message", expected)
					.. formatStack(thrown)
			else
				retval = retval .. formatReceived("Received value:         ", thrown, "message") .. formatStack(thrown)
			end

			return retval
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected pattern: ", expected)

			if thrown == nil then
				retval = retval .. "\n" .. DID_NOT_THROW
			else
				if thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
					retval = retval .. formatReceived("Received message: ", thrown, "message") .. formatStack(thrown)
				else
					retval = retval .. formatReceived("Received value:   ", thrown, "message") .. formatStack(thrown)
				end
			end

			return retval
		end
	end

	return { message = message, pass = pass }
end

type AsymmetricMatcher = {
	asymmetricMatch: (any, any) -> boolean,
}

function toThrowExpectedAsymmetric(
	matcherName: string,
	options: JestMatcherUtils.MatcherHintOptions,
	thrown: Thrown | nil,
	expected: AsymmetricMatcher
): SyncExpectationResult
	local pass = thrown ~= nil and expected:asymmetricMatch(thrown.value)

	local message
	if pass then
		-- ROBLOX deviation START: assertion to help analyze
		assert(thrown ~= nil)
		-- ROBLOX deviation END
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected asymmetric matcher: never ", expected)
				.. "\n"

			if thrown ~= nil and thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
				retval = retval
					.. formatReceived("Received name:    ", thrown, "name")
					.. formatReceived("Received message: ", thrown, "message")
					.. formatStack(thrown)
			else
				retval = retval .. formatReceived("Thrown value: ", thrown, "message") .. formatStack(thrown)
			end

			return retval
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected asymmetric matcher: ", expected)
				.. "\n"

			if thrown == nil then
				retval = retval .. DID_NOT_THROW
			else
				if thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
					retval = retval
						.. formatReceived("Received name:    ", thrown, "name")
						.. formatReceived("Received message: ", thrown, "message")
						.. formatStack(thrown)
				else
					retval = retval .. formatReceived("Thrown value: ", thrown, "message") .. formatStack(thrown)
				end
			end

			return retval
		end
	end

	return { message = message, pass = pass }
end

-- ROBLOX deviation: expected does not have Error type annotation
function toThrowExpectedObject(
	matcherName: string,
	options: JestMatcherUtils.MatcherHintOptions,
	thrown: Thrown | nil,
	expected: Error
): SyncExpectationResult
	local pass = thrown ~= nil and thrown.message == expected.message

	local message
	if pass then
		-- ROBLOX deviation START: assertion to help analyze
		assert(thrown ~= nil)
		-- ROBLOX deviation END
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected message: never ", expected.message)

			if thrown ~= nil and thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
				retval = retval .. formatStack(thrown)
			else
				retval = retval .. formatReceived("Received value:         ", thrown, "message") .. formatStack(thrown)
			end

			return retval
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options) .. "\n\n"

			if thrown == nil then
				retval = retval .. formatExpected("Expected message: ", expected.message) .. "\n" .. DID_NOT_THROW
			else
				if thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
					retval = retval
						.. printDiffOrStringify(
							expected.message,
							thrown.message,
							"Expected message",
							"Received message",
							true
						)
						.. "\n"
						.. formatStack(thrown)
				else
					retval = retval
						.. formatExpected("Expected message: ", expected.message)
						.. formatReceived("Received value:   ", thrown, "message")
						.. formatStack(thrown)
				end
			end

			return retval
		end
	end

	return { message = message, pass = pass }
end

-- ROBLOX deviation: expected does not have Function type annotation
function toThrowExpectedClass(
	matcherName: string,
	options: JestMatcherUtils.MatcherHintOptions,
	thrown: Thrown,
	expected: Function
): SyncExpectationResult
	local function isClass(a: any)
		return a and getmetatable(a) and getmetatable(a).__index
	end

	local pass = thrown ~= nil and thrown.value ~= nil and instanceof(thrown.value, expected)

	local message
	if pass then
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printExpectedConstructorNameNot("Expected constructor", expected)
			if
				thrown ~= nil
				and isClass(thrown.value)
				and isClass(expected)
				and getmetatable(thrown.value).__index ~= expected
				and not thrown.value["$$robloxInternalJestError"]
			then
				retval = retval
					.. printReceivedConstructorNameNot("Received constructor", getmetatable(thrown.value), expected)
			end

			retval = retval .. "\n"

			if thrown ~= nil and thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
				retval = retval .. formatReceived("Received message: ", thrown, "message") .. formatStack(thrown)
			else
				retval = retval .. formatReceived("Received value: ", thrown, "message") .. formatStack(thrown)
			end

			return retval
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. printExpectedConstructorName("Expected constructor", expected)

			if thrown == nil then
				retval = retval .. "\n" .. DID_NOT_THROW
			else
				if thrown.value ~= nil and isClass(thrown.value) and not thrown.value["$$robloxInternalJestError"] then
					retval = retval .. printReceivedConstructorName("Received constructor", getmetatable(thrown.value))
				end

				retval = retval .. "\n"

				if thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
					retval = retval .. formatReceived("Received message: ", thrown, "message") .. formatStack(thrown)
				else
					retval = retval .. formatReceived("Received value: ", thrown, "message") .. formatStack(thrown)
				end
			end

			return retval
		end
	end

	return { message = message, pass = pass }
end

function toThrowExpectedString(
	matcherName: string,
	options: JestMatcherUtils.MatcherHintOptions,
	thrown: Thrown | nil,
	expected: string
): SyncExpectationResult
	local pass = false
	-- ROBLOX deviation: thrown.message can be nil or a table, so ensure it is a string before calling find
	if thrown ~= nil and typeof(thrown.message) == "string" and thrown.message:find(expected, 1, true) then
		pass = true
	end

	local message
	if pass then
		-- ROBLOX deviation START: assertion to help analyze
		assert(thrown ~= nil)
		-- ROBLOX deviation END
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected substring: never ", expected)

			if thrown ~= nil and thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
				retval = retval
					.. formatReceived("Received message:         ", thrown, "message", expected)
					.. formatStack(thrown)
			else
				retval = retval
					.. formatReceived("Received value:           ", thrown, "message")
					.. formatStack(thrown)
			end

			return retval
		end
	else
		message = function()
			local retval = matcherHint(matcherName, nil, nil, options)
				.. "\n\n"
				.. formatExpected("Expected substring: ", expected)

			if thrown == nil then
				retval = retval .. "\n" .. DID_NOT_THROW
			else
				if thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
					retval = retval .. formatReceived("Received message:   ", thrown, "message") .. formatStack(thrown)
				else
					retval = retval .. formatReceived("Received value:     ", thrown, "message") .. formatStack(thrown)
				end
			end

			return retval
		end
	end

	return { message = message, pass = pass }
end

function toThrow(matcherName: string, options: MatcherHintOptions, thrown: Thrown | nil): SyncExpectationResult
	local pass = thrown ~= nil

	local message

	if pass then
		-- ROBLOX deviation START: assertion to help analyze
		assert(thrown ~= nil)
		-- ROBLOX deviation END
		message = function()
			local retval = matcherHint(matcherName, nil, "", options) .. "\n\n"

			if thrown ~= nil and thrown.hasMessage and not thrown.value["$$robloxInternalJestError"] then
				retval = retval
					.. formatReceived("Error name:    ", thrown, "name")
					.. formatReceived("Error message: ", thrown, "message")
					.. formatStack(thrown)
			else
				retval = retval .. formatReceived("Thrown value: ", thrown, "message") .. formatStack(thrown)
			end

			return retval
		end
	else
		message = function()
			return matcherHint(matcherName, nil, "", options) .. "\n\n" .. DID_NOT_THROW
		end
	end

	return { message = message, pass = pass }
end

function formatExpected(label: string, expected: any)
	return label .. printExpected(expected) .. "\n"
end

-- ROBLOX deviation: expected does not have string | RegExp type annotation
function formatReceived(
	label: string,
	thrown: Thrown, -- ROBLOX FIXME: narrowing | nil,
	key: string,
	expected: any -- ROBLOX FIXME: narrowing string | RegExp
)
	if thrown == nil then
		return ""
	end

	if key == "message" then
		local message = thrown.message

		if typeof(expected) == "string" then
			local index = message:find(expected)

			if index then
				return label .. printReceivedStringContainExpectedSubstring(message, index, #expected) .. "\n"
			end
		elseif getType(expected) == "regexp" then
			-- ROBLOX deviation: we don't check for expected.exec being a function
			-- since all RegExp polyfill instances have this function defined
			return label .. printReceivedStringContainExpectedResult(message, expected:exec(message)) .. "\n"
		end

		return label .. printReceived(message) .. "\n"
	end

	if key == "name" then
		if thrown.isError then
			return label .. printReceived(thrown.value.name) .. "\n"
		else
			return ""
		end
	end

	if key == "value" then
		if thrown.isError then
			return ""
		else
			return label .. printReceived(thrown.value) .. "\n"
		end
	end

	return ""
end

function formatStack(thrown: Thrown) -- ROBLOX FIXME: narrowing | nil)
	if thrown == nil or not thrown.isError then
		return ""
	else
		return formatStackTrace(thrown.value.stack, { testMatch = {} }, { noStackTrace = true })
	end
end

return {
	createMatcher = createMatcher,
	matchers = matchers,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="246">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/types.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>
type Record<K, T> = { [K]: T }
type Partial<T> = any
type Promise<T> = LuauPolyfill.Promise<T>
type PromiseLike<T> = LuauPolyfill.PromiseLike<T>
type Function = (...any) -> any
type Object = LuauPolyfill.Object
local JestMatcherUtils = require(Packages.JestMatcherUtils)

export type SyncExpectationResult = {
	pass: boolean,
	message: () -> string,
}

export type AsyncExpectationResult = Promise<SyncExpectationResult>

export type ExpectationResult = SyncExpectationResult | AsyncExpectationResult

--[[
	ROBLOX TODO: add default generic param when possible
	original code:
	export type RawMatcherFn<T extends MatcherState = MatcherState> = {
]]
-- ROBLOX FIXME: add Symbol to the definition: [INTERNAL_MATCHER_FLAG]: boolean?
export type RawMatcherFn<T> = any
-- ROBLOX FIXME: workaround for defult generic param
export type RawMatcherFn_ = RawMatcherFn<MatcherState>
-- ROBLOX deviation: currently no way – type the __call metamethod
-- {
--   __call: (any, any, any?) -> ExpectationResult,
-- -- ROBLOX deviation: [INTERNAL_MATCHER_FLAG]: boolean?
--   [Symbol]: boolean?
-- }

export type ThrowingMatcherFn = (any) -> ()
export type PromiseMatcherFn = (any) -> Promise<nil>

export type MatcherUtils = {
	dontThrow: (self: MatcherUtils) -> (),
	equals: EqualsFunction,
	utils: typeof(JestMatcherUtils) & { iterableEquality: Tester, subsetEquality: Tester },
}

type EqualsFunction = (a: unknown, b: unknown, customTesters: Array<Tester>?, strictCheck: boolean?) -> boolean
export type Tester = (any, any) -> boolean?

export type MatcherState = {
	assertionCalls: number,
	currentTestName: string?,
	dontThrow: (() -> ())?,
	error: Error?,
	equals: (any, any, Array<Tester>?, boolean?) -> boolean,
	expand: boolean?,
	expectedAssertionsNumber: number?,
	expectedAssertionsNumberError: Error?,
	isExpectingAssertions: boolean?,
	isExpectingAssertionsError: Error?,
	isNot: boolean,
	promise: string,
	suppressedErrors: Array<Error>,
	testPath: any, -- ROBLOX TODO: Config.Path?,
	utils: Object, -- ROBLOX deviation: no easy way to port to Lua: typeof jestMatcherUtils & {
	--   iterableEquality: Tester;
	--   subsetEquality: Tester;
	-- }
}

export type AsymmetricMatcher = {
	asymmetricMatch: (self: AsymmetricMatcher, other: unknown) -> boolean,
	toString: (self: AsymmetricMatcher) -> string,
	getExpectedType: ((self: AsymmetricMatcher) -> string)?,
	toAsymmetricMatcher: ((self: AsymmetricMatcher) -> string)?,
}

--[[
	ROBLOX TODO: add default generic param when possible
	original code:
	export type MatchersObject<T extends MatcherState = MatcherState> = {
]]
export type MatchersObject = { [string]: RawMatcherFn_ }
-- ROBLOX FIXME: workaround for defult generic param
export type ExpectedAssertionsErrors = Array<{
	actual: string | number,
	error: Error,
	expected: string,
}>

-- ROBLOX deviation start: no Omit utility in Luau
type AsymmetricMatchersOmitAnyAndAnything = {
	arrayContaining: (Array<unknown>) -> AsymmetricMatcher,
	closeTo: (number, number?) -> AsymmetricMatcher,
	objectContaining: (Record<string, unknown>) -> AsymmetricMatcher,
	stringContaining: (string) -> AsymmetricMatcher,
	stringMatching: (string | RegExp) -> AsymmetricMatcher,
	-- ROBLOX deviation: Luau-specific callable object matching
	callable: () -> AsymmetricMatcher,
}

type AsymmetricMatchers = {
	any: (unknown) -> AsymmetricMatcher,
	anything: () -> AsymmetricMatcher,
	nothing: () -> AsymmetricMatcher,
} & AsymmetricMatchersOmitAnyAndAnything
-- ROBLOX deviation end

export type ExpectObj<State = MatcherState> = {
	-- TODO: this is added by test runners, not `expect` itself
	addSnapshotSerializer: (any) -> (),
	assertions: (number) -> (),
	-- TODO: remove this `T extends` - should get from some interface merging
	extend: (MatchersObject) -> (),
	extractExpectedAssertionsErrors: () -> ExpectedAssertionsErrors,
	getState: () -> State,
	hasAssertions: () -> (),
	setState: (Partial<MatcherState>) -> (),
} & AsymmetricMatchers & {
	never: AsymmetricMatchersOmitAnyAndAnything,
}

-- This is a copy from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/de6730f4463cba69904698035fafd906a72b9664/types/jest/index.d.ts#L570-L817
export type Matchers<R, T> = {
	-- /**
	-- * Ensures the last call to a mock function was provided specific args.
	-- */
	lastCalledWith: (...any) -> R,
	-- /**
	-- * Ensure that the last call to a mock function has returned a specified value.
	-- */
	lastReturnedWith: (any) -> R,
	-- /**
	-- * If you know how to test something, `.not` lets you test its opposite.
	-- */
	-- ROBLOX deviation: use never instead of not to avoid use of Lua key word
	never: Matchers<R, T>,
	-- /**
	-- * Ensure that a mock function is called with specific arguments on an Nth call.
	-- */
	nthCalledWith: (number, ...any) -> R,
	-- /**
	-- * Ensure that the nth call to a mock function has returned a specified value.
	-- */
	nthReturnedWith: (number, any) -> R,
	-- ROBLOX TODO: (LUAU) fix types for resolves and rejects
	-- /**
	-- * Use resolves to unwrap the value of a fulfilled promise so any other
	-- * matcher can be chained. If the promise is rejected the assertion fails.
	-- */
	resolves: any,
	-- /**
	-- * Unwraps the reason of a rejected promise so any other matcher can be chained.
	-- * If the promise is fulfilled the assertion fails.
	-- */
	rejects: any,
	-- /**
	-- * Checks that a value is what you expect. It uses `===` to check strict equality.
	-- * Don't use `toBe` with floating-point numbers.
	-- */
	toBe: (any) -> R,
	-- /**
	-- * Ensures that a mock function is called.
	-- */
	toBeCalled: () -> R,
	-- /**
	--  * Ensures that a mock function is called an exact number of times.
	--  */
	toBeCalledTimes: (number) -> R,
	-- /**
	--  * Ensure that a mock function is called with specific arguments.
	--  */
	toBeCalledWith: (...any) -> R,
	-- /**
	--  * Using exact equality with floating point numbers is a bad idea.
	--  * Rounding means that intuitive things fail.
	--  * The default for `precision` is 2.
	--  */
	toBeCloseTo: (number, precision: number?) -> R,
	-- /**
	--  * Ensure that a variable is not undefined.
	--  */
	toBeDefined: () -> R,
	-- /**
	--  * When you don't care what a value is, you just want to
	--  * ensure a value is false in a boolean context.
	--  */
	toBeFalsy: () -> R,
	-- /**
	--  * For comparing floating point numbers.
	--  */
	toBeGreaterThan: (number) -> R,
	-- /**
	--  * For comparing floating point numbers.
	--  */
	toBeGreaterThanOrEqual: (number) -> R,
	-- /**
	--  * Ensure that an object is an instance of a class.
	--  * This matcher uses `instanceof` underneath.
	--  */
	toBeInstanceOf: (unknown) -> R,
	-- /**
	--  * For comparing floating point numbers.
	--  */
	toBeLessThan: (number) -> R,
	-- /**
	--  * For comparing floating point numbers.
	--  */
	toBeLessThanOrEqual: (number) -> R,
	-- /**
	--  * This is the same as `.toBe(null)` but the error messages are a bit nicer.
	--  * So use `.toBeNull()` when you want to check that something is null.
	--  */
	toBeNull: () -> R,
	-- ROBLOX deviation START: add Luau specific matcher for nil
	toBeNil: () -> R,
	-- ROBLOX deviation END
	-- /**
	--  * Use when you don't care what a value is, you just want to ensure a value
	--  * is true in a boolean context. In JavaScript, there are six falsy values:
	--  * `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Everything else is truthy.
	--  */
	toBeTruthy: () -> R,
	-- /**
	--  * Used to check that a variable is undefined.
	--  */
	toBeUndefined: () -> R,
	-- /**
	--  * Used to check that a variable is NaN.
	--  */
	toBeNaN: () -> R,
	-- /**
	--  * Used when you want to check that an item is in a list.
	--  * For testing the items in the list, this uses `===`, a strict equality check.
	--  */
	toContain: (any) -> R,
	-- /**
	--  * Used when you want to check that an item is in a list.
	--  * For testing the items in the list, this  matcher recursively checks the
	--  * equality of all fields, rather than checking for object identity.
	--  */
	toContainEqual: (any) -> R,
	-- /**
	--  * Used when you want to check that two objects have the same value.
	--  * This matcher recursively checks the equality of all fields, rather than checking for object identity.
	--  */
	toEqual: (any) -> R,
	-- /**
	--  * Ensures that a mock function is called.
	--  */
	toHaveBeenCalled: () -> R,
	-- /**
	--  * Ensures that a mock function is called an exact number of times.
	--  */
	toHaveBeenCalledTimes: (number) -> R,
	-- /**
	--  * Ensure that a mock function is called with specific arguments.
	--  */
	toHaveBeenCalledWith: (...any) -> R,
	-- /**
	--  * Ensure that a mock function is called with specific arguments on an Nth call.
	--  */
	toHaveBeenNthCalledWith: (number, ...any) -> R,
	-- /**
	--  * If you have a mock function, you can use `.toHaveBeenLastCalledWith`
	--  * to test what arguments it was last called with.
	--  */
	toHaveBeenLastCalledWith: (...any) -> R,
	-- /**
	--  * Use to test the specific value that a mock function last returned.
	--  * If the last call to the mock function threw an error, then this matcher will fail
	--  * no matter what value you provided as the expected return value.
	--  */
	toHaveLastReturnedWith: (any) -> R,
	-- /**
	--  * Used to check that an object has a `.length` property
	--  * and it is set to a certain numeric value.
	--  */
	toHaveLength: (number) -> R,
	-- /**
	--  * Use to test the specific value that a mock function returned for the nth call.
	--  * If the nth call to the mock function threw an error, then this matcher will fail
	--  * no matter what value you provided as the expected return value.
	--  */
	toHaveNthReturnedWith: (number, any) -> R,
	-- /**
	--  * Use to check if property at provided reference keyPath exists for an object.
	--  * For checking deeply nested properties in an object you may use dot notation or an array containing
	--  * the keyPath for deep references.
	--  *
	--  * Optionally, you can provide a value to check if it's equal to the value present at keyPath
	--  * on the target object. This matcher uses 'deep equality' (like `toEqual()`) and recursively checks
	--  * the equality of all fields.
	--  *
	--  * @example
	--  *
	--  * expect(houseForSale).toHaveProperty('kitchen.area', 20),
	--  */
	toHaveProperty: (string | Array<string>, any?) -> R,
	-- /**
	--  * Use to test that the mock function successfully returned (i.e., did not throw an error) at least one time
	--  */
	toHaveReturned: () -> R,
	-- /**
	--  * Use to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times.
	--  * Any calls to the mock function that throw an error are not counted toward the number of times the function returned.
	--  */
	toHaveReturnedTimes: (number) -> R,
	-- /**
	--  * Use to ensure that a mock function returned a specific value.
	--  */
	toHaveReturnedWith: (any) -> R,
	-- /**
	--  * Check that a string matches a regular expression.
	--  */
	toMatch: (string | RegExp) -> R,
	-- /**
	--  * Used to check that a JavaScript object matches a subset of the properties of an object
	--  */
	toMatchObject: (Record<string, unknown> | Array<Record<string, unknown>>) -> R,
	-- /**
	--  * Ensure that a mock function has returned (as opposed to thrown) at least once.
	--  */
	toReturn: () -> R,
	-- /**
	--  * Ensure that a mock function has returned (as opposed to thrown) a specified number of times.
	--  */
	toReturnTimes: (number) -> R,
	-- /**
	--  * Ensure that a mock function has returned a specified value at least once.
	--  */
	toReturnWith: (any) -> R,
	-- /**
	--  * Use to test that objects have the same types as well as structure.
	--  */
	toStrictEqual: (any) -> R,
	-- /**
	--  * Used to test that a function throws when it is called.
	--  */
	toThrow: (unknown?) -> R,
	-- /**
	--  * If you want to test that a specific error is thrown inside a function.
	--  */
	toThrowError: (unknown?) -> R,

	--[[ TODO: START snapshot matchers are not from `expect`, the types should not be here ]]
	--[[*
	 * This ensures that a value matches the most recent snapshot with property matchers.
	 * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.
	]]
	-- ROBLOX deviation START: Luau doesn't support method overloads so we need to include only one declaration satifsying all cases
	-- toMatchSnapshot: (string?) -> R,
	-- ROBLOX deviation END
	--[[*
	 * This ensures that a value matches the most recent snapshot.
	 * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.
	]]
	-- ROBLOX deviation START: Luau doesn't support method overloads so we need to include only one declaration satifsying all cases
	-- toMatchSnapshot: (string?) -> R,
	--    toMatchSnapshot<T extends {[P in keyof R]: unknown}>(
	--     propertyMatchers: Partial<T>,
	--     hint?: string,
	--   ): R;
	toMatchSnapshot: <T>(hintOrPropertyMatchers: string? | Partial<T>, hint: string?) -> R,
	-- ROBLOX deviation END

	-- /**
	--  * This ensures that a value matches the most recent snapshot with property matchers.
	--  * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.
	--  * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.
	--  */
	-- ROBLOX TODO: function generics and function overloads
	-- toMatchInlineSnapshot<T extends {[P in keyof R]: any}>(
	-- /**
	--  * This ensures that a value matches the most recent snapshot with property matchers.
	--  * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.
	--  * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.
	--  */
	toMatchInlineSnapshot: (string?) -> R,
	-- /**
	--  * Used to test that a function throws a error matching the most recent snapshot when it is called.
	--  */
	toThrowErrorMatchingSnapshot: () -> R,
	-- /**
	--  * Used to test that a function throws a error matching the most recent snapshot when it is called.
	--  * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.
	--  */
	toThrowErrorMatchingInlineSnapshot: (string?) -> R,
	-- /* TODO: END snapshot matchers are not from `expect`, the types should not be here */
	-- ROBLOX deviation START: add Roblox specific matchers
	toMatchInstance: (received: any, expected: any) -> R,
	-- ROBLOX deviation END
}
-- ROBLOX FIXME: workaround for defult generic param
export type Matchers_<R> = Matchers<R, unknown>

-- ROBLOX deviation START: had to move the Expect type definition below matchers to fix analyze issues
export type Expect<State = MatcherState> =
	typeof(setmetatable({}, { __call = (function() end :: any) :: <T>(self: any, actual: T) -> Matchers<nil, T> }))
	& ExpectObj<State>
-- ROBLOX FIXME: workaround for defult generic param
export type Expect_ =
	typeof(setmetatable({}, { __call = (function() end :: any) :: <T>(self: any, actual: T) -> Matchers<nil, T> }))
	& ExpectObj<MatcherState>
-- ROBLOX deviation END

-- ROBLOX deviation START: add additinal type to help with typing extended matchers
export type ExpectExtended<E, State = MatcherState> =
	typeof(setmetatable({}, { __call = (function() end :: any) :: <T>(self: any, actual: T) -> Matchers<nil, T> & E }))
	& ExpectObj<State>
-- ROBLOX deviation END

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="247">
              <Properties>
                <string name="Name">utils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/utils.ts
-- /**
-- * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
-- *
-- * This source code is licensed under the MIT license found in the
-- * LICENSE file in the root directory of this source tree.
-- *
-- */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local instanceof = LuauPolyfill.instanceof
local Object = LuauPolyfill.Object
local RegExp = require(Packages.RegExp)

local RobloxShared = require(Packages.RobloxShared)

-- ROBLOX deviation: omitted isPrimitive import
local jasmineUtils = require(CurrentModule.jasmineUtils)
local equals = jasmineUtils.equals
-- ROBLOX deviation: omitted isA, isImmutableUnorderedKeyed, isImmutableUnorderedSet

type Array<T> = LuauPolyfill.Array<T>

-- ROBLOX deviation start: predefine variables
local pathAsArray
-- ROBLOX deviation end

type GetPath = {
	hasEndProp: boolean?,
	lastTraversedObject: any,
	traversedPath: Array<string>,
	value: any?,
}

-- ROBLOX deviation: helper function moved to RobloxShared and no longer needed here
-- local hasPropertyInObject = RobloxShared.expect.hasPropertyInObject

local function getPath(object: { [string]: any }, propertyPath): GetPath
	if not Array.isArray(propertyPath) then
		propertyPath = pathAsArray(propertyPath)
	end

	if #propertyPath > 0 then
		local lastProp = #propertyPath == 1
		local prop = propertyPath[1]

		-- We need this code block in Lua since attempting object[prop] on a non-table
		-- will throw an error
		local ok, res = pcall(function()
			return object[prop]
		end)

		local newObject = res

		if not ok or (not lastProp and newObject == nil) then
			-- This is not the last prop in the chain. If we keep recursing
			-- we will get a nil access error. At this point we know that the
			-- chain has broken and we can return right away.
			return {
				hasEndProp = false,
				lastTraversedObject = object,
				traversedPath = {},
			}
		end

		local result = getPath(newObject, Array.slice(propertyPath, 2))

		if result.lastTraversedObject == nil then
			result.lastTraversedObject = object
		end

		table.insert(result.traversedPath, 1, prop)

		if lastProp then
			result.hasEndProp = newObject ~= nil

			if not result.hasEndProp then
				Array.shift(result.traversedPath)
			end
		end

		return result
	end

	return {
		lastTraversedObject = nil,
		traversedPath = {},
		value = object,
	}
end

-- ROBLOX deviation: moved to RobloxShared to avoid reaching into internals with rotriever workspaces
local getObjectSubset = RobloxShared.expect.getObjectSubset

-- ROBLOX deviation: omitted IteratorSymbol

-- ROBLOX deviation: currently unused so we comment out hasIterator
-- local function hasIterator(object: any): boolean
-- 	-- technically just the typeof(object) == table check would be sufficient
-- 	-- but to be more accurate we should return true for all types that can be
-- 	-- iterated over in Lua (string and table)
-- 	return typeof(object) == "table" or typeof(object) == "string"
-- end

local iterableEquality = RobloxShared.expect.iterableEquality

-- ROBLOX deviation: helper function moved to RobloxShared and no longer needed here
-- local isObject = RobloxShared.expect.isObject
-- local isObjectWithKeys = RobloxShared.expect.isObjectWithKeys

local subsetEquality = RobloxShared.expect.subsetEquality

local function typeEquality(a: any, b: any): boolean | nil
	if a == nil or b == nil then
		return nil
	end

	if typeof(a) ~= typeof(b) then
		return false
	end

	if not getmetatable(a) and not getmetatable(b) then
		return nil
	end

	if
		getmetatable(a)
		and getmetatable(b)
		and getmetatable(a).__index
		and getmetatable(b).__index
		and getmetatable(a).__index == getmetatable(b).__index
	then
		return nil
	end

	return false
end

-- ROBLOX deviation START: skipped as Lua doesn't support ArrayBuffer

-- local function arrayBufferEquality(
-- 	a: unknown,
-- 	b: unknown
-- ): boolean | nil
-- 	if
-- 		not Boolean.toJSBoolean(
-- 			error('not implemented') --[[ ROBLOX TODO: Unhandled node for type: BinaryExpression ]] --[[ a instanceof ArrayBuffer ]]
-- 		)
-- 		or not Boolean.toJSBoolean(
-- 			error('not implemented') --[[ ROBLOX TODO: Unhandled node for type: BinaryExpression ]] --[[ b instanceof ArrayBuffer ]]
-- 		)
-- 	then
-- 		return nil
-- 	end
-- 	local dataViewA = DataView.new(a)
-- 	local dataViewB = DataView.new(b)
-- 	-- Buffers are not equal when they do not have the same byte length
-- 	if dataViewA.byteLength ~= dataViewB.byteLength then
-- 		return false
-- 	end
-- 	-- Check if every byte value is equal to each other
-- 	local i = 0
-- 	while i < dataViewA.byteLength do
-- 		if dataViewA:getUint8(i) ~= dataViewB:getUint8(i) then
-- 			return false
-- 		end
-- 		i += 1
-- 	end
-- 	return true
-- end
-- ROBLOX deviation END

local function sparseArrayEquality(a: any, b: any): boolean | nil
	if not Array.isArray(a) or not Array.isArray(b) then
		return nil
	end

	local aKeys = Object.keys(a)
	local bKeys = Object.keys(b)

	return  --[[
			ROBLOX TODO: (ADO-1217) replace the line below
			once Map/Set functionality is implemented

			--equals(a, b, {iterableEquality, typeEquality}, true) and
		]]equals(a, b, { typeEquality }, true) and equals(aKeys, bKeys)
end

local function partition<T>(items: Array<T>, predicate: (T) -> boolean): { [number]: Array<T> }
	local result = { {}, {} }

	for _, item in ipairs(items) do
		table.insert(result[predicate(item) and 1 or 2], item)
	end

	return result
end

function pathAsArray(propertyPath: string): Array<any>
	-- will match everything that's not a dot or a bracket, and "" for consecutive dots.
	local pattern = RegExp("[^.[\\]]+|(?=(?:\\.)(?:\\.|$))") -- ROBLOX TODO: add 'g' flag when supported
	local properties: Array<string | number> = {}

	-- Because the regex won't match a dot in the beginning of the path, if present.
	if propertyPath:sub(1, 1) == "." then
		table.insert(properties, "")
	end

	--[[
		ROBLOX deviation: implement the following logic without using String.protorype.replace functionality
		original code:
		propertyPath.replace(pattern, match => {
		  properties.push(match);
		  return match;
		});
	]]
	local totalLength = 0
	local propertyPath_ = propertyPath
	local match = pattern:exec(propertyPath_)
	while match ~= nil and totalLength < #propertyPath do
		local wholeMatch = match[1]
		local wholeMatchEnd = match.index + #wholeMatch
		local matchIndex = totalLength + match.index
		local prevChar = propertyPath:sub(matchIndex - 1, matchIndex - 1)

		-- ROBLOX NOTE: for `[digit]` syntax we need to parse to number so that array indexing works correctly in Lua
		if prevChar == "[" then
			local matchNumber = tonumber(wholeMatch, 10)
			if matchNumber then
				table.insert(properties, matchNumber)
			else
				table.insert(properties, wholeMatch)
			end
		else
			table.insert(properties, wholeMatch)
		end
		totalLength += wholeMatchEnd

		propertyPath_ = propertyPath_:sub(wholeMatchEnd + 1)
		match = pattern:exec(propertyPath_)
	end
	-- ROBLOX deviation END

	return properties
end

-- ROBLOX deviation START: Custom implementation
local function isError(value: any): any
	return instanceof(value, Error)
end
-- ROBLOX deviation END

local function emptyObject(obj: any): boolean
	return typeof(obj) == "table" and #Object.keys(obj) == 0 or false
end

local MULTILINE_REGEXP = "[\r\n]"

local function isOneline(expected: any, received: any): boolean
	return typeof(expected) == "string"
		and typeof(received) == "string"
		and (not received:match(MULTILINE_REGEXP) or not expected:match(MULTILINE_REGEXP))
end

--[[
	ROBLOX TODO: (ADO-1217) uncomment the iterableEquality export once the
	function has been properly implemented
]]
return {
	getPath = getPath,
	getObjectSubset = getObjectSubset,
	iterableEquality = iterableEquality,
	subsetEquality = subsetEquality,
	-- ROBLOX deviation: Roblox Instance matchers
	-- ROBLOX TODO: uncomment when implementing snapshot property matchers on Instances
	-- instanceSubsetEquality = RobloxShared.RobloxInstance.instanceSubsetEquality,
	typeEquality = typeEquality,
	-- ROBLOX deviation: skipped as Lua doesn't support ArrayBuffer
	-- arrayBufferEquality = arrayBufferEquality,
	sparseArrayEquality = sparseArrayEquality,
	partition = partition,
	pathAsArray = pathAsArray,
	isError = isError,
	emptyObject = emptyObject,
	isOneline = isOneline,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="248">
            <Properties>
              <string name="Name">InstanceOf</string>
              <string name="Source"><![CDATA[local instanceof = require(script.instanceof)

return instanceof
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="249">
              <Properties>
                <string name="Name">instanceof</string>
                <string name="Source"><![CDATA[--!strict
-- polyfill for https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
local __DEV__ = _G.__DEV__

-- FIXME Luau: typing class as Object gives: Type '{ @metatable {| __call: <a>(a, ...any) -> Error, __tostring: <b, c>({+ message: b, name: c +}) -> string |}, Error }' could not be converted into 'table'
local function instanceof(tbl: any, class: any): boolean
	if __DEV__ then
		assert(typeof(class) == "table", "Received a non-table as the second argument for instanceof")
	end

	if typeof(tbl) ~= "table" then
		return false
	end

	local ok, hasNew = pcall(function()
		return class.new ~= nil and tbl.new == class.new
	end)
	if ok and hasNew then
		return true
	end

	local seen = { [tbl] = true }

	while tbl and typeof(tbl) == "table" do
		tbl = getmetatable(tbl)
		if typeof(tbl) == "table" then
			tbl = tbl.__index

			if tbl == class then
				return true
			end
		end

		-- if we still have a valid table then check against seen
		if typeof(tbl) == "table" then
			if seen[tbl] then
				return false
			end
			seen[tbl] = true
		end
	end

	return false
end

return instanceof
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="250">
            <Properties>
              <string name="Name">Jest</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest/src/jest.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent

local exports = {}
local coreModule = require(Packages.JestCore)
exports.SearchSource = coreModule.SearchSource
exports.TestWatcher = coreModule.TestWatcher
exports.createTestScheduler = coreModule.createTestScheduler
-- ROBLOX ROBLOX deviation START: not ported
-- exports.getVersion = coreModule.getVersion
-- ROBLOX deviation END
exports.runCLI = coreModule.runCLI
-- ROBLOX deviation START: JestCli is not ported
-- exports.run = require(Packages.JestCli).run
-- ROBLOX deviation END
return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="251">
            <Properties>
              <string name="Name">JestCircus</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: no upstream
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local circusModule = require(script.circus)

local exports = circusModule

export type Event = circusModule.Event
export type State = circusModule.State

-- ROBLOX deviation: exporting runner alongside the main entry point
local runner = require(script.runner);
(exports :: any).runner = runner

return exports :: typeof(circusModule) & { runner: typeof(runner) }
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="252">
              <Properties>
                <string name="Name">circus</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script
local Packages = CurrentModule.Parent.Parent

-- ROBLOX FIXME
type FIXME_ANALYZE = any

-- ROBLOX deviation START: predefine variables
local _dispatchDescribe: (
	blockFn: Circus_BlockFn,
	blockName: Circus_BlockNameLike,
	describeFn: DescribeFn,
	mode: Circus_BlockMode?
) -> ()
-- ROBLOX deviation END
local exports = {}
local typesModule = require(Packages.JestTypes)
type Circus_HookFn = typesModule.Circus_HookFn
type Circus_HookType = typesModule.Circus_HookType
type Circus_BlockFn = typesModule.Circus_BlockFn
type Circus_BlockNameLike = typesModule.Circus_BlockNameLike
type Circus_TestNameLike = typesModule.Circus_TestNameLike
type Circus_BlockMode = typesModule.Circus_BlockMode
type Circus_TestName = typesModule.Circus_TestName
type Circus_TestFn = typesModule.Circus_TestFn
type Circus_TestMode = typesModule.Circus_TestMode
type Circus_Event = typesModule.Circus_Event
type Circus_State = typesModule.Circus_State
type Global_It = typesModule.Global_It
local bindEach = require(Packages.JestEach).bind
local jest_utilModule = require(Packages.JestUtil)
local ErrorWithStack = jest_utilModule.ErrorWithStack
local convertDescriptorToString = jest_utilModule.convertDescriptorToString
local isPromise = jest_utilModule.isPromise
local dispatchSync = require(script.state).dispatchSync
local stateModule = require(script.state)
exports.setState = stateModule.setState
exports.getState = stateModule.getState
exports.resetState = stateModule.resetState
exports.run = require(script.run).default

type THook = (fn: Circus_HookFn, timeout: number?) -> ()
type DescribeFn = typeof(setmetatable({}, {
	__call = (nil :: any) :: (_self: any, blockName: Circus_BlockNameLike, blockFn: Circus_BlockFn) -> (),
}))

local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error

local describe = (function()
	local describe
	describe = setmetatable({}, {
		__call = function(_self: any, blockName: Circus_BlockNameLike, blockFn: Circus_BlockFn)
			return _dispatchDescribe(blockFn, blockName, describe)
		end,
	})
	local only
	only = setmetatable({}, {
		__call = function(_self: any, blockName: Circus_BlockNameLike, blockFn: Circus_BlockFn)
			return _dispatchDescribe(blockFn, blockName, only, "only")
		end,
	})
	local skip
	skip = setmetatable({}, {
		__call = function(_self: any, blockName: Circus_BlockNameLike, blockFn: Circus_BlockFn)
			return _dispatchDescribe(blockFn, blockName, skip, "skip")
		end,
	})

	describe.each = bindEach(
		-- ROBLOX FIXME: callable table can't be converted to a function
		describe :: FIXME_ANALYZE,
		false
	)

	only.each = bindEach(
		-- ROBLOX FIXME: callable table can't be converted to a function
		only :: FIXME_ANALYZE,
		false
	)
	skip.each = bindEach(
		-- ROBLOX FIXME: callable table can't be converted to a function
		skip :: FIXME_ANALYZE,
		false
	)

	describe.only = only
	describe.skip = skip

	return describe
end)()

function _dispatchDescribe(
	blockFn: Circus_BlockFn,
	blockName: Circus_BlockNameLike,
	describeFn: DescribeFn,
	-- ROBLOX FIXME Luau: can't type it properly as `Circus_BlockMode` because for some reason it conflicts with a predefined value type.
	mode: any?
): ()
	local asyncError = ErrorWithStack.new(
		nil,
		-- ROBLOX FIXME: callable table can't be converted to a function
		describeFn :: FIXME_ANALYZE
	)
	if blockFn == nil then
		asyncError.message = "Missing second argument. It must be a callback function."
		error(asyncError)
	end
	if typeof(blockFn) ~= "function" then
		asyncError.message = ("Invalid second argument, %s. It must be a callback function."):format(blockFn)
		error(asyncError)
	end
	do --[[ ROBLOX COMMENT: try-catch block conversion ]]
		-- ROBLOX deviation START: silence unused 'ok' variable
		-- local ok, result, hasReturned = xpcall(function()
		local _ok, result, hasReturned = xpcall(function()
			-- ROBLOX deviation END
			blockName = convertDescriptorToString(blockName)
		end, function(error_)
			asyncError.message = (error_ :: Error).message
			error(asyncError)
		end)
		-- ROBLOX deviation END
		if hasReturned then
			return result
		end
	end

	dispatchSync({
		asyncError = asyncError,
		-- ROBLOX deviation START: string type has difficulty being inferred via control flow
		-- blockName = blockName,
		blockName = blockName :: string,
		-- ROBLOX deviation END
		mode = mode,
		name = "start_describe_definition",
	})

	-- ROBLOX deviation: casting to any as this is runtime check that is not allowed by type
	local describeReturn = blockFn() :: any
	if isPromise(describeReturn) then
		error(ErrorWithStack.new(
			'Returning a Promise from "describe" is not supported. Tests must be defined synchronously.',
			-- ROBLOX FIXME: callable table can't be converted to a function
			describeFn :: FIXME_ANALYZE
		))
	elseif describeReturn ~= nil then
		error(ErrorWithStack.new(
			'A "describe" callback must not return a value.',
			-- ROBLOX FIXME: callable table can't be converted to a function
			describeFn :: FIXME_ANALYZE
		))
	end

	-- ROBLOX deviation START: string type has difficulty being inferred via control flow
	-- dispatchSync({ blockName = blockName, mode = mode, name = "finish_describe_definition" })
	dispatchSync({ blockName = blockName :: string, mode = mode, name = "finish_describe_definition" })
	-- ROBLOX deviation END
end

local function _addHook(fn: Circus_HookFn, hookType: Circus_HookType, hookFn: THook, timeout: number?)
	local asyncError = ErrorWithStack.new(nil, hookFn)
	if typeof(fn) ~= "function" then
		asyncError.message = "Invalid first argument. It must be a callback function."
		error(asyncError)
	end
	dispatchSync({
		asyncError = asyncError,
		fn = fn,
		hookType = hookType,
		name = "add_hook",
		timeout = timeout,
	})
end

-- Hooks have to pass themselves to the HOF in order for us to trim stack traces.
local beforeEach: THook
function beforeEach(fn, timeout)
	return _addHook(fn, "beforeEach", beforeEach, timeout)
end
local beforeAll: THook
function beforeAll(fn, timeout)
	return _addHook(fn, "beforeAll", beforeAll, timeout)
end
local afterEach: THook
function afterEach(fn, timeout)
	return _addHook(fn, "afterEach", afterEach, timeout)
end
local afterAll: THook
function afterAll(fn, timeout)
	return _addHook(fn, "afterAll", afterAll, timeout)
end

local test: Global_It = (function()
	-- ROBLOX deviation START: predefine variables
	local _addTest: (
		testName: Circus_TestNameLike,
		mode: Circus_TestMode,
		fn: Circus_TestFn | nil,
		testFn: (testName: Circus_TestNameLike, fn: Circus_TestFn, timeout: number?) -> (),
		timeout: number?,
		failing: boolean?
	) -> ()

	-- ROBLOX deviation END
	local test: FIXME_ANALYZE
	test = setmetatable({}, {
		__call = function(_self: any, testName: Circus_TestName, fn: Circus_TestFn, timeout: number?): ()
			return _addTest(testName, nil, fn, test, timeout)
		end,
	})
	local skip: FIXME_ANALYZE
	skip = setmetatable({}, {
		__call = function(_self: any, testName: Circus_TestName, fn: Circus_TestFn?, timeout: number?): ()
			return _addTest(testName, "skip", fn, skip, timeout)
		end,
	})
	local only: FIXME_ANALYZE
	only = setmetatable({}, {
		__call = function(_self: any, testName: Circus_TestName, fn: Circus_TestFn, timeout: number?): ()
			return _addTest(testName, "only", fn, test.only, timeout)
		end,
	})

	function bindFailing(mode: Circus_TestMode)
		function failing(testName: Circus_TestNameLike, fn: Circus_TestFn?, timeout: number?)
			return _addTest(testName, mode, fn, failing, timeout, true)
		end
		return failing
	end

	test.todo = function(testName: Circus_TestName, ...: any): ()
		local rest = { ... }
		if #rest > 0 or typeof(testName) ~= "string" then
			error(ErrorWithStack.new("Todo must be called with only a description.", test.todo))
		end
		return _addTest(testName, "todo", function() end, test.todo)
	end

	function _addTest(
		testName: Circus_TestNameLike,
		mode: Circus_TestMode,
		fn: Circus_TestFn | nil,
		testFn: (testName: Circus_TestName, fn: Circus_TestFn, timeout: number?) -> (),
		timeout: number?,
		failing: boolean?
	): ()
		local asyncError, hasErrored = ErrorWithStack.new(nil, testFn), false

		do --[[ ROBLOX COMMENT: try-catch block conversion ]]
			local _ok, result, hasReturned = xpcall(function()
				testName = convertDescriptorToString(testName)
			end, function(error_)
				asyncError.message = (error_ :: Error).message
				hasErrored = true
			end)
			if hasReturned then
				return result
			end
		end

		if hasErrored then
			error(asyncError)
		end

		if fn == nil then
			asyncError.message =
				"Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder."
			error(asyncError)
		end
		if typeof(fn) ~= "function" then
			asyncError.message = ("Invalid second argument, %s. It must be a callback function."):format(tostring(fn))
			error(asyncError)
		end

		return dispatchSync({
			asyncError = asyncError,
			fn = fn,
			failing = if failing == nil then false else failing,
			mode = mode,
			-- ROBLOX FIXME Luau: roblox-cli doesn't recognize this type as one of the SyncEvent union members
			name = "add_test" :: any,
			testName = testName,
			timeout = timeout,
		})
	end

	test.each = bindEach(test)
	only.each = bindEach(only)
	skip.each = bindEach(skip)

	only.failing = bindFailing("only")
	skip.failing = bindFailing("skip")

	test.failing = bindFailing()
	test.only = only
	test.skip = skip
	return test
end)()
-- ROBLOX FIXME Luau: Argument #4 type is not compatible. Type '(string | string | string)?' could not be converted into '("only" | "skip" | "todo")?'
local it: Global_It = test :: FIXME_ANALYZE
export type Event = Circus_Event
export type State = Circus_State
exports.afterAll = afterAll
exports.afterEach = afterEach
exports.beforeAll = beforeAll
exports.beforeEach = beforeEach
exports.describe = describe
exports.it = it
exports.test = test
exports.default = {
	afterAll = afterAll,
	afterEach = afterEach,
	beforeAll = beforeAll,
	beforeEach = beforeEach,
	describe = describe,
	it = it,
	test = test,
}

return exports
]]></string>
              </Properties>
              <Item class="Folder" referent="253">
                <Properties>
                  <string name="Name">__mocks__</string>
                </Properties>
                <Item class="ModuleScript" referent="254">
                  <Properties>
                    <string name="Name">Module</string>
                    <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
type CleanupFn = () -> any
type Function = (...any) -> any

type FIXME_ANALYZE = (ModuleScript) -> any

local requiredModules: { [ModuleScript]: any } = {}
local moduleCleanup: { [ModuleScript]: (() -> any)? } = {}
local mocks: { [ModuleScript]: CleanupFn } = {}

if _G.__NO_LOADMODULE__ then
	warn("debug.loadmodule not enabled. Test plans relying on resetModules " .. "will not work properly.")

	return {
		requireOverride = require :: FIXME_ANALYZE,
		resetModules = function()
			-- Should we warn on calling this more than once?
		end,
		mock = function(module: ModuleScript, fn: () -> any)
			-- Since we can't mock underneath require, we'll overwrite the
			-- require module altogether with the result of the mock
			local mockResult = fn()
			local realModule = require(module) :: any
			for k, v in pairs(mockResult) do
				realModule[k] = v
			end
			for k, _v in pairs(realModule) do
				if mockResult[k] == nil then
					realModule[k] = nil
				end
			end
		end,
		unmock = function(_module: ModuleScript)
			-- no op
		end,
	}
end

local function requireOverride(scriptInstance: ModuleScript): any
	-- This is crucial! We need to have an early out here so that we don't
	-- override requires of ourself; this would result in the module cache
	-- deviating into a bunch of separate ones.
	--
	-- TODO: This is a little janky, so we should find a way to do this that's a
	-- little more robust. We may want to apply it to anything in RobloxJest?
	if
		scriptInstance == script
		or scriptInstance == script.Parent
		or scriptInstance.Name == "jest-roblox"
		-- for the 2021 version of the Studio Inspector plugin
		or scriptInstance.Name == "DeveloperTools"
	then
		return require(scriptInstance) :: any
	end
	-- FIXME: an extra special hack that prevents us from frequently reloading
	-- `jest-roblox`, and therefore dodges the expensive modules found in:
	-- jest-roblox -> luau-polyfill@0.1.5 -> RegExp
	if scriptInstance.Name == "RegExp" then
		return require(scriptInstance) :: any
	end

	-- If already loaded and cached, return cached module. This should behave
	-- similarly to normal `require` behavior
	if requiredModules[scriptInstance] ~= nil then
		return requiredModules[scriptInstance]
	end

	local moduleResult
	-- First, check the mock cache and see if this is being mocked
	if typeof(mocks[scriptInstance]) == "function" then
		-- ROBLOX FIXME: Luau flow analysis bug workaround
		moduleResult = (mocks[scriptInstance] :: Function)()

		if moduleResult == nil then
			error(
				string.format(
					"[Mock Error]: %s did not return a valid result\n" .. "\tmocks must return a non-nil value",
					tostring(scriptInstance)
				)
			)
		end
	else
		-- Narrowing this type here lets us appease the type checker while still
		-- counting on types for the rest of this file
		local loadmodule: (ModuleScript) -> (any, string, CleanupFn) = debug["loadmodule"]
		local moduleFunction, errorMessage, cleanup = loadmodule(scriptInstance)
		assert(moduleFunction ~= nil, errorMessage)

		getfenv(moduleFunction).require = requireOverride
		-- getfenv(moduleFunction).delay = FakeTimers.delayOverride
		-- getfenv(moduleFunction).tick = FakeTimers.tickOverride
		-- getfenv(moduleFunction).task = FakeTimers.taskOverride
		moduleResult = moduleFunction()

		if moduleResult == nil then
			error(
				string.format(
					"[Module Error]: %s did not return a valid result\n"
						.. "\tModuleScripts must return a non-nil value",
					tostring(scriptInstance)
				)
			)
		end
		moduleCleanup[scriptInstance] = cleanup
	end

	-- Load normally into the require cache
	requiredModules[scriptInstance] = moduleResult

	return moduleResult
end

local function resetModules()
	-- Clear all modules in the override require cache
	requiredModules = {}

	for script, cleanup in pairs(moduleCleanup) do
		(cleanup :: CleanupFn)()
	end

	moduleCleanup = {}
end

local function mock(scriptInstance: ModuleScript, callback: () -> any)
	-- If there's a cached actual value, clear it out so that a new require
	-- will get the mock
	if requiredModules[scriptInstance] ~= nil then
		requiredModules[scriptInstance] = nil
		local cleanup = moduleCleanup[scriptInstance]
		if cleanup then
			(cleanup :: CleanupFn)()
			moduleCleanup[scriptInstance] = nil
		end
	end

	-- Silence type errors
	local getfenv: any = getfenv
	-- Make sure that the further requires used by this mock will also be using
	-- the require override
	getfenv(callback).require = requireOverride
	-- getfenv(callback).delay = FakeTimers.delayOverride
	-- getfenv(callback).tick = FakeTimers.tickOverride
	mocks[scriptInstance] = callback
end

local function unmock(scriptInstance: ModuleScript)
	-- If there's a cached mock value, clear it out so that a new require won't
	-- get the mock
	if requiredModules[scriptInstance] ~= nil then
		requiredModules[scriptInstance] = nil
		local cleanup = moduleCleanup[scriptInstance]
		if cleanup then
			(cleanup :: CleanupFn)()
			moduleCleanup[scriptInstance] = nil
		end
	end

	mocks[scriptInstance] = nil
end

return {
	requireOverride = requireOverride,
	resetModules = resetModules,
	mock = mock,
	unmock = unmock,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="255">
                  <Properties>
                    <string name="Name">testEventHandler</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/__mocks__/testEventHandler.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}
local CurrentModule = script.Parent
local SrcModule = CurrentModule.Parent
local Packages = SrcModule.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console

local CircusModule = require(Packages.JestTypes)
type Circus_EventHandler = CircusModule.Circus_EventHandler

local testEventHandler: Circus_EventHandler
function testEventHandler(_self, event, state)
	if event.name == "start_describe_definition" or event.name == "finish_describe_definition" then
		console.log(
			event.name .. ":",
			-- ROBLOX FIXME Luau: Type should be narrowed here to allow for accessing `blockName` property
			(event :: any).blockName
		)
	elseif event.name == "run_describe_start" or event.name == "run_describe_finish" then
		console.log(event.name .. ":", event.describeBlock.name)
	elseif event.name == "test_start" or event.name == "test_retry" or event.name == "test_done" then
		console.log(event.name .. ":", event.test.name)
	elseif event.name == "add_test" then
		console.log(
			event.name .. ":",
			-- ROBLOX FIXME Luau: Type should be narrowed here to allow for accessing `testName` property
			(event :: any).testName
		)
	elseif event.name == "test_fn_start" or event.name == "test_fn_success" or event.name == "test_fn_failure" then
		console.log(event.name .. ":", event.test.name)
	elseif event.name == "add_hook" then
		console.log(
			event.name .. ":",
			-- ROBLOX FIXME Luau: Type should be narrowed here to allow for accessing `hookType` property
			(event :: any).hookType
		)
	elseif event.name == "hook_start" or event.name == "hook_success" or event.name == "hook_failure" then
		console.log(event.name .. ":", event.hook.type)
	else
		console.log(event.name)
	end

	if event.name == "run_finish" then
		console.log("")
		console.log(("unhandledErrors: %d"):format(#state.unhandledErrors))
	end
end

exports.default = testEventHandler
return exports
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="256">
                  <Properties>
                    <string name="Name">testUtils</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/__mocks__/testUtils.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}
type ExecaSyncReturnValue = any

type Result = ExecaSyncReturnValue & { status: number, error_: string }
local function runTest(source: string)
	local content = ([[
		return function(script_)
			-- ROBLOX deviation START
			local Module = require(script_.Parent.Module)
			Module.resetModules()
			local require = Module.requireOverride
			local LuauPolyfill = require(script_.Parent.Parent.Parent.Parent.LuauPolyfill)
			local Array = LuauPolyfill.Array
			local Error = LuauPolyfill.Error
			local console = LuauPolyfill.console

			local stdout = {}

			local function getStdout()
				return Array.join(stdout, "\n")
			end

			local function log(...)
				table.insert(stdout, Array.join({ ... }, " "))
			end

			console.log = log

			local global = getfenv()
			-- ROBLOX deviation END

			local circus = require(script_.Parent.Parent)


			global.test = circus.test
			global.describe = circus.describe
			global.beforeEach = circus.beforeEach
			global.afterEach = circus.afterEach
			global.beforeAll = circus.beforeAll
			global.afterAll = circus.afterAll

			local testEventHandler = require(script_.Parent.testEventHandler).default
			local addEventHandler = require(script_.Parent.Parent.state).addEventHandler
			addEventHandler(testEventHandler)

			%s

			local run = require(script_.Parent.Parent.run).default

			run();

			return getStdout()
		end
  ]]):format(source)

	local getTest, error_ = loadstring(content)

	assert(getTest, ("Error while loading code: %s"):format(tostring(error_)))

	local run = getTest()

	local stdout = run(script)

	return {
		stdout = stdout,
	}
end
exports.runTest = runTest
return exports
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="257">
                <Properties>
                  <string name="Name">combined</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/globalErrorHandlers.ts
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/state.ts
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/eventHandler.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent
local typesModule = require(Packages.JestTypes)
type Circus_EventHandler = typesModule.Circus_EventHandler

-- ROBLOX deviation START: predefine common variables
local dispatchSync
local eventHandler: Circus_EventHandler
local injectGlobalErrorHandlers
local restoreGlobalErrorHandlers
-- ROBLOX deviation END

-- ROBLOX FILE START: eventHandler.ts
do
	local LuauPolyfill = require(Packages.LuauPolyfill)
	local Array = LuauPolyfill.Array
	local Boolean = LuauPolyfill.Boolean
	local Error = LuauPolyfill.Error

	local RegExp = require(Packages.RegExp)

	type Circus_EventHandler = typesModule.Circus_EventHandler
	type Circus_Event = typesModule.Circus_Event
	type Circus_State = typesModule.Circus_State
	type Circus_TestEntry = typesModule.Circus_TestEntry
	type Circus_HookType = typesModule.Circus_HookType
	type Circus_DescribeBlock = typesModule.Circus_DescribeBlock
	type Circus_BlockMode = typesModule.Circus_BlockMode
	--[[
		ROBLOX deviation: merged into this file to avoid circular dependencies
		original code:
		import {
		  injectGlobalErrorHandlers,
		  restoreGlobalErrorHandlers,
		} from './globalErrorHandlers';
	]]
	-- ROBLOX FIXME: resolve cyclic dep
	local TEST_TIMEOUT_SYMBOL = require(script.Parent.types).TEST_TIMEOUT_SYMBOL
	-- ROBLOX FIXME: resolve cyclic dep
	local utilsModule = require(script.Parent.utils)
	local addErrorToEachTestUnderDescribe = utilsModule.addErrorToEachTestUnderDescribe
	local describeBlockHasTests = utilsModule.describeBlockHasTests
	local getTestDuration = utilsModule.getTestDuration
	local invariant = utilsModule.invariant
	local makeDescribe = utilsModule.makeDescribe
	local makeTest = utilsModule.makeTest

	-- TODO: investigate why a shorter (event, state) signature results into TS7006 compiler error
	function eventHandler(_self: any, event: Circus_Event, state: Circus_State): ()
		repeat
			if event.name == "include_test_location_in_result" then
				state.includeTestLocationInResult = true
				break
			elseif event.name == "hook_start" then
				event.hook.seenDone = false
				break
			elseif event.name == "start_describe_definition" then
				-- ROBLOX FIXME Luau: requires "type states" feature. need to explicitely type as Circus_BlockMode as Luau doesn't correctly infer the union of singleton types
				local blockName, mode: Circus_BlockMode = event.blockName, event.mode
				local currentDescribeBlock, currentlyRunningTest =
					state.currentDescribeBlock, state.currentlyRunningTest

				if currentlyRunningTest ~= nil then
					table.insert(
						currentlyRunningTest.errors,
						Error.new(
							('Cannot nest a describe inside a test. Describe block "%s" cannot run because it is nested within "%s".'):format(
								blockName,
								currentlyRunningTest.name
							)
						)
					)
					break
				end

				local describeBlock = makeDescribe(blockName, currentDescribeBlock, mode)
				table.insert(currentDescribeBlock.children, describeBlock)
				state.currentDescribeBlock = describeBlock
				break
			elseif event.name == "finish_describe_definition" then
				local currentDescribeBlock = state.currentDescribeBlock
				invariant(currentDescribeBlock, "currentDescribeBlock must be there")

				if not Boolean.toJSBoolean(describeBlockHasTests(currentDescribeBlock)) then
					Array.forEach(currentDescribeBlock.hooks, function(hook)
						hook.asyncError.message = ("Invalid: %s() may not be used in a describe block containing no tests."):format(
							hook.type
						)
						table.insert(state.unhandledErrors, hook.asyncError)
					end)
				end

				-- pass mode of currentDescribeBlock to tests
				-- but do not when there is already a single test with "only" mode
				local shouldPassMode = not (
					currentDescribeBlock.mode == "only"
					and Array.some(currentDescribeBlock.children, function(child)
						return child.type == "test" and child.mode == "only"
					end)
				)
				if shouldPassMode then
					Array.forEach(currentDescribeBlock.children, function(child)
						if child.type == "test" and not Boolean.toJSBoolean(child.mode) then
							child.mode = currentDescribeBlock.mode
						end
					end)
				end
				if
					not Boolean.toJSBoolean(state.hasFocusedTests)
					and currentDescribeBlock.mode ~= "skip"
					and Array.some(currentDescribeBlock.children, function(child)
						return child.type == "test" and child.mode == "only"
					end)
				then
					state.hasFocusedTests = true
				end

				if currentDescribeBlock.parent ~= nil then
					state.currentDescribeBlock = currentDescribeBlock.parent
				end
				break
			elseif event.name == "add_hook" then
				local currentDescribeBlock, currentlyRunningTest, hasStarted =
					state.currentDescribeBlock, state.currentlyRunningTest, state.hasStarted
				local asyncError,
					fn,
					type_: Circus_HookType, --[[ ROBLOX FIXME Luau: roblox-cli doesn't correctly infer this type]]
					timeout =
					event.asyncError, event.fn, event.hookType, event.timeout

				if currentlyRunningTest ~= nil then
					table.insert(
						currentlyRunningTest.errors,
						Error.new(
							('Hooks cannot be defined inside tests. Hook of type "%s" is nested within "%s".'):format(
								type_,
								currentlyRunningTest.name
							)
						)
					)
					break
				elseif Boolean.toJSBoolean(hasStarted) then
					table.insert(
						state.unhandledErrors,
						Error.new(
							"Cannot add a hook after tests have started running. Hooks must be defined synchronously."
						)
					)
					break
				end
				local parent = currentDescribeBlock

				table.insert(currentDescribeBlock.hooks, {
					asyncError = asyncError,
					fn = fn,
					parent = parent,
					seenDone = false,
					timeout = timeout,
					type = type_,
				})
				break
			elseif event.name == "add_test" then
				local currentDescribeBlock, currentlyRunningTest, hasStarted =
					state.currentDescribeBlock, state.currentlyRunningTest, state.hasStarted
				-- ROBLOX FIXME Luau: requires "type states" feature. need to explicitely type as Circus_BlockMode as Luau doesn't correctly infer the union of singleton types.
				local asyncError, fn, mode: Circus_BlockMode, name, timeout, failing =
					event.asyncError, event.fn, event.mode, event.testName, event.timeout, event.failing

				if currentlyRunningTest ~= nil then
					table.insert(
						currentlyRunningTest.errors,
						Error.new(
							('Tests cannot be nested. Test "%s" cannot run because it is nested within "%s".'):format(
								name,
								currentlyRunningTest.name
							)
						)
					)
					break
				elseif Boolean.toJSBoolean(hasStarted) then
					table.insert(
						state.unhandledErrors,
						Error.new(
							"Cannot add a test after tests have started running. Tests must be defined synchronously."
						)
					)
					break
				end
				local test = makeTest(fn, mode, name, currentDescribeBlock, timeout, asyncError, failing)
				if currentDescribeBlock.mode ~= "skip" and test.mode == "only" then
					state.hasFocusedTests = true
				end
				table.insert(currentDescribeBlock.children, test)
				table.insert(currentDescribeBlock.tests, test)
				break
			elseif event.name == "hook_failure" then
				local test, describeBlock, error_, hook = event.test, event.describeBlock, event.error, event.hook
				local asyncError, type = hook.asyncError, hook.type

				if type == "beforeAll" then
					invariant(describeBlock, "always present for `*All` hooks")
					-- ROBLOX FIXME Luau: invariant should assert that describeBlock is not nil
					addErrorToEachTestUnderDescribe(describeBlock :: Circus_DescribeBlock, error_, asyncError)
				elseif type == "afterAll" then
					-- Attaching `afterAll` errors to each test makes execution flow
					-- too complicated, so we'll consider them to be global.
					table.insert(state.unhandledErrors, { error_, asyncError })
				else
					invariant(test, "always present for `*Each` hooks")
					-- ROBLOX FIXME Luau: invariant should assert that test is not nil
					table.insert((test :: Circus_TestEntry).errors, { error_, asyncError })
				end
				break
			elseif event.name == "test_skip" then
				event.test.status = "skip"
				break
			elseif event.name == "test_todo" then
				event.test.status = "todo"
				break
			elseif event.name == "test_done" then
				event.test.duration = getTestDuration(event.test)
				event.test.status = "done"
				state.currentlyRunningTest = nil
				break
			elseif event.name == "test_start" then
				state.currentlyRunningTest = event.test
				event.test.startedAt = DateTime.now().UnixTimestampMillis
				event.test.invocations += 1
				break
			elseif event.name == "test_fn_start" then
				event.test.seenDone = false
				break
			elseif event.name == "test_fn_failure" then
				local error_, asyncError = event.error, event.test.asyncError
				table.insert(event.test.errors, { error_, asyncError })
				break
			elseif event.name == "test_retry" then
				event.test.errors = {}
				break
			elseif event.name == "run_start" then
				state.hasStarted = true
				if Boolean.toJSBoolean(_G[TEST_TIMEOUT_SYMBOL]) then
					state.testTimeout = _G[TEST_TIMEOUT_SYMBOL]
				end
				break
			elseif event.name == "run_finish" then
				break
			elseif event.name == "setup" then
				-- Uncaught exception handlers should be defined on the parent process
				-- object. If defined on the VM's process object they just no op and let
				-- the parent process crash. It might make sense to return a `dispatch`
				-- function to the parent process and register handlers there instead, but
				-- i'm not sure if this is works. For now i just replicated whatever
				-- jasmine was doing -- dabramov
				-- ROBLOX deviation START: no access to parent process and global error handlers in Luau
				-- state.parentProcess = event.parentProcess
				-- invariant(state.parentProcess)
				-- state.originalGlobalErrorHandlers = injectGlobalErrorHandlers(state.parentProcess)
				-- ROBLOX deviation END
				if Boolean.toJSBoolean(event.testNamePattern) then
					state.testNamePattern = RegExp(event.testNamePattern, "i")
				end
				break
			elseif event.name == "teardown" then
				-- ROBLOX deviation START: no access to parent process and global error handlers in Luau
				-- invariant(state.originalGlobalErrorHandlers)
				-- invariant(state.parentProcess)
				-- restoreGlobalErrorHandlers(state.parentProcess, state.originalGlobalErrorHandlers)
				-- ROBLOX deviation END
				break
			elseif event.name == "error" then
				-- It's very likely for long-running async tests to throw errors. In this
				-- case we want to catch them and fail the current test. At the same time
				-- there's a possibility that one test sets a long timeout, that will
				-- eventually throw after this test finishes but during some other test
				-- execution, which will result in one test's error failing another test.
				-- In any way, it should be possible to track where the error was thrown
				-- from.
				if state.currentlyRunningTest ~= nil then
					table.insert(state.currentlyRunningTest.errors, event.error)
				else
					table.insert(state.unhandledErrors, event.error)
				end
				break
			end
		until true
	end
	exports.eventHandler = eventHandler
end
-- ROBLOX FILE END

-- ROBLOX FILE START: globalErrorHandlers.ts
do
	local LuauPolyfill = require(Packages.LuauPolyfill)
	local Array = LuauPolyfill.Array

	-- ROBLOX FIXME START: added types and objects that do not exist in Luau
	type NodeJS_UncaughtExceptionListener = any
	type NodeJS_UnhandledRejectionListener = any
	type NodeJS_Process = any
	local process = {
		listeners = function(_self, ...)
			return {}
		end,
	}
	-- ROBLOX FIXME END
	type Circus_GlobalErrorHandlers = typesModule.Circus_GlobalErrorHandlers
	--[[
		ROBLOX deviation: merged into this file to avoid circular dependencies
		original code:
		import {dispatchSync} from './state';
	]]

	local uncaught: NodeJS_UncaughtExceptionListener & NodeJS_UnhandledRejectionListener
	function uncaught(error_)
		dispatchSync({ error = error_, name = "error" })
	end

	function injectGlobalErrorHandlers(parentProcess: NodeJS_Process): Circus_GlobalErrorHandlers
		local uncaughtException = Array.slice(process:listeners("uncaughtException"))
		local unhandledRejection = Array.slice(process:listeners("unhandledRejection"))
		parentProcess:removeAllListeners("uncaughtException")
		parentProcess:removeAllListeners("unhandledRejection")
		parentProcess:on("uncaughtException", uncaught)
		parentProcess:on("unhandledRejection", uncaught)
		return { uncaughtException = uncaughtException, unhandledRejection = unhandledRejection }
	end
	exports.injectGlobalErrorHandlers = injectGlobalErrorHandlers

	function restoreGlobalErrorHandlers(
		parentProcess: NodeJS_Process,
		originalErrorHandlers: Circus_GlobalErrorHandlers
	): ()
		parentProcess:removeListener("uncaughtException", uncaught)
		parentProcess:removeListener("unhandledRejection", uncaught)
		for _, listener in ipairs(originalErrorHandlers.uncaughtException) do
			parentProcess:on("uncaughtException", listener)
		end
		for _, listener in ipairs(originalErrorHandlers.unhandledRejection) do
			parentProcess:on("unhandledRejection", listener)
		end
	end
	exports.restoreGlobalErrorHandlers = restoreGlobalErrorHandlers
end
-- ROBLOX FILE END

-- ROBLOX FILE START: state.ts
do
	local LuauPolyfill = require(Packages.LuauPolyfill)
	type Array<T> = LuauPolyfill.Array<T>
	type Promise<T> = LuauPolyfill.Promise<T>

	local Promise = require(Packages.Promise)

	type Circus_EventHandler = typesModule.Circus_EventHandler
	type Circus_State = typesModule.Circus_State
	type Circus_AsyncEvent = typesModule.Circus_AsyncEvent
	type Circus_SyncEvent = typesModule.Circus_SyncEvent
	--[[
		ROBLOX deviation: merged into this file to avoid circular dependencies
		original code:
		import eventHandler from './eventHandler';
	]]
	-- ROBLOX FIXME: resolve cyclic dep
	local formatNodeAssertErrors = require(script.Parent.formatNodeAssertErrors).default
	-- ROBLOX FIXME: resolve cyclic dep
	local STATE_SYM = require(script.Parent.types).STATE_SYM
	local makeDescribe = require(script.Parent.utils).makeDescribe
	local eventHandlers: Array<Circus_EventHandler> = { eventHandler, formatNodeAssertErrors }
	-- ROBLOX deviation START: move to `state_.lua` to avoid cyclic dependency
	local stateCommonModule = require(script.Parent.state_)
	local ROOT_DESCRIBE_BLOCK_NAME = stateCommonModule.ROOT_DESCRIBE_BLOCK_NAME
	-- ROBLOX deviation END
	exports.ROOT_DESCRIBE_BLOCK_NAME = ROOT_DESCRIBE_BLOCK_NAME
	local function createState(): Circus_State
		local ROOT_DESCRIBE_BLOCK = makeDescribe(ROOT_DESCRIBE_BLOCK_NAME)
		return {
			currentDescribeBlock = ROOT_DESCRIBE_BLOCK,
			currentlyRunningTest = nil,
			expand = nil,
			hasFocusedTests = false,
			hasStarted = false,
			includeTestLocationInResult = false,
			parentProcess = nil,
			rootDescribeBlock = ROOT_DESCRIBE_BLOCK,
			testNamePattern = nil,
			testTimeout = 5000,
			unhandledErrors = {},
		}
	end
	local function resetState(): ()
		_G[STATE_SYM] = createState()
	end
	exports.resetState = resetState
	resetState()
	-- ROBLOX deviation START: move to `state_.lua` to avoid cyclic dependency
	local getState = stateCommonModule.getState
	-- ROBLOX deviation END
	exports.getState = getState
	local function setState(state: Circus_State): Circus_State
		_G[STATE_SYM] = state
		return _G[STATE_SYM]
	end
	exports.setState = setState
	local function dispatch(event: Circus_AsyncEvent): Promise<nil>
		return Promise.resolve():andThen(function()
			for _, handler in ipairs(eventHandlers) do
				-- ROBLOX deviation START: need to check if value returned is a Promise, otherwise we can't run `:expect()`
				-- ROBLOX FIXME Luau: need to cast handler explicitely as Luau can't infer from type union properly
				local result = (
					handler :: (self: any, event: Circus_AsyncEvent, state: Circus_State) -> nil | Promise<nil>
				)(nil, event, getState())
				if result ~= nil then
					result:expect()
				end
				-- ROBLOX deviation END
			end
		end)
	end
	exports.dispatch = dispatch
	function dispatchSync(event: Circus_SyncEvent): ()
		for _, handler in ipairs(eventHandlers) do
			-- ROBLOX FIXME Luau: need to cast handler explicitely as Luau can't infer from type union properly
			(handler :: (self: any, event: Circus_SyncEvent, state: Circus_State) -> ())(nil, event, getState())
		end
	end
	exports.dispatchSync = dispatchSync
	local function addEventHandler(handler: Circus_EventHandler): ()
		table.insert(eventHandlers, handler)
	end
	exports.addEventHandler = addEventHandler
end
-- ROBLOX FILE END

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="258">
                <Properties>
                  <string name="Name">eventHandler</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/eventHandler.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- ROBLOX deviation START: moved implementation to `combined.lua` to avoid cyclic dependencies
local combinedModule = require(script.Parent.combined)
local exports = {}

exports.default = combinedModule.eventHandler
-- ROBLOX deviation END

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="259">
                <Properties>
                  <string name="Name">formatNodeAssertErrors</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/formatNodeAssertErrors.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local instanceof = LuauPolyfill.instanceof

-- ROBLOX deviation START: additional dependencies
local RobloxShared = require(Packages.RobloxShared)
local escapePatternCharacters = RobloxShared.escapePatternCharacters
local normalizePromiseError = RobloxShared.normalizePromiseError
local Error = LuauPolyfill.Error
local cleanLoadStringStack = RobloxShared.cleanLoadStringStack
-- ROBLOX deviation END

type Record<K, T> = { [K]: T }

local exports = {}
local AssertionError = LuauPolyfill.AssertionError
type AssertionError = LuauPolyfill.AssertionError
local chalk = require(Packages.ChalkLua)
local typesModule = require(Packages.JestTypes)
type Circus_Event = typesModule.Circus_Event
type Circus_State = typesModule.Circus_State
type Circus_TestError = typesModule.Circus_TestError
local jestMatcherUtilsModule = require(Packages.JestMatcherUtils)
type DiffOptions = jestMatcherUtilsModule.DiffOptions
local diff = jestMatcherUtilsModule.diff
local printExpected = jestMatcherUtilsModule.printExpected
local printReceived = jestMatcherUtilsModule.printReceived
local prettyFormat = require(Packages.PrettyFormat).format

-- ROBLOX deviation START: predefine variables
local formatNodeAssertErrors
local getOperatorName
local operatorMessage
local assertThrowingMatcherHint
local assertMatcherHint
local assertionErrorMessage
local isAssertionError
local buildHintString
-- ROBLOX deviation END

type AssertionErrorWithStack = AssertionError & { stack: string }

local assertOperatorsMap: Record<string, string> = {
	["!="] = "notEqual",
	["!=="] = "notStrictEqual",
	["=="] = "equal",
	["==="] = "strictEqual",
}

local humanReadableOperators: Record<string, string> = {
	deepEqual = "to deeply equal",
	deepStrictEqual = "to deeply and strictly equal",
	equal = "to be equal",
	notDeepEqual = "not to deeply equal",
	notDeepStrictEqual = "not to deeply and strictly equal",
	notEqual = "to not be equal",
	notStrictEqual = "not be strictly equal",
	strictEqual = "to strictly be equal",
}

function formatNodeAssertErrors(_self: any, event: Circus_Event, state: Circus_State): ()
	if event.name == "test_done" then
		event.test.errors = Array.map(event.test.errors, function(errors)
			local error_
			if Array.isArray(errors) then
				local originalError, asyncError = table.unpack(errors, 1, 2)

				if originalError == nil then
					error_ = asyncError
					-- ROBLOX deviation START: additional logic to handle Promise library error
				elseif originalError.kind == "ExecutionError" then
					error_ = normalizePromiseError(originalError)
					-- ROBLOX deviation END
				elseif not Boolean.toJSBoolean(originalError.stack) then
					error_ = asyncError

					error_.message = if Boolean.toJSBoolean(originalError.message)
						then originalError.message
						else ("thrown: %s"):format(prettyFormat(originalError, { maxDepth = 3 }))
					-- ROBLOX deviation START: add __recalculateStacktrace after message has been altered
					Error.__recalculateStacktrace(error_)
					-- ROBLOX deviation END
				else
					error_ = originalError
				end
			else
				error_ = errors
			end
			return if isAssertionError(error_)
				then { message = assertionErrorMessage(error_, { expand = state.expand }) }
				else errors
		end)
	end
end

function getOperatorName(operator: string | nil, stack: string)
	if typeof(operator) == "string" then
		return if Boolean.toJSBoolean(assertOperatorsMap[operator]) then assertOperatorsMap[operator] else operator
	end
	if stack:match("%.doesNotThrow") ~= nil then
		return "doesNotThrow"
	end
	if stack:match("%.throws") ~= nil then
		return "throws"
	end
	-- this fallback is only needed for versions older than node 10
	if stack:match("%.fail") ~= nil then
		return "fail"
	end
	return ""
end

function operatorMessage(operator: string | nil)
	local niceOperatorName = getOperatorName(operator, "")
	local humanReadableOperator = humanReadableOperators[niceOperatorName]

	return if typeof(operator) == "string"
		then ("%s to:\n"):format(
			if Boolean.toJSBoolean(humanReadableOperator) then humanReadableOperator else niceOperatorName
		)
		else ""
end

function assertThrowingMatcherHint(operatorName: string)
	return if Boolean.toJSBoolean(operatorName)
		then chalk.dim("assert") .. chalk.dim("." .. operatorName .. "(") .. chalk.red("function") .. chalk.dim(")")
		else ""
end

function assertMatcherHint(operator: string | nil, operatorName: string, expected: unknown)
	local message = ""

	if operator == "==" and expected == true then
		message = chalk.dim("assert") .. chalk.dim("(") .. chalk.red("received") .. chalk.dim(")")
	elseif Boolean.toJSBoolean(operatorName) then
		message = chalk.dim("assert")
			.. chalk.dim("." .. operatorName .. "(")
			.. chalk.red("received")
			.. chalk.dim(", ")
			.. chalk.green("expected")
			.. chalk.dim(")")
	end

	return message
end

function assertionErrorMessage(error_, options: DiffOptions)
	local expected, actual, generatedMessage, message, operator, stack =
		error_.expected, error_.actual, error_.generatedMessage, error_.message, error_.operator, error_.stack
	local diffString = diff(expected, actual, options)
	local hasCustomMessage = not Boolean.toJSBoolean(generatedMessage)
	local operatorName = getOperatorName(operator, stack)
	-- ROBLOX deviation START: adjust replace pattern to work with gsub
	local escapedMessage = escapePatternCharacters(message)
	local rep1 = stack:gsub(escapedMessage, "", 1)
	local rep2 = rep1:gsub("^AssertionError([^\n]*)", "")
	local trimmedStack = rep2:gsub("^Error([^\n]*)", "")
	-- ROBLOX deviation END

	if operatorName == "doesNotThrow" then
		return buildHintString(assertThrowingMatcherHint(operatorName))
			.. chalk.reset("Expected the function not to throw an error.\n")
			.. chalk.reset("Instead, it threw:\n")
			.. ("  %s"):format(printReceived(actual))
			.. chalk.reset(
				if Boolean.toJSBoolean(hasCustomMessage) then "\n\nMessage:\n  " .. tostring(message) else ""
			)
			.. trimmedStack
	end

	if operatorName == "throws" then
		return buildHintString(assertThrowingMatcherHint(operatorName))
			.. chalk.reset("Expected the function to throw an error.\n")
			.. chalk.reset("But it didn't throw anything.")
			.. chalk.reset(if hasCustomMessage then "\n\nMessage:\n  " .. message else "")
			.. trimmedStack
	end

	if operatorName == "fail" then
		return buildHintString(assertMatcherHint(operator, operatorName, expected))
			.. chalk.reset(if hasCustomMessage then "Message:\n  " .. tostring(message) else "")
			.. trimmedStack
	end

	return buildHintString(assertMatcherHint(operator, operatorName, expected))
		.. chalk.reset(("Expected value %s"):format(operatorMessage(operator)))
		.. ("  %s\n"):format(printExpected(expected))
		.. chalk.reset("Received:\n")
		.. ("  %s"):format(printReceived(actual))
		.. chalk.reset(if hasCustomMessage then "\n\nMessage:\n  " .. tostring(message) else "")
		.. (if Boolean.toJSBoolean(diffString) and diffString ~= nil
			then ("\n\nDifference:\n\n%s"):format(diffString)
			else "")
		.. trimmedStack
end

function isAssertionError(error_: Circus_TestError): boolean
	return error_
		and (instanceof(error_, AssertionError) or error_.name == AssertionError.name or error_.code == "ERR_ASSERTION")
end

function buildHintString(hint: string): string
	return if Boolean.toJSBoolean(hint) then tostring(hint) .. "\n\n" else ""
end

exports.default = formatNodeAssertErrors
return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="260">
                <Properties>
                  <string name="Name">globalErrorHandlers</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/globalErrorHandlers.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- ROBLOX deviation START: moved implementation to `combined.lua` to avoid cyclic dependencies

local combinedModule = require(script.Parent.combined)
local exports = {}

exports.injectGlobalErrorHandlers = combinedModule.injectGlobalErrorHandlers
exports.restoreGlobalErrorHandlers = combinedModule.restoreGlobalErrorHandlers

-- ROBLOX deviation END

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="261">
                <Properties>
                  <string name="Name">legacy-code-todo-rewrite</string>
                </Properties>
                <Item class="ModuleScript" referent="262">
                  <Properties>
                    <string name="Name">jestAdapter</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/legacy-code-todo-rewrite/jestAdapter.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local environmentModule = require(Packages.JestEnvironment)
type JestEnvironment = environmentModule.JestEnvironment
local test_resultModule = require(Packages.JestTestResult)
type TestFileEvent = test_resultModule.TestFileEvent
type TestResult = test_resultModule.TestResult
local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_ProjectConfig = typesModule.Config_ProjectConfig
local jest_runtimeModule = require(Packages.JestRuntime)
type Runtime = jest_runtimeModule.Runtime
-- ROBLOX TODO START: not implemented yet
-- local jest_snapshotModule = require(Packages.JestSnapshot)
type SnapshotStateType = any -- jest_snapshotModule.SnapshotStateType
-- ROBLOX TODO END
local deepCyclicCopy = require(Packages.JestUtil).deepCyclicCopy
local FRAMEWORK_INITIALIZER = script.Parent.jestAdapterInit

-- ROBLOX deviation START: predeclare variables
local _addSnapshotData
-- ROBLOX deviation END

local function jestAdapter(
	globalConfig: Config_GlobalConfig,
	config: Config_ProjectConfig,
	environment: JestEnvironment,
	runtime: Runtime,
	-- ROBLOX deviation: accept ModuleScript instead of string
	testPath: ModuleScript,
	sendMessageToJest: TestFileEvent?
): Promise<TestResult>
	return Promise.resolve():andThen(function()
		local ref = runtime:requireInternalModule(FRAMEWORK_INITIALIZER)
		local initialize, runAndTransformResultsToJestFormat = ref.initialize, ref.runAndTransformResultsToJestFormat

		local ref_ = initialize({
			config = config,
			environment = environment,
			globalConfig = globalConfig,
			localRequire = function(...)
				return runtime:requireModule(...)
			end,
			-- ROBLOX TODO: do we need this?
			-- parentProcess = process,
			sendMessageToJest = sendMessageToJest,
			setGlobalsForRuntime = function(...)
				runtime:setGlobalsForRuntime(...)
			end,
			testPath = testPath,
		}):expect()
		local globals, snapshotState = ref_.globals, ref_.snapshotState;

		-- ROBLOX deviation START: no modern/legacy timers
		(environment.fakeTimers :: any):useFakeTimers()
		-- if config.timers == "fake" or config.timers == "modern" then
		-- 	-- during setup, this cannot be null (and it's fine to explode if it is)
		-- 	(environment.fakeTimersModern :: any):useFakeTimers()
		-- elseif config.timers == "legacy" then
		-- 	(environment.fakeTimers :: any):useFakeTimers()
		-- end
		-- ROBLOX deviation END

		globals.beforeEach(function()
			if config.resetModules then
				runtime:resetModules()
			end
			if config.clearMocks then
				runtime:clearAllMocks()
			end
			if config.resetMocks then
				runtime:resetAllMocks()
				if
					Boolean.toJSBoolean(
						if Boolean.toJSBoolean(config.fakeTimers.enableGlobally)
							then config.fakeTimers.legacyFakeTimers
							else config.fakeTimers.enableGlobally
					)
				then
					-- during setup, this cannot be null (and it's fine to explode if it is)
					(environment.fakeTimers :: any):useFakeTimers()
				end
			end
			if config.restoreMocks then
				runtime:restoreAllMocks()
			end
		end)

		for _, path in config.setupFilesAfterEnv do
			-- ROBLOX deviation START: no esm modules in Lua
			runtime:requireModule(path, nil, nil, nil, true)
			-- local esm = runtime:unstable_shouldLoadAsEsm(path)
			-- if esm then
			-- 	runtime:unstable_importModule(path):expect()
			-- else
			-- 	runtime:requireModule(path)
			-- end
			-- ROBLOX deviation END
		end
		-- ROBLOX deviation START: no esm modules in Lua
		runtime:requireModule(testPath, nil, nil, nil, true)
		-- 	local esm = runtime:unstable_shouldLoadAsEsm(testPath)

		-- if esm then
		-- 	runtime:unstable_importModule(testPath):expect()
		-- else
		-- 	runtime:requireModule(testPath)
		-- end
		-- ROBLOX deviation END

		local results = runAndTransformResultsToJestFormat({
			config = config,
			globalConfig = globalConfig,
			testPath = testPath,
		}):expect()

		_addSnapshotData(results, snapshotState)

		-- We need to copy the results object to ensure we don't leaks the prototypes
		-- from the VM. Jasmine creates the result objects in the parent process, we
		-- should consider doing that for circus as well.
		return deepCyclicCopy(results, { keepPrototype = false })
	end)
end

function _addSnapshotData(results: TestResult, snapshotState: SnapshotStateType)
	Array.forEach(results.testResults, function(ref)
		local fullName, status = ref.fullName, ref.status
		if status == "pending" or status == "failed" then
			-- if test is skipped or failed, we don't want to mark
			-- its snapshots as obsolete.
			snapshotState:markSnapshotsAsCheckedForTest(fullName)
		end
	end)

	local uncheckedCount = snapshotState:getUncheckedCount()
	local uncheckedKeys = snapshotState:getUncheckedKeys()
	if Boolean.toJSBoolean(uncheckedCount) then
		snapshotState:removeUncheckedKeys()
	end

	local status = snapshotState:save()
	results.snapshot.fileDeleted = status.deleted
	results.snapshot.added = snapshotState.added
	results.snapshot.matched = snapshotState.matched
	results.snapshot.unmatched = snapshotState.unmatched
	results.snapshot.updated = snapshotState.updated
	results.snapshot.unchecked = if not status.deleted then uncheckedCount else 0
	-- Copy the array to prevent memory leaks
	results.snapshot.uncheckedKeys = Array.from(uncheckedKeys)
end

return jestAdapter
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="263">
                  <Properties>
                    <string name="Name">jestAdapterInit</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/legacy-code-todo-rewrite/jestAdapterInit.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

-- ROBLOX FIXME START: added types and objects that do not exist in Luau
type NodeJS_Process = any
-- ROBLOX FIXME END

local exports = {}

local throatModule = require(Packages.Throat)
local throat = throatModule.default
type ThroatLateBound<TResult, TArgs> = throatModule.ThroatLateBound<TResult, TArgs>

local environmentModule = require(Packages.JestEnvironment)
type JestEnvironment = environmentModule.JestEnvironment
local test_resultModule = require(Packages.JestTestResult)
type AssertionResult = test_resultModule.AssertionResult
type Status = test_resultModule.Status
type TestFileEvent = test_resultModule.TestFileEvent
type TestResult = test_resultModule.TestResult
local createEmptyTestResult = test_resultModule.createEmptyTestResult
local typesModule = require(Packages.JestTypes)
type Circus_Event = typesModule.Circus_Event
type Circus_RunResult = typesModule.Circus_RunResult
type Circus_TestEntry = typesModule.Circus_TestEntry
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type Global_ConcurrentTestFn = typesModule.Global_ConcurrentTestFn
type Global_TestFrameworkGlobals = typesModule.Global_TestFrameworkGlobals
-- ROBLOX deviation START: additional types
type Global_ItBase = typesModule.Global_ItBase
type Global_ItConcurrentBase = typesModule.Global_ItConcurrentBase
type Global_ItConcurrent = typesModule.Global_ItConcurrent
type Global_ItConcurrentExtended = typesModule.Global_ItConcurrentExtended
-- ROBLOX deviation END
local expectModule = require(Packages.Expect)
local extractExpectedAssertionsErrors = expectModule.extractExpectedAssertionsErrors
local getState = expectModule.getState
local setState = expectModule.setState
local bind = require(Packages.JestEach).bind
local jest_message_utilModule = require(Packages.JestMessageUtil)
local formatExecError = jest_message_utilModule.formatExecError
local formatResultsErrors = jest_message_utilModule.formatResultsErrors
local jest_snapshotModule = require(Packages.JestSnapshot)
local SnapshotState = jest_snapshotModule.SnapshotState
type SnapshotStateType = jest_snapshotModule.JestSnapshot_SnapshotStateType
local addSerializer = jest_snapshotModule.addSerializer
local buildSnapshotResolver = jest_snapshotModule.buildSnapshotResolver
local globals = require(script.Parent.Parent).default
local run = require(script.Parent.Parent.run).default
local stateModule = require(script.Parent.Parent.state)
local ROOT_DESCRIBE_BLOCK_NAME = stateModule.ROOT_DESCRIBE_BLOCK_NAME
local addEventHandler = stateModule.addEventHandler
local dispatch = stateModule.dispatch
local getRunnerState = stateModule.getState
local testCaseReportHandler = require(script.Parent.Parent.testCaseReportHandler).default
local getTestID = require(script.Parent.Parent.utils).getTestID
local jestExpectModule = require(script.Parent.jestExpect)
local createExpect = jestExpectModule.default
type Expect = jestExpectModule.Expect

type Process = NodeJS_Process

type JestGlobals = Global_TestFrameworkGlobals & { expect: Expect, expectExtended: any }

-- ROBLOX deviation START: additional deps
local RobloxShared = require(Packages.RobloxShared)
local getRelativePath = RobloxShared.getRelativePath
-- ROBLOX deviation END

-- ROBLOX deviation START: predeclare variables
local handleSnapshotStateAfterRetry
local eventHandler
local _addExpectedAssertionErrors
local _addSuppressedErrors
-- ROBLOX deviation END

local function initialize(
	ref: {
		config: Config_ProjectConfig,
		environment: JestEnvironment,
		globalConfig: Config_GlobalConfig,
		-- ROBLOX deviation: no default param
		localRequire: <T>(path: Config_Path) -> T,
		-- ROBLOX deviation START: use ModuleScript instead of string
		testPath: ModuleScript,
		-- ROBLOX deviation END
		parentProcess: Process,
		sendMessageToJest: TestFileEvent?,
		setGlobalsForRuntime: (globals: JestGlobals) -> (),
	}
): Promise<{ globals: Global_TestFrameworkGlobals, snapshotState: SnapshotStateType }>
	local config, environment, globalConfig, localRequire, parentProcess, sendMessageToJest, setGlobalsForRuntime, testPath =
		ref.config,
		ref.environment,
		ref.globalConfig,
		ref.localRequire,
		ref.parentProcess,
		ref.sendMessageToJest,
		ref.setGlobalsForRuntime,
		ref.testPath

	return Promise.resolve():andThen(function()
		if globalConfig.testTimeout ~= nil and globalConfig.testTimeout > 0 then
			getRunnerState().testTimeout = globalConfig.testTimeout
		end

		local mutex = throat(globalConfig.maxConcurrency) :: ThroatLateBound<any, any>

		-- @ts-expect-error
		local globalsObject: Global_TestFrameworkGlobals = Object.assign({}, globals, {
			fdescribe = globals.describe.only,
			fit = globals.it.only,
			xdescribe = globals.describe.skip,
			xit = globals.it.skip,
			xtest = globals.it.skip,
		})

		globalsObject.test.concurrent = (function(
			-- ROBLOX FIXME Luau: this type should be inferred
			test: Global_ItConcurrent
		): Global_ItConcurrentExtended
			local function concurrent_(testName: string, testFn: Global_ConcurrentTestFn, timeout: number?)
				-- For concurrent tests we first run the function that returns promise, and then register a
				-- normal test that will be waiting on the returned promise (when we start the test, the promise
				-- will already be in the process of execution).
				-- Unfortunately at this stage there's no way to know if there are any `.only` tests in the suite
				-- that will result in this test to be skipped, so we'll be executing the promise function anyway,
				-- even if it ends up being skipped.
				local promise = mutex(function()
					return testFn()
				end)
				-- Avoid triggering the uncaught promise rejection handler in case the test errors before
				-- being awaited on.
				promise:catch(function() end);
				-- ROBLOX FIXME Luau: analyze shouldn't need this cast to Global_ItBase
				(globalsObject.test :: Global_ItBase)(testName, function()
					return promise
				end, timeout)
			end
			local concurrent = setmetatable({}, {
				__call = function(_self, testName: string, testFn: Global_ConcurrentTestFn, timeout: number?): ()
					concurrent_(testName, testFn, timeout)
				end,
			}) :: Global_ItConcurrentExtended

			local function only_(testName: string, testFn: Global_ConcurrentTestFn, timeout: number?)
				local promise = mutex(function()
					return testFn()
				end)
				-- eslint-disable-next-line jest/no-focused-tests
				test.only(testName, function()
					return promise
				end, timeout)
			end
			local only = setmetatable({}, {
				__call = function(_self, testName: string, testFn: Global_ConcurrentTestFn, timeout: number?)
					return only_(testName, testFn, timeout)
				end,
			}) :: Global_ItConcurrentBase

			concurrent.only = only
			concurrent.skip = test.skip

			concurrent.each = bind(test, false)
			concurrent.skip.each = bind(test.skip, false)
			only.each = bind(test.only, false)

			return concurrent
		end)(globalsObject.test)

		addEventHandler(eventHandler)

		if environment.handleTestEvent ~= nil then
			local handleTestEvent = environment.handleTestEvent
			addEventHandler(function(...: any)
				return handleTestEvent(environment, ...)
			end)
		end

		local runtimeGlobals: JestGlobals = Object.assign({}, globalsObject, { expect = createExpect(globalConfig) })
		runtimeGlobals.expectExtended = runtimeGlobals.expect
		setGlobalsForRuntime(runtimeGlobals)

		if config.injectGlobals then
			Object.assign(environment.global, runtimeGlobals)
		end

		dispatch({
			name = "setup",
			parentProcess = parentProcess,
			runtimeGlobals = runtimeGlobals,
			testNamePattern = globalConfig.testNamePattern,
		}):expect()

		if config.testLocationInResults then
			dispatch({ name = "include_test_location_in_result" }):expect()
		end

		-- Jest tests snapshotSerializers in order preceding built-in serializers.
		-- Therefore, add in reverse because the last added is the first tested.
		Array.forEach(Array.reverse(Array.concat(config.snapshotSerializers)), function(path)
			return addSerializer(localRequire(path))
		end)

		local expand, updateSnapshot = globalConfig.expand, globalConfig.updateSnapshot
		local snapshotResolver = buildSnapshotResolver(config, localRequire):expect()
		local snapshotPath = snapshotResolver:resolveSnapshotPath(testPath)

		local snapshotState = SnapshotState.new(
			snapshotPath,
			--[[
				ROBLOX FIXME Luau: getting analyze error that doesn't actually makes sense. Seems it might be related to type unification issues somehow.
				Type '{ expand: boolean?, snapshotFormat: PrettyFormatOptions, updateSnapshot: string }' could not be converted into 'SnapshotStateOptions'

				and the SnapshotStateOptions is defined as follows:
				type ConfigSnapshotUpdateState = string
				type SnapshotStateOptions = {
					updateSnapshot: ConfigSnapshotUpdateState,
					-- ROBLOX deviation: the function return is defined as any instead of null | Prettier
					-- prettierPath: ConfigPath;
					expand: boolean?,
					snapshotFormat: PrettyFormatOptions,
				}
			]]
			{
				expand = expand,
				-- ROBLOX deviation START: not supported
				-- prettierPath = config.prettierPath,
				-- ROBLOX deviation END
				snapshotFormat = config.snapshotFormat,
				updateSnapshot = updateSnapshot,
			} :: any
		)
		-- @ts-expect-error: snapshotState is a jest extension of `expect`
		setState({ snapshotState = snapshotState, testPath = testPath })

		addEventHandler(handleSnapshotStateAfterRetry(snapshotState))
		if sendMessageToJest ~= nil then
			addEventHandler(testCaseReportHandler(getRelativePath(testPath), sendMessageToJest))
		end

		-- Return it back to the outer scope (test runner outside the VM).
		return { globals = globalsObject, snapshotState = snapshotState }
	end)
end
exports.initialize = initialize

local function runAndTransformResultsToJestFormat(ref: {
	config: Config_ProjectConfig,
	globalConfig: Config_GlobalConfig,
	testPath: string,
}): Promise<TestResult>
	local config, globalConfig, testPath = ref.config, ref.globalConfig, ref.testPath

	return Promise.resolve():andThen(function()
		local runResult: Circus_RunResult = Promise.resolve(run()):expect()

		local numFailingTests = 0
		local numPassingTests = 0
		local numPendingTests = 0
		local numTodoTests = 0

		local assertionResults: Array<AssertionResult> = Array.map(runResult.testResults, function(testResult)
			local status: Status
			if testResult.status == "skip" then
				status = "pending"
				numPendingTests += 1
			elseif testResult.status == "todo" then
				status = "todo"
				numTodoTests += 1
			elseif #testResult.errors ~= 0 then
				status = "failed"
				numFailingTests += 1
			else
				status = "passed"
				numPassingTests += 1
			end

			local ancestorTitles = Array.filter(testResult.testPath, function(name)
				return name ~= ROOT_DESCRIBE_BLOCK_NAME
			end)
			local title = table.remove(ancestorTitles)

			return {
				ancestorTitles = ancestorTitles,
				duration = testResult.duration,
				failureDetails = testResult.errorsDetailed,
				failureMessages = testResult.errors,
				fullName = if Boolean.toJSBoolean(title)
					then Array.join(Array.concat(ancestorTitles, title), " ")
					else Array.join(ancestorTitles, " "),
				invocations = testResult.invocations,
				location = testResult.location,
				numPassingAsserts = 0,
				retryReasons = testResult.retryReasons,
				status = status,
				title = testResult.testPath[#testResult.testPath],
			}
		end)

		local failureMessage = formatResultsErrors(
			assertionResults,
			config,
			-- ROBLOX FIXME Luau: Config_GlobalConfig contains noStackTrace and noCodeFrame is optional in StackTraceOptions so it should be fine
			(globalConfig :: any) :: { noStackTrace: boolean, noCodeFrame: boolean? },
			testPath
		)
		local testExecError

		if #runResult.unhandledErrors ~= 0 then
			testExecError = {
				message = "",
				stack = Array.join(runResult.unhandledErrors, "\n"),
			}
			failureMessage = (Boolean.toJSBoolean(failureMessage) and failureMessage or "")
				.. "\n\n"
				.. Array.join(
					Array.map(runResult.unhandledErrors, function(err)
						return formatExecError(
							err,
							config,
							-- ROBLOX FIXME Luau: Config_GlobalConfig contains noStackTrace and noCodeFrame is optional in StackTraceOptions so it should be fine
							(globalConfig :: any) :: { noStackTrace: boolean, noCodeFrame: boolean? }
						)
					end),
					"\n"
				)
		end

		dispatch({ name = "teardown" }):expect()

		return Object.assign({}, createEmptyTestResult(), {
			console = Object.None,
			displayName = config.displayName,
			failureMessage = failureMessage,
			numFailingTests = numFailingTests,
			numPassingTests = numPassingTests,
			numPendingTests = numPendingTests,
			numTodoTests = numTodoTests,
			testExecError = testExecError,
			testFilePath = testPath,
			testResults = assertionResults,
		})
	end)
end
exports.runAndTransformResultsToJestFormat = runAndTransformResultsToJestFormat

function handleSnapshotStateAfterRetry(snapshotState: SnapshotStateType)
	return function(_self, event: Circus_Event)
		if event.name == "test_retry" then
			-- Clear any snapshot data that occurred in previous test run
			snapshotState:clear()
		end
	end
end

function eventHandler(_self, event: Circus_Event)
	return Promise.resolve():andThen(function()
		repeat
			if event.name == "test_start" then
				setState({ currentTestName = getTestID(event.test) })
				break
			elseif event.name == "test_done" then
				_addSuppressedErrors(event.test)
				_addExpectedAssertionErrors(event.test)
				break
			end
		until true
	end)
end

function _addExpectedAssertionErrors(test: Circus_TestEntry)
	local failures = extractExpectedAssertionsErrors()
	local errors = Array.map(failures, function(failure)
		return failure.error
	end)
	test.errors = Array.concat(test.errors, errors)
end

-- Get suppressed errors from ``jest-matchers`` that weren't throw during
-- test execution and add them to the test result, potentially failing
-- a passing test.
function _addSuppressedErrors(test: Circus_TestEntry)
	local suppressedErrors = getState().suppressedErrors
	setState({ suppressedErrors = {} })
	if #suppressedErrors ~= 0 then
		test.errors = Array.concat(test.errors, suppressedErrors)
	end
end

return exports
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="264">
                  <Properties>
                    <string name="Name">jestExpect</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/legacy-code-todo-rewrite/jestExpect.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent.Parent.Parent

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
local expect = require(Packages.Expect)
local jest_snapshotModule = require(Packages.JestSnapshot)
local addSerializer = jest_snapshotModule.addSerializer
-- ROBLOX TODO: not implemented yet
-- local toMatchInlineSnapshot = jest_snapshotModule.toMatchInlineSnapshot
local toMatchSnapshot = jest_snapshotModule.toMatchSnapshot
-- ROBLOX TODO: not implemented yet
-- local toThrowErrorMatchingInlineSnapshot = jest_snapshotModule.toThrowErrorMatchingInlineSnapshot
local toThrowErrorMatchingSnapshot = jest_snapshotModule.toThrowErrorMatchingSnapshot
export type Expect = typeof(expect)

-- ROBLOX deviation: inline type as Pick utility type is not available in Luau
type Pick_Config_GlobalConfig_expand = {
	expand: boolean,
}
exports.default = function(config: Pick_Config_GlobalConfig_expand): Expect
	expect.setState({ expand = config.expand })
	expect.extend({
		-- ROBLOX TODO: not implemented yet
		-- toMatchInlineSnapshot = toMatchInlineSnapshot,
		toMatchSnapshot = toMatchSnapshot,
		-- ROBLOX TODO: not implemented yet
		-- toThrowErrorMatchingInlineSnapshot = toThrowErrorMatchingInlineSnapshot,
		toThrowErrorMatchingSnapshot = toThrowErrorMatchingSnapshot,
	})
	expect.addSnapshotSerializer = addSerializer
	return expect
end
return exports
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="265">
                  <Properties>
                    <string name="Name">temporarySnapshotData</string>
                    <string name="Source"><![CDATA[return {}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="266">
                <Properties>
                  <string name="Name">run</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/run.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
type Promise<T> = LuauPolyfill.Promise<T>

local Promise = require(Packages.Promise)

local exports = {}
local typesModule = require(Packages.JestTypes)
type Circus_RunResult = typesModule.Circus_RunResult
type Circus_DescribeBlock = typesModule.Circus_DescribeBlock
type Circus_TestEntry = typesModule.Circus_TestEntry
type Circus_Hook = typesModule.Circus_Hook
type Circus_TestContext = typesModule.Circus_TestContext
local stateModule = require(script.Parent.state)
local dispatch = stateModule.dispatch
local getState = stateModule.getState
local RETRY_TIMES = require(script.Parent.types).RETRY_TIMES
local utilsModule = require(script.Parent.utils)
local callAsyncCircusFn = utilsModule.callAsyncCircusFn
local getAllHooksForDescribe = utilsModule.getAllHooksForDescribe
local getEachHooksForTest = utilsModule.getEachHooksForTest
local getTestID = utilsModule.getTestID
local invariant = utilsModule.invariant
local makeRunResult = utilsModule.makeRunResult

-- ROBLOX deviation START: predefine variables
local _runTestsForDescribeBlock
local _runTest
local _callCircusHook
local _callCircusTest
-- ROBLOX deviation END

local function run(): Promise<Circus_RunResult>
	return Promise.resolve():andThen(function()
		local rootDescribeBlock
		do
			local ref = getState()
			rootDescribeBlock = ref.rootDescribeBlock
		end
		dispatch({ name = "run_start" }):expect()
		_runTestsForDescribeBlock(rootDescribeBlock):expect()
		dispatch({ name = "run_finish" }):expect()
		return makeRunResult(getState().rootDescribeBlock, getState().unhandledErrors)
	end)
end

function _runTestsForDescribeBlock(describeBlock: Circus_DescribeBlock)
	return Promise.resolve():andThen(function()
		dispatch({ describeBlock = describeBlock, name = "run_describe_start" }):expect()
		local ref = getAllHooksForDescribe(describeBlock)
		local beforeAll, afterAll = ref.beforeAll, ref.afterAll

		local isSkipped = describeBlock.mode == "skip"

		if not isSkipped then
			for _, hook in ipairs(beforeAll) do
				_callCircusHook({
					describeBlock = describeBlock,
					hook = hook,
				}):expect()
			end
		end

		-- Tests that fail and are retried we run after other tests
		local ref_ = tonumber(_G[RETRY_TIMES], 10)
		local retryTimes = if ref_ ~= nil then ref_ else 0
		local deferredRetryTests = {}

		for _, child in ipairs(describeBlock.children) do
			if child.type == "describeBlock" then
				_runTestsForDescribeBlock(child):expect()
			elseif child.type == "test" then
				local hasErrorsBeforeTestRun = #child.errors > 0
				_runTest(child, isSkipped):expect()

				if hasErrorsBeforeTestRun == false and retryTimes > 0 and #child.errors > 0 then
					table.insert(deferredRetryTests, child)
				end
			end
		end

		-- Re-run failed tests n-times if configured
		for _, test in ipairs(deferredRetryTests) do
			local numRetriesAvailable = retryTimes

			while numRetriesAvailable > 0 and #test.errors > 0 do
				-- Clear errors so retries occur
				dispatch({ name = "test_retry", test = test }):expect()

				_runTest(test, isSkipped):expect()
				numRetriesAvailable -= 1
			end
		end

		if not isSkipped then
			for _, hook in ipairs(afterAll) do
				_callCircusHook({ describeBlock = describeBlock, hook = hook }):expect()
			end
		end

		dispatch({ describeBlock = describeBlock, name = "run_describe_finish" }):expect()
	end)
end

function _runTest(test: Circus_TestEntry, parentSkipped: boolean): Promise<nil>
	return Promise.resolve():andThen(function()
		dispatch({ name = "test_start", test = test }):expect()
		local testContext = {}
		local ref = getState()
		local hasFocusedTests, testNamePattern = ref.hasFocusedTests, ref.testNamePattern
		local isSkipped = parentSkipped
			or test.mode == "skip"
			or (hasFocusedTests and test.mode ~= "only")
			or (testNamePattern and not testNamePattern:test(getTestID(test)))

		if isSkipped then
			dispatch({ name = "test_skip", test = test }):expect()
			return
		end

		if test.mode == "todo" then
			dispatch({ name = "test_todo", test = test }):expect()
			return
		end

		local ref_ = getEachHooksForTest(test)
		local afterEach, beforeEach = ref_.afterEach, ref_.beforeEach

		for _, hook in ipairs(beforeEach) do
			if #test.errors > 0 then
				-- If any of the before hooks failed already, we don't run any
				-- hooks after that.
				break
			end

			_callCircusHook({
				hook = hook,
				test = test,
				testContext = testContext,
			}):expect()
		end

		_callCircusTest(test, testContext):expect()

		for _, hook in ipairs(afterEach) do
			_callCircusHook({ hook = hook, test = test, testContext = testContext }):expect()
		end

		-- `afterAll` hooks should not affect test status (pass or fail), because if
		-- we had a global `afterAll` hook it would block all existing tests until
		-- this hook is executed. So we dispatch `test_done` right away.
		dispatch({ name = "test_done", test = test }):expect()
	end)
end

function _callCircusHook(ref: {
	hook: Circus_Hook,
	describeBlock: Circus_DescribeBlock?,
	test: Circus_TestEntry?,
	testContext: Circus_TestContext?,
}): Promise<nil>
	local hook, test, describeBlock, testContext = ref.hook, ref.test, ref.describeBlock, ref.testContext
	return Promise.resolve():andThen(function()
		dispatch({ hook = hook, name = "hook_start" }):expect()
		local timeout = if Boolean.toJSBoolean(hook.timeout) and hook.timeout ~= nil
			then hook.timeout
			else getState().testTimeout

		local ok, error_ = pcall(function()
			callAsyncCircusFn(hook, testContext, { isHook = true, timeout = timeout }):expect()
			dispatch({
				describeBlock = describeBlock,
				hook = hook,
				name = "hook_success",
				test = test,
			}):expect()
		end)
		if not ok then
			dispatch({
				describeBlock = describeBlock,
				error = error_,
				hook = hook,
				name = "hook_failure",
				test = test,
			}):expect()
		end
	end)
end

function _callCircusTest(test: Circus_TestEntry, testContext: Circus_TestContext): Promise<nil>
	return Promise.resolve():andThen(function()
		dispatch({ name = "test_fn_start", test = test }):expect()
		local timeout = Boolean.toJSBoolean(test.timeout) and test.timeout or getState().testTimeout
		invariant(test.fn, "Tests with no 'fn' should have 'mode' set to 'skipped'")

		if #test.errors > 0 then
			return -- We don't run the test if there's already an error in before hooks.
		end
		local ok, error_ = pcall(function()
			callAsyncCircusFn(test, testContext, { isHook = false, timeout = timeout }):expect()
			if test.failing then
				test.asyncError.message =
					"Failing test passed even though it was supposed to fail. Remove `.failing` to remove error."
				dispatch({
					error = test.asyncError,
					name = "test_fn_failure",
					test = test,
				})
			else
				dispatch({ name = "test_fn_success", test = test }):expect()
			end
		end)
		if not ok then
			if test.failing then
				dispatch({ name = "test_fn_success", test = test })
			else
				dispatch({ error = error_, name = "test_fn_failure", test = test }):expect()
			end
		end
	end)
end

exports.default = run

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="267">
                <Properties>
                  <string name="Name">state</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/state.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- ROBLOX deviation START: moved implementation to `combined.lua` to avoid cyclic dependencies

local combinedModule = require(script.Parent.combined)

local exports = {}

exports.ROOT_DESCRIBE_BLOCK_NAME = combinedModule.ROOT_DESCRIBE_BLOCK_NAME
exports.resetState = combinedModule.resetState
exports.getState = combinedModule.getState
exports.setState = combinedModule.setState
exports.dispatch = combinedModule.dispatch
exports.dispatchSync = combinedModule.dispatchSync
exports.addEventHandler = combinedModule.addEventHandler

-- ROBLOX deviation END

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="268">
                <Properties>
                  <string name="Name">state_</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/state.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- ROBLOX deviation: moved implementation from `state.lua` to avoid cyclic dependencies
local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent

local typesModule = require(Packages.JestTypes)
type Circus_State = typesModule.Circus_State

local STATE_SYM = require(script.Parent.types).STATE_SYM

local exports = {}

local ROOT_DESCRIBE_BLOCK_NAME = "ROOT_DESCRIBE_BLOCK"
exports.ROOT_DESCRIBE_BLOCK_NAME = ROOT_DESCRIBE_BLOCK_NAME

local function getState(): Circus_State
	return _G[STATE_SYM]
end
exports.getState = getState

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="269">
                <Properties>
                  <string name="Name">testCaseReportHandler</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/testCaseReportHandler.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent
local exports = {}
local testResultModule = require(Packages.JestTestResult)
type TestFileEvent = testResultModule.TestFileEvent
local typesModule = require(Packages.JestTypes)
type Circus_Event = typesModule.Circus_Event
local utilsModule = require(script.Parent.utils)
local makeSingleTestResult = utilsModule.makeSingleTestResult
local parseSingleTestResult = utilsModule.parseSingleTestResult

local function testCaseReportHandler(testPath: string, sendMessageToJest: TestFileEvent)
	return function(_self, event: Circus_Event): ()
		if event.name == "test_done" then
			local testResult = makeSingleTestResult(event.test)
			local testCaseResult = parseSingleTestResult(testResult)
			-- ROBLOX FIXME Luau: roblox-cli doesn't allow for mixed arrays
			sendMessageToJest("test-case-result", { testPath :: any, testCaseResult })
		end
	end
end

exports.default = testCaseReportHandler

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="270">
                <Properties>
                  <string name="Name">types</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/types.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol

local exports = {}

-- Used as type
local typesModule = require(Packages.JestTypes)
type Circus_State = typesModule.Circus_State
local expect = require(Packages.Expect)

local STATE_SYM = (Symbol("JEST_STATE_SYMBOL") :: unknown) :: "STATE_SYM_SYMBOL"
exports.STATE_SYM = STATE_SYM
local RETRY_TIMES = (Symbol.for_("RETRY_TIMES") :: unknown) :: "RETRY_TIMES_SYMBOL"
exports.RETRY_TIMES = RETRY_TIMES
-- To pass this value from Runtime object to state we need to use global[sym]
local TEST_TIMEOUT_SYMBOL = (Symbol.for_("TEST_TIMEOUT_SYMBOL") :: unknown) :: "TEST_TIMEOUT_SYMBOL"
exports.TEST_TIMEOUT_SYMBOL = TEST_TIMEOUT_SYMBOL

-- ROBLOX NOTE: can't declare type within a global namespace in Luau
export type NodeJS_Global = {
	STATE_SYM_SYMBOL: Circus_State,
	RETRY_TIMES_SYMBOL: string,
	TEST_TIMEOUT_SYMBOL: number,
	expect: typeof(expect),
}

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="271">
                <Properties>
                  <string name="Name">utils</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/src/utils.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>

local Promise = require(Packages.Promise)

-- ROBLOX deviation START: predefine variables
local makeTestResults
local getTestID
local _getError
local getErrorStack
local invariant
-- ROBLOX deviation END

-- ROBLOX deviation START: add additional imports
local RegExp = require(Packages.RegExp)
-- ROBLOX deviation END

-- ROBLOX deviation START: add function to extract bare string message from stacktrace line
local function separateMessageFromStack(content: string): { message: string, stack: string }
	if not content then
		return { message = "", stack = "" }
	end
	local message = content
	local stack = ""
	local re = RegExp([=[^(\s*LoadedCode.*:\d+)?(: )?(.*)$]=])
	local messageMatch = re:exec(content)
	if messageMatch then
		message = messageMatch[4]
		stack = messageMatch[2]
	end
	return { message = message, stack = stack }
end
-- ROBLOX deviation END

-- ROBLOX FIXME START: added types and objects that do not exist in Luau
type NodeJS_Timeout = LuauPolyfill.Timeout
-- ROBLOX FIXME END

local exports = {}

-- ROBLOX deviation START: not using path and co dependencies
-- local path = require(Packages.path)
-- local co = require(Packages.co).default
-- ROBLOX deviation END
-- ROBLOX deviation: use dedent implementation from graphql-lua
local dedent = require(Packages.RobloxShared).dedent
-- ROBLOX deviation: generator functions are not supported in Lua
-- local isGeneratorFn = require(Packages["is-generator-fn"]).default
--[[
	ROBLOX deviation:
	not using slash and stack-utils dependencies
	original code:
	import slash = require('slash');
	import StackUtils = require('stack-utils');
]]
local testResultModule = require(Packages.JestTestResult)
type AssertionResult = testResultModule.AssertionResult
type Status = testResultModule.Status
local typesModule = require(Packages.JestTypes)
type Circus_BlockName = typesModule.Circus_BlockName
type Circus_DescribeBlock = typesModule.Circus_DescribeBlock
type Circus_BlockMode = typesModule.Circus_BlockMode
type Circus_TestFn = typesModule.Circus_TestFn
type Circus_TestMode = typesModule.Circus_TestMode
type Circus_TestName = typesModule.Circus_TestName
type Circus_Exception = typesModule.Circus_Exception
type Circus_TestEntry = typesModule.Circus_TestEntry
type Circus_Hook = typesModule.Circus_Hook
type Circus_AsyncFn = typesModule.Circus_AsyncFn
type Circus_TestContext = typesModule.Circus_TestContext
type Circus_TestResult = typesModule.Circus_TestResult
type Circus_TestResults = typesModule.Circus_TestResults
type Circus_TestStatus = typesModule.Circus_TestStatus
type Circus_RunResult = typesModule.Circus_RunResult
type Global_PromiseReturningTestFn = typesModule.Global_PromiseReturningTestFn
type Global_TestReturnValue = typesModule.Global_TestReturnValue
type Global_GeneratorReturningTestFn = typesModule.Global_GeneratorReturningTestFn
local jestUtilModule = require(Packages.JestUtil)
local ErrorWithStack = jestUtilModule.ErrorWithStack
local convertDescriptorToString = jestUtilModule.convertDescriptorToString
local formatTime = jestUtilModule.formatTime
local prettyFormat = require(Packages.PrettyFormat).format
-- ROBLOX deviation: move to `state_.lua` to avoid cyclic dependency
local stateModule = require(script.Parent.state_)
local ROOT_DESCRIBE_BLOCK_NAME = stateModule.ROOT_DESCRIBE_BLOCK_NAME
local getState = stateModule.getState

-- ROBLOX deviation START: not using slash and stack-utils dependencies
-- local stackUtils = StackUtils.new({ cwd = "A path that does not exist" })
-- local jestEachBuildDir = slash(path:dirname(require:resolve("jest-each")))
-- ROBLOX deviation END

local function takesDoneCallback(
	fn: Circus_AsyncFn
): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ fn is Global.DoneTakingTestFn ]]
	return debug.info(fn, "a") > 1
end

-- ROBLOX deviation START: generator functions are not supported in Lua
local function isGeneratorFunction(
	_fn: Global_PromiseReturningTestFn | Global_GeneratorReturningTestFn
): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ fn is Global.GeneratorReturningTestFn ]]
	--[[
		ROBLOX deviation START: generator functions are not supported in Lua
		original code:
		return isGeneratorFn(fn);
	]]
	return false
	-- ROBLOX deviation END
end

local function makeDescribe(
	name: Circus_BlockName,
	parent: Circus_DescribeBlock?,
	mode: Circus_BlockMode?
): Circus_DescribeBlock
	local _mode = mode
	if parent ~= nil and not Boolean.toJSBoolean(mode) then
		-- If not set explicitly, inherit from the parent describe.
		_mode = parent.mode
	end

	return {
		type = "describeBlock", -- eslint-disable-next-line sort-keys
		children = {},
		hooks = {},
		-- ROBLOX FIXME Luau: if statement above should narrow the type to non-nil
		mode = _mode :: Circus_BlockMode,
		name = convertDescriptorToString(name),
		parent = parent,
		tests = {},
	}
end
exports.makeDescribe = makeDescribe

local function makeTest(
	fn: Circus_TestFn,
	mode: Circus_TestMode,
	name: Circus_TestName,
	parent: Circus_DescribeBlock,
	timeout: number | nil,
	asyncError: Circus_Exception,
	failing: boolean
): Circus_TestEntry
	return {
		type = "test", -- eslint-disable-next-line sort-keys
		asyncError = asyncError,
		duration = nil,
		errors = {},
		failing = failing,
		fn = fn,
		invocations = 0,
		mode = mode,
		name = convertDescriptorToString(name),
		parent = parent,
		retryReasons = {},
		seenDone = false,
		startedAt = nil,
		status = nil,
		timeout = timeout,
	}
end
exports.makeTest = makeTest

-- Traverse the tree of describe blocks and return true if at least one describe
-- block has an enabled test.
-- Traverse the tree of describe blocks and return true if at least one describe
-- block has an enabled test.
local function hasEnabledTest(describeBlock: Circus_DescribeBlock): boolean
	local ref = getState()
	local hasFocusedTests, testNamePattern = ref.hasFocusedTests, ref.testNamePattern
	return Array.some(describeBlock.children, function(child: Circus_DescribeBlock | Circus_TestEntry)
		return if child.type == "describeBlock"
			then hasEnabledTest(child)
			else not (
				child.mode == "skip"
				or (hasFocusedTests and child.mode ~= "only")
				or (testNamePattern and not testNamePattern:test(getTestID(child :: Circus_TestEntry)))
			)
	end)
end

type DescribeHooks = {
	beforeAll: Array<Circus_Hook>,
	afterAll: Array<Circus_Hook>,
}

local function getAllHooksForDescribe(describe: Circus_DescribeBlock): DescribeHooks
	local result: DescribeHooks = { afterAll = {}, beforeAll = {} }

	if hasEnabledTest(describe) then
		for _, hook in ipairs(describe.hooks) do
			if hook.type == "beforeAll" then
				table.insert(result.beforeAll, hook)
			elseif hook.type == "afterAll" then
				table.insert(result.afterAll, hook)
			end
		end
	end

	return result
end
exports.getAllHooksForDescribe = getAllHooksForDescribe

type TestHooks = {
	beforeEach: Array<Circus_Hook>,
	afterEach: Array<Circus_Hook>,
}

local function getEachHooksForTest(test: Circus_TestEntry): TestHooks
	local result: TestHooks = { afterEach = {}, beforeEach = {} }
	local block: Circus_DescribeBlock | nil = test.parent

	repeat
		local beforeEachForCurrentBlock = {}
		-- TODO: inline after https://github.com/microsoft/TypeScript/pull/34840 is released

		local hook: Circus_Hook
		for _, hook_ in ipairs((block :: Circus_DescribeBlock).hooks) do
			hook = hook_
			if hook.type == "beforeEach" then
				table.insert(beforeEachForCurrentBlock, hook)
			elseif hook.type == "afterEach" then
				table.insert(result.afterEach, hook)
			end
		end
		-- 'beforeEach' hooks are executed from top to bottom, the opposite of the
		-- way we traversed it.

		result.beforeEach = Array.concat({}, beforeEachForCurrentBlock, result.beforeEach)

		block = (block :: Circus_DescribeBlock).parent
	until not Boolean.toJSBoolean(block)
	return result
end
exports.getEachHooksForTest = getEachHooksForTest

local function describeBlockHasTests(describe: Circus_DescribeBlock): boolean
	return Array.some(describe.children, function(child)
		return child.type == "test" or describeBlockHasTests(child)
	end)
end
exports.describeBlockHasTests = describeBlockHasTests

local function _makeTimeoutMessage(timeout: number, isHook: boolean)
	return ("Exceeded timeout of %s for a %s.\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test."):format(
		formatTime(timeout),
		if isHook then "hook" else "test"
	)
end

-- Global values can be overwritten by mocks or tests. We'll capture
-- the original values in the variables before we require any files.
-- ROBLOX deviation: using LuauPolyfill instead of global
local setTimeout, clearTimeout = LuauPolyfill.setTimeout, LuauPolyfill.clearTimeout

local function checkIsError(
	error_: unknown
): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ error is Error ]]
	return Boolean.toJSBoolean(error_)
		and Boolean.toJSBoolean((error_ :: Error).message)
		and Boolean.toJSBoolean((error_ :: Error).stack)
end

local function callAsyncCircusFn(
	testOrHook: Circus_TestEntry | Circus_Hook,
	testContext: Circus_TestContext | nil,
	ref: { isHook: boolean, timeout: number }
): Promise<unknown>
	local isHook, timeout = ref.isHook, ref.timeout
	local timeoutID: NodeJS_Timeout
	local completed = false

	local fn, asyncError = testOrHook.fn, testOrHook.asyncError

	return Promise.new(function(resolve: (...any) -> (), reject: (reason: any) -> ())
		timeoutID = setTimeout(function()
			return reject(_makeTimeoutMessage(timeout, isHook))
		end, timeout)

		-- If this fn accepts `done` callback we return a promise that fulfills as
		-- soon as `done` called.
		if takesDoneCallback(fn) then
			local returnedValue: unknown = nil

			local function done(reason: (Error | string)?): ()
				-- We need to keep a stack here before the promise tick
				local errorAtDone = ErrorWithStack.new(nil, done)

				if not completed and testOrHook.seenDone then
					errorAtDone.message = "Expected done to be called once, but it was called multiple times."

					if Boolean.toJSBoolean(reason) then
						errorAtDone.message ..= " Reason: " .. prettyFormat(reason, { maxDepth = 3 })
					end
					reject(errorAtDone)
					error(errorAtDone)
				else
					-- ROBLOX FIXME Luau: both Circus_TestEntry and Circus_Hook have this field but Luau analyze still complains
					(testOrHook :: any).seenDone = true
				end

				-- Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously
				-- ROBLOX deviation: using Promise.delay instead of Promise.resolve as the latter resolves synchronously in Lua implementation
				Promise.delay(0):andThen(function()
					if returnedValue ~= nil then
						-- ROBLOX CHECK: dedent with tagged templates might be implemented differently
						asyncError.message = dedent(([[

      Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.
      Returned value: %s
      ]]):format(prettyFormat(returnedValue, {
							maxDepth = 3,
						})))
						return reject(asyncError)
					end

					local errorAsErrorObject: Error
					if checkIsError(reason) then
						-- ROBLOX FIXME: Luau doesn't support type assertions with a function
						errorAsErrorObject = reason :: Error
					else
						errorAsErrorObject = errorAtDone
						errorAtDone.message = ("Failed: %s"):format(prettyFormat(reason, { maxDepth = 3 }))
					end

					-- Consider always throwing, regardless if `reason` is set or not
					if completed and Boolean.toJSBoolean(reason) then
						errorAsErrorObject.message = "Caught error after test environment was torn down\n\n"
							.. errorAsErrorObject.message

						error(errorAsErrorObject)
					end

					return if Boolean.toJSBoolean(reason) then reject(errorAsErrorObject) else resolve()
				end)
			end

			-- ROBLOX FIXME Luau: roblox cli doesn't allow to call when type is a union of functions
			returnedValue = (fn :: any)(testContext, done)

			return
		end

		local returnedValue: Global_TestReturnValue
		-- ROBLOX FIXME Luau: seems like a false negative for type conversion
		if isGeneratorFunction(fn :: any) then
			-- ROBLOX deviation START: generator functions are not supported in Lua
			error("Generator functions are not supported in Lua")
			-- returnedValue = co:wrap(fn)({})
			-- ROBLOX deviation END
		else
			-- ROBLOX FIXME Luau: pcall should accept variadic number of params
			local ok, result = (pcall :: any)(fn, testContext)
			if not ok then
				local error_ = result
				reject(error_)
				return
			end
			returnedValue = result
		end

		-- If it's a Promise, return it. Test for an object with a `then` function
		-- to support custom Promise implementations.
		if
			typeof(returnedValue) == "table"
			and returnedValue ~= nil
			and typeof(returnedValue.andThen) == "function"
		then
			returnedValue:andThen(function()
				return resolve()
			end, reject)
			return
		end

		if not isHook and returnedValue ~= nil then
			-- ROBLOX CHECK: dedent with tagged templates might be implemented differently
			reject((dedent(([[

test functions can only return Promise or undefined.
      Returned value: %s
      ]]):format(prettyFormat(returnedValue, {
				maxDepth = 3,
			})))))
			return
		end

		-- Otherwise this test is synchronous, and if it didn't throw it means
		-- it passed.
		resolve()
	end)
		:andThen(function()
			completed = true
			-- If timeout is not cleared/unrefed the node process won't exit until
			-- it's resolved.
			-- ROBLOX deviation: no need to unref the timeoutID in Lua
			-- timeoutID.unref?.()
			clearTimeout(timeoutID)
		end)
		:catch(function(error_)
			completed = true
			-- ROBLOX deviation: no need to unref the timeoutID in Lua
			-- timeoutID.unref?.()
			clearTimeout(timeoutID)
			-- ROBLOX deviation START: add special handling for bare strings getting thrown as Promise chain will make them unusable otherwise
			if typeof(error_) == "string" then
				local separated = separateMessageFromStack(error_)
				local wrappedError = Error.new(separated.message);
				(wrappedError :: any).__stack = separated.stack
				Error.__recalculateStacktrace(wrappedError)
				error(wrappedError)
			end
			-- ROBLOX deviation END
			error(error_)
		end)
end
exports.callAsyncCircusFn = callAsyncCircusFn

local function getTestDuration(test: Circus_TestEntry): number | nil
	local startedAt = test.startedAt
	return if typeof(startedAt) == "number" then DateTime.now().UnixTimestampMillis - startedAt else nil
end
exports.getTestDuration = getTestDuration

local function makeRunResult(describeBlock: Circus_DescribeBlock, unhandledErrors: Array<Error>): Circus_RunResult
	return {
		testResults = makeTestResults(describeBlock),
		unhandledErrors = Array.map(Array.map(unhandledErrors, _getError), getErrorStack),
	}
end
exports.makeRunResult = makeRunResult

local function makeSingleTestResult(test: Circus_TestEntry): Circus_TestResult
	local _includeTestLocationInResult = getState().includeTestLocationInResult
	local testPath = {}
	local parent: Circus_TestEntry | Circus_DescribeBlock | nil = test

	local status = test.status
	invariant(status, "Status should be present after tests are run.")

	repeat
		--[[
			ROBLOX FIXME Luau:
			weird type checking issue.
			In the first loop pass parent is guaranteed to not be nil because it's equal to `test`
			Every concecutive loop run is guarded by until check
		]]
		table.insert(testPath, 1, (parent :: Circus_TestEntry | Circus_DescribeBlock).name)

		parent = (parent :: Circus_TestEntry | Circus_DescribeBlock).parent
	until parent == nil

	local location = nil
	-- ROBLOX TODO START: uncomment when implemented relevant pieces of stackUtils
	-- if includeTestLocationInResult then
	-- 	local stackLines = String.split(test.asyncError.stack, "\n")
	-- 	local stackLine = stackLines[2]
	-- 	local parsedLine = stackUtils:parseLine(stackLine)
	-- 	if parsedLine ~= nil and parsedLine.file ~= nil and String.startsWith(parsedLine.file, jestEachBuildDir) then
	-- 		local stackLine = stackLines[5]
	-- 		parsedLine = stackUtils:parseLine(stackLine)
	-- 	end
	-- 	if
	-- 		Boolean.toJSBoolean(parsedLine)
	-- 		and typeof(parsedLine.column) == "number"
	-- 		and typeof(parsedLine.line) == "number"
	-- 	then
	-- 		location = {
	-- 			column = parsedLine.column,
	-- 			line = parsedLine.line,
	-- 		}
	-- 	end
	-- end
	-- ROBLOX TODO END

	local errorsDetailed = Array.map(test.errors, _getError)

	return {
		duration = test.duration,
		errors = Array.map(errorsDetailed, getErrorStack),
		errorsDetailed = errorsDetailed,
		invocations = test.invocations,
		location = location,
		retryReasons = Array.map(Array.map(test.retryReasons, _getError), getErrorStack),
		-- ROBLOX FIXME Luau: assert above should narrow the type to non-nil
		status = status :: Circus_TestStatus,
		testPath = Array.from(testPath),
	}
end
exports.makeSingleTestResult = makeSingleTestResult

function makeTestResults(describeBlock: Circus_DescribeBlock): Circus_TestResults
	local testResults: Circus_TestResults = {}

	for _, child in ipairs(describeBlock.children) do
		if child.type == "describeBlock" then
			testResults = Array.concat(testResults, makeTestResults(child))
		elseif child.type == "test" then
			table.insert(testResults, makeSingleTestResult(child))
		end
	end

	return testResults
end

-- Return a string that identifies the test (concat of parent describe block
-- names + test title)
function getTestID(test: Circus_TestEntry): string
	local titles = {}
	local parent: Circus_TestEntry | Circus_DescribeBlock | nil = test
	repeat
		--[[
			ROBLOX FIXME Luau:
			weird type checking issue.
			In the first loop pass parent is guaranteed to not be nil because it's equal to `test`
			Every concecutive loop run is guarded by until check
		]]
		table.insert(titles, 1, (parent :: Circus_TestEntry | Circus_DescribeBlock).name)

		parent = (parent :: Circus_TestEntry | Circus_DescribeBlock).parent
	until parent == nil

	table.remove(titles, 1) -- remove TOP_DESCRIBE_BLOCK_NAME
	return Array.join(titles, " ")
end
exports.getTestID = getTestID

function _getError(errors: (Circus_Exception | Array<Circus_Exception | nil | Circus_Exception>)?): Error
	local error_
	local asyncError: Circus_Exception

	if Array.isArray(errors) then
		-- ROBLOX FIXME START: Luau doesn't support type assertions with a function
		local errors_ = errors :: Array<Circus_Exception | nil | Circus_Exception>
		error_ = errors_[1]
		asyncError = errors_[2]
		-- ROBLOX FIXME END
	else
		error_ = errors
		asyncError = Error.new()
	end

	if error_ ~= nil and (typeof(error_.stack) == "string" or Boolean.toJSBoolean(error_.message)) then
		return error_
	end

	asyncError.message = ("thrown: %s"):format(prettyFormat(error_, { maxDepth = 3 }))

	return asyncError
end

function getErrorStack(error_): string
	-- ROBLOX DEVIATION START: avoid losing error info from already-separated
	-- messages by only reducing to the stack if the message is a subset of it
	if typeof(error_.stack) == "string" then
		local plain = true
		if string.find(error_.stack, error_.message, nil, plain) then
			return error_.stack
		else
			return error_.message .. "\n" .. error_.stack
		end
	end
	return error_.message
	-- ROBLOX DEVIATION END
	-- return if typeof(error_.stack) == "string" then error_.stack else error_.message
end

local function addErrorToEachTestUnderDescribe(
	describeBlock: Circus_DescribeBlock,
	error_,
	asyncError: Circus_Exception
): ()
	for _, child in ipairs(describeBlock.children) do
		if child.type == "describeBlock" then
			-- ROBLOX FIXME Luau: analyze should narrow the child type here
			addErrorToEachTestUnderDescribe(child :: Circus_DescribeBlock, error_, asyncError)
		elseif child.type == "test" then
			table.insert(child.errors, { error_, asyncError })
		end
	end
end
exports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe

function invariant(
	condition: unknown,
	message: string?
): () --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ asserts condition ]]
	if not Boolean.toJSBoolean(condition) then
		error(Error.new(message))
	end
end
exports.invariant = invariant

local function parseSingleTestResult(testResult: Circus_TestResult): AssertionResult
	local status: Status
	if testResult.status == "skip" then
		status = "pending"
	elseif testResult.status == "todo" then
		status = "todo"
	elseif #testResult.errors > 0 then
		status = "failed"
	else
		status = "passed"
	end

	local ancestorTitles = Array.filter(testResult.testPath, function(name)
		return name ~= ROOT_DESCRIBE_BLOCK_NAME
	end)
	local title = table.remove(ancestorTitles)

	return {
		ancestorTitles = ancestorTitles,
		duration = testResult.duration,
		failureDetails = testResult.errorsDetailed,
		failureMessages = Array.from(testResult.errors),
		fullName = if Boolean.toJSBoolean(title)
			then Array.join(Array.concat(ancestorTitles, title), " ")
			else Array.join(ancestorTitles, " "),
		invocations = testResult.invocations,
		location = testResult.location,
		numPassingAsserts = 0,
		retryReasons = Array.from(testResult.retryReasons),
		status = status,
		title = testResult.testPath[#testResult.testPath],
	}
end
exports.parseSingleTestResult = parseSingleTestResult

return exports
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="272">
              <Properties>
                <string name="Name">runner</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-circus/runner.js

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
-- Allow people to use `jest-circus/runner` as a runner.
local runner = require(script.Parent.circus["legacy-code-todo-rewrite"].jestAdapter)
return runner
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="273">
            <Properties>
              <string name="Name">JestConfig</string>
              <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

-- ROBLOX deviation START: not needed
-- local path = require(Packages.path)
-- ROBLOX deviation END
local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation START: not needed
-- local fs = require(Packages["graceful-fs"])
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_Argv = typesModule.Config_Argv
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_InitialOptions = typesModule.Config_InitialOptions
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
-- ROBLOX deviation START: not needed
-- local tryRealpath = require(Packages.JestUtil).tryRealpath
-- ROBLOX deviation END
local constants = require(script.constants)
local normalize = require(script.normalize).default
local readConfigFileAndSetRootDir = require(script.readConfigFileAndSetRootDir).default
local resolveConfigPath = require(script.resolveConfigPath).default
local utilsModule = require(script.utils)
local isJSONString = utilsModule.isJSONString

-- ROBLOX deviation START: not needed
-- local replaceRootDirInPath = utilsModule.replaceRootDirInPath
-- TODO: remove export in Jest 28
-- exports.getTestEnvironment = require(Packages["jest-resolve"]).resolveTestEnvironment
-- ROBLOX deviation END
exports.isJSONString = require(script.utils).isJSONString
exports.normalize = require(script.normalize).default
-- ROBLOX deviation START: not needed
-- exports.deprecationEntries = require(script.Deprecated).default
-- exports.replaceRootDirInPath = require(script.utils).replaceRootDirInPath
-- ROBLOX deviation END
exports.defaults = require(script.Defaults).default
-- ROBLOX deviation START: not needed
-- exports.descriptions = require(script.Descriptions).default
-- ROBLOX deviation END
exports.constants = constants

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
type NodeJS_WriteStream = RobloxShared.NodeJS_WriteStream
local JSON = nodeUtils.JSON
-- ROBLOX deviation END

-- ROBLOX deviation START: predefine functions
local groupOptions
local ensureNoDuplicateConfigs
-- ROBLOX deviation END

type ReadConfig = {
	-- ROBLOX deviation START: using ModuleScript instead of Config_Path
	configPath: ModuleScript | nil,
	-- ROBLOX deviation END
	globalConfig: Config_GlobalConfig,
	hasDeprecationWarnings: boolean,
	projectConfig: Config_ProjectConfig,
}

local function readConfig(
	cwdInstance: Instance,
	argv: Config_Argv,
	-- ROBLOX deviation START: using Instance instead of Config_Path
	packageRootOrConfig: Instance | Config_InitialOptions,
	-- ROBLOX deviation END
	-- Whether it needs to look into `--config` arg passed to CLI.
	-- It only used to read initial config. If the initial config contains
	-- `project` property, we don't want to read `--config` value and rather
	-- read individual configs for every project.
	skipArgvConfigOption: boolean?,
	-- ROBLOX deviation START: using Instance instead of Config_Path
	parentConfigDirname: Instance?,
	-- ROBLOX deviation END
	projectIndex: any?,
	skipMultipleConfigWarning: boolean?
): Promise<ReadConfig>
	if projectIndex == nil then
		projectIndex = math.huge
	end
	if skipMultipleConfigWarning == nil then
		skipMultipleConfigWarning = false
	end
	return Promise.resolve():andThen(function()
		local rawOptions: Config_InitialOptions
		local configPath = nil

		if
			-- ROBLOX deviation START: using Instance instead of Config_Path
			typeof(packageRootOrConfig) ~= "Instance" and typeof(packageRootOrConfig) ~= "string"
			-- ROBLOX deviation END
		then
			-- ROBLOX deviation START: configuration as an object not supported yet
			error(Error.new("Jest: configuration as an object not supported yet"))
			-- if parentConfigDirname ~= nil then
			-- 	rawOptions = packageRootOrConfig :: Config_InitialOptions
			-- 	rawOptions.rootDir = if rawOptions.rootDir ~= nil
			-- 		then replaceRootDirInPath(parentConfigDirname, rawOptions.rootDir)
			-- 		else parentConfigDirname
			-- else
			-- 	error(Error.new("Jest: Cannot use configuration as an object without a file path."))
			-- end
			-- ROBLOX deviation END
		elseif isJSONString(argv.config) then
			-- A JSON string was passed to `--config` argument and we can parse it
			-- and use as is.
			local config

			local ok = pcall(function()
				config = JSON.parse(argv.config)
			end)
			if not ok then
				error(Error.new("There was an error while parsing the `--config` argument as a JSON string."))
			end
			-- NOTE: we might need to resolve this dir to an absolute path in the future
			config.rootDir = Boolean.toJSBoolean(config.rootDir) and config.rootDir or packageRootOrConfig
			rawOptions = config
			-- A string passed to `--config`, which is either a direct path to the config
			-- or a path to directory containing `package.json`, `jest.config.js` or `jest.config.ts`
		elseif not skipArgvConfigOption and typeof(argv.config) == "string" then
			configPath = resolveConfigPath(argv.config, cwdInstance, skipMultipleConfigWarning)
			rawOptions = readConfigFileAndSetRootDir(configPath):expect()
		else
			-- Otherwise just try to find config in the current rootDir.
			configPath = resolveConfigPath(packageRootOrConfig, cwdInstance, skipMultipleConfigWarning)
			rawOptions = readConfigFileAndSetRootDir(configPath):expect()
		end
		local ref = normalize(rawOptions, argv, configPath, projectIndex):expect()
		local options, hasDeprecationWarnings = ref.options, ref.hasDeprecationWarnings

		local ref_ = groupOptions(options)
		local globalConfig, projectConfig = ref_.globalConfig, ref_.projectConfig
		return {
			configPath = configPath,
			globalConfig = globalConfig,
			hasDeprecationWarnings = hasDeprecationWarnings,
			projectConfig = projectConfig,
		}
	end)
end
exports.readConfig = readConfig

function groupOptions(options: Config_ProjectConfig & Config_GlobalConfig): {
	globalConfig: Config_GlobalConfig,
	projectConfig: Config_ProjectConfig,
}
	return {
		globalConfig = (
				Object.freeze({
					bail = options.bail,
					-- ROBLOX deviation START: not supported
					-- changedFilesWithAncestor = options.changedFilesWithAncestor,
					-- ROBLOX deviation END
					changedSince = options.changedSince,
					-- ROBLOX deviation START: not supported
					-- collectCoverage = options.collectCoverage,
					-- collectCoverageFrom = options.collectCoverageFrom,
					-- collectCoverageOnlyFrom = options.collectCoverageOnlyFrom,
					-- coverageDirectory = options.coverageDirectory,
					-- coverageProvider = options.coverageProvider,
					-- coverageReporters = options.coverageReporters,
					-- coverageThreshold = options.coverageThreshold,
					-- detectLeaks = options.detectLeaks,
					-- detectOpenHandles = options.detectOpenHandles,
					-- errorOnDeprecated = options.errorOnDeprecated,
					-- ROBLOX deviation END
					expand = options.expand,
					filter = options.filter,
					-- ROBLOX deviation START: not supported
					-- findRelatedTests = options.findRelatedTests,
					-- forceExit = options.forceExit,
					-- globalSetup = options.globalSetup,
					-- globalTeardown = options.globalTeardown,
					-- ROBLOX deviation END
					json = options.json,
					-- ROBLOX deviation START: not supported
					-- lastCommit = options.lastCommit,
					-- ROBLOX deviation END
					listTests = options.listTests,
					-- ROBLOX deviation START: not supported
					-- logHeapUsage = options.logHeapUsage,
					-- ROBLOX deviation END
					maxConcurrency = options.maxConcurrency,
					maxWorkers = options.maxWorkers,
					-- ROBLOX deviation START: not supported
					-- noSCM = nil,
					-- ROBLOX deviation END
					noStackTrace = options.noStackTrace,
					nonFlagArgs = options.nonFlagArgs,
					-- ROBLOX deviation START: not supported
					-- notify = options.notify,
					-- notifyMode = options.notifyMode,
					-- onlyChanged = options.onlyChanged,
					-- onlyFailures = options.onlyFailures,
					-- ROBLOX deviation END
					outputFile = options.outputFile,
					passWithNoTests = options.passWithNoTests,
					projects = options.projects,
					-- ROBLOX deviation START: not supported
					-- replname = options.replname,
					reporters = options.reporters,
					-- ROBLOX deviation END
					rootDir = options.rootDir,
					runTestsByPath = options.runTestsByPath,
					silent = options.silent,
					skipFilter = options.skipFilter,
					snapshotFormat = options.snapshotFormat,
					testFailureExitCode = options.testFailureExitCode,
					testNamePattern = options.testNamePattern,
					testPathPattern = options.testPathPattern,
					-- ROBLOX deviation START: not supported
					-- testResultsProcessor = options.testResultsProcessor,
					-- testSequencer = options.testSequencer,
					-- ROBLOX deviation END
					testTimeout = options.testTimeout,
					updateSnapshot = options.updateSnapshot,
					-- ROBLOX deviation START: not supported
					-- useStderr = options.useStderr,
					-- ROBLOX deviation END
					verbose = options.verbose,
					-- ROBLOX deviation START: not supported
					-- watch = options.watch,
					-- watchAll = options.watchAll,
					-- watchPlugins = options.watchPlugins,
					-- watchman = options.watchman,
					-- ROBLOX deviation END
				}) :: any
			) :: Config_GlobalConfig,
		projectConfig = Object.freeze({
			automock = options.automock,
			-- ROBLOX deviation START: caching not supported
			-- cache = options.cache,
			-- cacheDirectory = options.cacheDirectory,
			-- ROBLOX devation END
			clearMocks = options.clearMocks,
			-- ROBLOX deviation START: not supported
			-- coveragePathIgnorePatterns = options.coveragePathIgnorePatterns,
			-- cwd = options.cwd,
			-- dependencyExtractor = options.dependencyExtractor,
			-- detectLeaks = options.detectLeaks,
			-- detectOpenHandles = options.detectOpenHandles,
			-- ROBLOX deviation END
			displayName = options.displayName,
			-- ROBLOX deviation START: not supported
			-- errorOnDeprecated = options.errorOnDeprecated,
			-- extensionsToTreatAsEsm = options.extensionsToTreatAsEsm,
			-- extraGlobals = options.extraGlobals,
			-- filter = options.filter,
			-- forceCoverageMatch = options.forceCoverageMatch,
			-- globalSetup = options.globalSetup,
			-- globalTeardown = options.globalTeardown,
			-- globals = options.globals,
			-- haste = options.haste,
			-- ROBLOX deviation END
			id = options.id,
			injectGlobals = options.injectGlobals,
			-- ROBLOX deviation START: not supported
			-- moduleDirectories = options.moduleDirectories,
			-- moduleFileExtensions = options.moduleFileExtensions,
			-- moduleLoader = options.moduleLoader,
			-- moduleNameMapper = options.moduleNameMapper,
			-- modulePathIgnorePatterns = options.modulePathIgnorePatterns,
			-- modulePaths = options.modulePaths,
			-- prettierPath = options.prettierPath,
			-- ROBLOX deviation END
			-- ROBLOX deviation: mock data model
			mockDataModel = options.mockDataModel,
			-- ROBLOX deviation: inject alike types
			oldFunctionSpying = options.oldFunctionSpying,
			resetMocks = options.resetMocks,
			resetModules = options.resetModules,
			-- ROBLOX deviation START: not supported
			-- resolver = options.resolver,
			-- ROBLOX deviation END
			restoreMocks = options.restoreMocks,
			rootDir = options.rootDir,
			roots = options.roots,
			runner = options.runner,
			runtime = options.runtime,
			sandboxInjectedGlobals = options.sandboxInjectedGlobals,
			setupFiles = options.setupFiles,
			setupFilesAfterEnv = options.setupFilesAfterEnv,
			-- ROBLOX deviation START: not supported
			-- skipFilter = options.skipFilter,
			-- skipNodeResolution = options.skipNodeResolution,
			-- ROBLOX deviation END
			slowTestThreshold = options.slowTestThreshold,
			snapshotFormat = options.snapshotFormat,
			-- ROBLOX deviation START: not supported
			-- snapshotResolver = options.snapshotResolver,
			-- ROBLOX deviation END
			snapshotSerializers = options.snapshotSerializers,
			testEnvironment = options.testEnvironment,
			testEnvironmentOptions = options.testEnvironmentOptions,
			testLocationInResults = options.testLocationInResults,
			testMatch = options.testMatch,
			testPathIgnorePatterns = options.testPathIgnorePatterns,
			testRegex = options.testRegex,
			-- ROBLOX deviation START: not supported
			-- testRunner = options.testRunner,
			-- testURL = options.testURL,
			-- ROBLOX deviation END
			timers = options.timers,
			-- ROBLOX deviation START: not supported
			-- transform = options.transform,
			-- transformIgnorePatterns = options.transformIgnorePatterns,
			-- unmockedModulePathPatterns = options.unmockedModulePathPatterns,
			-- watchPathIgnorePatterns = options.watchPathIgnorePatterns,
			-- ROBLOX deviation END
		}) :: Config_ProjectConfig,
	}
end

function ensureNoDuplicateConfigs(
	parsedConfigs: Array<ReadConfig>,
	projects: typeof((({} :: any) :: Config_GlobalConfig).projects)
)
	if #projects <= 1 then
		return
	end
	local configPathMap = Map.new()
	for _, config in parsedConfigs do
		local configPath = config.configPath
		if configPathMap:has(configPath) then
			local message = ([[Whoops! Two projects resolved to the same config path: %s:

  Project 1: %s
  Project 2: %s

This usually means that your %s config includes a directory that doesn't have any configuration recognizable by Jest. Please fix it.
]]):format(
				(chalk.bold(tostring(configPath))),
				(
					chalk.bold(tostring(projects[(Array.findIndex(parsedConfigs, function(x)
						return x == config
					end))]))
				),
				tostring(chalk.bold(tostring(projects[(Array.findIndex(parsedConfigs, function(x)
					return x == configPathMap:get(configPath)
				end))]))),
				tostring(chalk.bold('"projects"'))
			)
			error(Error.new(message))
		end
		if configPath ~= nil then
			configPathMap:set(configPath, config)
		end
	end
end

-- Possible scenarios:
--  1. jest --config config.json
--  2. jest --projects p1 p2
--  3. jest --projects p1 p2 --config config.json
--  4. jest --projects p1
--  5. jest
--
-- If no projects are specified, process.cwd() will be used as the default
-- (and only) project.
local function readConfigs(
	cwdInstance: Instance,
	argv: Config_Argv,
	-- ROBLOX deviation: using Instance instead of Config_Path
	projectPaths: Array<Instance>
): Promise<{
	globalConfig: Config_GlobalConfig,
	configs: Array<Config_ProjectConfig>,
	hasDeprecationWarnings: boolean,
}>
	return Promise.resolve():andThen(function()
		local globalConfig
		local hasDeprecationWarnings
		local configs: Array<Config_ProjectConfig> = {}
		local projects = projectPaths
		-- ROBLOX deviation START: using ModuleScript instead of Config_Path
		local configPath: ModuleScript | nil
		-- ROBLOX deviation END
		if #projectPaths == 1 then
			local parsedConfig = readConfig(cwdInstance, argv, projects[1]):expect()
			configPath = parsedConfig.configPath
			hasDeprecationWarnings = parsedConfig.hasDeprecationWarnings
			globalConfig = parsedConfig.globalConfig
			configs = { parsedConfig.projectConfig }
			if Boolean.toJSBoolean(if globalConfig.projects ~= nil then #globalConfig.projects else nil) then
				-- Even though we had one project in CLI args, there might be more
				-- projects defined in the config.
				-- In other words, if this was a single project,
				-- and its config has `projects` settings, use that value instead.
				projects = globalConfig.projects
			end
		end
		if #projects > 0 then
			local cwd = cwdInstance
			local projectIsCwd = projects[1] == cwd
			local parsedConfigs = Promise.all(Array.map(
				Array.filter(projects, function(root)
					-- Ignore globbed files that cannot be `require`d.
					if typeof(root) == "Instance" and #root:GetChildren() == 0 and not root:isA("ModuleScript") then
						return false
					end
					return true
				end),
				function(root, projectIndex)
					local projectIsTheOnlyProject = projectIndex == 1 and #projects == 1
					local skipArgvConfigOption =
						not if projectIsTheOnlyProject then projectIsCwd else projectIsTheOnlyProject

					return readConfig(
						cwdInstance,
						argv,
						root,
						skipArgvConfigOption,
						if configPath ~= nil then configPath.Parent else cwd,
						projectIndex,
						-- we wanna skip the warning if this is the "main" project
						projectIsCwd
					)
				end
			)):expect()
			ensureNoDuplicateConfigs(parsedConfigs, projects)
			configs = Array.map(parsedConfigs, function(ref)
				local projectConfig = ref.projectConfig
				return projectConfig
			end)
			if not hasDeprecationWarnings then
				hasDeprecationWarnings = Array.some(parsedConfigs, function(ref)
					local hasDeprecationWarnings = ref.hasDeprecationWarnings
					return Boolean.toJSBoolean(hasDeprecationWarnings)
				end)
			end
			-- If no config was passed initially, use the one from the first project
			if not Boolean.toJSBoolean(globalConfig) then
				globalConfig = parsedConfigs[1].globalConfig
			end
		end
		if not Boolean.toJSBoolean(globalConfig) or not Boolean.toJSBoolean(#configs) then
			error(Error.new("jest: No configuration found for any project."))
		end
		return {
			configs = configs,
			globalConfig = globalConfig,
			hasDeprecationWarnings = Boolean.toJSBoolean(hasDeprecationWarnings),
		}
	end)
end
exports.readConfigs = readConfigs

-- ROBLOX deviation START: type checked project and global config defaults
do
	-- Some configuration such as `displayName` isn't included in this. If this
	-- is something you depend on knowing, you should be using an actual
	-- configuration file instead.
	-- This is only provided here for the convenience of Jest unit tests, which
	-- need to have a reasonable baseline which they may configure further.
	local grouped = groupOptions(exports.defaults :: any)
	exports.globalDefaults = grouped.globalConfig
	exports.projectDefaults = grouped.projectConfig
end
-- ROBLOX deviation END

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="274">
              <Properties>
                <string name="Name">Defaults</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/Defaults.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local exports = {}

-- ROBLOX deviation START: hardcode values
-- local sep = require(Packages.path).sep
-- local isCI = require(Packages["ci-info"]).isCI
local isCI = false
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_DefaultOptions = typesModule.Config_DefaultOptions
-- ROBLOX deviation START: not needed
-- local replacePathSepForRegex = require(Packages["jest-regex-util"]).replacePathSepForRegex
-- local NODE_MODULES = require(script.Parent.constants).NODE_MODULES
-- local getCacheDirectory = require(script.Parent.getCacheDirectory).default
-- local NODE_MODULES_REGEXP = replacePathSepForRegex(NODE_MODULES)
-- ROBLOX deviation END
local defaultOptions: Config_DefaultOptions = {
	automock = false,
	bail = 0,
	-- ROBLOX deviation START: caching not supported
	-- cache = true,
	-- cacheDirectory = getCacheDirectory(),
	-- ROBLOX deviation END
	changedFilesWithAncestor = false,
	ci = isCI,
	clearMocks = false,
	-- ROBLOX deviation START: not supported
	-- collectCoverage = false,
	-- ROBLOX deviation END
	coveragePathIgnorePatterns = {
		-- ROBLOX deviation START: no node_modules
		-- NODE_MODULES_REGEXP
		-- ROBLOX deviation END
	},
	-- ROBLOX deviation START: not supported
	-- coverageProvider = "babel",
	-- coverageReporters = { "json", "text", "lcov", "clover" },
	-- detectLeaks = false,
	-- detectOpenHandles = false,
	-- errorOnDeprecated = false,
	-- ROBLOX deviation END
	expand = false,
	-- ROBLOX deviation START: not supported
	-- extensionsToTreatAsEsm = {},
	-- forceCoverageMatch = {},
	-- ROBLOX deviation END
	globals = {},
	-- ROBLOX deviation START: not supported
	-- haste = {
	-- 	computeSha1 = false,
	-- 	enableSymlinks = false,
	-- 	forceNodeFilesystemAPI = false,
	-- 	throwOnModuleCollision = false,
	-- },
	-- ROBLOX deviation END
	injectGlobals = true,
	listTests = false,
	maxConcurrency = 5,
	maxWorkers = "50%",
	-- ROBLOX deviation START: not supported
	-- moduleDirectories = { "node_modules" },
	-- moduleFileExtensions = { "js", "jsx", "ts", "tsx", "json", "node" },
	-- moduleNameMapper = {},
	-- modulePathIgnorePatterns = {},
	-- ROBLOX deviation END
	-- ROBLOX deviation: mock data model
	mockDataModel = false,
	noStackTrace = false,
	notify = false,
	-- ROBLOX deviation START: not supported
	-- notifyMode = "failure-change",
	-- ROBLOX deviation END
	-- ROBLOX deviation: inject alike types
	oldFunctionSpying = true,
	passWithNoTests = false,
	-- ROBLOX deviation START: not supported
	-- prettierPath = "prettier",
	-- ROBLOX deviation END
	resetMocks = false,
	resetModules = false,
	restoreMocks = false,
	roots = { "<rootDir>" },
	runTestsByPath = false,
	runner = "jest-runner",
	setupFiles = {},
	setupFilesAfterEnv = {},
	skipFilter = false,
	slowTestThreshold = 5,
	snapshotSerializers = {},
	testEnvironment = Packages.JestEnvironmentLuau,
	testEnvironmentOptions = {},
	testFailureExitCode = 1,
	testLocationInResults = false,
	-- ROBLOX deviation START: using lua files as defaults for tests
	testMatch = { "**/__tests__/**/*", "**/?(*.)+(spec|test)?(.lua|.luau)" },
	-- ROBLOX deviation END
	testPathIgnorePatterns = {
		-- ROBLOX deviation START: no node_modules
		-- NODE_MODULES_REGEXP
		-- ROBLOX deviation END
	},
	testRegex = {},
	-- ROBLOX deviation START: not supported
	-- testRunner = "jest-circus/runner",
	-- testSequencer = "@jest/test-sequencer",
	-- testURL = "http://localhost",
	-- ROBLOX deviation END
	timers = "real",
	-- ROBLOX deviation START: not supported
	-- transformIgnorePatterns = {
	-- 	NODE_MODULES_REGEXP,
	-- 	("\\.pnp\\.[^\\%s]+$"):format(tostring(sep)),
	-- },
	-- ROBLOX deviation END
	useStderr = false,
	watch = false,
	watchPathIgnorePatterns = {},
	watchman = true,
}
exports.default = defaultOptions
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="275">
              <Properties>
                <string name="Name">ReporterValidationErrors</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/ReporterValidationErrors.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>
type Record<K, T> = { [K]: T }

local exports = {}

local chalk = require(Packages.ChalkLua)
local typesModule = require(Packages.JestTypes)
type Config_ReporterConfig = typesModule.Config_ReporterConfig
local getType = require(Packages.JestGetType).getType
local jestValidateModule = require(Packages.JestValidate)
local ValidationError = jestValidateModule.ValidationError
type ValidationError = jestValidateModule.ValidationError
local utilsModule = require(script.Parent.utils)
local BULLET = utilsModule.BULLET
local DOCUMENTATION_NOTE = utilsModule.DOCUMENTATION_NOTE

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
local JSON = nodeUtils.JSON
-- ROBLOX deviation END

-- ROBLOX deviation START: predefine functions
local validateArrayReporter
-- ROBLOX deviation END

-- ROBLOX deviation START: valid reporter needs to be either a table or a ModuleScript
local validReporterTypes = { "table", "string", "ModuleScript" }
-- ROBLOX deviation END
local ERROR = ("%sReporter Validation Error"):format(tostring(BULLET))

--[[*
 * Reporter Validation Error is thrown if the given arguments
 * within the reporter are not valid.
 *
 * This is a highly specific reporter error and in the future will be
 * merged with jest-validate. Till then, we can make use of it. It works
 * and that's what counts most at this time.
 ]]
local function createReporterError(
	reporterIndex: number,
	reporterValue: Array<Config_ReporterConfig> | string
): ValidationError
	local errorMessage = ("  Reporter at index %s must be of type:\n"):format(tostring(reporterIndex))
		.. ("    %s\n"):format(chalk.green(chalk.bold(Array.join(validReporterTypes, " or "))))
		.. "  but instead received:\n"
		.. ("    %s"):format(chalk.red(chalk.bold(getType(reporterValue))))
	return ValidationError.new(ERROR, errorMessage, DOCUMENTATION_NOTE)
end
exports.createReporterError = createReporterError

local function createArrayReporterError(
	arrayReporter: Config_ReporterConfig,
	reporterIndex: number,
	valueIndex: number,
	value: string | ModuleScript | Record<string, any>,
	expectedType: string,
	valueName: string
): ValidationError
	local errorMessage = ("  Unexpected value for %s "):format(valueName)
		.. ("at index %s of reporter at index %s\n"):format(tostring(valueIndex), tostring(reporterIndex))
		.. "  Expected:\n"
		.. ("    %s\n"):format(chalk.red(chalk.bold(expectedType)))
		.. "  Got:\n"
		.. ("    %s\n"):format(chalk.green(chalk.bold(getType(value))))
		.. "  Reporter configuration:\n"
		.. ("    %s"):format(
			chalk.green(chalk.bold(Array.join(String.split(JSON.stringify(arrayReporter, nil, 2), "\n"), "\n    ")))
		)
	return ValidationError.new(ERROR, errorMessage, DOCUMENTATION_NOTE)
end
exports.createArrayReporterError = createArrayReporterError

local function validateReporters(reporterConfig: Array<string | ModuleScript | Config_ReporterConfig>): boolean
	return Array.every(reporterConfig, function(reporter: string | ModuleScript | Config_ReporterConfig, index)
		if typeof(reporter) == "table" then
			validateArrayReporter(reporter, index)
		elseif typeof(reporter) ~= "string" and typeof(reporter) ~= "Instance" then
			error(createReporterError(index, reporter))
		end
		return true
	end)
end
exports.validateReporters = validateReporters

function validateArrayReporter(arrayReporter: Config_ReporterConfig, reporterIndex: number)
	-- ROBLOX deviation START: path needs to be ModuleScript and options need to be a table
	local path, options = arrayReporter.reporter, arrayReporter.options
	if typeof(path) ~= "string" and (typeof(path) ~= "Instance" or not path:IsA("ModuleScript")) then
		error(
			createArrayReporterError(arrayReporter, reporterIndex, 0, path, "ModuleScript or string", "reporter name")
		)
	elseif typeof(options) ~= "table" then
		error(createArrayReporterError(arrayReporter, reporterIndex, 1, options, "table", "Reporter Configuration"))
	end
	-- ROBLOX deviation END
end
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="276">
              <Properties>
                <string name="Name">color</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/color.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
local exports = {}
-- local createHash = require(Packages.crypto).createHash
-- ROBLOX deviation START: inline as ChalkLua doesn't export this type
-- local chalkModule = require(Packages.chalk)
type ForegroundColor =
	"black"
	| "red"
	| "green"
	| "yellow"
	| "blue"
	| "magenta"
	| "cyan"
	| "white"
	| "gray"
	| "grey"
	| "blackBright"
	| "redBright"
	| "greenBright"
	| "yellowBright"
	| "blueBright"
	| "magentaBright"
	| "cyanBright"
	| "whiteBright"
-- ROBLOX deviation END
type Color = ForegroundColor

local colors: Array<Color> = { "red", "green", "yellow", "blue", "magenta", "cyan", "white" }

local function getDisplayNameColor(seed: string?): Color
	if seed == nil then
		return "white"
	end

	-- ROBLOX deviation START: randomize color using math.random
	-- local hash = createHash("sha256")
	-- hash:update(seed)
	-- local num = hash:digest():readUInt32LE(0)
	local num = math.random(#colors)
	return colors[num]
	-- ROBLOX deviation END
end
exports.getDisplayNameColor = getDisplayNameColor

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="277">
              <Properties>
                <string name="Name">constants</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/constants.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

-- ROBLOX deviation START: not needed
-- local path = require(Packages.path)
-- local NODE_MODULES = tostring(path.sep) .. "node_modules" .. tostring(path.sep)
-- exports.NODE_MODULES = NODE_MODULES
-- local DEFAULT_JS_PATTERN = "\\.[jt]sx?$"
-- exports.DEFAULT_JS_PATTERN = DEFAULT_JS_PATTERN
-- local PACKAGE_JSON = "package.json"
-- exports.PACKAGE_JSON = PACKAGE_JSON
-- ROBLOX deviation END
local JEST_CONFIG_BASE_NAME = "jest.config"
exports.JEST_CONFIG_BASE_NAME = JEST_CONFIG_BASE_NAME
-- ROBLOX deviation START: not needed
-- local JEST_CONFIG_EXT_CJS = ".cjs"
-- exports.JEST_CONFIG_EXT_CJS = JEST_CONFIG_EXT_CJS
-- local JEST_CONFIG_EXT_MJS = ".mjs"
-- exports.JEST_CONFIG_EXT_MJS = JEST_CONFIG_EXT_MJS
-- local JEST_CONFIG_EXT_JS = ".js"
-- exports.JEST_CONFIG_EXT_JS = JEST_CONFIG_EXT_JS
-- local JEST_CONFIG_EXT_TS = ".ts"
-- exports.JEST_CONFIG_EXT_TS = JEST_CONFIG_EXT_TS
-- local JEST_CONFIG_EXT_JSON = ".json"
-- exports.JEST_CONFIG_EXT_JSON = JEST_CONFIG_EXT_JSON
-- local JEST_CONFIG_EXT_ORDER = Object.freeze({
-- 	JEST_CONFIG_EXT_JS,
-- 	JEST_CONFIG_EXT_TS,
-- 	JEST_CONFIG_EXT_MJS,
-- 	JEST_CONFIG_EXT_CJS,
-- 	JEST_CONFIG_EXT_JSON,
-- })
-- exports.JEST_CONFIG_EXT_ORDER = JEST_CONFIG_EXT_ORDER
-- ROBLOX deviation END

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="278">
              <Properties>
                <string name="Name">getMaxWorkers</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/getMaxWorkers.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: no needed
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
type Object = LuauPolyfill.Object

local exports = {}

-- ROBLOX deviation START: no needed
-- local cpus = require(Packages.os).cpus
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_Argv = typesModule.Config_Argv

-- ROBLOX deviation START: additional types
type Partial<U> = Object
type Pick<U, V> = Object
-- ROBLOX deviation END

local function getMaxWorkers(
	argv: Partial<Pick<Config_Argv, "maxWorkers" | "runInBand" | "watch" | "watchAll">>,
	defaultOptions: Partial<Pick<Config_Argv, "maxWorkers">>?
): number
	-- ROBLOX deviation START: no concurrent run allowed
	return 1
	-- if Boolean.toJSBoolean(argv.runInBand) then
	-- 	return 1
	-- elseif Boolean.toJSBoolean(argv.maxWorkers) then
	-- 	return parseWorkers(argv.maxWorkers)
	-- elseif
	-- 	Boolean.toJSBoolean(
	-- 		if Boolean.toJSBoolean(defaultOptions)
	-- 			then defaultOptions.maxWorkers
	-- 			else defaultOptions
	-- 	)
	-- then
	-- 	return parseWorkers(defaultOptions.maxWorkers)
	-- else
	-- 	-- In watch mode, Jest should be unobtrusive and not use all available CPUs.
	-- 	local cpusInfo = cpus()
	-- 	local ref = if typeof(cpusInfo) == "table" then cpusInfo.length else nil
	-- 	local numCpus = if ref ~= nil then ref else 1
	-- 	local isWatchModeEnabled = Boolean.toJSBoolean(argv.watch) and argv.watch or argv.watchAll
	-- 	return Math:max(
	-- 		if Boolean.toJSBoolean(isWatchModeEnabled) then Math:floor(numCpus / 2) else numCpus - 1,
	-- 		1
	-- 	)
	-- end
	-- ROBLOX deviation END
end
exports.default = getMaxWorkers

-- ROBLOX deviation START: no needed
-- local function parseWorkers(maxWorkers: string | number): number
-- 	local parsed = tonumber(tostring(maxWorkers), 10)
-- 	if
-- 		Boolean.toJSBoolean((function()
-- 			local ref = typeof(maxWorkers) == "string" and maxWorkers:trim():endsWith("%")
-- 			local ref = if Boolean.toJSBoolean(ref)
-- 				then
-- 					parsed
-- 					> 0 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
-- 				else ref
-- 			return if Boolean.toJSBoolean(ref)
-- 				then
-- 					parsed
-- 					<= 100 --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
-- 				else ref
-- 		end)())
-- 	then
-- 		local numCpus = cpus().length
-- 		local workers = Math:floor(parsed / 100 * numCpus)
-- 		return Math:max(workers, 1)
-- 	end
-- 	return if parsed > 0 then parsed else 1
-- end
-- ROBLOX deviation END

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="279">
              <Properties>
                <string name="Name">normalize</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/normalize.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

-- ROBLOX deviation START: predefine functions
local showTestPathPatternError
-- ROBLOX deviation END

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
local process = nodeUtils.process
local getRelativePath = RobloxShared.getRelativePath
-- ROBLOX deviation END

-- ROBLOX deviation START: not needed
-- local createHash = require(Packages.crypto).createHash
-- local path = require(Packages.path)
-- ROBLOX deviation END
local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation START: not needed
-- local merge = require(Packages.deepmerge)
-- local glob = require(Packages.glob).sync
-- local statSync = require(Packages["graceful-fs"]).statSync
-- local micromatch = require(Packages.micromatch)
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_Argv = typesModule.Config_Argv
type Config_DisplayName = typesModule.Config_DisplayName
type Config_Glob = typesModule.Config_Glob
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_InitialOptions = typesModule.Config_InitialOptions
type Config_InitialOptionsWithRootDir = typesModule.Config_InitialOptionsWithRootDir
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type Config_ReporterConfig = typesModule.Config_ReporterConfig
-- ROBLOX deviation START: not used

-- local replacePathSepForRegex = require(Packages["jest-regex-util"]).replacePathSepForRegex
local function replacePathSepForRegex(value)
	return value
end
-- local jest_resolveModule = require(Packages["jest-resolve"])
-- local Resolver = jest_resolveModule.default
-- local resolveRunner = jest_resolveModule.resolveRunner
-- local resolveSequencer = jest_resolveModule.resolveSequencer
-- local resolveTestEnvironment = jest_resolveModule.resolveTestEnvironment
-- local resolveWatchPlugin = jest_resolveModule.resolveWatchPlugin
-- ROBLOX deviation END
local jest_utilModule = require(Packages.JestUtil)
local clearLine = jest_utilModule.clearLine
-- ROBLOX deviation START: not used

-- local replacePathSepForGlob = jest_utilModule.replacePathSepForGlob
local function replacePathSepForGlob(value)
	return value
end
-- local requireOrImportModule = jest_utilModule.requireOrImportModule
-- local tryRealpath = jest_utilModule.tryRealpath
-- ROBLOX deviation END
local jestValidateModule = require(Packages.JestValidate)
local ValidationError = jestValidateModule.ValidationError
-- ROBLOX deviation START: not used
-- local validate = jest_validateModule.validate
-- ROBLOX deviation END
local DEFAULT_CONFIG = require(script.Parent.Defaults).default
-- ROBLOX deviation START: not used
-- local DEPRECATED_CONFIG = require(script.Parent.Deprecated).default
-- local VALID_CONFIG = require(script.Parent.ValidConfig).default
-- ROBLOX deviation END
local validateReporters = require(script.Parent.ReporterValidationErrors).validateReporters
local getDisplayNameColor = require(script.Parent.color).getDisplayNameColor
-- ROBLOX deviation START: not used
-- local DEFAULT_JS_PATTERN = constantsModule.DEFAULT_JS_PATTERN
-- ROBLOX deviation END
local getMaxWorkers = require(script.Parent.getMaxWorkers).default
-- ROBLOX deviation START: not needed now. Will be necessary when we want to implement TestSequencer
-- local parseShardPair = require(script.Parent.parseShardPair).parseShardPair
-- ROBLOX deviation END
local setFromArgv = require(script.Parent.setFromArgv).default
local utilsModule = require(script.Parent.utils)
local BULLET = utilsModule.BULLET
local DOCUMENTATION_NOTE = utilsModule.DOCUMENTATION_NOTE
-- ROBLOX deviation START: not used
-- local _replaceRootDirTags = utilsModule._replaceRootDirTags
-- local escapeGlobCharacters = utilsModule.escapeGlobCharacters
-- local replaceRootDirInPath = utilsModule.replaceRootDirInPath
-- local resolve = utilsModule.resolve
-- ROBLOX deviation END
local validatePattern = require(script.Parent.validatePattern).default

local ERROR = ("%sValidation Error"):format(BULLET)
-- ROBLOX deviation START: not used
-- local PRESET_EXTENSIONS = { ".json", ".js", ".cjs", ".mjs" }
-- local PRESET_NAME = "jest-preset"
-- ROBLOX deviation END

type AllOptions = Config_ProjectConfig & Config_GlobalConfig

local BUILTIN_REPORTERS = {
	default = true,
	summary = true,
	["github-actions"] = true,
}

local function createConfigError(message: string)
	return ValidationError.new(ERROR, message, DOCUMENTATION_NOTE)
end

local function verifyDirectoryExists(
	-- ROBLOX deviation START: using Instance instead of Config_Path
	path: Instance?,
	-- ROBLOX deviation END
	key: string
)
	-- ROBLOX deviation START: statSync not necessary as path is an Instance
	if typeof(path) ~= "Instance" then
		error(
			createConfigError(
				("  Directory %s in the %s option was not found."):format(chalk.bold(tostring(path)), chalk.bold(key))
			)
		)
	end

	-- local ok, err = pcall(function()
	-- 	local rootStat = statSync(path)
	-- 	if not Boolean.toJSBoolean(rootStat:isDirectory()) then
	-- 		error(
	-- 			createConfigError(
	-- 				("  %s in the %s option is not a directory."):format(chalk.bold(path), chalk.bold(key))
	-- 			)
	-- 		)
	-- 	end
	-- end)
	-- if not ok then
	-- 	if instanceof(err, ValidationError) then
	-- 		error(err)
	-- 	end

	-- 	if err.code == "ENOENT" then
	-- 		error(
	-- 			createConfigError(
	-- 				("  Directory %s in the %s option was not found."):format(chalk.bold(path), chalk.bold(key))
	-- 			)
	-- 		)
	-- 	end

	-- 	-- Not sure in which cases `statSync` can throw, so let's just show the underlying error to the user
	-- 	error(
	-- 		createConfigError(
	-- 			("  Got an error trying to find %s in the %s option.\n\n  Error was: %s"):format(
	-- 				chalk.bold(path),
	-- 				chalk.bold(key),
	-- 				tostring(err.message)
	-- 			)
	-- 		)
	-- 	)
	-- end
	-- ROBLOX deviation END
end

-- ROBLOX deviation START: not used
-- -- TS 3.5 forces us to split these into 2
-- local function mergeModuleNameMapperWithPreset(options: Config_InitialOptionsWithRootDir, preset: Config_InitialOptions)
-- 	if Boolean.toJSBoolean(options["moduleNameMapper"]) and Boolean.toJSBoolean(preset["moduleNameMapper"]) then
-- 		options["moduleNameMapper"] =
-- 			Object.assign({}, options["moduleNameMapper"], preset["moduleNameMapper"], options["moduleNameMapper"])
-- 	end
-- end

-- local function mergeTransformWithPreset(options: Config_InitialOptionsWithRootDir, preset: Config_InitialOptions)
-- 	if Boolean.toJSBoolean(options["transform"]) and Boolean.toJSBoolean(preset["transform"]) then
-- 		options["transform"] = Object.assign({}, options["transform"], preset["transform"], options["transform"])
-- 	end
-- end

-- local function mergeGlobalsWithPreset(options: Config_InitialOptions, preset: Config_InitialOptions)
-- 	if Boolean.toJSBoolean(options["globals"]) and Boolean.toJSBoolean(preset["globals"]) then
-- 		options["globals"] = merge(preset["globals"], options["globals"])
-- 	end
-- end

-- local function setupPreset(
-- 	options: Config_InitialOptionsWithRootDir,
-- 	optionsPreset: string
-- ): Promise<Config_InitialOptionsWithRootDir>
-- 	return Promise.resolve():andThen(function()
-- 		local preset: Config_InitialOptions
-- 		local presetPath = replaceRootDirInPath(options.rootDir, optionsPreset)
-- 		local presetModule = Resolver:findNodeModule(
-- 			if Boolean.toJSBoolean(presetPath:startsWith(".")) then presetPath else path.join(presetPath, PRESET_NAME),
-- 			{ basedir = options.rootDir, extensions = PRESET_EXTENSIONS }
-- 		)
-- 		do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 			local ok, result, hasReturned = xpcall(function()
-- 				if not Boolean.toJSBoolean(presetModule) then
-- 					error(Error.new(("Cannot find module '%s'"):format(tostring(presetPath))))
-- 				end -- Force re-evaluation to support multiple projects
-- 				do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 					local ok, result, hasReturned = xpcall(function()
-- 						require_.cache[tostring(require_:resolve(presetModule))] = nil
-- 					end, function() end)
-- 					if hasReturned then
-- 						return result
-- 					end
-- 				end
-- 				preset = requireOrImportModule(presetModule):expect()
-- 			end, function(error_)
-- 				if
-- 					Boolean.toJSBoolean((function()
-- 						local ref = error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: BinaryExpression with 'instanceof' operator ]] --[[ error instanceof SyntaxError ]]
-- 						return Boolean.toJSBoolean(ref) and ref or error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: BinaryExpression with 'instanceof' operator ]] --[[ error instanceof TypeError ]]
-- 					end)())
-- 				then
-- 					error(
-- 						createConfigError(
-- 							("  Preset %s is invalid:\n\n  %s\n  %s"):format(
-- 								chalk.bold(presetPath),
-- 								tostring(error_.message),
-- 								tostring(error_.stack)
-- 							)
-- 						)
-- 					)
-- 				end
-- 				if
-- 					Boolean.toJSBoolean(
-- 						Array.includes(error_.message, "Cannot find module") --[[ ROBLOX CHECK: check if 'error.message' is an Array ]]
-- 					)
-- 				then
-- 					if
-- 						Boolean.toJSBoolean(
-- 							Array.includes(error_.message, presetPath) --[[ ROBLOX CHECK: check if 'error.message' is an Array ]]
-- 						)
-- 					then
-- 						local preset = Resolver:findNodeModule(presetPath, { basedir = options.rootDir })
-- 						if Boolean.toJSBoolean(preset) then
-- 							error(
-- 								createConfigError(
-- 									('  Module %s should have "jest-preset.js" or "jest-preset.json" file at the root.'):format(
-- 										chalk.bold(presetPath)
-- 									)
-- 								)
-- 							)
-- 						end
-- 						error(createConfigError(("  Preset %s not found."):format(chalk.bold(presetPath))))
-- 					end
-- 					error(
-- 						createConfigError(
-- 							("  Missing dependency in %s:\n\n  %s\n  %s"):format(
-- 								chalk.bold(presetPath),
-- 								tostring(error_.message),
-- 								tostring(error_.stack)
-- 							)
-- 						)
-- 					)
-- 				end
-- 				error(
-- 					createConfigError(
-- 						("  An unknown error occurred in %s:\n\n  %s\n  %s"):format(
-- 							chalk.bold(presetPath),
-- 							tostring(error_.message),
-- 							tostring(error_.stack)
-- 						)
-- 					)
-- 				)
-- 			end)
-- 			if hasReturned then
-- 				return result
-- 			end
-- 		end
-- 		if Boolean.toJSBoolean(options.setupFiles) then
-- 			options.setupFiles =
-- 				Array.concat(Boolean.toJSBoolean(preset.setupFiles) and preset.setupFiles or {}, options.setupFiles) --[[ ROBLOX CHECK: check if 'preset.setupFiles || []' is an Array ]]
-- 		end
-- 		if Boolean.toJSBoolean(options.setupFilesAfterEnv) then
-- 			options.setupFilesAfterEnv = Array.concat(
-- 				Boolean.toJSBoolean(preset.setupFilesAfterEnv) and preset.setupFilesAfterEnv or {},
-- 				options.setupFilesAfterEnv
-- 			) --[[ ROBLOX CHECK: check if 'preset.setupFilesAfterEnv || []' is an Array ]]
-- 		end
-- 		if
-- 			Boolean.toJSBoolean(
-- 				if Boolean.toJSBoolean(options.modulePathIgnorePatterns)
-- 					then preset.modulePathIgnorePatterns
-- 					else options.modulePathIgnorePatterns
-- 			)
-- 		then
-- 			options.modulePathIgnorePatterns =
-- 				Array.concat(preset.modulePathIgnorePatterns, options.modulePathIgnorePatterns) --[[ ROBLOX CHECK: check if 'preset.modulePathIgnorePatterns' is an Array ]]
-- 		end
-- 		mergeModuleNameMapperWithPreset(options, preset)
-- 		mergeTransformWithPreset(options, preset)
-- 		mergeGlobalsWithPreset(options, preset)
-- 		return Object.assign({}, preset, options)
-- 	end)
-- end

-- local function setupBabelJest(options: Config_InitialOptionsWithRootDir)
-- 	local transform = options.transform
-- 	local babelJest
-- 	if Boolean.toJSBoolean(transform) then
-- 		local customJSPattern = Array.find(Object.keys(transform), function(pattern)
-- 			local regex = RegExp.new(pattern)
-- 			local ref = regex:test("a.js")
-- 			return Boolean.toJSBoolean(ref) and ref or regex:test("a.jsx")
-- 		end) --[[ ROBLOX CHECK: check if 'Object.keys(transform)' is an Array ]]
-- 		local customTSPattern = Array.find(Object.keys(transform), function(pattern)
-- 			local regex = RegExp.new(pattern)
-- 			local ref = regex:test("a.ts")
-- 			return Boolean.toJSBoolean(ref) and ref or regex:test("a.tsx")
-- 		end) --[[ ROBLOX CHECK: check if 'Object.keys(transform)' is an Array ]]
-- 		Array.forEach({ customJSPattern, customTSPattern }, function(pattern)
-- 			if Boolean.toJSBoolean(pattern) then
-- 				local customTransformer = transform[tostring(pattern)]
-- 				if Boolean.toJSBoolean(Array.isArray(customTransformer)) then
-- 					if
-- 						customTransformer[
-- 							1 --[[ ROBLOX adaptation: added 1 to array index ]]
-- 						] == "babel-jest"
-- 					then
-- 						babelJest = require_:resolve("babel-jest")
-- 						customTransformer[
-- 							1 --[[ ROBLOX adaptation: added 1 to array index ]]
-- 						] =
-- 							babelJest
-- 					elseif
-- 						Boolean.toJSBoolean(
-- 							Array.includes(
-- 								customTransformer[
-- 									1 --[[ ROBLOX adaptation: added 1 to array index ]]
-- 								],
-- 								"babel-jest"
-- 							) --[[ ROBLOX CHECK: check if 'customTransformer[0]' is an Array ]]
-- 						)
-- 					then
-- 						babelJest = customTransformer[
-- 							1 --[[ ROBLOX adaptation: added 1 to array index ]]
-- 						]
-- 					end
-- 				else
-- 					if customTransformer == "babel-jest" then
-- 						babelJest = require_:resolve("babel-jest")
-- 						transform[tostring(pattern)] = babelJest
-- 					elseif
-- 						Boolean.toJSBoolean(
-- 							Array.includes(customTransformer, "babel-jest") --[[ ROBLOX CHECK: check if 'customTransformer' is an Array ]]
-- 						)
-- 					then
-- 						babelJest = customTransformer
-- 					end
-- 				end
-- 			end
-- 		end)
-- 	else
-- 		babelJest = require_:resolve("babel-jest")
-- 		options.transform = { [tostring(DEFAULT_JS_PATTERN)] = babelJest }
-- 	end
-- end

-- local function normalizeCollectCoverageOnlyFrom(
-- 	options: Config_InitialOptionsWithRootDir & Required<Pick<Config_InitialOptions, "collectCoverageOnlyFrom">>,
-- 	key: any --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof Pick<Config.InitialOptions, 'collectCoverageOnlyFrom'> ]]
-- )
-- 	local initialCollectCoverageFrom = options[key]
-- 	local collectCoverageOnlyFrom: Array<Config_Glob> = if Boolean.toJSBoolean(
-- 			Array.isArray(initialCollectCoverageFrom)
-- 		)
-- 		then initialCollectCoverageFrom -- passed from argv
-- 		else Object.keys(initialCollectCoverageFrom) -- passed from options
-- 	return Array.reduce(collectCoverageOnlyFrom, function(map, filePath)
-- 		filePath = path:resolve(options.rootDir, replaceRootDirInPath(options.rootDir, filePath))
-- 		map[tostring(filePath)] = true
-- 		return map
-- 	end, Object.create(nil)) --[[ ROBLOX CHECK: check if 'collectCoverageOnlyFrom' is an Array ]]
-- end

-- local function normalizeCollectCoverageFrom(
-- 	options: Config_InitialOptions & Required<Pick<Config_InitialOptions, "collectCoverageFrom">>,
-- 	key: any --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof Pick<Config.InitialOptions, 'collectCoverageFrom'> ]]
-- )
-- 	local initialCollectCoverageFrom = options[key]
-- 	local value: Array<Config_Glob> | nil
-- 	if not Boolean.toJSBoolean(initialCollectCoverageFrom) then
-- 		value = {}
-- 	end
-- 	if not Boolean.toJSBoolean(Array.isArray(initialCollectCoverageFrom)) then
-- 		do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 			local ok, result, hasReturned = xpcall(function()
-- 				value = JSON:parse(initialCollectCoverageFrom)
-- 			end, function() end)
-- 			if hasReturned then
-- 				return result
-- 			end
-- 		end
-- 		if
-- 			Boolean.toJSBoolean(
-- 				if Boolean.toJSBoolean(options[key])
-- 					then not Boolean.toJSBoolean(Array.isArray(value))
-- 					else options[key]
-- 			)
-- 		then
-- 			value = { initialCollectCoverageFrom }
-- 		end
-- 	else
-- 		value = initialCollectCoverageFrom
-- 	end
-- 	if Boolean.toJSBoolean(value) then
-- 		value = Array.map(value, function(filePath)
-- 			return filePath:replace(
-- 				error("not implemented"), --[[ ROBLOX TODO: Unhandled node for type: RegExpLiteral ]] --[[ /^(!?)(<rootDir>\/)(.*)/ ]]
-- 				"$1$3"
-- 			)
-- 		end) --[[ ROBLOX CHECK: check if 'value' is an Array ]]
-- 	end
-- 	return value
-- end

-- local function normalizeUnmockedModulePathPatterns(
-- 	options: Config_InitialOptionsWithRootDir,
-- 	key: any --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof Pick<Config.InitialOptions, 'coveragePathIgnorePatterns' | 'modulePathIgnorePatterns' | 'testPathIgnorePatterns' | 'transformIgnorePatterns' | 'watchPathIgnorePatterns' | 'unmockedModulePathPatterns'> ]]
-- )
-- 	-- _replaceRootDirTags is specifically well-suited for substituting
-- 	-- <rootDir> in paths (it deals with properly interpreting relative path
-- 	-- separators, etc).
-- 	--
-- 	-- For patterns, direct global substitution is far more ideal, so we
-- 	-- special case substitutions for patterns here.
-- 	return Array.map(options[key] :: any, function(pattern)
-- 		return replacePathSepForRegex(pattern:replace(RegExp("<rootDir>", "g"), options.rootDir))
-- 	end)
-- end
-- ROBLOX deviation END

local function normalizePreprocessor(options: Config_InitialOptionsWithRootDir): Config_InitialOptionsWithRootDir
	-- ROBLOX deviation START: not supported
	-- 	if Boolean.toJSBoolean(options.scriptPreprocessor) and Boolean.toJSBoolean(options.transform) then
	-- 		error(
	-- 			createConfigError(
	-- 				([[  Options: %s and %s cannot be used together.
	--   Please change your configuration to only use %s.]]):format(
	-- 					chalk.bold("scriptPreprocessor"),
	-- 					chalk.bold("transform"),
	-- 					chalk.bold("transform")
	-- 				)
	-- 			)
	-- 		)
	-- 	end

	-- 	if
	-- 		Boolean.toJSBoolean(options.preprocessorIgnorePatterns)
	-- 		and Boolean.toJSBoolean(options.transformIgnorePatterns)
	-- 	then
	-- 		error(
	-- 			createConfigError(
	-- 				([[  Options %s and %s cannot be used together.
	--   Please change your configuration to only use %s.]]):format(
	-- 					chalk.bold("preprocessorIgnorePatterns"),
	-- 					chalk.bold("transformIgnorePatterns"),
	-- 					chalk.bold("transformIgnorePatterns")
	-- 				)
	-- 			)
	-- 		)
	-- 	end

	-- 	if Boolean.toJSBoolean(options.scriptPreprocessor) then
	-- 		options.transform = { [".*"] = options.scriptPreprocessor }
	-- 	end

	-- 	if Boolean.toJSBoolean(options.preprocessorIgnorePatterns) then
	-- 		options.transformIgnorePatterns = options.preprocessorIgnorePatterns
	-- 	end

	-- 	options.scriptPreprocessor = nil
	-- 	options.preprocessorIgnorePatterns = nil
	-- ROBLOX deviation END
	return options
end

local function normalizeMissingOptions(
	options: Config_InitialOptionsWithRootDir,
	-- ROBLOX deviation START: using ModuleScript instead of Config_Path
	configPath: ModuleScript | nil,
	-- ROBLOX deviation END
	projectIndex: number
): Config_InitialOptionsWithRootDir
	if not Boolean.toJSBoolean(options.id) then
		options.id = getRelativePath((options.rootDir :: any) :: Instance, nil)
		-- ROBLOX deviation START: createHash not supported
		-- 	options.name = createHash("md5")
		-- 		:update(options.rootDir)
		-- 		-- In case we load config from some path that has the same root dir
		-- 		:update(
		-- 			Boolean.toJSBoolean(configPath) and configPath or ""
		-- 		)
		-- 		:update(tostring(projectIndex))
		-- 		:digest("hex")
		-- ROBLOX deviation END
	end

	if options.setupFiles == nil then
		options.setupFiles = {}
	end
	return options
end
local function normalizeRootDir(options: Config_InitialOptions): Config_InitialOptionsWithRootDir
	-- Assert that there *is* a rootDir
	if not Boolean.toJSBoolean(options.rootDir) then
		error(createConfigError(("  Configuration option %s must be specified."):format(chalk.bold("rootDir"))))
	end
	-- ROBLOX deviation START: not necessary as rootDir is an Instance
	-- options.rootDir = path:normalize(options.rootDir)

	-- xpcall(function()
	-- 	-- try to resolve windows short paths, ignoring errors (permission errors, mostly)
	-- 	options.rootDir = tryRealpath(options.rootDir)
	-- end, function() end)
	-- ROBLOX deviation END

	verifyDirectoryExists(options.rootDir, "rootDir")

	return Object.assign({}, options, { rootDir = options.rootDir })
end

local function normalizeReporters(options: Config_InitialOptionsWithRootDir)
	local reporters = options.reporters
	if not reporters or not Array.isArray(reporters) then
		return options
	end

	validateReporters(reporters)
	options.reporters = Array.map(reporters, function(reporterConfig)
		local normalizedReporterConfig: Config_ReporterConfig = if typeof(reporterConfig) ~= "table"
			then
				-- if reporter config is a string, we wrap it in an array
				-- and pass an empty object for options argument, to normalize
				-- the shape.
				-- ROBLOX deviation: ReporterConfig is a named table since we can't type tuples
				{ reporter = reporterConfig, options = {} }
			else reporterConfig

		local reporterPath = normalizedReporterConfig.reporter
		if not BUILTIN_REPORTERS[reporterPath] then
			local ok, result = pcall(function()
				return require(reporterPath) :: any
			end)
			if not ok or not result then
				error(
					"Could not resolve a module for a custom reporter.\n"
						.. ("  Module name: %s\n"):format(tostring(reporterPath))
				)
			end
		end
		return normalizedReporterConfig
	end)

	return options
end

local function buildTestPathPattern(argv: Config_Argv): string
	local patterns = {}
	if argv._ ~= nil then
		patterns = Array.concat(patterns, argv._)
	end
	if argv.testPathPattern ~= nil then
		patterns = Array.concat(patterns, argv.testPathPattern)
	end

	local function replacePosixSep(pattern: string | number)
		-- yargs coerces positional args into numbers
		local patternAsString = tostring(pattern)
		-- ROBLOX deviation START: no special handling for Windows
		return patternAsString
		-- if path.sep == "/" then
		-- 	return patternAsString
		-- end
		-- return patternAsString:gsub("",
		-- 	error("not implemented"), --[[ ROBLOX TODO: Unhandled node for type: RegExpLiteral ]] --[[ /\//g ]]
		-- 	"\\\\"
		-- )
		-- ROBLOX deviation END
	end

	local testPathPattern = Array.join(Array.map(patterns, replacePosixSep), "|")
	if validatePattern(testPathPattern) then
		return testPathPattern
	else
		showTestPathPatternError(testPathPattern)
		return ""
	end
end

function showTestPathPatternError(testPathPattern: string)
	clearLine(process.stdout)

	-- eslint-disable-next-line no-console
	console.log(
		chalk.red(
			("  Invalid testPattern %s supplied. "):format(tostring(testPathPattern)) .. "Running all tests instead."
		)
	)
end

-- ROBLOX deviation START: no esm modules in Luau
-- local function validateExtensionsToTreatAsEsm(
-- 	extensionsToTreatAsEsm: typeof((({} :: any) :: Config_InitialOptions).extensionsToTreatAsEsm)
-- )
-- 	if not Boolean.toJSBoolean(extensionsToTreatAsEsm) or extensionsToTreatAsEsm.length == 0 then
-- 		return
-- 	end
-- 	local function printConfig(opts: Array<string>)
-- 		local string_ = Array.join(
-- 			Array.map(opts, function(ext)
-- 				return ("'%s'"):format(tostring(ext))
-- 			end), --[[ ROBLOX CHECK: check if 'opts' is an Array ]]
-- 			", "
-- 		)
-- 		return chalk.bold(("extensionsToTreatAsEsm: [%s]"):format(tostring(string_)))
-- 	end
-- 	local extensionWithoutDot = Array.some(extensionsToTreatAsEsm, function(ext)
-- 		return not Boolean.toJSBoolean(ext:startsWith("."))
-- 	end) --[[ ROBLOX CHECK: check if 'extensionsToTreatAsEsm' is an Array ]]
-- 	if Boolean.toJSBoolean(extensionWithoutDot) then
-- 		error(createConfigError(([[  Option: %s includes a string that does not start with a period (%s).
--   Please change your configuration to %s.]]):format(
-- 			tostring(printConfig(extensionsToTreatAsEsm)),
-- 			chalk.bold("."),
-- 			tostring(printConfig(
-- 				Array.map(extensionsToTreatAsEsm, function(ext)
-- 					return if Boolean.toJSBoolean(ext:startsWith(".")) then ext else (".%s"):format(tostring(ext))
-- 				end) --[[ ROBLOX CHECK: check if 'extensionsToTreatAsEsm' is an Array ]]
-- 			))
-- 		)))
-- 	end
-- 	if
-- 		Boolean.toJSBoolean(
-- 			Array.includes(extensionsToTreatAsEsm, ".js") --[[ ROBLOX CHECK: check if 'extensionsToTreatAsEsm' is an Array ]]
-- 		)
-- 	then
-- 		error(
-- 			createConfigError(
-- 				("  Option: %s includes %s which is always inferred based on %s in its nearest %s."):format(
-- 					tostring(printConfig(extensionsToTreatAsEsm)),
-- 					chalk.bold("'.js'"),
-- 					chalk.bold("type"),
-- 					chalk.bold("package.json")
-- 				)
-- 			)
-- 		)
-- 	end
-- 	if
-- 		Boolean.toJSBoolean(
-- 			Array.includes(extensionsToTreatAsEsm, ".cjs") --[[ ROBLOX CHECK: check if 'extensionsToTreatAsEsm' is an Array ]]
-- 		)
-- 	then
-- 		error(
-- 			createConfigError(
-- 				("  Option: %s includes %s which is always treated as CommonJS."):format(
-- 					tostring(printConfig(extensionsToTreatAsEsm)),
-- 					chalk.bold("'.cjs'")
-- 				)
-- 			)
-- 		)
-- 	end
-- 	if
-- 		Boolean.toJSBoolean(
-- 			Array.includes(extensionsToTreatAsEsm, ".mjs") --[[ ROBLOX CHECK: check if 'extensionsToTreatAsEsm' is an Array ]]
-- 		)
-- 	then
-- 		error(
-- 			createConfigError(
-- 				("  Option: %s includes %s which is always treated as an ECMAScript Module."):format(
-- 					tostring(printConfig(extensionsToTreatAsEsm)),
-- 					chalk.bold("'.mjs'")
-- 				)
-- 			)
-- 		)
-- 	end
-- end
-- ROBLOX deviation END

local function normalize(
	initialOptions: Config_InitialOptions,
	argv: Config_Argv,
	-- ROBLOX deviation START: using ModuleScript instead of Config_Path
	configPath: (ModuleScript | nil)?,
	-- ROBLOX deviation END
	projectIndex_: number?
): Promise<{ hasDeprecationWarnings: boolean, options: AllOptions }>
	local projectIndex = if projectIndex_ ~= nil then projectIndex_ else math.huge
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: no deprecation warnings support
		-- local hasDeprecationWarnings = validate(initialOptions, {
		-- 	comment = DOCUMENTATION_NOTE,
		-- 	deprecatedConfig = DEPRECATED_CONFIG,
		-- 	exampleConfig = VALID_CONFIG,
		-- 	recursiveDenylist = {
		-- 		"collectCoverageOnlyFrom", -- 'coverageThreshold' allows to use 'global' and glob strings on the same
		-- 		-- level, there's currently no way we can deal with such config
		-- 		"coverageThreshold",
		-- 		"globals",
		-- 		"moduleNameMapper",
		-- 		"testEnvironmentOptions",
		-- 		"transform",
		-- 	},
		-- }).hasDeprecationWarnings
		local hasDeprecationWarnings = false
		-- ROBLOX deviation END

		local options = normalizePreprocessor(
			normalizeReporters(
				normalizeMissingOptions(normalizeRootDir(setFromArgv(initialOptions, argv)), configPath, projectIndex)
			)
		)

		-- ROBLOX deviation START: not supported
		-- if Boolean.toJSBoolean(options.preset) then
		-- 	options = setupPreset(options, options.preset):expect()
		-- end

		-- 		if not Boolean.toJSBoolean(options.setupFilesAfterEnv) then
		-- 			options.setupFilesAfterEnv = {}
		-- 		end

		-- 		if Boolean.toJSBoolean(options.setupTestFrameworkScriptFile) and #options.setupFilesAfterEnv > 0 then
		-- 			error(
		-- 				createConfigError(
		-- 					([[  Options: %s and %s cannot be used together.
		--   Please change your configuration to only use %s.]]):format(
		-- 						chalk.bold("setupTestFrameworkScriptFile"),
		-- 						chalk.bold("setupFilesAfterEnv"),
		-- 						chalk.bold("setupFilesAfterEnv")
		-- 					)
		-- 				)
		-- 			)
		-- 		end

		-- 		if Boolean.toJSBoolean(options.setupTestFrameworkScriptFile) then
		-- 			table.insert(options.setupFilesAfterEnv, options.setupTestFrameworkScriptFile) --[[ ROBLOX CHECK: check if 'options.setupFilesAfterEnv' is an Array ]]
		-- 		end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no need to resolve as this is a ModuleScript
		options.testEnvironment = options.testEnvironment or DEFAULT_CONFIG.testEnvironment
		-- resolveTestEnvironment({
		-- 	requireResolveFunction = require_.resolve,
		-- 	rootDir = options.rootDir,
		-- 	testEnvironment = Boolean.toJSBoolean(options.testEnvironment) and options.testEnvironment
		-- 		or require_:resolve(DEFAULT_CONFIG.testEnvironment),
		-- })
		-- ROBLOX deviation END

		if options.roots == nil and options.testPathDirs ~= nil then
			options.roots = options.testPathDirs
			options.testPathDirs = nil
		end

		if options.roots == nil then
			options.roots = { options.rootDir }
		end

		-- ROBLOX deviation START: no need to resolve as this is a ModuleScript
		-- if
		-- 	not Boolean.toJSBoolean(options.testRunner)
		-- 	or options.testRunner == "circus"
		-- 	or options.testRunner == "jest-circus"
		-- then
		-- 	options.testRunner = require_:resolve("jest-circus/runner")
		-- elseif options.testRunner == "jasmine2" then
		-- 	options.testRunner = require_:resolve("jest-jasmine2")
		-- end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: not supported
		-- if not Boolean.toJSBoolean(options.coverageDirectory) then
		-- 	options.coverageDirectory = path:resolve(options.rootDir, "coverage")
		-- end

		-- setupBabelJest(options)
		-- ROBLOX deviation END
		-- TODO: Type this properly
		local newOptions = (Object.assign({}, DEFAULT_CONFIG) :: unknown) :: AllOptions

		-- ROBLOX deviation START: not supported
		-- if Boolean.toJSBoolean(options.resolver) then
		-- 	newOptions.resolver =
		-- 		resolve(nil, { filePath = options.resolver, key = "resolver", rootDir = options.rootDir })
		-- end

		-- validateExtensionsToTreatAsEsm(options.extensionsToTreatAsEsm)

		-- if options.watchman == nil then
		-- 	options.watchman = DEFAULT_CONFIG.watchman
		-- end
		-- ROBLOX deviation END

		local optionKeys = Object.keys(options) :: Array<string> --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof Config.InitialOptions ]]

		Array.reduce(optionKeys, function(
			newOptions,
			key: string --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof Config.InitialOptions ]]
		)
			-- The resolver has been resolved separately; skip it
			if key == "resolver" then
				return newOptions
			end

			-- This is cheating, because it claims that all keys of InitialOptions are Required.
			-- We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,
			-- so oldOptions[key] is the only way it should be used.
			-- ROBLOX deviation START: no Required and Pick helpers
			local oldOptions = options :: Config_InitialOptions
			-- & Required<Pick<Config_InitialOptions, typeof(key)>>
			-- ROBLOX deviation END
			local value: any
			repeat --[[ ROBLOX comment: switch statement conversion ]]
				-- ROBLOX deviation START: not supported
				if false then
					-- if key == "collectCoverageOnlyFrom" then
					-- 	value = normalizeCollectCoverageOnlyFrom(oldOptions, key)
					-- 	break
					-- ROBLOX deviation END
					-- ROBLOX deviation START: no need to resolve
				elseif key == "setupFiles" or key == "setupFilesAfterEnv" or key == "snapshotSerializers" then
					do
						local option = oldOptions[key]
						if option ~= nil then
							value = Array.map(option, function(path)
								return if path == "<rootDir>" then options.rootDir else path
							end)
						end
						-- value = if Boolean.toJSBoolean(option)
						-- 	then Array.map(option, function(filePath)
						-- 		return resolve(
						-- 			newOptions.resolver,
						-- 			{ filePath = filePath, key = key, rootDir = options.rootDir }
						-- 		)
						-- 	end)
						-- 	else option
					end
					break
				elseif key == "modulePaths" or key == "roots" then
					do
						local option = oldOptions[key]
						if option ~= nil then
							value = Array.map(option, function(path)
								return if path == "<rootDir>" then options.rootDir else path
							end)
						end
						-- 	value = if Boolean.toJSBoolean(option)
						-- 		then Array.map(option, function(filePath)
						-- 			return path:resolve(options.rootDir, replaceRootDirInPath(options.rootDir, filePath))
						-- 		end)
						-- 		else option
					end
					break
					-- ROBLOX deviation END
					-- ROBLOX deviation START: not supported
					-- elseif key == "collectCoverageFrom" then
					-- 	value = normalizeCollectCoverageFrom(oldOptions, key)
					-- 	break
					-- elseif key == "cacheDirectory" or key == "coverageDirectory" then
					-- 	do
					-- 		local option = oldOptions[key]
					-- 		value = if Boolean.toJSBoolean(option)
					-- 			then path:resolve(options.rootDir, replaceRootDirInPath(options.rootDir, option))
					-- 			else option
					-- 	end
					-- 	break
					-- ROBLOX deviation END
					-- ROBLOX deviation START: no need to resolve
					-- elseif
					-- 	key == "dependencyExtractor"
					-- 	or key == "globalSetup"
					-- 	or key == "globalTeardown"
					-- 	or key == "moduleLoader"
					-- 	or key == "snapshotResolver"
					-- 	or key == "testResultsProcessor"
					-- 	or key == "testRunner"
					-- 	or key == "filter"
					-- then
					-- 	do
					-- 		local option = oldOptions[key]
					-- 		value = if Boolean.toJSBoolean(option)
					-- 			then resolve(newOptions.resolver, { filePath = option, key = key, rootDir = options.rootDir })
					-- 			else option
					-- 	end
					-- 	break
					-- elseif key == "runner" then
					-- 	do
					-- 		local option = oldOptions[key]
					-- 		value = if Boolean.toJSBoolean(option)
					-- 			then resolveRunner(newOptions.resolver, {
					-- 				filePath = option,
					-- 				requireResolveFunction = require_.resolve,
					-- 				rootDir = options.rootDir,
					-- 			})
					-- 			else option
					-- 	end
					-- 	break
					-- ROBLOX deviation END
					-- ROBLOX deviation START: not supported
					-- elseif key == "prettierPath" then
					-- 	do
					-- 		-- We only want this to throw if "prettierPath" is explicitly passed
					-- 		-- from config or CLI, and the requested path isn't found. Otherwise we
					-- 		-- set it to null and throw an error lazily when it is used.
					-- 		local option = oldOptions[key]
					-- 		value = if Boolean.toJSBoolean(option)
					-- 			then resolve(newOptions.resolver, {
					-- 				filePath = option,
					-- 				key = key,
					-- 				optional = option == DEFAULT_CONFIG[key],
					-- 				rootDir = options.rootDir,
					-- 			})
					-- 			else option
					-- 	end
					-- 	break
					-- elseif key == "moduleNameMapper" then
					-- 	local moduleNameMapper = oldOptions[key]
					-- 	value = if Boolean.toJSBoolean(moduleNameMapper)
					-- 		then Array.map(Object.keys(moduleNameMapper), function(regex)
					-- 			local item = if Boolean.toJSBoolean(moduleNameMapper)
					-- 				then moduleNameMapper[tostring(regex)]
					-- 				else moduleNameMapper
					-- 			return if Boolean.toJSBoolean(item)
					-- 				then { regex, _replaceRootDirTags(options.rootDir, item) }
					-- 				else item
					-- 		end) --[[ ROBLOX CHECK: check if 'Object.keys(moduleNameMapper)' is an Array ]]
					-- 		else moduleNameMapper
					-- 	break
					-- elseif key == "transform" then
					-- 	local transform = oldOptions[key]
					-- 	value = if Boolean.toJSBoolean(transform)
					-- 		then
					-- 			Array.map(Object.keys(transform), function(regex)
					-- 				local transformElement = transform[tostring(regex)]
					-- 				return {
					-- 					regex,
					-- 					resolve(newOptions.resolver, {
					-- 						filePath = if Boolean.toJSBoolean(Array.isArray(transformElement))
					-- 							then
					-- 								transformElement[
					-- 									1 --[[ ROBLOX adaptation: added 1 to array index ]]
					-- 								]
					-- 							else transformElement,
					-- 						key = key,
					-- 						rootDir = options.rootDir,
					-- 					}),
					-- 					if Boolean.toJSBoolean(Array.isArray(transformElement))
					-- 						then
					-- 							transformElement[
					-- 								2 --[[ ROBLOX adaptation: added 1 to array index ]]
					-- 							]
					-- 						else {},
					-- 				}
					-- 			end) --[[ ROBLOX CHECK: check if 'Object.keys(transform)' is an Array ]]
					-- 		else transform
					-- 	break
					-- ROBLOX deviation END
				elseif
					key == "testPathIgnorePatterns"
					-- or key == "coveragePathIgnorePatterns"
					-- or key == "modulePathIgnorePatterns"
					-- or key == "transformIgnorePatterns"
					-- or key == "watchPathIgnorePatterns"
					-- or key == "unmockedModulePathPatterns"
				then
					-- ROBLOX deviation START: subbing rootDir not supported
					value = oldOptions[key]
					-- ROBLOX deviation END
					break
					-- ROBLOX deviation START: no need to resolve
					-- elseif key == "haste" then
					-- 	value = Object.assign({}, oldOptions[key])
					-- 	if
					-- 		value.hasteImplModulePath ~= nil --[[ ROBLOX CHECK: loose inequality used upstream ]]
					-- 	then
					-- 		local resolvedHasteImpl = resolve(newOptions.resolver, {
					-- 			filePath = replaceRootDirInPath(options.rootDir, value.hasteImplModulePath),
					-- 			key = "haste.hasteImplModulePath",
					-- 			rootDir = options.rootDir,
					-- 		})
					-- 		value.hasteImplModulePath = Boolean.toJSBoolean(resolvedHasteImpl) and resolvedHasteImpl or nil
					-- 	end
					-- 	break
					-- ROBLOX deviation END
				elseif key == "projects" then
					value = Array.reduce(
						Array.map(Boolean.toJSBoolean(oldOptions[key]) and oldOptions[key] or {}, function(project)
							-- ROBLOX deviation START: project is an Instance
							return project
							-- return if typeof(project) == "string"
							-- 	then _replaceRootDirTags(options.rootDir, project)
							-- 	else project
							-- ROBLOX deviation END
						end),
						function(projects, project)
							-- Project can be specified as globs. If a glob matches any files,
							-- We expand it to these paths. If not, we keep the original path
							-- for the future resolution.
							-- ROBLOX deviation START: project is an Instance
							local globMatches = {}
							-- local globMatches = if typeof(project) == "string" then glob(project) else {}
							return Array.concat(projects, if #globMatches > 0 then globMatches else { project })
							-- ROBLOX deviation END
						end,
						{}
					)
					break
				elseif key == "moduleDirectories" or key == "testMatch" then
					do
						-- ROBLOX deviation START: _replaceRootDirTags not supported
						local replacedRootDirTags = oldOptions[key]
						-- local replacedRootDirTags = _replaceRootDirTags(escapeGlobCharacters(options.rootDir), oldOptions[key])
						-- ROBLOX deviation END
						if replacedRootDirTags ~= nil then
							value = if Array.isArray(replacedRootDirTags)
								then Array.map(replacedRootDirTags, replacePathSepForGlob)
								else replacePathSepForGlob(replacedRootDirTags)
						else
							value = replacedRootDirTags
						end
					end
					break
				elseif key == "testRegex" then
					do
						local option = oldOptions[key]
						value = if option ~= nil and Boolean.toJSBoolean(option)
							then Array.map(if Array.isArray(option) then option else { option }, replacePathSepForRegex)
							else {}
					end
					break
					-- ROBLOX deviation START: not supported
					-- elseif key == "moduleFileExtensions" then
					-- 	do
					-- 		value = oldOptions[key]
					-- 		if
					-- 			Boolean.toJSBoolean((function()
					-- 				local ref = Array.isArray(value)
					-- 				local ref = if Boolean.toJSBoolean(ref)
					-- 					then options.runner == nil or options.runner == DEFAULT_CONFIG.runner
					-- 					else ref
					-- 				return if Boolean.toJSBoolean(ref)
					-- 					then -- Only require 'js' for the default jest-runner
					-- 						-- Only require 'js' for the default jest-runner
					-- 						not Boolean.toJSBoolean(
					-- 							Array.includes(value, "js") --[[ ROBLOX CHECK: check if 'value' is an Array ]]
					-- 						)
					-- 					else ref
					-- 			end)())
					-- 		then
					-- 			local errorMessage = "  moduleFileExtensions must include 'js':\n"
					-- 				.. "  but instead received:\n"
					-- 				.. ("    %s"):format(tostring(chalk.bold:red(JSON:stringify(value)))) -- If `js` is not included, any dependency Jest itself injects into
					-- 			-- the environment, like jasmine or sourcemap-support, will need to
					-- 			-- `require` its modules with a file extension. This is not plausible
					-- 			-- in the long run, so it's way easier to just fail hard early.
					-- 			-- We might consider throwing if `json` is missing as well, as it's a
					-- 			-- fair assumption from modules that they can do
					-- 			-- `require('some-package/package') without the trailing `.json` as it
					-- 			-- works in Node normally.
					-- 			error(
					-- 				createConfigError(
					-- 					tostring(errorMessage) .. "\n  Please change your configuration to include 'js'."
					-- 				)
					-- 			)
					-- 		end
					-- 		break
					-- 	end
					-- ROBLOX deviation END
				elseif key == "bail" then
					do
						local bail = oldOptions[key]
						if typeof(bail) == "boolean" then
							value = if bail then 1 else 0
						elseif typeof(bail) == "string" then
							value = 1
							-- If Jest is invoked as `jest --bail someTestPattern` then need to
							-- move the pattern from the `bail` configuration and into `argv._`
							-- to be processed as an extra parameter
							table.insert(argv._, bail)
						else
							value = oldOptions[key]
						end
						break
					end
				elseif key == "displayName" then
					do
						local displayName = oldOptions[key] :: Config_DisplayName
						--[[*
							* Ensuring that displayName shape is correct here so that the
							* reporters can trust the shape of the data
						]]
						if typeof(displayName) == "table" then
							local name, color = displayName.name, displayName.color
							if
								not Boolean.toJSBoolean(name)
								or not Boolean.toJSBoolean(color)
								or typeof(name) ~= "string"
								or typeof(color) ~= "string"
							then
								local errorMessage = ('  Option "%s" must be of type:\n\n'):format(
									chalk.bold("displayName")
								) .. "  {\n" .. "    name: string;\n" .. "    color: string;\n" .. "  }\n"
								error(createConfigError(errorMessage))
							end
							value = oldOptions[key]
						else
							value = {
								color = getDisplayNameColor(options.runner),
								name = displayName,
							}
						end
						break
					end
				elseif key == "testTimeout" then
					do
						if oldOptions[key] < 0 then
							error(
								createConfigError(
									('  Option "%s" must be a natural number.'):format(chalk.bold("testTimeout"))
								)
							)
						end
						value = oldOptions[key]
						break
					end
				elseif
					key == "automock"
					or key == "cache"
					or key == "changedSince"
					or key == "changedFilesWithAncestor"
					or key == "clearMocks"
					or key == "collectCoverage"
					or key == "coverageProvider"
					or key == "coverageReporters"
					or key == "coverageThreshold"
					or key == "detectLeaks"
					or key == "detectOpenHandles"
					or key == "errorOnDeprecated"
					or key == "expand"
					or key == "extensionsToTreatAsEsm"
					or key == "extraGlobals"
					or key == "globals"
					or key == "findRelatedTests"
					or key == "forceCoverageMatch"
					or key == "forceExit"
					or key == "injectGlobals"
					or key == "lastCommit"
					or key == "listTests"
					or key == "logHeapUsage"
					or key == "maxConcurrency"
					or key == "id"
					or key == "noStackTrace"
					or key == "notify"
					or key == "notifyMode"
					or key == "mockDataModel"
					or key == "onlyChanged"
					or key == "onlyFailures"
					or key == "outputFile"
					or key == "oldFunctionSpying"
					or key == "passWithNoTests"
					or key == "replname"
					or key == "reporters"
					or key == "resetMocks"
					or key == "resetModules"
					or key == "restoreMocks"
					or key == "rootDir"
					or key == "runTestsByPath"
					or key == "silent"
					or key == "skipFilter"
					or key == "skipNodeResolution"
					or key == "slowTestThreshold"
					or key == "snapshotFormat"
					or key == "testEnvironment"
					or key == "testEnvironmentOptions"
					or key == "testFailureExitCode"
					or key == "testLocationInResults"
					or key == "testNamePattern"
					or key == "testURL"
					or key == "timers"
					or key == "useStderr"
					or key == "verbose"
					or key == "watch"
					or key == "watchAll"
					or key == "watchman"
				then
					value = oldOptions[key]
					break
					-- ROBLOX deviation START: not supported
					-- elseif key == "watchPlugins" then
					-- 	value = Array.map(
					-- 		Boolean.toJSBoolean(oldOptions[key]) and oldOptions[key] or {},
					-- 		function(watchPlugin)
					-- 			if typeof(watchPlugin) == "string" then
					-- 				return {
					-- 					config = {},
					-- 					path = resolveWatchPlugin(newOptions.resolver, {
					-- 						filePath = watchPlugin,
					-- 						requireResolveFunction = require_.resolve,
					-- 						rootDir = options.rootDir,
					-- 					}),
					-- 				}
					-- 			else
					-- 				return {
					-- 					config = Boolean.toJSBoolean(watchPlugin[2]) and watchPlugin[2] or {},
					-- 					path = resolveWatchPlugin(newOptions.resolver, {
					-- 						filePath = watchPlugin[1],
					-- 						requireResolveFunction = require_.resolve,
					-- 						rootDir = options.rootDir,
					-- 					}),
					-- 				}
					-- 			end
					-- 		end
					-- 	)
					-- 	break
					-- ROBLOX deviation END
				end
			until true
			-- @ts-expect-error: automock is missing in GlobalConfig, so what
			newOptions[key] = value
			return newOptions
		end, newOptions)
		-- ROBLOX deviation START: not supported
		-- if
		-- 	Boolean.toJSBoolean(options.watchman)
		-- 	and typeof(options.haste) == "table"
		-- 	and options.haste.enableSymlinks
		-- then
		-- 	error(
		-- 		ValidationError.new(
		-- 			"Validation Error",
		-- 			"haste.enableSymlinks is incompatible with watchman",
		-- 			"Either set haste.enableSymlinks to false or do not use watchman"
		-- 		)
		-- 	)
		-- end
		-- ROBLOX deviation END

		Array.forEach(newOptions.roots, function(root, i)
			verifyDirectoryExists(root, ("roots[%s]"):format(tostring(i)))
		end)

		-- ROBLOX deviation START: not supported
		-- xpcall(function()
		-- 	-- try to resolve windows short paths, ignoring errors (permission errors, mostly)
		-- 	newOptions.cwd = tryRealpath(process:cwd())
		-- end, function() end)

		-- newOptions.testSequencer = resolveSequencer(newOptions.resolver, {
		-- 	filePath = Boolean.toJSBoolean(options.testSequencer) and options.testSequencer or require_:resolve(
		-- 		DEFAULT_CONFIG.testSequencer
		-- 	),
		-- 	requireResolveFunction = require_.resolve,
		-- 	rootDir = options.rootDir,
		-- })
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no need to resolve
		-- if newOptions.runner == DEFAULT_CONFIG.runner then
		-- 	newOptions.runner = require_:resolve(newOptions.runner)
		-- end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: not supported
		-- local ref = if typeof(argv._) == "table" then argv._.map else nil
		-- newOptions.nonFlagArgs = if ref ~= nil
		-- 	then ref(function(arg)
		-- 		return ("%s"):format(tostring(arg))
		-- 	end)
		-- 	else nil
		-- ROBLOX deviation END
		newOptions.testPathPattern = buildTestPathPattern(argv)
		newOptions.json = Boolean.toJSBoolean(argv.json)
		newOptions.testFailureExitCode = tonumber((newOptions.testFailureExitCode :: unknown) :: string, 10) or 0
		-- ROBLOX deviation START: not supported
		-- if
		-- 	Boolean.toJSBoolean((function()
		-- 		local ref = Boolean.toJSBoolean(newOptions.lastCommit) and newOptions.lastCommit
		-- 			or newOptions.changedFilesWithAncestor
		-- 		return Boolean.toJSBoolean(ref) and ref or newOptions.changedSince
		-- 	end)())
		-- then
		-- 	newOptions.onlyChanged = true
		-- end

		-- if argv.all then
		-- 	newOptions.onlyChanged = false
		-- 	newOptions.onlyFailures = false
		-- elseif Boolean.toJSBoolean(newOptions.testPathPattern) then
		-- 	-- When passing a test path pattern we don't want to only monitor changed
		-- 	-- files unless `--watch` is also passed.
		-- 	newOptions.onlyChanged = newOptions.watch
		-- end

		-- if not newOptions.onlyChanged then
		-- 	newOptions.onlyChanged = false
		-- end

		-- if not Boolean.toJSBoolean(newOptions.lastCommit) then
		-- 	newOptions.lastCommit = false
		-- end

		-- if not Boolean.toJSBoolean(newOptions.onlyFailures) then
		-- 	newOptions.onlyFailures = false
		-- end

		-- if not Boolean.toJSBoolean(newOptions.watchAll) then
		-- 	newOptions.watchAll = false
		-- end

		-- -- as unknown since it can happen. We really need to fix the types here
		-- if newOptions.moduleNameMapper == DEFAULT_CONFIG.moduleNameMapper :: unknown then
		-- 	newOptions.moduleNameMapper = {}
		-- end
		-- ROBLOX deviation END

		newOptions.updateSnapshot = if Boolean.toJSBoolean(argv.ci) and not argv.updateSnapshot
			then "none"
			else if argv.updateSnapshot then "all" else "new"

		newOptions.maxConcurrency = tonumber((newOptions.maxConcurrency :: unknown) :: string, 10) or 0
		newOptions.maxWorkers = getMaxWorkers(argv, options)

		if #(newOptions.testRegex :: any) > 0 and options.testMatch ~= nil then
			error(
				createConfigError(
					("  Configuration options %s and"):format(chalk.bold("testMatch"))
						.. (" %s cannot be used together."):format(chalk.bold("testRegex"))
				)
			)
		end

		if #(newOptions.testRegex :: any) > 0 and options.testMatch == nil then
			-- Prevent the default testMatch conflicting with any explicitly
			-- configured `testRegex` value
			newOptions.testMatch = {}
		end

		-- ROBLOX deviation START: not supported
		-- -- If argv.json is set, coverageReporters shouldn't print a text report.
		-- if argv.json then
		-- 	newOptions.coverageReporters = Array.filter(
		-- 		Boolean.toJSBoolean(newOptions.coverageReporters) and newOptions.coverageReporters or {},
		-- 		function(reporter)
		-- 			return reporter ~= "text"
		-- 		end
		-- 	)
		-- end

		-- -- If collectCoverage is enabled while using --findRelatedTests we need to
		-- -- avoid having false negatives in the generated coverage report.
		-- -- The following: `--findRelatedTests '/rootDir/file1.js' --coverage`
		-- -- Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`
		-- -- where arguments to `--collectCoverageFrom` should be globs (or relative
		-- -- paths to the rootDir)
		-- if
		-- 	Boolean.toJSBoolean(
		-- 		if Boolean.toJSBoolean(newOptions.collectCoverage)
		-- 			then argv.findRelatedTests
		-- 			else newOptions.collectCoverage
		-- 	)
		-- then
		-- 	local collectCoverageFrom = Array.map(newOptions.nonFlagArgs, function(filename)
		-- 		filename = replaceRootDirInPath(options.rootDir, filename)
		-- 		return if Boolean.toJSBoolean(path:isAbsolute(filename))
		-- 			then path:relative(options.rootDir, filename)
		-- 			else filename
		-- 	end) --[[ ROBLOX CHECK: check if 'newOptions.nonFlagArgs' is an Array ]] -- Don't override existing collectCoverageFrom options
		-- 	if Boolean.toJSBoolean(newOptions.collectCoverageFrom) then
		-- 		collectCoverageFrom = Array.reduce(collectCoverageFrom, function(patterns, filename)
		-- 			if
		-- 				micromatch(
		-- 					{ replacePathSepForGlob(path:relative(options.rootDir, filename)) },
		-- 					newOptions.collectCoverageFrom :: any
		-- 				).length == 0
		-- 			then
		-- 				return patterns
		-- 			end
		-- 			return Array.concat({}, Array.spread(patterns), { filename })
		-- 		end, newOptions.collectCoverageFrom) --[[ ROBLOX CHECK: check if 'collectCoverageFrom' is an Array ]]
		-- 	end
		-- 	newOptions.collectCoverageFrom = collectCoverageFrom
		-- elseif not Boolean.toJSBoolean(newOptions.collectCoverageFrom) then
		-- 	newOptions.collectCoverageFrom = {}
		-- end

		-- if not Boolean.toJSBoolean(newOptions.findRelatedTests) then
		-- 	newOptions.findRelatedTests = false
		-- end
		-- ROBLOX deviation END

		if not Boolean.toJSBoolean(newOptions.projects) then
			newOptions.projects = {}
		end

		-- ROBLOX deviation START: not supported
		-- if not Boolean.toJSBoolean(newOptions.extraGlobals) then
		-- 	newOptions.extraGlobals = {}
		-- end

		-- if not Boolean.toJSBoolean(newOptions.forceExit) then
		-- 	newOptions.forceExit = false
		-- end

		-- if not Boolean.toJSBoolean(newOptions.logHeapUsage) then
		-- 	newOptions.logHeapUsage = false
		-- end
		-- ROBLOX deviation END

		return { hasDeprecationWarnings = hasDeprecationWarnings, options = newOptions }
	end)
end
exports.default = normalize
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="280">
              <Properties>
                <string name="Name">parseShardPair</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v29.1.2-1-g2662f4708e/packages/jest-config/src/parseShardPair.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Number = LuauPolyfill.Number
local Error = LuauPolyfill.Error
local String = LuauPolyfill.String
local RegExp = require(Packages.RegExp)
local exports = {}
export type ShardPair = { shardCount: number, shardIndex: number }
local function parseShardPair(pair: string): ShardPair
	local shardPair = Array.filter(
		Array.map(
			Array.filter(String.split(pair, "/"), function(d)
				return RegExp("^\\d+$"):test(d)
			end),
			function(d)
				return tonumber(d, 10)
			end
		),
		function(shard)
			return not Boolean.toJSBoolean(Number.isNaN(shard))
		end
	)
	local shardIndex, shardCount = table.unpack(shardPair, 1, 2)
	if #shardPair ~= 2 then
		error(Error.new("The shard option requires a string in the format of <n>/<m>."))
	end
	if shardIndex == 0 or shardCount == 0 then
		error(Error.new("The shard option requires 1-based values, received 0 or lower in the pair."))
	end
	if (shardIndex :: number) > (shardCount :: number) then
		error(Error.new("The shard option <n>/<m> requires <n> to be lower or equal than <m>."))
	end
	return { shardCount = shardCount :: number, shardIndex = shardIndex :: number }
end
exports.parseShardPair = parseShardPair
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="281">
              <Properties>
                <string name="Name">readConfigFileAndSetRootDir</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/readConfigFileAndSetRootDir.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

-- ROBLOX deviation START: not needed
-- local path = require(Packages.path)
-- local fs = require(Packages["graceful-fs"])
-- local ts_nodeModule = require(Packages["ts-node"])
-- type Service = ts_nodeModule.Service
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_InitialOptions = typesModule.Config_InitialOptions
-- ROBLOX deviation START: not needed
-- type Config_Path = typesModule.Config_Path
-- local jest_utilModule = require(Packages.JestUtil)
-- local interopRequireDefault = jest_utilModule.interopRequireDefault
-- local requireOrImportModule = jest_utilModule.requireOrImportModule
-- local constantsModule = require(script.Parent.constants)
-- local JEST_CONFIG_EXT_JSON = constantsModule.JEST_CONFIG_EXT_JSON
-- local JEST_CONFIG_EXT_TS = constantsModule.JEST_CONFIG_EXT_TS
-- local PACKAGE_JSON = constantsModule.PACKAGE_JSON
-- @ts-expect-error: vendored
-- local jsonlint = require(script.Parent.vendor.jsonlint).default
-- ROBLOX deviation END

-- Read the configuration and set its `rootDir`
-- 1. If it's a `package.json` file, we look into its "jest" property
-- 2. If it's a `jest.config.ts` file, we use `ts-node` to transpile & require it
-- 3. For any other file, we just require it. If we receive an 'ERR_REQUIRE_ESM'
--    from node, perform a dynamic import instead.
local function readConfigFileAndSetRootDir(
	-- ROBLOX deviation: using ModuleScript instead of Config_Path
	configPath: ModuleScript
): Promise<Config_InitialOptions>
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: custom implementation
		-- local isTS = configPath:endsWith(JEST_CONFIG_EXT_TS)
		-- local isJSON = configPath:endsWith(JEST_CONFIG_EXT_JSON)
		-- ROBLOX deviation END
		local ok, configObjectOrError = pcall(require, configPath)

		if not ok then
			local error_ = configObjectOrError
			error(
				Error.new(
					("Failed to load the Luau config file %s\n  %s"):format(tostring(configPath), tostring(error_))
				)
			)
		end
		local configObject = configObjectOrError

		if typeof(configObject) == "function" then
			configObject = Promise.resolve(configObject()):expect()
		end

		if not configObject.rootDir or typeof(configObject.rootDir) ~= "Instance" then
			-- If rootDir is not there, we'll set it to this file's __dirname
			configObject.rootDir = configPath.Parent
		end
		return configObject
		-- ROBLOX deviation END
	end)
end
exports.default = readConfigFileAndSetRootDir

-- ROBLOX deviation START: not needed
-- local registerer -- Load the TypeScript configuration: Service
-- local function loadTSConfigFile(configPath: Config_Path): Promise<Config_InitialOptions>
-- 	return Promise.resolve():andThen(function()
-- 		-- Register TypeScript compiler instance
-- 		do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 			local ok, result, hasReturned = xpcall(function()
-- 				error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: AssignmentExpression ]] --[[ registerer ||= require('ts-node').register({
--       compilerOptions: {
--         module: 'CommonJS'
--       }
--     }) ]]
-- 			end, function(e: any)
-- 				if e.code == "MODULE_NOT_FOUND" then
-- 					error(
-- 						Error.new(
-- 							(
-- 								"Jest: 'ts-node' is required for the TypeScript configuration files. Make sure it is installed\nError: %s"
-- 							):format(tostring(e.message))
-- 						)
-- 					)
-- 				end
-- 				error(e)
-- 			end)
-- 			if hasReturned then
-- 				return result
-- 			end
-- 		end
-- 		registerer:enabled(true)
-- 		local configObject = interopRequireDefault(require_(configPath)).default -- In case the config is a function which imports more Typescript code
-- 		if typeof(configObject) == "function" then
-- 			configObject = configObject():expect()
-- 		end
-- 		registerer:enabled(false)
-- 		return configObject
-- 	end)
-- end
-- ROBLOX deviation END

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="282">
              <Properties>
                <string name="Name">resolveConfigPath</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/resolveConfigPath.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local String = LuauPolyfill.String
local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

-- ROBLOX deviation START: not needed
-- local path = require(Packages.path)
-- ROBLOX deviation END
local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation START: not needed
-- local fs = require(Packages["graceful-fs"])
-- local slash = require(Packages.slash)
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path
local constantsModule = require(script.Parent.constants)
local JEST_CONFIG_BASE_NAME = constantsModule.JEST_CONFIG_BASE_NAME
-- ROBLOX deviation START: not needed
-- local JEST_CONFIG_EXT_ORDER = constantsModule.JEST_CONFIG_EXT_ORDER
-- local PACKAGE_JSON = constantsModule.PACKAGE_JSON
-- ROBLOX deviation END
local utilsModule = require(script.Parent.utils)
local DOCUMENTATION_NOTE = utilsModule.DOCUMENTATION_NOTE

-- ROBLOX deviation START: predefine functions
local resolveConfigPathByTraversing: (
	pathToResolve: Instance,
	initialPath: Config_Path | Instance,
	-- ROBLOX deviation: using Instance instead of Config_Path
	cwd: Instance,
	skipMultipleConfigWarning: boolean
) -> ModuleScript -- ROBLOX deviation: using ModuleScript instead of Config_Path
local makeResolutionErrorMessage: (initialPath: Config_Path | Instance, cwd: Instance) -> string
local makeMultipleConfigsWarning
-- ROBLOX deviation END

local function isFile(filePath: Instance?)
	-- ROBLOX deviation START: custom implementation
	return typeof(filePath) == "Instance" and filePath:IsA("ModuleScript") and String.endsWith(filePath.Name, ".config")
	-- ROBLOX deviation END
end

local function getConfigFilename(ext: string)
	return JEST_CONFIG_BASE_NAME .. ext
end

exports.default = function(
	pathToResolve: Config_Path | Instance,
	-- ROBLOX deviation: using Instance instead of Config_Path
	cwd: Instance,
	_skipMultipleConfigWarning: boolean?
): ModuleScript -- ROBLOX deviation: using ModuleScript instead of Config_Path
	local skipMultipleConfigWarning = if _skipMultipleConfigWarning ~= nil then _skipMultipleConfigWarning else false

	-- ROBLOX deviation START: custom implementation
	local function resolvePath(root: Instance, path: string): Instance | nil
		-- ROBLOX TODO: handle nested path
		return (root :: any)[path]
	end

	local absolutePath: Instance?
	if typeof(pathToResolve) == "string" then
		absolutePath = resolvePath(cwd, pathToResolve)
	else
		absolutePath = pathToResolve
	end

	if isFile(absolutePath) then
		return absolutePath :: ModuleScript
	end

	if absolutePath == nil then
		error(
			Error.new(
				"Can't find a root directory while resolving a config file path.\n"
					.. ("Provided path to resolve: %s\n"):format(tostring(pathToResolve))
					.. ("cwd: %s"):format(tostring(cwd))
			)
		)
	end

	return resolveConfigPathByTraversing(
		-- ROBLOX FIXME Luau: absolutePath nil check above
		absolutePath :: Instance,
		pathToResolve,
		cwd,
		skipMultipleConfigWarning
	)
	-- ROBLOX deviation END
end

-- ROBLOX deviation START: additional helper function
local function isJestConfigFile(child: Instance)
	return child:IsA("ModuleScript") and child.Name == JEST_CONFIG_BASE_NAME
end
-- ROBLOX deviation END

function resolveConfigPathByTraversing(
	pathToResolve: Instance,
	initialPath: Config_Path | Instance,
	-- ROBLOX deviation: using Instance instead of Config_Path
	cwd: Instance,
	skipMultipleConfigWarning: boolean
) --[[ ROBLOX deviation: using ModuleScript instead of Config_Path]]: ModuleScript
	-- ROBLOX deviation START: custom logic
	-- ROBLOX NOTE: additional nil check
	if pathToResolve == nil or typeof(pathToResolve.GetChildren) ~= "function" then
		error(Error.new(makeResolutionErrorMessage(initialPath, cwd)))
	end

	local configFiles = (
		Array.filter(pathToResolve:GetChildren(), function(child)
			local ok, result = pcall(isJestConfigFile, child)
			return ok and result
		end) :: Array<any>
	) :: Array<ModuleScript>
	if not skipMultipleConfigWarning and #configFiles > 1 then
		console.warn(makeMultipleConfigsWarning(configFiles))
	end
	if #configFiles > 0 then
		return configFiles[1]
	end

	-- This is the system root.
	-- We tried everything, config is nowhere to be found ¯\_(ツ)_/¯
	if pathToResolve == game then
		error(Error.new(makeResolutionErrorMessage(initialPath, cwd)))
	end

	-- go up a level and try it again
	return resolveConfigPathByTraversing(pathToResolve.Parent :: Instance, initialPath, cwd, skipMultipleConfigWarning)
	-- ROBLOX deviation END
end

-- ROBLOX deviation START: not needed
-- local function findPackageJson(pathToResolve: Config_Path)
-- 	local packagePath = path:resolve(pathToResolve, PACKAGE_JSON)
-- 	if Boolean.toJSBoolean(isFile(packagePath)) then
-- 		return packagePath
-- 	end
-- 	return nil
-- end
-- local function hasPackageJsonJestKey(packagePath: Config_Path)
-- 	local content = fs:readFileSync(packagePath, "utf8")
-- 	do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 		local ok, result, hasReturned = xpcall(function()
-- 			return Array.indexOf(Object.keys(JSON:parse(content)), "jest") ~= -1, true
-- 		end, function()
-- 			-- If package is not a valid JSON
-- 			return false, true
-- 		end)
-- 		if hasReturned then
-- 			return result
-- 		end
-- 	end
-- end
-- ROBLOX deviation END

function makeResolutionErrorMessage(
	-- ROBLOX deviation: using Instance instead of Config_Path
	initialPath: Config_Path | Instance,
	-- ROBLOX deviation: using Instance instead of Config_Path
	cwd: Instance
): string
	return "Could not find a config file based on provided values:\n"
		.. ('path: "%s"\n'):format(tostring(initialPath))
		.. ('cwd: "%s"\n'):format(tostring(cwd))
		-- ROBLOX deviation START: align message to make more sense in Luau context
		.. "Config paths must be specified by either a direct path to a config script\n"
		.. "or a path to a directory. If directory is given, Jest will try to\n"
		-- ROBLOX deviation END
		.. ("traverse directory tree up, until it finds one of those files in exact order: %s."):format(
			Array.join(
				Array.map(
					-- ROBLOX deviation START: only support Lua config files
					-- JEST_CONFIG_EXT_ORDER
					{ ".lua" },
					-- ROBLOX deviation END
					function(ext)
						return ('"%s"'):format((getConfigFilename(ext)))
					end
				),
				" or "
			)
		)
end

local function extraIfPackageJson(configPath: Config_Path)
	-- ROBLOX deviation START: no package.json handling
	-- if Boolean.toJSBoolean(configPath:endsWith(PACKAGE_JSON)) then
	-- 	return "`jest` key in "
	-- end
	-- ROBLOX deviation END
	return ""
end

function makeMultipleConfigsWarning(configPaths: Array<ModuleScript>)
	return chalk.yellow({
		Array.join(
			Array.concat(
				{},
				{ chalk.bold("\u{25cf} Multiple configurations found:") },
				Array.map(configPaths, function(configPath)
					return ("    * %s%s"):format(tostring(extraIfPackageJson(configPath)), tostring(configPath))
				end),
				{
					"",
					"  Implicit config resolution does not allow multiple configuration files.",
					"  Either remove unused config files or select one explicitly with `--config`.",
				}
			),
			"\n"
		),
		DOCUMENTATION_NOTE,
	})
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="283">
              <Properties>
                <string name="Name">setFromArgv</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/setFromArgv.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
type Record<K, T> = { [K]: T }

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_Argv = typesModule.Config_Argv
type Config_InitialOptions = typesModule.Config_InitialOptions
local isJSONString = require(script.Parent.utils).isJSONString

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
local JSON = nodeUtils.JSON
-- ROBLOX deviation END

local specialArgs = { "_", "$0", "h", "help", "config" }

local function setFromArgv(options: Config_InitialOptions, argv: Config_Argv): Config_InitialOptions
	local argvToOptions = Array.reduce(
		Array.filter(Object.keys(argv), function(key)
			-- ROBLOX FIXME Luau: analyze complains about argv not being a table
			return (argv :: any)[key] ~= nil and Array.indexOf(specialArgs, key) == -1
		end),
		function(options: Record<string, unknown>, key)
			local condition_ = key
			-- ROBLOX deviation START: not supported
			if false then
				-- if condition_ == "coverage" then
				-- 	options.collectCoverage = argv[key]
				-- ROBLOX deviation END
			elseif condition_ == "json" then
				-- ROBLOX FIXME Luau: analyze complains about argv not being a table
				options.useStderr = (argv :: any)[key]
				-- ROBLOX deviation START: not supported
				-- elseif condition_ == "watchAll" then
				-- 	options.watch = false
				-- 	options.watchAll = argv[key]
				-- elseif condition_ == "env" then
				-- 	options.testEnvironment = argv[key]
				-- ROBLOX deviation END
			elseif condition_ == "config" then
				-- ROBLOX NOTE: empty elseif
			elseif
				-- ROBLOX deviation START: not supported
				-- condition_ == "coverageThreshold" or
				condition_ == "globals"
				-- or condition_ == "haste"
				-- or condition_ == "moduleNameMapper"
				-- or condition_ == "testEnvironmentOptions"
				-- or condition_ == "transform"
				-- ROBLOX deviation END
			then
				-- ROBLOX FIXME Luau: analyze complains about argv not being a table
				local str = (argv :: any)[key]
				if isJSONString(str) then
					options[key] = JSON.parse(str)
				end
			else
				-- ROBLOX FIXME Luau: analyze complains about argv not being a table
				options[key] = (argv :: any)[key]
			end
			return options
		end,
		{}
	)
	return Object.assign({}, options, if isJSONString(argv.config) then JSON.parse(argv.config) else nil, argvToOptions)
end
exports.default = setFromArgv

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="284">
              <Properties>
                <string name="Name">utils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/utils.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: not needed
-- local Array = LuauPolyfill.Array
-- local Boolean = LuauPolyfill.Boolean
-- local Error = LuauPolyfill.Error
-- ROBLOX deviation END
local String = LuauPolyfill.String
-- ROBLOX deviation START: not needed
-- local instanceof = LuauPolyfill.instanceof
-- ROBLOX deviation END
type Array<T> = LuauPolyfill.Array<T>
type Record<K, T> = { [K]: T }

local exports = {}

-- ROBLOX deviation START: not needed
-- local path = require(Packages.path)
-- ROBLOX deviation END
local chalk = require(Packages.ChalkLua)
local typesModule = require(Packages.JestTypes)
type Config_Glob = typesModule.Config_Glob
type Config_Path = typesModule.Config_Path
-- ROBLOX deviation START: not needed
-- local Resolver = require(Packages["jest-resolve"]).default
-- local ValidationError = require(Packages["jest-validate"]).ValidationError
-- local ValidationError = Error
-- ROBLOX deviation END

type ResolveOptions = {
	-- ROBLOX deviation START: using Instance instead of Config_Path
	rootDir: Instance,
	-- ROBLOX deviation END
	key: string,
	filePath: Config_Path,
	optional: boolean?,
}

local BULLET: string = chalk.bold("\u{25cf} ")
exports.BULLET = BULLET
local DOCUMENTATION_NOTE = ([[  %s
  https://roblox.github.io/jest-roblox-internal/configuration
]]):format(chalk.bold("Configuration Documentation:"))
exports.DOCUMENTATION_NOTE = DOCUMENTATION_NOTE

-- ROBLOX deviation START: not ported yet
-- local function createValidationError(message: string)
-- 	return ValidationError.new(("%sValidation Error"):format(tostring(BULLET)), message, DOCUMENTATION_NOTE)
-- end

-- local function resolve(resolver: string | nil, ref: ResolveOptions): string
-- 	local key, filePath, rootDir, optional = ref.key, ref.filePath, ref.rootDir, ref.optional
-- 	local module = Resolver:findNodeModule(
-- 		replaceRootDirInPath(rootDir, filePath),
-- 		{ basedir = rootDir, resolver = if resolver ~= nil then resolver else nil }
-- 	)
-- 	if not Boolean.toJSBoolean(module) and not optional then
-- 		error(
-- 			createValidationError(
-- 				([[  Module %s in the %s option was not found.
--          %s is: %s]]):format(
-- 					chalk.bold(filePath),
-- 					chalk.bold(key),
-- 					chalk.bold("<rootDir>"),
-- 					tostring(rootDir)
-- 				)
-- 			)
-- 		)
-- 	end
-- 	--- can cast as string since nulls will be thrown
-- 	return module :: string
-- end
-- exports.resolve = resolve

-- local function escapeGlobCharacters(path: Config_Path): Config_Glob
-- 	return path:replace(
-- 		error("not implemented"), --[[ ROBLOX TODO: Unhandled node for type: RegExpLiteral ]] --[[ /([()*{}\[\]!?\\])/g ]]
-- 		"\\$1"
-- 	)
-- end
-- exports.escapeGlobCharacters = escapeGlobCharacters

-- local function replaceRootDirInPath(rootDir: Config_Path, filePath: Config_Path): string
-- 	if not Boolean.toJSBoolean(RegExp("^<rootDir>"):test(filePath)) then
-- 		return filePath
-- 	end
-- 	return path:resolve(rootDir, path:normalize("./" .. tostring(filePath:substring(("<rootDir>").length))))
-- end
-- exports.replaceRootDirInPath = replaceRootDirInPath

-- local function _replaceRootDirInObject<T>(rootDir: Config_Path, config: T): T
-- 	local newConfig = {} :: T
-- 	for configKey in config do
-- 		newConfig[configKey] = if configKey == "rootDir"
-- 			then config[configKey]
-- 			else _replaceRootDirTags(rootDir, config[configKey])
-- 	end
-- 	return newConfig
-- end

-- type OrArray<T> = T | Array<T>
-- type ReplaceRootDirConfigObj = Record<string, Config_Path>
-- type ReplaceRootDirConfigValues = OrArray<ReplaceRootDirConfigObj> | OrArray<RegExp> | OrArray<Config_Path>

-- local function _replaceRootDirTags<T>(rootDir: Config_Path, config: T): T
-- 	if config == nil then
-- 		return config
-- 	end
-- 	local condition_ = typeof(config)
-- 	if condition_ == "table" then
-- 		if Array.isArray(config) then
-- 			--/ can be string[] or {}[]
-- 			return Array.map(config, function(item)
-- 				return _replaceRootDirTags(rootDir, item)
-- 			end) :: T
-- 		end
-- 		if instanceof(config, RegExp) then
-- 			return config
-- 		end

-- 		return _replaceRootDirInObject(rootDir, config :: ReplaceRootDirConfigObj) :: T
-- 	elseif condition_ == "string" then
-- 		return replaceRootDirInPath(rootDir, config) :: T
-- 	end
-- 	return config
-- end
-- exports._replaceRootDirTags = _replaceRootDirTags
-- ROBLOX deviation END

type JSONString = string & {
	["$$type"]: never,
} -- newtype
local function isJSONString(
	text: (JSONString | string)?
): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ text is JSONString ]]
	return text ~= nil and typeof(text) == "string" and String.startsWith(text, "{") and String.endsWith(text, "}")
end
exports.isJSONString = isJSONString
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="285">
              <Properties>
                <string name="Name">validatePattern</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-config/src/validatePattern.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local RegExp = require(Packages.RegExp)

local exports = {}

local function validatePattern(pattern: string?): boolean
	if pattern ~= nil and Boolean.toJSBoolean(pattern) then
		local ok = pcall(function()
			-- eslint-disable-next-line no-new
			RegExp(pattern, "i")
		end)
		if not ok then
			return false
		end
	end
	return true
end
exports.default = validatePattern
return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="286">
            <Properties>
              <string name="Name">JestConsole</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-console/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script

local exports = {}

-- ROBLOX deviation START: additional helper / polyfill modules
exports.helpers = require(CurrentModule.helpers)

local ConsoleModule = require(CurrentModule.Console)
exports.Console = ConsoleModule
export type Console = ConsoleModule.Console
export type ConsoleOptions = ConsoleModule.ConsoleOptions
-- ROBLOX deviation END

local BufferedConsoleModule = require(CurrentModule.BufferedConsole)
exports.BufferedConsole = BufferedConsoleModule.default
export type BufferedConsole = BufferedConsoleModule.BufferedConsole

local CustomConsoleModule = require(CurrentModule.CustomConsole)
exports.CustomConsole = CustomConsoleModule.default
export type CustomConsole = CustomConsoleModule.CustomConsole

local NullConsoleModule = require(CurrentModule.NullConsole)
exports.NullConsole = NullConsoleModule.default
export type NullConsole = NullConsoleModule.NullConsole
exports.getConsoleOutput = require(CurrentModule.getConsoleOutput).default

local typesModule = require(CurrentModule.types)
export type ConsoleBuffer = typesModule.ConsoleBuffer
export type LogMessage = typesModule.LogMessage
export type LogType = typesModule.LogType
export type LogEntry = typesModule.LogEntry
export type InspectOptions = typesModule.InspectOptions

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="287">
              <Properties>
                <string name="Name">BufferedConsole</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-console/src/BufferedConsole.ts
--[[*
* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]

local exports = {}

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local String = LuauPolyfill.String
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
type Error = LuauPolyfill.Error

local ConsoleModule = require(CurrentModule.Console)
local Console = ConsoleModule.default
type Console = ConsoleModule.Console

-- ROBLOX deviation START: use custom implementations instead of unavailable node API
local helpers = require(CurrentModule.helpers)
local format = helpers.format
local formatWithOptions = helpers.formatWithOptions
-- ROBLOX deviation END

local chalk = require(Packages.ChalkLua)

local JestUtil = require(Packages.JestUtil)
local ErrorWithStack = JestUtil.ErrorWithStack
local formatTime = JestUtil.formatTime

local typesModule = require(CurrentModule.types)
type ConsoleBuffer = typesModule.ConsoleBuffer
type LogCounters = typesModule.LogCounters
type LogMessage = typesModule.LogMessage
type LogTimers = typesModule.LogTimers
type LogType = typesModule.LogType
type InspectOptions = typesModule.InspectOptions

local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable

export type BufferedConsole = {
	Console: Console,
	assert: (self: BufferedConsole, value: unknown, message: (string | Error)?) -> (),
	count: (self: BufferedConsole, label: string?) -> (),
	countReset: (self: BufferedConsole, label: string?) -> (),
	debug: (self: BufferedConsole, firstArg: unknown, ...any) -> (),
	dir: (self: BufferedConsole, firstArg: unknown, options: InspectOptions?) -> (),
	dirxml: (self: BufferedConsole, firstArg: unknown, ...any) -> (),
	error: (self: BufferedConsole, firstArg: unknown, ...any) -> (),
	group: (self: BufferedConsole, title: string?, ...any) -> (),
	groupCollapsed: (self: BufferedConsole, title: string?, ...any) -> (),
	groupEnd: (self: BufferedConsole) -> (),
	info: (self: BufferedConsole, firstArg: unknown, ...any) -> (),
	log: (self: BufferedConsole, firstArg: unknown, ...any) -> (),
	time: (self: BufferedConsole, label: string?) -> (),
	timeEnd: (self: BufferedConsole, label: string?) -> (),
	timeLog: (self: BufferedConsole, label: string?, ...any) -> (),
	warn: (self: BufferedConsole, firstArg: unknown, ...any) -> (),
	getBuffer: (self: BufferedConsole) -> ConsoleBuffer?,
	write: (buffer: ConsoleBuffer, type: LogType, message: LogMessage, level: (number | nil)?) -> ConsoleBuffer,
}

type BufferedConsolePrivate = BufferedConsole & {
	_log: (self: BufferedConsolePrivate, type: LogType, message: LogMessage) -> (),
	_buffer: ConsoleBuffer,
	_counters: LogCounters,
	_timers: LogTimers,
	_groupDepth: number,
}

-- ROBLOX deviation START: pre declare invariant function
local invariant
-- ROBLOX deviation END

-- ROBLOX FIXME LUAU: Casting to any to prevent unwanted type narrowing for write method
local BufferedConsole = setmetatable({}, { __index = Console }) :: any
BufferedConsole.__index = BufferedConsole

function BufferedConsole.new(): BufferedConsole
	local self = setmetatable(
		Console.new({
			write = function(self, message)
				BufferedConsole.write(((self :: any) :: BufferedConsolePrivate)._buffer, "log", message, nil)

				return true
			end,
		} :: Writeable),
		BufferedConsole
	) :: any
	self._buffer = {}
	self._counters = {}
	self._timers = {}
	self._groupDepth = 0
	self.Console = Console
	return self :: BufferedConsole
end

function BufferedConsole.write(buffer: ConsoleBuffer, type: LogType, message: LogMessage, level: (number | nil)?)
	local stackLevel = if level ~= nil then level else 2
	local rawStack = ErrorWithStack.new(nil, BufferedConsole.write).stack
	invariant(rawStack, "always have a stack trace")
	local origin = Array.join(
		Array.filter(Array.slice(String.split(rawStack :: string, "\n"), stackLevel), Boolean.toJSBoolean),
		"\n"
	)
	table.insert(buffer, { message = message, origin = origin, type = type })
	return buffer
end

function BufferedConsole:_log(type: LogType, message: LogMessage)
	BufferedConsole.write(self._buffer, type :: any, ("  "):rep(self._groupDepth) .. message, 3)
end

function BufferedConsole.assert(self: BufferedConsolePrivate, value: unknown, message: (string | Error)?)
	xpcall(function()
		assert(value)
	end, function(error_)
		local msg = ""
		if message ~= nil then
			msg = " " .. tostring(message)
		end

		self:_log("assert", tostring(error_) .. msg)
	end)
end

function BufferedConsole.count(self: BufferedConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	if self._counters[label] == nil then
		self._counters[label] = 0
	end
	self._counters[label] += 1
	self:_log("count", format("%s: %s", label, self._counters[label]))
end

function BufferedConsole.countReset(self: BufferedConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	self._counters[label] = 0
end

function BufferedConsole.debug(self: BufferedConsolePrivate, firstArg: unknown, ...: any)
	self:_log("debug", format(firstArg, ...))
end

function BufferedConsole.dir(self: BufferedConsolePrivate, firstArg: unknown, options_: InspectOptions?)
	local options: InspectOptions = options_ or {}
	local representation = inspect(firstArg, options)
	self:_log("dir", formatWithOptions(options, representation))
end

function BufferedConsole.dirxml(self: BufferedConsolePrivate, firstArg: unknown, ...: any)
	self:_log("dirxml", format(firstArg, ...))
end

function BufferedConsole.error(self: BufferedConsolePrivate, firstArg: unknown, ...: any)
	self:_log("error", format(firstArg, ...))
end

function BufferedConsole.group(self: BufferedConsolePrivate, title: string?, ...: any)
	local rest = { ... }
	self._groupDepth += 1
	if Boolean.toJSBoolean(title) or #rest > 0 then
		self:_log("group", chalk.bold(format(title, ...)))
	end
end

function BufferedConsole.groupCollapsed(self: BufferedConsolePrivate, title: string?, ...: any)
	local rest = { ... }
	self._groupDepth += 1
	if Boolean.toJSBoolean(title) or #rest > 0 then
		self:_log("groupCollapsed", chalk.bold(format(title, ...)))
	end
end

function BufferedConsole.groupEnd(self: BufferedConsolePrivate)
	if self._groupDepth > 0 then
		self._groupDepth -= 1
	end
end

function BufferedConsole.info(self: BufferedConsolePrivate, firstArg: unknown, ...: any)
	self:_log("info", format(firstArg, ...))
end

function BufferedConsole.log(self: BufferedConsolePrivate, firstArg: unknown, ...: any)
	self:_log("log", format(firstArg, ...))
end

function BufferedConsole.time(self: BufferedConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	if Boolean.toJSBoolean(self._timers[label]) then
		return
	end
	self._timers[label] = DateTime.now()
end

function BufferedConsole.timeEnd(self: BufferedConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	local startTime = self._timers[label]
	if Boolean.toJSBoolean(startTime) then
		local endTime = DateTime.now()
		local time = endTime.UnixTimestampMillis - startTime.UnixTimestampMillis
		self:_log("time", format("%s: %s", label, formatTime(time)))
		self._timers[label] = nil
	end
end

function BufferedConsole.timeLog(self: BufferedConsolePrivate, label_: string?, ...: any)
	local label: string = if label_ ~= nil then label_ else "default"
	local startTime = self._timers[label]
	if Boolean.toJSBoolean(startTime) then
		local endTime = DateTime.now()
		local time = endTime.UnixTimestampMillis - startTime.UnixTimestampMillis
		self:_log("time", format("%s: %s", label, formatTime(time), ...))
	end
end

function BufferedConsole.warn(self: BufferedConsolePrivate, firstArg: unknown, ...: any)
	self:_log("warn", format(firstArg, ...))
end

function BufferedConsole.getBuffer(self: BufferedConsolePrivate): ConsoleBuffer?
	return if #self._buffer > 0 then self._buffer else nil
end

function invariant(condition: unknown, message: string?)
	if not Boolean.toJSBoolean(condition) then
		error(Error.new(message))
	end
end

exports.default = BufferedConsole
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="288">
              <Properties>
                <string name="Name">Console</string>
                <string name="Source"><![CDATA[--[[
	Copyright Node.js contributors. All rights reserved.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	IN THE SOFTWARE.
]]
-- ROBLOX NOTE: no upstream: minimal implementation derived from - https://github.com/nodejs/node/blob/094b2ae/lib/internal/console/constructor.js

local exports = {}

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local format = require(CurrentModule.helpers).format

local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable

export type Console = {
	error: (...unknown) -> (),
	log: (...unknown) -> (),
	_stdout: Writeable,
	_stderr: Writeable,
	_write: (self: Console, type: string, value: string) -> (),
}

export type ConsoleOptions = {
	stdout: Writeable?,
	stderr: Writeable?,
}

local Console = {}
Console.__index = Console

function Console.new(stdout: ConsoleOptions | Writeable, stderr: Writeable?, options: ConsoleOptions?): Console
	local self = setmetatable({}, Console)
	local opts = (options or {}) :: ConsoleOptions

	if typeof((stdout :: Writeable).write) == "function" then
		opts.stdout = stdout :: Writeable
		opts.stderr = stderr
	end

	if opts.stderr == nil then
		opts.stderr = opts.stdout
	end

	if opts.stdout == nil or typeof(opts.stdout.write) ~= "function" then
		error("stdout must have a write method")
	end

	if opts.stderr == nil or typeof(opts.stderr.write) ~= "function" then
		error("stderr must have a write method")
	end

	self._stdout = opts.stdout :: Writeable
	self._stderr = opts.stderr :: Writeable

	return (self :: any) :: Console
end

function Console._write(self: Console, type: string, value: string)
	local stream = if type == "stdout" then self._stdout else self._stderr
	stream:write(value)
end

function Console:log(...: unknown)
	self:_write("stdout", format(...))
end

function Console:error(...: unknown)
	self:_write("stderr", format(...))
end

exports.default = Console
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="289">
              <Properties>
                <string name="Name">CustomConsole</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-console/src/CustomConsole.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local Console = require(CurrentModule.Console).default

local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local inspect = LuauPolyfill.util.inspect
type Error = LuauPolyfill.Error

-- ROBLOX deviation START: use custom implementations instead of unavailable node API
local helpersModule = require(CurrentModule.helpers)
local format = helpersModule.format
local formatWithOptions = helpersModule.formatWithOptions

local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable
type NodeJS_WriteStream = RobloxShared.NodeJS_WriteStream

-- ROBLOX deviation END

local chalk = require(Packages.ChalkLua)

local JestUtil = require(Packages.JestUtil)
local clearLine = JestUtil.clearLine
local formatTime = JestUtil.formatTime

local typesModule = require(CurrentModule.types)
type LogCounters = typesModule.LogCounters
type LogMessage = typesModule.LogMessage
type LogTimers = typesModule.LogTimers
type LogType = typesModule.LogType
type InspectOptions = typesModule.InspectOptions

type Formatter = (type: LogType, message: LogMessage) -> string

export type CustomConsole = {
	Console: any,
	assert: (self: CustomConsole, value: unknown, message: (string | Error)?) -> (),
	count: (self: CustomConsole, label: string?) -> (),
	countReset: (self: CustomConsole, label: string?) -> (),
	debug: (self: CustomConsole, firstArg: unknown, ...any) -> (),
	dir: (self: CustomConsole, firstArg: unknown, options: InspectOptions?) -> (),
	dirxml: (self: CustomConsole, firstArg: unknown, ...any) -> (),
	error: (self: CustomConsole, firstArg: unknown, ...any) -> (),
	group: (self: CustomConsole, title: string?, ...any) -> (),
	groupCollapsed: (self: CustomConsole, title: string?, ...any) -> (),
	groupEnd: (self: CustomConsole) -> (),
	info: (self: CustomConsole, firstArg: unknown, ...any) -> (),
	log: (self: CustomConsole, firstArg: unknown, ...any) -> (),
	time: (self: CustomConsole, label: string?) -> (),
	timeEnd: (self: CustomConsole, label: string?) -> (),
	timeLog: (self: CustomConsole, label: string?, ...any) -> (),
	warn: (self: CustomConsole, firstArg: unknown, ...any) -> (),
	getBuffer: () -> nil,
}

type CustomConsolePrivate = CustomConsole & {
	_log: (self: CustomConsole, type: LogType, message: LogMessage) -> (),
	_logError: (self: CustomConsole, type: LogType, message: LogMessage) -> (),
	_groupDepth: number,
	_counters: LogCounters,
	_timers: LogTimers,
	_stdout: Writeable,
	_stderr: Writeable,
	_formatBuffer: Formatter,
	_write: (self: CustomConsole, type: string, value: string) -> (),
}

-- ROBLOX FIXME LUAU: Casting to any to prevent unwanted type narrowing
local CustomConsole = setmetatable({}, { __index = Console }) :: any
CustomConsole.__index = CustomConsole

function CustomConsole.new(
	stdout: NodeJS_WriteStream,
	stderr: NodeJS_WriteStream,
	formatBuffer_: Formatter?
): CustomConsole
	local self = setmetatable((Console.new(stdout, stderr) :: any) :: CustomConsolePrivate, CustomConsole)

	local formatBuffer: Formatter = if formatBuffer_ ~= nil
		then formatBuffer_
		else function(_: LogType, message: LogMessage)
			return message
		end

	self._counters = {}
	self._timers = {}
	self._groupDepth = 0
	self.Console = Console

	self._stdout = stdout
	self._stderr = stderr

	self._formatBuffer = formatBuffer

	return (self :: any) :: CustomConsole
end

function CustomConsole._log(self: CustomConsolePrivate, type: LogType, message: string)
	clearLine(self._stdout);
	-- ROBLOX FIXME: Find a better way to handle super calls
	(Console.log :: any)(self, self._formatBuffer(type, ("  "):rep(self._groupDepth) .. message))
end

function CustomConsole._logError(self: CustomConsolePrivate, type: LogType, message: string)
	clearLine(self._stderr);
	-- ROBLOX FIXME: Find a better way to handle super calls
	(Console.error :: any)(self, self._formatBuffer(type, ("  "):rep(self._groupDepth) .. message))
end

function CustomConsole.assert(self: CustomConsolePrivate, value: unknown, message: (string | Error)?)
	xpcall(function()
		assert(value)
	end, function(error_)
		local msg = ""
		if message ~= nil then
			msg = " " .. tostring(message)
		end

		self:_logError("assert", tostring(error_) .. msg)
	end)
end

function CustomConsole.count(self: CustomConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"

	if self._counters[label] == nil then
		self._counters[label] = 0
	end

	self._counters[label] += 1
	self:_log("count", format("%s: %s", label, self._counters[label]))
end

function CustomConsole.countReset(self: CustomConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	self._counters[label] = 0
end

function CustomConsole.debug(self: CustomConsolePrivate, firstArg: unknown, ...: any)
	self:_log("debug", format(firstArg, ...))
end

function CustomConsole.dir(self: CustomConsolePrivate, firstArg: unknown, options_: InspectOptions?)
	local options: InspectOptions = options_ or {}
	local representation = inspect(firstArg, options)
	self:_log("dir", formatWithOptions(options, representation))
end

function CustomConsole.dirxml(self: CustomConsolePrivate, firstArg: unknown, ...: any)
	self:_log("dirxml", format(firstArg, ...))
end

function CustomConsole.error(self: CustomConsolePrivate, firstArg: unknown, ...: any)
	self:_logError("error", format(firstArg, ...))
end

function CustomConsole.group(self: CustomConsolePrivate, title: string?, ...: any)
	local args = { ... }
	self._groupDepth += 1
	if Boolean.toJSBoolean(title) or #args > 0 then
		self:_log("group", chalk.bold(format(title, ...)))
	end
end

function CustomConsole.groupCollapsed(self: CustomConsolePrivate, title: string?, ...: any)
	local args = { ... }
	self._groupDepth += 1
	if Boolean.toJSBoolean(title) or #args > 0 then
		self:_log("groupCollapsed", chalk.bold(format(title, ...)))
	end
end

function CustomConsole.groupEnd(self: CustomConsolePrivate)
	if self._groupDepth > 0 then
		self._groupDepth -= 1
	end
end

function CustomConsole.info(self: CustomConsolePrivate, firstArg: unknown, ...: any)
	self:_log("info", format(firstArg, ...))
end

function CustomConsole.log(self: CustomConsolePrivate, firstArg: unknown, ...: any)
	self:_log("log", format(firstArg, ...))
end

function CustomConsole.time(self: CustomConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	if self._timers[label] ~= nil then
		return
	end
	self._timers[label] = DateTime.now()
end

function CustomConsole.timeEnd(self: CustomConsolePrivate, label_: string?)
	local label: string = if label_ ~= nil then label_ else "default"
	local startTime = self._timers[label]
	if Boolean.toJSBoolean(startTime) then
		local endTime = DateTime.now()
		local time = endTime.UnixTimestampMillis - startTime.UnixTimestampMillis
		self:_log("time", format("%s: %s", label, formatTime(time)))
		self._timers[label] = nil
	end
end

function CustomConsole.timeLog(self: CustomConsolePrivate, label_: string?, ...: any)
	local label: string = if label_ ~= nil then label_ else "default"
	local startTime = self._timers[label]
	if Boolean.toJSBoolean(startTime) then
		local endTime = DateTime.now()
		local time = endTime.UnixTimestampMillis - startTime.UnixTimestampMillis
		self:_log("time", format("%s: %s", label, formatTime(time), ...))
	end
end

function CustomConsole.warn(self: CustomConsolePrivate, firstArg: unknown, ...: any)
	self:_logError("warn", format(firstArg, ...))
end

function CustomConsole:getBuffer()
	return nil
end

exports.default = CustomConsole
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="290">
              <Properties>
                <string name="Name">NullConsole</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-console/src/NullConsole.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local CurrentModule = script.Parent
local CustomConsole = require(CurrentModule.CustomConsole).default

export type NullConsole = {
	assert: (...any) -> (),
	debug: (...any) -> (),
	dir: (...any) -> (),
	error: (...any) -> (),
	info: (...any) -> (),
	log: (...any) -> (),
	time: (...any) -> (),
	timeEnd: (...any) -> (),
	timeLog: (...any) -> (),
	trace: () -> ...any,
	warn: (...any) -> (),
	group: (...any) -> (),
	groupCollapsed: (...any) -> (),
	groupEnd: (...any) -> (),
}

local NullConsole = setmetatable({}, { __index = CustomConsole })
NullConsole.__index = NullConsole

function NullConsole.new(...)
	local self = setmetatable(CustomConsole.new(...), NullConsole)
	return self
end

function NullConsole:assert() end
function NullConsole:debug() end
function NullConsole:dir() end
function NullConsole:error() end
function NullConsole:info() end
function NullConsole:log() end
function NullConsole:time() end
function NullConsole:timeEnd() end
function NullConsole:timeLog() end
function NullConsole:trace() end
function NullConsole:warn() end
function NullConsole:group() end
function NullConsole:groupCollapsed() end
function NullConsole:groupEnd() end

exports.default = NullConsole
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="291">
              <Properties>
                <string name="Name">getConsoleOutput</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-console/src/getConsoleOutput.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local String = LuauPolyfill.String
type Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>

local chalk = require(Packages.ChalkLua)

local jestTypesModule = require(Packages.JestTypes)
type GlobalConfig = jestTypesModule.Config_GlobalConfig

local messageUtilsModule = require(Packages.JestMessageUtil)
local formatStackTrace = messageUtilsModule.formatStackTrace
type StackTraceConfig = messageUtilsModule.StackTraceConfig
type StackTraceOptions = messageUtilsModule.StackTraceOptions

local typesModule = require(CurrentModule.types)
type ConsoleBuffer = typesModule.ConsoleBuffer

local getConsoleOutput = function(buffer: ConsoleBuffer, config: StackTraceConfig, globalConfig: GlobalConfig): string
	local TITLE_INDENT = if globalConfig.verbose then "  " else "    "
	local CONSOLE_INDENT = TITLE_INDENT .. "  "

	local logEntries: string = Array.reduce(buffer, function(output: string, ref)
		local type_, message, origin = ref.type, ref.message, ref.origin

		message = Array.join(
			Array.map(String.split(message, "\n"), function(line)
				return CONSOLE_INDENT .. line
			end),
			"\n"
		)

		local typeMessage = "console." .. type_
		local noStackTrace = true
		local noCodeFrame = true

		if type_ == "warn" then
			message = chalk.yellow(message)
			typeMessage = chalk.yellow(typeMessage)
			noStackTrace = globalConfig.noStackTrace or false
			noCodeFrame = false
		elseif type_ == "error" then
			message = chalk.red(message)
			typeMessage = chalk.red(typeMessage)
			noStackTrace = globalConfig.noStackTrace or false
			noCodeFrame = false
		end

		local options = {
			noStackTrace = noStackTrace,
			noCodeFrame = noCodeFrame,
		}

		local formattedStackTrace = formatStackTrace(origin, config, options)
		return output
			.. TITLE_INDENT
			.. chalk.dim(typeMessage)
			.. "\n"
			.. String.trimEnd(message)
			.. "\n"
			.. chalk.dim(String.trimEnd(formattedStackTrace))
			.. "\n\n"
	end, "")

	return String.trimEnd(logEntries) .. "\n"
end

exports.default = getConsoleOutput
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="292">
              <Properties>
                <string name="Name">helpers</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE upstream: Added some utilities to support keeping the upstream code consistent

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect
type Array<T> = LuauPolyfill.Array<T>

local typesModule = require(CurrentModule.types)
type InspectOptions = typesModule.InspectOptions

function concatRestArgs(restArgs: Array<unknown>)
	local restStr = ""
	if #restArgs > 0 then
		restStr = " " .. table.concat(restArgs, " ")
	end
	return restStr
end

function getFormattedValue(value: unknown, inspectOptions: InspectOptions?)
	return if type(value) == "string" then value else inspect(value, inspectOptions)
end

function format(...)
	return formatter(nil, ...)
end

function formatWithOptions(inspectOptions: InspectOptions, fmt: unknown, ...)
	return formatter(inspectOptions, fmt, ...)
end

function formatter(inspectOptions: InspectOptions?, fmt: unknown, ...)
	local args = { ... }

	local fmtArgs = {}
	local extraArgs = {}

	local fmt_: string = ""

	if type(fmt) == "string" then
		local _, c = fmt:gsub("%%[sdj%%]", "")

		for key, value in pairs(args) do
			local formattedValue = getFormattedValue(value, inspectOptions)
			if key <= c then
				table.insert(fmtArgs, formattedValue)
			else
				table.insert(extraArgs, formattedValue)
			end
		end
		fmt_ = fmt
	else
		fmt_ = inspect(fmt, inspectOptions)
		for _, value in pairs(args) do
			table.insert(extraArgs, getFormattedValue(value, inspectOptions))
		end
	end

	return string.format(fmt_, table.unpack(fmtArgs)) .. concatRestArgs(extraArgs)
end

return {
	format = format,
	formatWithOptions = formatWithOptions,
	concatRestArgs = concatRestArgs,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="293">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-console/src/types.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

export type LogMessage = string

export type LogEntry = { message: LogMessage, origin: string, type: LogType }

export type LogCounters = { [string]: number }

export type LogTimers = { [string]: DateTime }

export type LogType =
	"assert"
	| "count"
	| "debug"
	| "dir"
	| "dirxml"
	| "error"
	| "group"
	| "groupCollapsed"
	| "info"
	| "log"
	| "time"
	| "warn"

export type ConsoleBuffer = Array<LogEntry>

-- ROBLOX deviation START: add type for supproted inspect options
export type InspectOptions = {
	depth: number?,
}
-- Roblox deviation END

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="294">
            <Properties>
              <string name="Name">JestCore</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/jest.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

exports.SearchSource = require(script.SearchSource).default
exports.createTestScheduler = require(script.TestScheduler).createTestScheduler
exports.TestWatcher = require(script.TestWatcher).default
exports.runCLI = require(script.cli).runCLI
-- ROBLOX deviation START: not needed
-- exports.getVersion = require(script.version).default
-- ROBLOX deviation END
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="295">
              <Properties>
                <string name="Name">ReporterDispatcher</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/ReporterDispatcher.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local instanceof = LuauPolyfill.instanceof
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>
type Set<T> = LuauPolyfill.Set<T>
local Promise = require(Packages.Promise)
type Function = (...any) -> ...any

local exports = {}

--[[ eslint-disable local/ban-types-eventually ]]

local reportersModule = require(Packages.JestReporters)
type Reporter = reportersModule.Reporter
type ReporterOnStartOptions = reportersModule.ReporterOnStartOptions
local test_resultModule = require(Packages.JestTestResult)
type AggregatedResult = test_resultModule.AggregatedResult
type Test = test_resultModule.Test
type TestCaseResult = test_resultModule.TestCaseResult
type TestContext = test_resultModule.TestContext
type TestResult = test_resultModule.TestResult

-- ROBLOX deviation START: add additional imports and types
local types = require(script.Parent.types)
type ReporterConstructor = types.ReporterConstructor
-- ROBLOX deviation END

export type ReporterDispatcher = {
	register: (self: ReporterDispatcher, reporter: Reporter) -> (),
	unregister: (self: ReporterDispatcher, reporterConstructor: ReporterConstructor) -> (),
	onTestFileResult: (
		self: ReporterDispatcher,
		test: Test,
		testResult: TestResult,
		results: AggregatedResult
	) -> Promise<nil>,
	onTestFileStart: (self: ReporterDispatcher, test: Test) -> Promise<nil>,
	onRunStart: (
		self: ReporterDispatcher,
		results: AggregatedResult,
		options: ReporterOnStartOptions
	) -> Promise<nil>,
	onTestCaseResult: (self: ReporterDispatcher, test: Test, testCaseResult: TestCaseResult) -> Promise<nil>,
	onRunComplete: (
		self: ReporterDispatcher,
		testContexts: Set<TestContext>,
		results: AggregatedResult
	) -> Promise<nil>, -- Return a list of last errors for every reporter
	getErrors: (self: ReporterDispatcher) -> Array<Error>,
	hasErrors: (self: ReporterDispatcher) -> boolean,
}

type ReporterDispatcherPrivate = {
	_reporters: Array<Reporter>,

	register: (self: ReporterDispatcherPrivate, reporter: Reporter) -> (),
	unregister: (self: ReporterDispatcherPrivate, reporterConstructor: ReporterConstructor) -> (),
	onTestFileResult: (
		self: ReporterDispatcherPrivate,
		test: Test,
		testResult: TestResult,
		results: AggregatedResult
	) -> Promise<nil>,
	onTestFileStart: (self: ReporterDispatcherPrivate, test: Test) -> Promise<nil>,
	onRunStart: (
		self: ReporterDispatcherPrivate,
		results: AggregatedResult,
		options: ReporterOnStartOptions
	) -> Promise<nil>,
	onTestCaseResult: (self: ReporterDispatcherPrivate, test: Test, testCaseResult: TestCaseResult) -> Promise<nil>,
	onRunComplete: (
		self: ReporterDispatcherPrivate,
		testContexts: Set<TestContext>,
		results: AggregatedResult
	) -> Promise<nil>, -- Return a list of last errors for every reporter
	getErrors: (self: ReporterDispatcherPrivate) -> Array<Error>,
	hasErrors: (self: ReporterDispatcherPrivate) -> boolean,
}

type ReporterDispatcher_statics = {
	new: () -> ReporterDispatcher,
}

local ReporterDispatcher = {} :: ReporterDispatcherPrivate & ReporterDispatcher_statics;
(ReporterDispatcher :: any).__index = ReporterDispatcher

function ReporterDispatcher.new(): ReporterDispatcher
	local self = setmetatable({}, ReporterDispatcher)
	self._reporters = {}
	return (self :: any) :: ReporterDispatcher
end

function ReporterDispatcher:register(reporter: Reporter): ()
	table.insert(self._reporters, reporter)
end

function ReporterDispatcher:unregister(reporterConstructor: ReporterConstructor): ()
	self._reporters = Array.filter(self._reporters, function(reporter)
		return not instanceof(reporter, reporterConstructor)
	end)
end

function ReporterDispatcher:onTestFileResult(
	test: Test,
	testResult: TestResult,
	results: AggregatedResult
): Promise<nil>
	return Promise.resolve():andThen(function()
		for _, reporter in self._reporters do
			if reporter.onTestFileResult ~= nil then
				Promise.resolve(reporter.onTestFileResult(reporter, test, testResult, results)):expect()
			elseif reporter.onTestResult ~= nil then
				Promise.resolve(reporter.onTestResult(reporter, test, testResult, results)):expect()
			end
		end

		-- Release memory if unused later.
		testResult.coverage = nil
		testResult.console = nil
	end)
end

function ReporterDispatcher:onTestFileStart(test: Test): Promise<nil>
	return Promise.resolve():andThen(function()
		for _, reporter in self._reporters do
			if reporter.onTestFileStart ~= nil then
				Promise.resolve(reporter.onTestFileStart(reporter, test)):expect()
			elseif reporter.onTestStart ~= nil then
				Promise.resolve(reporter.onTestStart(reporter, test)):expect()
			end
		end
	end)
end

function ReporterDispatcher:onRunStart(results: AggregatedResult, options: ReporterOnStartOptions): Promise<nil>
	return Promise.resolve():andThen(function()
		for _, reporter in self._reporters do
			if reporter.onRunStart ~= nil then
				Promise.resolve(reporter:onRunStart(results, options)):expect()
			end
		end
	end)
end

function ReporterDispatcher:onTestCaseResult(test: Test, testCaseResult: TestCaseResult): Promise<nil>
	return Promise.resolve():andThen(function()
		for _, reporter in self._reporters do
			if reporter.onTestCaseResult ~= nil then
				Promise.resolve(reporter.onTestCaseResult(reporter, test, testCaseResult)):expect()
			end
		end
	end)
end

function ReporterDispatcher:onRunComplete(testContexts: Set<TestContext>, results: AggregatedResult): Promise<nil>
	return Promise.resolve():andThen(function()
		for _, reporter in self._reporters do
			if reporter.onRunComplete ~= nil then
				Promise.resolve(reporter:onRunComplete(testContexts, results)):expect()
			end
		end
	end)
end

function ReporterDispatcher:getErrors(): Array<Error>
	local errors = {}
	for _, reporter in self._reporters do
		local error_ = if reporter.getLastError ~= nil then reporter:getLastError() else nil
		if error_ ~= nil then
			table.insert(errors, error_)
		end
	end
	return Array.from(errors) :: Array<Error>
end

function ReporterDispatcher:hasErrors(): boolean
	return #self:getErrors() ~= 0
end

exports.default = ReporterDispatcher :: ReporterDispatcher & ReporterDispatcher_statics

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="296">
              <Properties>
                <string name="Name">SearchSource</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/SearchSource.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation START: not needed
-- local Error = LuauPolyfill.Error
-- local Object = LuauPolyfill.Object
-- local Set = LuauPolyfill.Set
-- ROBLOX deviation END
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
type Set<T> = LuauPolyfill.Set<T>
local Promise = require(Packages.Promise)
local RegExp = require(Packages.RegExp)

local exports = {}

-- ROBLOX deviation START: not needed
-- local os_ = require(Packages.os)
-- local path = require(Packages.path)
-- local micromatch = require(Packages.micromatch)
-- ROBLOX deviation END
local test_resultModule = require(Packages.JestTestResult)
type Test = test_resultModule.Test
local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
-- ROBLOX deviation START: not needed
-- local jest_changed_filesModule = require(Packages["jest-changed-files"])
-- type ChangedFiles = jest_changed_filesModule.ChangedFiles
type ChangedFiles = nil
-- local replaceRootDirInPath = require(Packages["jest-config"]).replaceRootDirInPath
-- local escapePathForRegex = require(Packages["jest-regex-util"]).escapePathForRegex
-- local DependencyResolver = require(Packages["jest-resolve-dependencies"]).DependencyResolver
-- ROBLOX deviation END
local jest_runtimeModule = require(Packages.JestRuntime)
type Context = jest_runtimeModule.Context
-- ROBLOX deviation START: not needed
-- local buildSnapshotResolver = require(Packages.JestSnapshot).buildSnapshotResolver
-- ROBLOX deviation END
local jest_utilModule = require(Packages.JestUtil)
local globsToMatcher = jest_utilModule.globsToMatcher
local testPathPatternToRegExp = jest_utilModule.testPathPatternToRegExp
local typesModule = require(script.Parent.types)
type Filter = typesModule.Filter
type Stats = typesModule.Stats
type TestPathCases = typesModule.TestPathCases

local globalTypesModule = require(Packages.JestTypes)
type Config_Path = globalTypesModule.Config_Path

-- ROBLOX deviation START: custom implementation for getting all files
type FileInfo = { path: Config_Path, script: ModuleScript }

local getRelativePath = require(Packages.RobloxShared).getRelativePath

-- ROBLOX deviation START: additional function to construct file path from ModuleScript
local getDataModelService = require(Packages.RobloxShared).getDataModelService
local CoreScriptSyncService = getDataModelService("CoreScriptSyncService")
-- ROBLOX deviation END

local function getAllFiles(context: Context): Array<FileInfo>
	local descendants = context.config.rootDir:GetDescendants()
	return Array.map(
		Array.filter(descendants, function(descendant)
			return descendant:isA("ModuleScript")
		end),
		function(script_: ModuleScript)
			-- ROBLOX deviation: resolve to a FS path if CoreScriptSyncService is available
			local path_ = nil
			if CoreScriptSyncService then
				path_ = CoreScriptSyncService:GetScriptFilePath(script_)
			else
				path_ = getRelativePath(script_, context.config.rootDir)
			end
			-- ROBLOX deviation END
			return {
				path = path_,
				script = script_,
			}
		end
	)
end
-- ROBLOX deviation END

export type SearchResult = {
	-- ROBLOX deviation START: not supported
	-- noSCM: boolean?,
	stats: Stats?,
	-- collectCoverageFrom: Set<string>?,
	-- ROBLOX deviation END
	tests: Array<Test>,
	total: number?,
}

export type TestSelectionConfig = {
	input: string?,
	findRelatedTests: boolean?,
	onlyChanged: boolean?,
	paths: Array<Config_Path>?,
	shouldTreatInputAsPattern: boolean?,
	testPathPattern: string?,
	watch: boolean?,
}

local function regexToMatcher(testRegex: typeof((({} :: any) :: Config_ProjectConfig).testRegex))
	local regexes = Array.map(testRegex, function(testRegex)
		return RegExp(testRegex)
	end)
	return function(path: Config_Path)
		return Array.some(regexes, function(regex)
			local result = regex:test(path)

			-- prevent stateful regexes from breaking, just in case
			regex.lastIndex = 0

			return result
		end)
	end
end

local function toTests(
	context: Context,
	-- ROBLOX deviation START: custom FileInfo type instead of Config_Path
	tests: Array<FileInfo>
	-- ROBLOX deviation END
): Array<Test>
	return Array.map(tests, function(test)
		return {
			context = context,
			duration = nil,
			path = test.path,
			script = test.script,
		}
	end)
end

-- ROBLOX deviation START: not ported
-- local function hasSCM(changedFilesInfo: ChangedFiles)
-- 	local repos = changedFilesInfo.repos
-- 	-- no SCM (git/hg/...) is found in any of the roots.
-- 	local noSCM = Array.every(Object.values(repos), function(scm)
-- 		return scm.size == 0
-- 	end)
-- 	return not Boolean.toJSBoolean(noSCM)
-- end
-- ROBLOX deviation END

export type SearchSource = {
	isTestFilePath: (self: SearchSource, path: Config_Path) -> boolean,
	findMatchingTests: (self: SearchSource, testPathPattern: string?) -> SearchResult,
	-- ROBLOX deviation START: not ported
	-- findRelatedTests: (
	-- 	self: SearchSource,
	-- 	allPaths: Set<Config_Path>,
	-- 	collectCoverage: boolean
	-- ) -> Promise<SearchResult>,
	-- findTestsByPaths: (self: SearchSource, paths: Array<Config_Path>) -> SearchResult,
	-- findRelatedTestsFromPattern: (
	-- 	self: SearchSource,
	-- 	paths: Array<Config_Path>,
	-- 	collectCoverage: boolean
	-- ) -> Promise<SearchResult>,
	-- findTestRelatedToChangedFiles: (
	-- 	self: SearchSource,
	-- 	changedFilesInfo: ChangedFiles,
	-- 	collectCoverage: boolean
	-- ) -> Promise<SearchResult>,
	-- filterPathsWin32: (self: SearchSource, paths: Array<string>) -> Array<string>,
	-- ROBLOX deviation END
	getTestPaths: (
		self: SearchSource,
		globalConfig: Config_GlobalConfig,
		changedFiles: ChangedFiles?,
		filter: Filter?
	) -> Promise<SearchResult>,
	-- ROBLOX deviation START: not ported
	-- findRelatedSourcesFromTestsInChangedFiles: (
	-- 	self: SearchSource,
	-- 	changedFilesInfo: ChangedFiles
	-- ) -> Promise<Array<string>>,
	-- ROBLOX deviation END
}

type SearchSourcePrivate = {
	_context: Context,
	-- ROBLOX deviation START: not ported
	--  _dependencyResolver: DependencyResolver | nil;
	-- ROBLOX deviation END
	_testPathCases: TestPathCases,
	-- ROBLOX deviation START: not ported
	-- _getOrBuildDependencyResolver: (self: SearchSourcePrivate) -> Promise<DependencyResolver>,
	-- ROBLOX deviation END
	_filterTestPathsWithStats: (
		self: SearchSourcePrivate,
		allPaths: Array<Test>,
		testPathPattern: string
	) -> SearchResult,
	_getAllTestPaths: (self: SearchSourcePrivate, testPathPattern: string) -> SearchResult,
	_getTestPaths: (
		self: SearchSourcePrivate,
		globalConfig: Config_GlobalConfig,
		_changedFiles: ChangedFiles?
	) -> Promise<SearchResult>,

	isTestFilePath: (self: SearchSourcePrivate, path: Config_Path) -> boolean,
	findMatchingTests: (self: SearchSourcePrivate, testPathPattern: string?) -> SearchResult,
	-- ROBLOX deviation START: not ported
	-- findRelatedTests: (
	-- 	self: SearchSourcePrivate,
	-- 	allPaths: Set<Config_Path>,
	-- 	collectCoverage: boolean
	-- ) -> Promise<SearchResult>,
	-- findTestsByPaths: (self: SearchSourcePrivate, paths: Array<Config_Path>) -> SearchResult,
	-- findRelatedTestsFromPattern: (
	-- 	self: SearchSourcePrivate,
	-- 	paths: Array<Config_Path>,
	-- 	collectCoverage: boolean
	-- ) -> Promise<SearchResult>,
	-- findTestRelatedToChangedFiles: (
	-- 	self: SearchSourcePrivate,
	-- 	changedFilesInfo: ChangedFiles,
	-- 	collectCoverage: boolean
	-- ) -> Promise<SearchResult>,
	-- filterPathsWin32: (self: SearchSourcePrivate, paths: Array<string>) -> Array<string>,
	-- ROBLOX deviation END
	getTestPaths: (
		self: SearchSourcePrivate,
		globalConfig: Config_GlobalConfig,
		changedFiles: ChangedFiles | nil,
		filter: Filter?
	) -> Promise<SearchResult>,
	-- ROBLOX deviation START: not ported
	-- findRelatedSourcesFromTestsInChangedFiles: (
	-- 	self: SearchSourcePrivate,
	-- 	changedFilesInfo: ChangedFiles
	-- ) -> Promise<Array<string>>,
	-- ROBLOX deviation END
}

type SearchSource_statics = {
	new: (context: Context) -> SearchSource,
}

local SearchSource = {} :: SearchSourcePrivate & SearchSource_statics;
(SearchSource :: any).__index = SearchSource

function SearchSource.new(context: Context): SearchSource
	local self = setmetatable({}, SearchSource)
	self._testPathCases = {}
	local config = context.config
	self._context = context
	self._dependencyResolver = nil

	-- ROBLOX deviation START: not needed
	-- local rootPattern = RegExp(Array.join(
	-- 	Array.map(config.roots, function(dir)
	-- 		return escapePathForRegex(dir .. path.sep)
	-- 	end),
	-- 	"|"
	-- ))
	-- table.insert(self._testPathCases, {
	-- 	isMatch = function(path)
	-- 		return rootPattern:test(path)
	-- 	end,
	-- 	stat = "roots",
	-- })
	-- ROBLOX deviation END

	if #config.testMatch > 0 then
		-- TODO LDP-145: remove optional file extension
		for i, path in config.testMatch do
			config.testMatch[i] = path .. "?(.lua|.luau)"
		end
		table.insert(self._testPathCases, { isMatch = globsToMatcher(config.testMatch), stat = "testMatch" })
	end

	if #config.testPathIgnorePatterns > 0 then
		table.insert(self._testPathCases, {
			isMatch = function(path)
				for _, p in config.testPathIgnorePatterns do
					if RegExp(p):test(path) then
						return false
					end
				end
				return true
			end,
			stat = "testPathIgnorePatterns",
		})
	end

	if #config.testRegex > 0 then
		table.insert(self._testPathCases, { isMatch = regexToMatcher(config.testRegex), stat = "testRegex" })
	end

	return (self :: any) :: SearchSource
end

-- ROBLOX deviation START: not ported
-- function SearchSource:_getOrBuildDependencyResolver(): Promise<DependencyResolver>
-- 	return Promise.resolve():andThen(function()
-- 		if not self._dependencyResolver then
-- 			self._dependencyResolver = DependencyResolver.new(
-- 				self._context.resolver,
-- 				self._context.hasteFS,
-- 				buildSnapshotResolver(self._context.config):expect()
-- 			)
-- 		end
-- 		return self._dependencyResolver
-- 	end)
-- end
-- ROBLOX deviation END

function SearchSource:_filterTestPathsWithStats(allPaths: Array<Test>, testPathPattern: string?): SearchResult
	local data: { stats: Stats, tests: Array<Test>, total: number } = {
		stats = { roots = 0, testMatch = 0, testPathIgnorePatterns = 0, testRegex = 0 },
		tests = {},
		total = #allPaths,
	}

	-- ROBLOX FIXME Luau: should be inferred from passed param
	local testCases = Array.from(self._testPathCases) :: typeof(self._testPathCases) -- clone
	if testPathPattern ~= nil and Boolean.toJSBoolean(testPathPattern) then
		local regex = testPathPatternToRegExp(testPathPattern)
		table.insert(testCases, {
			isMatch = function(path: string)
				return regex:test(path)
			end,
			stat = "testPathPattern",
		})
		data.stats.testPathPattern = 0
	end

	data.tests = Array.filter(allPaths, function(test)
		local filterResult = true
		for _, ref in testCases do
			local isMatch, stat = ref.isMatch, ref.stat
			if isMatch(test.path) then
				-- ROBLOX deviation START: make sure data.stats[stat] is not `nil` before adding 1
				data.stats[stat] = data.stats[stat] or 0
				-- ROBLOX deviation END
				-- ROBLOX FIXME Luau: stat is typed as a union of Stat type keys so this should be infered as number?
				(data.stats :: { [string]: number })[stat] += 1
			else
				filterResult = false
			end
		end
		return filterResult
	end)

	return data
end

function SearchSource:_getAllTestPaths(testPathPattern: string?): SearchResult
	return self:_filterTestPathsWithStats(
		toTests(
			self._context,
			-- ROBLOX deviation START: custom logic for getting all files
			getAllFiles(self._context)
			-- ROBLOX devation END
		),
		-- ROBLOX deviation START: workaround 'string?' param type being mistaken for 'string'
		-- testPathPattern
		testPathPattern :: string
		-- ROBLOX devation END
	)
end

function SearchSource:isTestFilePath(path: Config_Path): boolean
	return Array.every(self._testPathCases, function(testCase)
		return testCase.isMatch(path)
	end)
end

-- ROBLOX deviation START: workaround 'string?' param type being mistaken for 'string'
-- function SearchSource_private:findMatchingTests(testPathPattern: string): SearchResult
-- 	return self:_getAllTestPaths(testPathPattern)
function SearchSource:findMatchingTests(testPathPattern: string?): SearchResult
	return self:_getAllTestPaths(testPathPattern :: string)
	-- ROBLOX deviation END
end

-- ROBLOX deviation START: not ported
-- function SearchSource:findRelatedTests(allPaths: Set<Config_Path>, collectCoverage: boolean): Promise<SearchResult>
-- 	return Promise.resolve():andThen(function()
-- 		local dependencyResolver = self:_getOrBuildDependencyResolver():expect()

-- 		if not collectCoverage then
-- 			return {
-- 				tests = toTests(
-- 					self._context,
-- 					dependencyResolver:resolveInverse(
-- 						allPaths,
-- 						self.isTestFilePath:bind(self),
-- 						{ skipNodeResolution = self._context.config.skipNodeResolution }
-- 					)
-- 				),
-- 			}
-- 		end

-- 		local testModulesMap = dependencyResolver:resolveInverseModuleMap(
-- 			allPaths,
-- 			self.isTestFilePath:bind(self),
-- 			{ skipNodeResolution = self._context.config.skipNodeResolution }
-- 		)

-- 		local allPathsAbsolute = Array.map(Array.from(allPaths), function(p)
-- 			return path:resolve(p)
-- 		end)

-- 		local collectCoverageFrom = Set.new()

-- 		Array.forEach(testModulesMap, function(testModule)
-- 			if not Boolean.toJSBoolean(testModule.dependencies) then
-- 				return
-- 			end

-- 			Array.forEach(testModule.dependencies, function(p)
-- 				if not Array.includes(allPathsAbsolute, p) then
-- 					return
-- 				end

-- 				local filename = replaceRootDirInPath(self._context.config.rootDir, p)
-- 				collectCoverageFrom:add(
-- 					if Boolean.toJSBoolean(path:isAbsolute(filename))
-- 						then path:relative(self._context.config.rootDir, filename)
-- 						else filename
-- 				)
-- 			end)
-- 		end)

-- 		return {
-- 			collectCoverageFrom = collectCoverageFrom,
-- 			tests = toTests(
-- 				self._context,
-- 				Array.map(testModulesMap, function(testModule)
-- 					return testModule.file
-- 				end)
-- 			),
-- 		}
-- 	end)
-- end

-- function SearchSource:findTestsByPaths(paths: Array<Config_Path>): SearchResult
-- 	return {
-- 		tests = toTests(
-- 			self._context,
-- 			Array.filter(
-- 				Array.map(paths, function(p)
-- 					return path:resolve(self._context.config.cwd, p)
-- 				end),
-- 				function(_self, ...)
-- 					self:isTestFilePath(...)
-- 				end
-- 			)
-- 		),
-- 	}
-- end

-- function SearchSource:findRelatedTestsFromPattern(
-- 	paths: Array<Config_Path>,
-- 	collectCoverage: boolean
-- ): Promise<SearchResult>
-- 	return Promise.resolve():andThen(function()
-- 		if Array.isArray(paths) and #paths > 0 then
-- 			local resolvedPaths = Array.map(paths, function(p)
-- 				return path:resolve(self._context.config.cwd, p)
-- 			end)
-- 			return self:findRelatedTests(Set.new(resolvedPaths), collectCoverage)
-- 		end
-- 		return { tests = {} }
-- 	end)
-- end

-- function SearchSource:findTestRelatedToChangedFiles(
-- 	changedFilesInfo: ChangedFiles,
-- 	collectCoverage: boolean
-- ): Promise<SearchResult>
-- 	return Promise.resolve():andThen(function()
-- 		if not Boolean.toJSBoolean(hasSCM(changedFilesInfo)) then
-- 			return { noSCM = true, tests = {} }
-- 		end
-- 		local changedFiles = changedFilesInfo.changedFiles
-- 		return self:findRelatedTests(changedFiles, collectCoverage)
-- 	end)
-- end
-- ROBLOX deviation END

function SearchSource:_getTestPaths(
	globalConfig: Config_GlobalConfig,
	_changedFiles: ChangedFiles?
): Promise<SearchResult>
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: not supported yet
		-- if globalConfig.onlyChanged then
		-- 	if not changedFiles then
		-- 		error(Error.new("Changed files must be set when running with -o."))
		-- 	end

		-- 	return self:findTestRelatedToChangedFiles(changedFiles, globalConfig.collectCoverage)
		-- end

		-- local paths = globalConfig.nonFlagArgs

		-- if globalConfig.findRelatedTests and "win32" == os_:platform() then
		-- 	paths = self:filterPathsWin32(paths)
		-- end

		-- if globalConfig.runTestsByPath and paths and #paths > 0 then
		-- 	return self:findTestsByPaths(paths)
		-- elseif globalConfig.findRelatedTests and paths and #paths > 0 then
		-- 	return self:findRelatedTestsFromPattern(paths, globalConfig.collectCoverage)
		-- elseif globalConfig.testPathPattern ~= nil then
		-- ROBLOX deviation END
		if globalConfig.testPathPattern ~= nil then
			return self:findMatchingTests(globalConfig.testPathPattern)
		else
			return { tests = {} }
		end
	end)
end

-- ROBLOX deviation START: not ported
-- function SearchSource:filterPathsWin32(paths: Array<string>): Array<string>
-- 	local allFiles = self._context.hasteFS:getAllFiles()
-- 	local options = { nocase = true, windows = false }

-- 	local function normalizePosix(filePath: string)
-- 		return filePath:replace(
-- 			error("not implemented"), --[[ ROBLOX TODO: Unhandled node for type: RegExpLiteral ]] --[[ /\\/g ]]
-- 			"/"
-- 		)
-- 	end

-- 	paths = Array.map(
-- 		Array.filter(
-- 			Array.map(paths, function(p)
-- 				-- micromatch works with forward slashes: https://github.com/micromatch/micromatch#backslashes
-- 				local normalizedPath = normalizePosix(path:resolve(self._context.config.cwd, p))
-- 				local match = micromatch(Array.map(allFiles, normalizePosix), normalizedPath, options)
-- 				return match[1]
-- 			end),
-- 			Boolean.toJSBoolean
-- 		),
-- 		function(p)
-- 			return path:resolve(p)
-- 		end
-- 	)
-- 	return paths
-- end
-- ROBLOX deviation END

function SearchSource:getTestPaths(
	globalConfig: Config_GlobalConfig,
	changedFiles: ChangedFiles?,
	filter: Filter?
): Promise<SearchResult>
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: custom implementation
		local searchResult = self:_getTestPaths(globalConfig, changedFiles):expect()
		-- ROBLOX deviation END

		return searchResult
	end)
end

-- ROBLOX deviation START: not ported
-- function SearchSource:findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo: ChangedFiles): Promise<Array<string>>
-- 	return Promise.resolve():andThen(function()
-- 		if not hasSCM(changedFilesInfo) then
-- 			return {}
-- 		end
-- 		local changedFiles = changedFilesInfo.changedFiles
-- 		local dependencyResolver = self:_getOrBuildDependencyResolver():expect()
-- 		local relatedSourcesSet = Set.new()
-- 		Array.forEach(changedFiles, function(filePath)
-- 			if self:isTestFilePath(filePath) then
-- 				local sourcePaths = dependencyResolver:resolve(
-- 					filePath,
-- 					{ skipNodeResolution = self._context.config.skipNodeResolution }
-- 				)
-- 				Array.forEach(sourcePaths, function(sourcePath)
-- 					return relatedSourcesSet:add(sourcePath)
-- 				end)
-- 			end
-- 		end)
-- 		return Array.from(relatedSourcesSet)
-- 	end)
-- end
-- ROBLOX deviation END

exports.default = SearchSource :: SearchSource & SearchSource_statics

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="297">
              <Properties>
                <string name="Name">TestScheduler</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/TestScheduler.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set
local WeakMap = LuauPolyfill.WeakMap
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
type Set<T> = LuauPolyfill.Set<T>
local Promise = require(Packages.Promise)
type Function = (...any) -> ...any
type Record<K, T> = { [K]: T }

local exports = {}

--[[ eslint-disable local/ban-types-eventually ]]
local chalk = require(Packages.ChalkLua)
local exit = require(Packages.RobloxShared).nodeUtils.exit
local reportersModule = require(Packages.JestReporters)
-- ROBLOX deviation START: not needed
-- local CoverageReporter = reportersModule.CoverageReporter
-- ROBLOX deviation END
local DefaultReporter = reportersModule.DefaultReporter
type JestReporter = reportersModule.BaseReporter
type Reporter = reportersModule.Reporter
type ReporterContext = reportersModule.ReporterContext
local GitHubActionsReporter = reportersModule.GitHubActionsReporter
local SummaryReporter = reportersModule.SummaryReporter
local VerboseReporter = reportersModule.VerboseReporter
local test_resultModule = require(Packages.JestTestResult)
type AggregatedResult = test_resultModule.AggregatedResult
type SerializableError = test_resultModule.SerializableError
type Test = test_resultModule.Test
type TestContext = test_resultModule.TestContext
type TestResult = test_resultModule.TestResult
local addResult = test_resultModule.addResult
local buildFailureTestResult = test_resultModule.buildFailureTestResult
local makeEmptyAggregatedTestResult = test_resultModule.makeEmptyAggregatedTestResult
-- ROBLOX deviation START: not needed
-- local createScriptTransformer = require(Packages["@jest"].transform).createScriptTransformer
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_Path = typesModule.Config_Path
type Config_ReporterConfig = typesModule.Config_ReporterConfig
local formatExecError = require(Packages.JestMessageUtil).formatExecError
local jest_runnerModule = require(Packages.JestRunner)
type TestRunner = jest_runnerModule.TestRunner
type TestRunnerContext = jest_runnerModule.TestRunnerContext
-- ROBLOX deviation START: snapshot not used yet
-- local snapshot = require(Packages.JestSnapshot)
-- ROBLOX deviation END
local ReporterDispatcherModule = require(script.Parent.ReporterDispatcher)
local ReporterDispatcher = ReporterDispatcherModule.default
type ReporterDispatcher = ReporterDispatcherModule.ReporterDispatcher
local TestWatcherModule = require(script.Parent.TestWatcher)
type TestWatcher = TestWatcherModule.TestWatcher
local shouldRunInBand = require(script.Parent.testSchedulerHelper).shouldRunInBand

-- ROBLOX deviation START: add additional imports and types
local types = require(script.Parent.types)
type ReporterConstructor = types.ReporterConstructor
-- ROBLOX deviation END

-- ROBLOX deviation START: predefine variables
local TestScheduler: TestSchedulerPrivate & TestScheduler_statics
local invariant
local createAggregatedResults
local getEstimatedTime
-- ROBLOX deviation END

export type TestSchedulerOptions = { startRun: (globalConfig: Config_GlobalConfig) -> () }
export type TestSchedulerContext = ReporterContext | TestRunnerContext

local function createTestScheduler(
	globalConfig: Config_GlobalConfig,
	context: TestSchedulerContext
): Promise<TestScheduler>
	return Promise.resolve():andThen(function()
		local scheduler = TestScheduler.new(globalConfig, context)
		scheduler:_setupReporters():expect()
		return scheduler
	end)
end
exports.createTestScheduler = createTestScheduler

type TestScheduler = {
	addReporter: (self: TestScheduler, reporter: Reporter) -> (),
	removeReporter: (self: TestScheduler, reporterConstructor: ReporterConstructor) -> (),
	scheduleTests: (self: TestScheduler, tests: Array<Test>, watcher: TestWatcher) -> Promise<AggregatedResult>,
	_setupReporters: (self: TestScheduler) -> Promise<nil>,
}

type TestSchedulerPrivate = {
	addReporter: (self: TestSchedulerPrivate, reporter: Reporter) -> (),
	removeReporter: (self: TestSchedulerPrivate, reporterConstructor: ReporterConstructor) -> (),
	scheduleTests: (
		self: TestSchedulerPrivate,
		tests: Array<Test>,
		watcher: TestWatcher
	) -> Promise<AggregatedResult>,
	_setupReporters: (self: TestSchedulerPrivate) -> Promise<nil>,

	_context: TestSchedulerContext,
	_dispatcher: ReporterDispatcher,
	_globalConfig: Config_GlobalConfig,
	_partitionTests: (
		self: TestSchedulerPrivate,
		testRunners: Record<string, TestRunner>,
		tests: Array<Test>
	) -> Record<string, Array<Test>> | nil,
	_addCustomReporter: (self: TestSchedulerPrivate, reporter: ModuleScript, options: Record<string, any>) -> any,
	_bailIfNeeded: (
		self: TestSchedulerPrivate,
		testContexts: Set<TestContext>,
		aggregatedResults: AggregatedResult,
		watcher: TestWatcher
	) -> Promise<nil>,
}

type TestScheduler_statics = {
	new: (globalConfig: Config_GlobalConfig, context: TestSchedulerContext) -> TestScheduler,
}

TestScheduler = {} :: TestSchedulerPrivate & TestScheduler_statics;
(TestScheduler :: any).__index = TestScheduler

function TestScheduler.new(globalConfig: Config_GlobalConfig, context: TestSchedulerContext): TestScheduler
	local self = setmetatable({}, TestScheduler)
	self._context = context
	self._dispatcher = ReporterDispatcher.new()
	self._globalConfig = globalConfig
	return (self :: any) :: TestScheduler
end

function TestScheduler:addReporter(reporter: Reporter): ()
	self._dispatcher:register(reporter)
end

function TestScheduler:removeReporter(reporterConstructor: ReporterConstructor): ()
	self._dispatcher:unregister(reporterConstructor)
end

function TestScheduler:scheduleTests(tests: Array<Test>, watcher: TestWatcher): Promise<AggregatedResult>
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: predeclare functions
		local onResult
		local onFailure
		local updateSnapshotState
		-- ROBLOX deviation END

		local onTestFileStart = function(...)
			return self._dispatcher:onTestFileStart(...)
		end
		local timings: Array<number> = {}
		local testContexts = Set.new()
		Array.forEach(tests, function(test)
			testContexts:add(test.context)
			-- ROBLOX deviation START: can't compare nil to number
			local duration = test.duration or 0
			if duration > 0 then
				table.insert(timings, duration)
			end
			-- ROBLOX deviation END
		end)

		local aggregatedResults = createAggregatedResults(#tests)
		local estimatedTime = math.ceil(getEstimatedTime(timings, self._globalConfig.maxWorkers) / 1000)

		local runInBand = shouldRunInBand(tests, timings, self._globalConfig)

		function onResult(test: Test, testResult: TestResult): Promise<nil>
			return Promise.resolve():andThen(function()
				if watcher:isInterrupted() then
					return Promise.resolve()
				end

				if #testResult.testResults == 0 then
					local message = "Your test suite must contain at least one test."
					return onFailure(test, { message = message, stack = Error.new(message).stack })
				end -- Throws when the context is leaked after executing a test.
				if Boolean.toJSBoolean(testResult.leaks) then
					local message = ("%sYour test suite is leaking memory. Please ensure all references are cleaned.\n"):format(
						tostring(chalk.red:bold("EXPERIMENTAL FEATURE!\n"))
					) .. "\n" .. "There is a number of things that can leak memory:\n" .. "  - Async operations that have not finished (e.g. fs.readFile).\n" .. "  - Timers not properly mocked (e.g. setInterval, setTimeout).\n" .. "  - Keeping references to the global scope."
					return onFailure(test, { message = message, stack = Error.new(message).stack })
				end

				addResult(aggregatedResults, testResult)
				self._dispatcher:onTestFileResult(test, testResult, aggregatedResults):expect()
				return self:_bailIfNeeded(testContexts, aggregatedResults, watcher)
			end)
		end

		function onFailure(test: Test, error_: SerializableError): Promise<nil>
			return Promise.resolve():andThen(function()
				if watcher:isInterrupted() then
					return
				end
				local testResult = buildFailureTestResult(test.path, error_)
				testResult.failureMessage = formatExecError(
					testResult.testExecError,
					test.context.config,
					-- ROBLOX FIXME Luau: Config_GlobalConfig contains noStackTrace and noCodeFrame is optional in StackTraceOptions so it should be fine
					(self._globalConfig :: any) :: { noStackTrace: boolean, noCodeFrame: boolean? },
					test.path
				)
				addResult(aggregatedResults, testResult)
				self._dispatcher:onTestFileResult(test, testResult, aggregatedResults):expect()
			end)
		end

		function updateSnapshotState()
			return Promise.resolve():andThen(function()
				local contextsWithSnapshotResolvers = Promise.all(Array.map(Array.from(testContexts), function(context)
					return Promise.resolve():andThen(function()
						return {
							context,
							-- ROBLOX deviation START: no snapshot resolver implemented yet
							-- snapshot:buildSnapshotResolver(context.config):expect(),
							-- ROBLOX deviation END
						}
					end)
				end)):expect()

				Array.forEach(contextsWithSnapshotResolvers, function(_ref)
					-- ROBLOX deviation START: no snapshot resolver implemented yet
					-- local context, snapshotResolver = table.unpack(ref, 1, 2)
					local status = {
						filesRemoved = 0,
						filesRemovedList = {},
					}
					-- snapshot:cleanup(
					-- 	context.hasteFS,
					-- 	self._globalConfig.updateSnapshot,
					-- 	snapshotResolver,
					-- 	context.config.testPathIgnorePatterns
					-- )
					-- ROBLOX deviation END

					aggregatedResults.snapshot.filesRemoved += status.filesRemoved
					aggregatedResults.snapshot.filesRemovedList = Array.concat(
						if aggregatedResults.snapshot.filesRemovedList ~= nil
							then aggregatedResults.snapshot.filesRemovedList
							else {},
						status.filesRemovedList
					)
				end)
				local updateAll = self._globalConfig.updateSnapshot == "all"
				aggregatedResults.snapshot.didUpdate = updateAll
				aggregatedResults.snapshot.failure = not updateAll
					and (
						aggregatedResults.snapshot.unchecked > 0
						or aggregatedResults.snapshot.unmatched > 0
						or aggregatedResults.snapshot.filesRemoved > 0
					)
			end)
		end

		self._dispatcher
			:onRunStart(
				aggregatedResults,
				{ estimatedTime = estimatedTime, showStatus = not Boolean.toJSBoolean(runInBand) }
			)
			:expect()

		local testRunners: { [string]: TestRunner } = {}
		local contextsByTestRunner = WeakMap.new()
		Promise.all(Array.map(Array.from(testContexts), function(context)
			return Promise.resolve():andThen(function()
				local config = context.config
				if not Boolean.toJSBoolean(testRunners[config.runner]) then
					-- ROBLOX deviation START: use regular require to load TestRunner
					-- local transformer = createScriptTransformer(config):expect()
					-- local Runner: TestRunner = transformer:requireAndTranspileModule(config.runner):expect()
					local Runner: TestRunner = require(Packages.JestRunner).default
					-- ROBLOX deviation END
					local runner = Runner.new(self._globalConfig, {
						changedFiles = self._context.changedFiles,
						sourcesRelatedToTestsInChangedFiles = self._context.sourcesRelatedToTestsInChangedFiles,
					})
					testRunners[config.runner] = runner
					contextsByTestRunner:set(runner, context)
				end
			end)
		end)):expect()

		local testsByRunner = self:_partitionTests(testRunners, tests)

		if testsByRunner ~= nil then
			local ok, result = pcall(function()
				for _, runner in Object.keys(testRunners) do
					local testRunner = testRunners[runner]
					local context = contextsByTestRunner:get(testRunner)

					invariant(context)

					local tests = testsByRunner[runner]

					local testRunnerOptions = {
						serial = runInBand or Boolean.toJSBoolean(testRunner.isSerial),
					}

					--[[*
					 * Test runners with event emitters are still not supported
					 * for third party test runners.
					]]
					if testRunner.__PRIVATE_UNSTABLE_API_supportsEventEmitters__ then
						local unsubscribes = {
							testRunner:on("test-file-start", function(ref)
								local test = ref[1]
								return onTestFileStart(test)
							end),
							testRunner:on("test-file-success", function(ref)
								local test, testResult = table.unpack(ref, 1, 2)
								return onResult(test, testResult)
							end),
							testRunner:on("test-file-failure", function(ref)
								local test, error_ = table.unpack(ref, 1, 2)
								return onFailure(test, error_)
							end),
							testRunner:on("test-case-result", function(ref)
								local testPath, testCaseResult = table.unpack(ref, 1, 2)
								local test: Test = {
									context = context,
									path = testPath,
									script = nil :: any, -- TODO: remove when we clean up Test type
								}
								self._dispatcher:onTestCaseResult(test, testCaseResult)
							end),
						}

						testRunner
							:runTests(
								-- ROBLOX FIXME Luau: Type 'Array<Test>' from 'JestRoblox/_Workspace/JestCore/JestCore/TestScheduler' could not be converted into 'Array<Test>' from 'JestRoblox/_Workspace/JestRunner/JestRunner'
								tests :: Array<any>,
								watcher,
								nil,
								nil,
								nil,
								testRunnerOptions
							)
							:expect()

						Array.forEach(unsubscribes, function(sub)
							return sub()
						end)
					else
						testRunner
							:runTests(
								-- ROBLOX FIXME Luau: Type 'Array<Test>' from 'JestRoblox/_Workspace/JestCore/JestCore/TestScheduler' could not be converted into 'Array<Test>' from 'JestRoblox/_Workspace/JestRunner/JestRunner'
								tests :: Array<any>,
								watcher,
								onTestFileStart,
								-- ROBLOX FIXME Luau: Type '(Test, TestResult) -> Promise<nil>' could not be converted into '((Test, TestResult) -> Promise<nil>)?'
								onResult :: Function,
								-- ROBLOX FIXME Luau: Type '(Test, SerializableError) -> Promise<nil>' could not be converted into '((Test, SerializableError) -> Promise<nil>)?'
								onFailure :: Function,
								testRunnerOptions
							)
							:expect()
					end
					-- ROBLOX deviation START: add cache of loaded module functions to a test runner
					-- test runner should call clean up functions when it is done
					testRunner:cleanup()
					-- ROBLOX deviation END
				end
			end)

			if not ok then
				local error_ = result
				if not watcher:isInterrupted() then
					error(error_)
				end
			end
		end

		updateSnapshotState():expect()
		aggregatedResults.wasInterrupted = watcher:isInterrupted()
		self._dispatcher:onRunComplete(testContexts, aggregatedResults):expect()

		local anyTestFailures = not (
			aggregatedResults.numFailedTests == 0 and aggregatedResults.numRuntimeErrorTestSuites == 0
		)
		local anyReporterErrors = self._dispatcher:hasErrors()

		aggregatedResults.success = not (anyTestFailures or aggregatedResults.snapshot.failure or anyReporterErrors)

		return aggregatedResults
	end)
end

function TestScheduler:_partitionTests(
	testRunners: Record<string, TestRunner>,
	tests: Array<Test>
): Record<string, Array<Test>> | nil
	if #Object.keys(testRunners) > 1 then
		return Array.reduce(tests, function(testRuns, test)
			local runner = test.context.config.runner
			if not Boolean.toJSBoolean(testRuns[runner]) then
				testRuns[runner] = {}
			end
			table.insert(testRuns[runner], test)
			return testRuns
		end, {})
	elseif #tests > 0 and tests[1] ~= nil then
		-- If there is only one runner, don't partition the tests.
		return Object.assign({}, {
			[tests[1].context.config.runner] = tests,
		})
	else
		return nil
	end
end

function TestScheduler:_setupReporters()
	return Promise.resolve():andThen(function()
		local ref = self._globalConfig
		local coverage, notify, verbose = false, false, ref.verbose
		local reporters
		-- ROBLOX deviation: ReporterConfig is a named table since we can't type tuples
		if ref.reporters ~= nil then
			reporters = ref.reporters
		else
			reporters = { { reporter = "default", options = {} } }
		end
		local summary = false
		for _, val in reporters do
			local reporter = val
			local options = {}
			if typeof(val) == "table" then
				reporter = val.reporter
				options = val.options
			end

			if typeof(reporter) == "string" then
				if reporter == "default" then
					summary = true
					self:addReporter(
						if verbose
							then VerboseReporter.new(self._globalConfig)
							else DefaultReporter.new(self._globalConfig)
					)
				elseif reporter == "github-actions" then
					self:addReporter(GitHubActionsReporter.new(self._globalConfig))
				elseif reporter == "summary" then
					summary = true
				end
			elseif typeof(reporter) == "Instance" and reporter:IsA("ModuleScript") then
				self:_addCustomReporter(reporter, options):expect()
			end
		end

		if summary then
			self:addReporter(SummaryReporter.new(self._globalConfig))
		end
	end)
end

function TestScheduler:_addCustomReporter(reporter: ModuleScript, options: Record<string, any>)
	return Promise.resolve():andThen(function()
		local ok, result, hasReturned = xpcall(function()
			local reporterConstructor: ReporterConstructor = require(reporter) :: any
			self:addReporter(reporterConstructor.new(self._globalConfig, options, self._context :: ReporterContext))
		end, function(error_)
			error_.message = ('An error occurred while adding the reporter at path "%s".\n%s'):format(
				chalk.bold(reporter),
				error_.message
			)
			error(error_)
		end)
	end)
end

function TestScheduler:_bailIfNeeded(
	testContexts: Set<TestContext>,
	aggregatedResults: AggregatedResult,
	watcher: TestWatcher
): Promise<nil>
	return Promise.resolve():andThen(function()
		if self._globalConfig.bail ~= 0 and aggregatedResults.numFailedTests >= self._globalConfig.bail then
			if watcher:isWatchMode() then
				watcher:setState({ interrupted = true }):expect()
				return
			end

			local ok, result = pcall(function()
				self._dispatcher:onRunComplete(testContexts, aggregatedResults):expect()
			end)
			local exitCode = self._globalConfig.testFailureExitCode
			exit(exitCode)
			if not ok then
				error(result)
			end
		end
	end)
end

function invariant(
	condition: unknown,
	message: string?
): () --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ asserts condition ]]
	if not Boolean.toJSBoolean(condition) then
		error(Error.new(message))
	end
end

function createAggregatedResults(numTotalTestSuites: number)
	local result = makeEmptyAggregatedTestResult()
	result.numTotalTestSuites = numTotalTestSuites
	result.startTime = DateTime.now().UnixTimestampMillis
	result.success = false
	return result
end

function getEstimatedTime(timings: Array<number>, workers: number): number
	if #timings == 0 then
		return 0
	end
	local max = math.max(table.unpack(timings))
	return if #timings <= workers
		then max
		else math.max(Array.reduce(timings, function(
			-- ROBLOX FIXME Luau: should be inferred from reduce's initial value
			sum: number,
			time_
		)
			return sum + time_
		end) / workers, max)
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="298">
              <Properties>
                <string name="Name">TestWatcher</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/TestWatcher.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

local emitteryModule = require(Packages.Emittery)
local emittery = emitteryModule.default
type emittery<EventData> = emitteryModule.Emittery

type State = { interrupted: boolean }

export type TestWatcher = emittery<{ change: State }> & {
	state: State,
	setState: (self: TestWatcher, state: State) -> Promise<nil>,
	isInterrupted: (self: TestWatcher) -> boolean,
	isWatchMode: (self: TestWatcher) -> boolean,
	_isWatchMode: boolean,
}
local TestWatcher = setmetatable({}, { __index = emittery })
TestWatcher.__index = TestWatcher
function TestWatcher.new(ref: { isWatchMode: boolean }): TestWatcher
	local self = setmetatable(emittery.new(), TestWatcher) :: any
	local isWatchMode = ref.isWatchMode
	self.state = { interrupted = false }
	self._isWatchMode = isWatchMode
	return (self :: any) :: TestWatcher
end

function TestWatcher:setState(state: State): Promise<nil>
	return Promise.resolve():andThen(function()
		Object.assign(self.state, state)
		self:emit("change", self.state):expect()
	end)
end

function TestWatcher:isInterrupted(): boolean
	return self.state.interrupted
end

function TestWatcher:isWatchMode(): boolean
	return self._isWatchMode
end
exports.default = TestWatcher

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="299">
              <Properties>
                <string name="Name">cli</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/cli/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation START: not needed
-- local exit = require(Packages.exit)
-- local rimraf = require(Packages.rimraf)
-- local CustomConsole = require(Packages.JestConsole).CustomConsole
-- ROBLOX deviation END
local test_resultModule = require(Packages.JestTestResult)
type AggregatedResult = test_resultModule.AggregatedResult
type TestContext = test_resultModule.TestContext
local jestTypesModule = require(Packages.JestTypes)
type Config_Argv = jestTypesModule.Config_Argv
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
-- ROBLOX deviation START: not used
-- local jest_changed_filesModule = require(Packages["jest-changed-files"])
-- type ChangedFilesPromise = jest_changed_filesModule.ChangedFilesPromise
type ChangedFilesPromise = Promise<any>
local readConfigs = require(Packages.JestConfig).readConfigs
-- local jest_haste_mapModule = require(Packages["jest-haste-map"])
-- type HasteMap = jest_haste_mapModule.default
type HasteMap = any
-- ROBLOX deviation END
local Runtime = require(Packages.JestRuntime)
type Context = Runtime.Context
local jest_utilModule = require(Packages.JestUtil)
-- ROBLOX deviation START: not needed
-- local createDirectory = jest_utilModule.createDirectory
-- ROBLOX deviation END
local preRunMessage = jest_utilModule.preRunMessage
local TestWatcher = require(script.Parent.TestWatcher).default
local formatHandleErrors = require(script.Parent.collectHandles).formatHandleErrors
local getChangedFilesPromise = require(script.Parent.getChangedFilesPromise).default
local getProjectNamesMissingWarning = require(script.Parent.getProjectNamesMissingWarning).default
local getSelectProjectsMessage = require(script.Parent.getSelectProjectsMessage).default
local createContext = require(script.Parent.lib.createContext).default
-- ROBLOX deviation START: not needed
-- local handleDeprecationWarnings = require(script.Parent.lib.handleDeprecationWarnings).default
-- ROBLOX deviation END
local logDebugMessages = require(script.Parent.lib.logDebugMessages).default
local pluralize = require(script.Parent.pluralize).default
local runJest = require(script.Parent.runJest).default
local typesModule = require(script.Parent.types)
type Filter = typesModule.Filter
-- ROBLOX deviation START: not needed
-- local watch = require(script.Parent.watch).default
-- ROBLOX deviation END
local preRunMessagePrint = preRunMessage.print

type OnCompleteCallback = (results: AggregatedResult) -> ...nil

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
local process = nodeUtils.process
local exit = nodeUtils.exit
type NodeJS_WriteStream = RobloxShared.NodeJS_WriteStream
-- ROBLOX deviation END

-- ROBLOX deviation START: predefine functions
local _run10000
local runWithoutWatch
-- ROBLOX deviation END

local function runCLI(
	cwdInstance: Instance,
	argv: Config_Argv,
	-- ROBLOX deviation: using Instance instead of Config_Path
	projects: Array<Instance>
): Promise<{ results: AggregatedResult, globalConfig: Config_GlobalConfig }>
	return Promise.resolve():andThen(function()
		local results

		-- If we output a JSON object, we can't write anything to stdout, since: AggregatedResult | nil
		-- it'll break the JSON structure and it won't be valid.
		local outputStream = if Boolean.toJSBoolean(argv.json) or Boolean.toJSBoolean(argv.useStderr)
			then process.stderr
			else process.stdout

		local ref = readConfigs(cwdInstance, argv, projects):expect()
		local globalConfig, configs, hasDeprecationWarnings = ref.globalConfig, ref.configs, ref.hasDeprecationWarnings

		if argv.debug then
			logDebugMessages(globalConfig, configs, outputStream)
		end

		if argv.showConfig then
			logDebugMessages(globalConfig, configs, process.stdout)
			exit(0)
		end

		-- ROBLOX deviation START: no cache support
		-- if argv.clearCache then
		-- 	Array.forEach(configs, function(config)
		-- 		rimraf:sync(config.cacheDirectory)
		-- 		process.stdout:write(("Cleared %s\n"):format(tostring(config.cacheDirectory)))
		-- 	end)
		--
		-- 	exit(0)
		-- end
		-- ROBLOX deviation END

		local configsOfProjectsToRun = configs
		if Boolean.toJSBoolean(argv.selectProjects) then
			local namesMissingWarning = getProjectNamesMissingWarning(
				configs,
				{ ignoreProjects = argv.ignoreProjects, selectProjects = argv.selectProjects }
			)
			if Boolean.toJSBoolean(namesMissingWarning) and namesMissingWarning then
				outputStream:write(namesMissingWarning)
			end
			outputStream:write(
				getSelectProjectsMessage(
					configsOfProjectsToRun,
					{ ignoreProjects = argv.ignoreProjects, selectProjects = argv.selectProjects }
				)
			)
		end

		_run10000(globalConfig, configsOfProjectsToRun, hasDeprecationWarnings, outputStream, function(r)
			results = r
		end):expect()

		if argv.watch or argv.watchAll then
			-- If in watch mode, return the promise that will never resolve.
			-- If the watch mode is interrupted, watch should handle the process
			-- shutdown.
			return Promise.new(function() end)
		end

		if not Boolean.toJSBoolean(results) then
			error(Error.new("AggregatedResult must be present after test run is complete"))
		end

		local openHandles = results.openHandles

		if openHandles ~= nil and #openHandles > 0 then
			local formatted = formatHandleErrors(openHandles, configs[1])

			local openHandlesString = pluralize("open handle", #formatted, "s")

			local message = chalk.red(
				("\nJest has detected the following %s potentially keeping Jest from exiting:\n\n"):format(
					openHandlesString
				)
			) .. Array.join(formatted, "\n\n")

			console.error(message)
		end

		return { globalConfig = globalConfig, results = results }
	end)
end
exports.runCLI = runCLI

local function buildContextsAndHasteMaps(
	configs: Array<Config_ProjectConfig>,
	_globalConfig: Config_GlobalConfig,
	_outputStream: NodeJS_WriteStream
)
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: no haste maps support
		-- local hasteMapInstances = {}
		local contexts = Promise.all(Array.map(configs, function(config, index)
			return Promise.resolve():andThen(function()
				-- createDirectory(config.cacheDirectory)
				-- local hasteMapInstance = Runtime:createHasteMap(config, {
				-- 	console = CustomConsole.new(outputStream, outputStream),
				-- 	maxWorkers = math.max(1, math.floor(globalConfig.maxWorkers / #configs)),
				-- 	resetCache = not Boolean.toJSBoolean(config.cache),
				-- 	watch = Boolean.toJSBoolean(globalConfig.watch) and globalConfig.watch or globalConfig.watchAll,
				-- 	watchman = globalConfig.watchman,
				-- })
				-- hasteMapInstances[index] = hasteMapInstance
				return createContext(config, nil)
			end)
		end)):expect()
		return {
			contexts = contexts,
			-- hasteMapInstances = hasteMapInstances,
		}
		-- ROBLOX deviation END
	end)
end

function _run10000(
	globalConfig: Config_GlobalConfig,
	configs: Array<Config_ProjectConfig>,
	hasDeprecationWarnings: boolean,
	outputStream: NodeJS_WriteStream,
	onComplete: OnCompleteCallback
)
	return Promise.resolve():andThen(function()
		-- Queries to hg/git can take a while, so we need to start the process
		-- as soon as possible, so by the time we need the result it's already there.
		local changedFilesPromise = getChangedFilesPromise(globalConfig, configs)
		-- Filter may need to do an HTTP call or something similar to setup.
		-- We will wait on an async response from this before using the filter.
		local filter: Filter | nil
		if Boolean.toJSBoolean(globalConfig.filter) and not globalConfig.skipFilter then
			local rawFilter =
				-- ROBLOX deviation: need to cast as require doesn't allow to import unknown paths
				(require :: any)(globalConfig.filter)
			local filterSetupPromise: Promise<unknown | nil> | nil
			if Boolean.toJSBoolean(rawFilter.setup) then
				-- Wrap filter setup Promise to avoid "uncaught Promise" error.
				-- If an error is returned, we surface it in the return value.
				filterSetupPromise = (function()
					return Promise.resolve():andThen(function()
						local ok, result = pcall(function()
							rawFilter:setup():expect()
						end)
						if not ok then
							return result
						end
						return nil
					end)
				end)()
			end
			filter = function(testPaths: Array<string>)
				return Promise.resolve():andThen(function()
					if filterSetupPromise ~= nil then
						-- Expect an undefined return value unless there was an error.
						local err = filterSetupPromise:expect()
						if Boolean.toJSBoolean(err) then
							error(err)
						end
					end
					return rawFilter(testPaths)
				end)
			end
		end

		local ref = buildContextsAndHasteMaps(configs, globalConfig, outputStream):expect()
		-- ROBLOX deviation START: not supported: hasteMapInstances
		-- local contexts, hasteMapInstances = ref.contexts, ref.hasteMapInstances
		local contexts = ref.contexts

		-- if globalConfig.watch or globalConfig.watchAll then
		-- 	runWatch(contexts, configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter):expect()
		-- else
		runWithoutWatch(globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter):expect()
		-- end
		-- ROBLOX deviation END
	end)
end

-- ROBLOX deviation START: not supported
-- local function runWatch(
-- 	contexts: Array<Context>,
-- 	_configs: Array<Config_ProjectConfig>,
-- 	_hasDeprecationWarnings: boolean,
-- 	_globalConfig: Config_GlobalConfig,
-- 	_outputStream: NodeJS_WriteStream,
-- 	_hasteMapInstances: Array<HasteMap>,
-- 	_filter: Filter?
-- )
-- 	return Promise.resolve():andThen(function()
-- 		error("watch tests is not handled yet")
-- 		-- ROBLOX deviation START: no deprecation warning handling
-- 		-- if hasDeprecationWarnings then
-- 		-- 	local ok, result = pcall(function()
-- 		-- 		handleDeprecationWarnings(outputStream, process.stdin):expect()
-- 		-- 		return watch(globalConfig, contexts, outputStream, hasteMapInstances, nil, nil, filter), true
-- 		-- 	end)
-- 		-- 	if not ok then
-- 		-- 		exit(0)
-- 		-- 	end
-- 		-- 	return result
-- 		-- end
-- 		-- ROBLOX deviation END

-- 		-- return watch(globalConfig, contexts, outputStream, hasteMapInstances, nil, nil, filter)
-- 	end)
-- end
-- ROBLOX deviation END

function runWithoutWatch(
	globalConfig: Config_GlobalConfig,
	contexts: Array<TestContext>,
	outputStream: NodeJS_WriteStream,
	onComplete: OnCompleteCallback,
	changedFilesPromise: ChangedFilesPromise?,
	filter: Filter?
)
	return Promise.resolve():andThen(function()
		local function startRun(): Promise<nil>
			return Promise.resolve():andThen(function()
				if not globalConfig.listTests then
					preRunMessagePrint(outputStream)
				end
				return runJest({
					changedFilesPromise = changedFilesPromise,
					contexts = contexts,
					failedTestsCache = nil,
					filter = filter,
					globalConfig = globalConfig,
					onComplete = onComplete,
					outputStream = outputStream,
					startRun = startRun,
					testWatcher = TestWatcher.new({ isWatchMode = false }),
				})
			end)
		end
		return startRun()
	end)
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="300">
              <Properties>
                <string name="Name">collectHandles</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/collectHandles.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Set = LuauPolyfill.Set
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>

local exports = {}

--[[ eslint-disable local/ban-types-eventually ]]

-- ROBLOX deviation START: not needed
-- local asyncHooks = require(Packages.async_hooks)
-- local promisify = require(Packages.util).promisify
-- ROBLOX deviation END
local RobloxShared = require(Packages.RobloxShared)
local stripAnsi = RobloxShared.stripAnsi

local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig
local formatExecError = require(Packages.JestMessageUtil).formatExecError
-- ROBLOX deviation START: collectHandles not ported
-- local ErrorWithStack = require(Packages.JestUtil).ErrorWithStack
-- export type HandleCollectionResult = () -> Promise<Array<Error>>
-- local function stackIsFromUser(stack: string)
-- 	-- Either the test file, or something required by it
-- 	if String.includes(stack, "Runtime.requireModule") then
-- 		return true
-- 	end

-- 	-- jest-jasmine it or describe call
-- 	if String.includes(stack, "asyncJestTest") or String.includes(stack, "asyncJestLifecycle") then
-- 		return true
-- 	end

-- 	-- An async function call from within circus
-- 	if String.includes(stack, "callAsyncCircusFn") then
-- 		-- jest-circus it or describe call
-- 		return String.includes(stack, "_callCircusTest") or String.includes(stack, "_callCircusHook") --[[ ROBLOX CHECK: check if 'stack' is an Array ]]
-- 	end

-- 	return false
-- end

-- local function alwaysActive()
-- 	return true
-- end

-- -- @ts-expect-error: doesn't exist in v10 typings
-- local hasWeakRef = typeof(WeakRef) == "function"

-- local asyncSleep = promisify(setTimeout)

-- -- Inspired by https://github.com/mafintosh/why-is-node-running/blob/master/index.js
-- -- Extracted as we want to format the result ourselves
-- local function collectHandles(): HandleCollectionResult
-- 	local activeHandles = Map.new()
-- 	local hook = asyncHooks:createHook({
-- 		destroy = function(self, asyncId)
-- 			activeHandles:delete(asyncId)
-- 		end,
-- 		init = function(self, asyncId, type_, triggerAsyncId, resource: {} | NodeJS_Timeout)
-- 			-- Skip resources that should not generally prevent the process from
-- 			-- exiting, not last a meaningfully long time, or otherwise shouldn't be
-- 			-- tracked.
-- 			if
-- 				type_ == "PROMISE"
-- 				or type_ == "TIMERWRAP"
-- 				or type_ == "ELDHISTOGRAM"
-- 				or type_ == "PerformanceObserver"
-- 				or type_ == "RANDOMBYTESREQUEST"
-- 				or type_ == "DNSCHANNEL"
-- 				or type_ == "ZLIB"
-- 			then
-- 				return
-- 			end
-- 			local error_ = ErrorWithStack.new(type_, initHook, 100)
-- 			local fromUser = stackIsFromUser(Boolean.toJSBoolean(error_.stack) and error_.stack or "")

-- 			-- If the async resource was not directly created by user code, but was
-- 			-- triggered by another async resource from user code, track it and use
-- 			-- the original triggering resource's stack.
-- 			if not fromUser then
-- 				local triggeringHandle = activeHandles:get(triggerAsyncId)
-- 				if triggeringHandle ~= nil then
-- 					fromUser = true
-- 					error_.stack = triggeringHandle.error.stack
-- 				end
-- 			end
-- 			if fromUser then
-- 				local isActive: () -> boolean

-- 				if type_ == "Timeout" or type_ == "Immediate" then
-- 					-- Timer that supports hasRef (Node v11+)
-- 					if Array.indexOf(Object.keys(resource), "hasRef") ~= -1 then
-- 						if hasWeakRef then
-- 							-- @ts-expect-error: doesn't exist in v10 typings
-- 							local ref = WeakRef.new(resource)
-- 							isActive = function()
-- 								local ref_ = if typeof(ref:deref()) == "table" then ref:deref().hasRef else nil
-- 								local ref__ = if ref_ ~= nil then ref_() else nil
-- 								return if ref__ ~= nil then ref__ else false
-- 							end
-- 						else
-- 							-- @ts-expect-error: doesn't exist in v10 typings
-- 							isActive = resource.hasRef:bind(resource)
-- 						end
-- 					else
-- 						-- Timer that doesn't support hasRef
-- 						isActive = alwaysActive
-- 					end
-- 				else
-- 					-- Any other async resource
-- 					isActive = alwaysActive
-- 				end

-- 				activeHandles:set(asyncId, { error = error_, isActive = isActive })
-- 			end
-- 		end,
-- 	})

-- 	hook:enable()

-- 	return function()
-- 		return Promise.resolve():andThen(function()
-- 			-- Wait briefly for any async resources that have been queued for
-- 			-- destruction to actually be destroyed.
-- 			-- For example, Node.js TCP Servers are not destroyed until *after* their
-- 			-- `close` callback runs. If someone finishes a test from the `close`
-- 			-- callback, we will not yet have seen the resource be destroyed here.
-- 			asyncSleep(100):expect()

-- 			hook:disable()

-- 			-- Get errors for every async resource still referenced at this moment
-- 			local result = Array.map(
-- 				Array.filter(Array.from(activeHandles:values()), function(ref)
-- 					local isActive = ref.isActive
-- 					return isActive()
-- 				end),
-- 				function(ref)
-- 					local error_ = ref.error
-- 					return error_
-- 				end
-- 			)

-- 			activeHandles:clear()
-- 			return result
-- 		end)
-- 	end
-- end
-- exports.default = collectHandles
-- ROBLOX deviation END

local function formatHandleErrors(errors: Array<Error>, config: Config_ProjectConfig): Array<string>
	local stacks = Set.new()

	return Array.filter(
		Array.map(errors, function(err)
			return formatExecError(err, config, { noStackTrace = false }, nil, true)
		end),
		-- E.g. timeouts might give multiple traces to the same line of code
		-- This hairy filtering tries to remove entries with duplicate stack traces
		function(handle)
			local ansiFree: string = stripAnsi(handle)

			-- ROBLOX deviation START: rewritten logic to Lua's pattern matching
			local match = string.match(ansiFree, "%s+at(.*)")

			if match == nil then
				return true
			end

			local stack = String.trim(string.sub(ansiFree, string.find(ansiFree, match :: string) :: number))
			-- ROBLOX deviation END

			if stacks:has(stack) then
				return false
			end

			stacks:add(stack)

			return true
		end
	)
end
exports.formatHandleErrors = formatHandleErrors

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="301">
              <Properties>
                <string name="Name">getChangedFilesPromise</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getChangedFilesPromise.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>

local exports = {}

-- ROBLOX deviation START: skipped unnecessary imports
local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type ChangedFilesPromise = Promise<nil>
-- ROBLOX deviation END

-- ROBLOX deviation START: getChangedFilesPromise is unimplemented
-- local function getChangedFilesPromise(
-- 	globalConfig: Config_GlobalConfig,
-- 	configs: Array<Config_ProjectConfig>
-- ): ChangedFilesPromise | nil
-- 	if Boolean.toJSBoolean(globalConfig.onlyChanged) then
-- 		local allRootsForAllProjects = Array.reduce(configs, function(roots, config)
-- 			if Boolean.toJSBoolean(config.roots) then
-- 				table.insert(
-- 					roots,
-- 					error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: SpreadElement ]] --[[ ...config.roots ]]
-- 				) --[[ ROBLOX CHECK: check if 'roots' is an Array ]]
-- 			end
-- 			return roots
-- 		end, {}) --[[ ROBLOX CHECK: check if 'configs' is an Array ]]
-- 		return getChangedFilesForRoots(allRootsForAllProjects, {
-- 			changedSince = globalConfig.changedSince,
-- 			lastCommit = globalConfig.lastCommit,
-- 			withAncestor = globalConfig.changedFilesWithAncestor,
-- 		}):catch(function(e)
-- 			local message = Array.join(
-- 				Array.filter(
-- 					formatExecError(
-- 						e,
-- 						configs[
-- 							1 --[[ ROBLOX adaptation: added 1 to array index ]]
-- 						],
-- 						{ noStackTrace = true }
-- 					):split("\n"),
-- 					function(line)
-- 						return not Boolean.toJSBoolean(
-- 							Array.includes(line, "Command failed:") --[[ ROBLOX CHECK: check if 'line' is an Array ]]
-- 						)
-- 					end
-- 				), --[[ ROBLOX CHECK: check if 'formatExecError(e, configs[0], {
--         noStackTrace: true
--       }).split('\n')' is an Array ]]
-- 				"\n"
-- 			)
-- 			console.error(chalk.red(("\n\n%s"):format(tostring(message))))
-- 			process:exit(1)
-- 		end)
-- 	end
-- 	return nil
-- end
exports.default = function(
	_globalConfig: Config_GlobalConfig,
	_configs: Array<Config_ProjectConfig>
): ChangedFilesPromise | nil
	--[[
			ROBLOX deviation: skipped lines 17-41
			original code: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getChangedFilesPromise.ts#L17-L41
		]]
	return nil
end
-- ROBLOX deviation END

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="302">
              <Properties>
                <string name="Name">getConfigsOfProjectsToRun</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getConfigsOfProjectsToRun.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig
local getProjectDisplayName = require(script.Parent.getProjectDisplayName).default

-- ROBLOX deviation START: add hoisted function declarations
local createProjectFilter
-- ROBLOX deviation END

local function getConfigsOfProjectsToRun(
	projectConfigs: Array<Config_ProjectConfig>,
	opts: {
		ignoreProjects: Array<string> | nil,
		selectProjects: Array<string> | nil,
	}
): Array<Config_ProjectConfig>
	local projectFilter = createProjectFilter(opts)
	return Array.filter(projectConfigs, function(config)
		local name = getProjectDisplayName(config)
		return projectFilter(name)
	end)
end
exports.default = getConfigsOfProjectsToRun

-- ROBLOX deviation START: predeclared function
-- local function createProjectFilter(opts: {
function createProjectFilter(
	opts: {
		-- ROBLOX deviation END
		ignoreProjects: Array<string> | nil,
		selectProjects: Array<string> | nil,
	}
)
	-- ROBLOX deviation START: ensure arrays are not nil for 'includes'
	-- local selectProjects, ignoreProjects = opts.selectProjects, opts.ignoreProjects
	local selectProjects, ignoreProjects =
		if Array.isArray(opts.selectProjects) then opts.selectProjects :: Array<string> else {} :: Array<string>,
		if Array.isArray(opts.ignoreProjects) then opts.ignoreProjects :: Array<string> else {} :: Array<string>
	-- ROBLOX deviation END

	local function always()
		return true
	end

	-- ROBLOX deviation START: use length check instead of JSBoolean check for table
	-- local selected = if Boolean.toJSBoolean(selectProjects)
	local selected: (string?) -> boolean | string? = if #selectProjects > 0
		-- ROBLOX deviation END
		then function(name: string | nil)
			return if Boolean.toJSBoolean(name) then Array.includes(selectProjects, name) else name
		end
		else always

	-- ROBLOX deviation START: use length check instead of JSBoolean check for table
	-- local notIgnore = if Boolean.toJSBoolean(ignoreProjects)
	local notIgnore: (string?) -> boolean = if #ignoreProjects > 0
		-- ROBLOX deviation END
		then function(name: string | nil)
			return not Boolean.toJSBoolean(
				if Boolean.toJSBoolean(name) then Array.includes(ignoreProjects, name) else name
			)
		end
		else always

	-- ROBLOX deviation START: always return boolean
	-- local function test(name: string | nil)
	-- 	local ref = selected(name)
	-- 	return if Boolean.toJSBoolean(ref) then notIgnore(name) else ref
	-- end
	local function test(name: string | nil): boolean
		return Boolean.toJSBoolean(selected(name)) and Boolean.toJSBoolean(notIgnore(name))
	end
	-- ROBLOX deviation END

	return test
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="303">
              <Properties>
                <string name="Name">getNoTestFound</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getNoTestFound.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean

local exports = {}

local chalk = require(Packages.ChalkLua)
local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
local pluralize = require(script.Parent.pluralize).default
local typesModule = require(script.Parent.types)
type TestRunData = typesModule.TestRunData

local function getNoTestFound(
	testRunData: TestRunData,
	globalConfig: Config_GlobalConfig,
	willExitWith0: boolean
): string
	-- ROBLOX deviation START: add type annotation to 'number'
	-- local testFiles = Array.reduce(testRunData, function(current, testRun)
	local testFiles = Array.reduce(testRunData, function(
		current: number, -- ROBLOX FIXME Luau: should be inferred from reduce's initial value
		testRun
	)
		-- ROBLOX deviation END
		return current + (Boolean.toJSBoolean(testRun.matches.total) and testRun.matches.total or 0)
	end, 0)

	local dataMessage
	if Boolean.toJSBoolean(globalConfig.runTestsByPath) then
		dataMessage = ("Files: %s"):format(tostring(Array.join(
			Array.map(globalConfig.nonFlagArgs, function(p)
				return ('"%s"'):format(tostring(p))
			end),
			", "
		)))
	else
		dataMessage = ("Pattern: %s - 0 matches"):format(chalk.yellow(globalConfig.testPathPattern))
	end
	if Boolean.toJSBoolean(willExitWith0) then
		return ("%s\n"):format(chalk.bold("No tests found, exiting with code 0"))
			.. ("In %s"):format(chalk.bold(globalConfig.rootDir))
			.. "\n"
			.. ("  %s checked across %s. Run with `--verbose` for more details."):format(
				tostring(pluralize("file", testFiles, "s")),
				-- ROBLOX deviation START: fix length check
				-- tostring(pluralize("project", testRunData.length, "s"))
				tostring(pluralize("project", #testRunData, "s"))
				-- ROBLOX deviation END
			)
			.. ("\n%s"):format(tostring(dataMessage))
	end
	return ("%s\n"):format(chalk.bold("No tests found, exiting with code 1"))
		.. "Run with `--passWithNoTests` to exit with code 0"
		.. "\n"
		.. ("In %s"):format(chalk.bold(globalConfig.rootDir))
		.. "\n"
		.. ("  %s checked across %s. Run with `--verbose` for more details."):format(
			tostring(pluralize("file", testFiles, "s")),
			-- ROBLOX deviation START: fix length check
			-- tostring(pluralize("project", testRunData.length, "s"))
			tostring(pluralize("project", #testRunData, "s"))
			-- ROBLOX deviation END
		)
		.. ("\n%s"):format(tostring(dataMessage))
end
exports.default = getNoTestFound

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="304">
              <Properties>
                <string name="Name">getNoTestFoundPassWithNoTests</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getNoTestFoundPassWithNoTests.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent

local exports = {}

local chalk = require(Packages.ChalkLua)

local function getNoTestFoundPassWithNoTests(): string
	return chalk.bold("No tests found, exiting with code 0")
end
exports.default = getNoTestFoundPassWithNoTests

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="305">
              <Properties>
                <string name="Name">getNoTestFoundVerbose</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getNoTestFoundVerbose.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
type Record<K, T> = { [K]: T }

local exports = {}

local chalk = require(Packages.ChalkLua)
local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
local pluralize = require(script.Parent.pluralize).default
local typesModule = require(script.Parent.types)
type Stats = typesModule.Stats
type TestRunData = typesModule.TestRunData

local function getNoTestFoundVerbose(
	testRunData: TestRunData,
	globalConfig: Config_GlobalConfig,
	willExitWith0: boolean
): string
	local individualResults = Array.map(testRunData, function(testRun)
		local stats_ = testRun.matches.stats ~= nil and testRun.matches.stats or {} :: Stats
		local config = testRun.context.config
		local statsMessage = Array.join(
			Array.filter(
				Array.map(
					Object.keys(stats_) :: Array<any>, --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof Stats ]]
					function(key): string | nil
						if key == "roots" and #config.roots == 1 then
							return nil
						end
						local value = ((config :: any) :: Record<string, unknown>)[key]
						if Boolean.toJSBoolean(value) then
							local valueAsString = if Array.isArray(value)
								then Array.join(value :: Array<unknown>, ", ")
								else tostring(value)
							local matches =
								pluralize("match", Boolean.toJSBoolean(stats_[key]) and stats_[key] or 0, "es")
							return ("  %s: %s - %s"):format(key, chalk.yellow(valueAsString), tostring(matches))
						end
						return nil
					end
				),
				function(line)
					return Boolean.toJSBoolean(line)
				end
			),
			"\n"
		)
		return if Boolean.toJSBoolean(testRun.matches.total)
			then ("In %s\n"):format(chalk.bold(tostring(config.rootDir))) .. ("  %s checked.\n"):format(
				pluralize("file", Boolean.toJSBoolean(testRun.matches.total) and testRun.matches.total or 0, "s")
			) .. statsMessage
			else ("No files found in %s.\n"):format(tostring(config.rootDir))
				.. "Make sure Jest's configuration does not exclude this directory."
				.. "\nTo set up Jest, make sure a package.json file exists.\n"
				.. "Jest Documentation: "
				.. "https://jestjs.io/docs/configuration"
	end)
	local dataMessage
	if globalConfig.runTestsByPath then
		dataMessage = ("Files: %s"):format(Array.join(
			Array.map(globalConfig.nonFlagArgs, function(p)
				return ('"%s"'):format(tostring(p))
			end),
			", "
		))
	else
		dataMessage = ("Pattern: %s - 0 matches"):format(chalk.yellow(globalConfig.testPathPattern))
	end
	if Boolean.toJSBoolean(willExitWith0) then
		return ("%s\n%s\n%s"):format(
			chalk.bold("No tests found, exiting with code 0"),
			tostring(Array.join(individualResults, "\n") --[[ ROBLOX CHECK: check if 'individualResults' is an Array ]]),
			tostring(dataMessage)
		)
	end
	return ("%s\n"):format(chalk.bold("No tests found, exiting with code 1"))
		.. "Run with `--passWithNoTests` to exit with code 0"
		.. "\n"
		.. Array.join(individualResults, "\n")
		.. "\n"
		.. dataMessage
end
exports.default = getNoTestFoundVerbose

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="306">
              <Properties>
                <string name="Name">getNoTestsFoundMessage</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getNoTestsFoundMessage.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean

local exports = {}

local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
local getNoTestFound = require(script.Parent.getNoTestFound).default
-- ROBLOX deviation START: not needed
-- local getNoTestFoundFailed = require(script.Parent.getNoTestFoundFailed).default
-- ROBLOX deviation END
local getNoTestFoundPassWithNoTests = require(script.Parent.getNoTestFoundPassWithNoTests).default
-- ROBLOX deviation START: not needed
-- local getNoTestFoundRelatedToChangedFiles = require(script.Parent.getNoTestFoundRelatedToChangedFiles).default
-- ROBLOX deviation END
local getNoTestFoundVerbose = require(script.Parent.getNoTestFoundVerbose).default
local typesModule = require(script.Parent.types)
type TestRunData = typesModule.TestRunData

local function getNoTestsFoundMessage(
	testRunData: TestRunData,
	globalConfig: Config_GlobalConfig
): { exitWith0: boolean, message: string }
	-- ROBLOX deviation START: don't check unsupported flags
	local exitWith0 = Boolean.toJSBoolean(globalConfig.passWithNoTests)
	-- ROBLOX deviation END

	-- ROBLOX deviation START: not supported
	-- if Boolean.toJSBoolean(globalConfig.onlyFailures) then
	-- 	return { exitWith0 = exitWith0, message = getNoTestFoundFailed(globalConfig) }
	-- end
	-- if Boolean.toJSBoolean(globalConfig.onlyChanged) then
	-- 	return {
	-- 		exitWith0 = exitWith0,
	-- 		message = getNoTestFoundRelatedToChangedFiles(globalConfig),
	-- 	}
	-- end
	-- ROBLOX deviation END

	if Boolean.toJSBoolean(globalConfig.passWithNoTests) then
		return { exitWith0 = exitWith0, message = getNoTestFoundPassWithNoTests() }
	end
	return {
		exitWith0 = exitWith0,
		-- ROBLOX deviation START: fix length check
		-- message = if Boolean.toJSBoolean(testRunData.length == 1 or globalConfig.verbose)
		-- 	then getNoTestFoundVerbose(testRunData, globalConfig, exitWith0)
		-- 	else getNoTestFound(testRunData, globalConfig, exitWith0),
		message = if Boolean.toJSBoolean(#testRunData == 1 or globalConfig.verbose)
			then getNoTestFoundVerbose(testRunData, globalConfig, exitWith0)
			else getNoTestFound(testRunData, globalConfig, exitWith0),
		-- ROBLOX deviation END
	}
end
exports.default = getNoTestsFoundMessage

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="307">
              <Properties>
                <string name="Name">getProjectDisplayName</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getProjectDisplayName.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig

local function getProjectDisplayName(projectConfig: Config_ProjectConfig): string | nil
	local ref = if typeof(projectConfig.displayName) == "table" then projectConfig.displayName.name else nil
	return Boolean.toJSBoolean(ref) and ref or nil
end
exports.default = getProjectDisplayName

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="308">
              <Properties>
                <string name="Name">getProjectNamesMissingWarning</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getProjectNamesMissingWarning.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local chalk = require(Packages.ChalkLua)
local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig
local getProjectDisplayName = require(script.Parent.getProjectDisplayName).default

local function getProjectNamesMissingWarning(
	projectConfigs: Array<Config_ProjectConfig>,
	opts: {
		ignoreProjects: Array<string> | nil,
		selectProjects: Array<string> | nil,
	}
): string | nil
	local numberOfProjectsWithoutAName = #Array.filter(projectConfigs, function(config)
		return not Boolean.toJSBoolean(getProjectDisplayName(config))
	end)
	if numberOfProjectsWithoutAName == 0 then
		return nil
	end
	local args: Array<string> = {}
	if Boolean.toJSBoolean(opts.selectProjects) then
		table.insert(args, "--selectProjects") --[[ ROBLOX CHECK: check if 'args' is an Array ]]
	end
	if Boolean.toJSBoolean(opts.ignoreProjects) then
		table.insert(args, "--ignoreProjects") --[[ ROBLOX CHECK: check if 'args' is an Array ]]
	end
	return chalk.yellow(
		("You provided values for %s but %s.\n"):format(
			tostring(Array.join(args, " and ") --[[ ROBLOX CHECK: check if 'args' is an Array ]]),
			if numberOfProjectsWithoutAName == 1
				then "a project does not have a name"
				else ("%s projects do not have a name"):format(tostring(numberOfProjectsWithoutAName))
		) .. "Set displayName in the config of all projects in order to disable this warning.\n"
	)
end
exports.default = getProjectNamesMissingWarning

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="309">
              <Properties>
                <string name="Name">getSelectProjectsMessage</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/getSelectProjectsMessage.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local chalk = require(Packages.ChalkLua)
local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig
local getProjectDisplayName = require(script.Parent.getProjectDisplayName).default

-- ROBLOX deviation START: predefine functions
local getNoSelectionWarning
local getProjectsRunningMessage
local getProjectNameListElement
-- ROBLOX deviation END

local function getSelectProjectsMessage(
	projectConfigs: Array<Config_ProjectConfig>,
	opts: {
		ignoreProjects: Array<string> | nil,
		selectProjects: Array<string> | nil,
	}
): string
	-- ROBLOX deviation START: fix length check
	-- if projectConfigs.length == 1 then
	if #projectConfigs == 0 then
		-- ROBLOX deviation END
		return getNoSelectionWarning(opts)
	end
	return getProjectsRunningMessage(projectConfigs)
end
exports.default = getSelectProjectsMessage

function getNoSelectionWarning(opts: {
	ignoreProjects: Array<string> | nil,
	selectProjects: Array<string> | nil,
}): string
	if
		Boolean.toJSBoolean(
			if Boolean.toJSBoolean(opts.ignoreProjects) then opts.selectProjects else opts.ignoreProjects
		)
	then
		return chalk.yellow(
			"You provided values for --selectProjects and --ignoreProjects, but no projects were found matching the selection.\n"
				.. "Are you ignoring all the selected projects?\n"
		)
	elseif Boolean.toJSBoolean(opts.ignoreProjects) then
		return chalk.yellow(
			"You provided values for --ignoreProjects, but no projects were found matching the selection.\n"
				.. "Are you ignoring all projects?\n"
		)
	elseif Boolean.toJSBoolean(opts.selectProjects) then
		return chalk.yellow(
			"You provided values for --selectProjects but no projects were found matching the selection.\n"
		)
	else
		return chalk.yellow("No projects were found.\n")
	end
end

function getProjectsRunningMessage(projectConfigs: Array<Config_ProjectConfig>): string
	if #projectConfigs == 1 then
		local name = getProjectDisplayName(projectConfigs[1])
		return ("Running one project: %s\n"):format(chalk.bold(name))
	end
	local projectsList = Array.join(Array.sort(Array.map(projectConfigs, getProjectNameListElement)), "\n")
	return ("Running %s projects:\n%s\n"):format(tostring(#projectConfigs), tostring(projectsList))
end

function getProjectNameListElement(projectConfig: Config_ProjectConfig): string
	local name = getProjectDisplayName(projectConfig)
	local elementContent = if Boolean.toJSBoolean(name) then chalk.bold(name) else "<unnamed project>"
	return ("- %s"):format(tostring(elementContent))
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="310">
              <Properties>
                <string name="Name">lib</string>
              </Properties>
              <Item class="ModuleScript" referent="311">
                <Properties>
                  <string name="Name">createContext</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/lib/createContext.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent.Parent

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig
-- ROBLOX deviation START: no haste maps support
-- local jest_haste_mapModule = require(Packages["jest-haste-map"])
-- type HasteMapObject = jest_haste_mapModule.HasteMapObject
type HasteMapObject = nil
-- ROBLOX deviation END
local jest_runtimeModule = require(Packages.JestRuntime)
-- local Runtime = jest_runtimeModule.default
type Context = jest_runtimeModule.Context

-- ROBLOX deviation START: no haste maps support
-- local function createContext(config: Config_ProjectConfig, ref0: HasteMapObject): TestContext
-- 	local hasteFS, moduleMap = ref.hasteFS, ref.moduleMap
-- ROBLOX deviation END
local function createContext(config: Config_ProjectConfig, _ref: HasteMapObject): Context
	return {
		config = config,
		-- ROBLOX deviation START: no haste maps support
		-- hasteFS = hasteFS,
		-- moduleMap = moduleMap,
		-- resolver = Runtime:createResolver(config, moduleMap),
		-- ROBLOX deviation END
	}
end
exports.default = createContext

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="312">
                <Properties>
                  <string name="Name">logDebugMessages</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/lib/logDebugMessages.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_ProjectConfig = typesModule.Config_ProjectConfig
-- ROBLOX FIXME START: no version available
-- local VERSION = require_("../../package.json").version -- if the output here changes, update `getConfig` in e2e/runJest.ts
local VERSION = "27.4.7"
-- ROBLOX FIXME END

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
type NodeJS_WriteStream = RobloxShared.NodeJS_WriteStream
local JSON = nodeUtils.JSON
-- ROBLOX deviation END

local function logDebugMessages(
	globalConfig: Config_GlobalConfig,
	configs: Array<Config_ProjectConfig> | Config_ProjectConfig,
	outputStream: NodeJS_WriteStream
): ()
	local output = { configs = configs, globalConfig = globalConfig, version = VERSION }
	outputStream:write((JSON.stringify(output, nil, "  ")) .. "\n")
end
exports.default = logDebugMessages

return exports
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="313">
              <Properties>
                <string name="Name">pluralize</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/pluralize.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}
local function pluralize(word: string, count: number, ending: string): string
	return ("%s %s%s"):format(tostring(count), word, if count == 1 then "" else ending)
end
exports.default = pluralize
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="314">
              <Properties>
                <string name="Name">runJest</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/runJest.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set
local console = LuauPolyfill.console
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

-- ROBLOX deviation START: unused
-- local path = require(Packages.path)
-- local chalk = require(Packages.ChalkLua)
-- local exit = require(Packages.exit)
-- local fs = require(Packages["graceful-fs"])
-- ROBLOX deviation END
local CustomConsole = require(Packages.JestConsole).CustomConsole
local test_resultModule = require(Packages.JestTestResult)
type AggregatedResult = test_resultModule.AggregatedResult
type Test = test_resultModule.Test
type TestContext = test_resultModule.TestContext
-- ROBLOX deviation START: not needed
-- local TestResultsProcessor = test_resultModule.TestResultsProcessor
-- ROBLOX deviation END
local formatTestResults = test_resultModule.formatTestResults
local makeEmptyAggregatedTestResult = test_resultModule.makeEmptyAggregatedTestResult
-- ROBLOX deviation START: not needed
-- local test_sequencerModule = require(Packages["@jest"]["test-sequencer"])
-- type TestSequencer = test_sequencerModule.default
-- ROBLOX deviation END
local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_Path = jestTypesModule.Config_Path
-- ROBLOX deviation START: changed files not supported
-- local jest_changed_filesModule = require(Packages["jest-changed-files"])
-- type ChangedFiles = jest_changed_filesModule.ChangedFiles
type ChangedFiles = nil
-- type ChangedFilesPromise = jest_changed_filesModule.ChangedFilesPromise
type ChangedFilesPromise = Promise<ChangedFiles>
-- local Resolver = require(Packages["jest-resolve"]).default
-- ROBLOX deviation END
local jest_runtimeModule = require(Packages.JestRuntime)
type Context = jest_runtimeModule.Context
-- ROBLOX deviation START:
-- local jest_utilModule = require(Packages.JestUtil)
-- local requireOrImportModule = jest_utilModule.requireOrImportModule
-- local tryRealpath = jest_utilModule.tryRealpath
-- local jest_watcherModule = require(Packages["jest-watcher"])
-- local JestHook = jest_watcherModule.JestHook
-- local JestHookEmitter = jest_watcherModule.JestHookEmitter
type JestHookEmitter = nil
-- local FailedTestsCacheModule = require(script.Parent.FailedTestsCache)
-- type FailedTestsCache = FailedTestsCacheModule.FailedTestsCache
type FailedTestsCache = nil
-- ROBLOX deviation END
local searchSourceModule = require(script.Parent.SearchSource)
local SearchSource = searchSourceModule.default
type SearchSource = searchSourceModule.SearchSource
local TestSchedulerModule = require(script.Parent.TestScheduler)
type TestSchedulerContext = TestSchedulerModule.TestSchedulerContext
local createTestScheduler = TestSchedulerModule.createTestScheduler
local TestWatcherModule = require(script.Parent.TestWatcher)
type TestWatcher = TestWatcherModule.TestWatcher
-- ROBLOX deviation START: collectHandles not supported
-- local collectHandlesModule = require(script.Parent.collectHandles)
-- local collectNodeHandles = collectHandlesModule.default
-- type HandleCollectionResult = collectHandlesModule.HandleCollectionResult
type HandleCollectionResult = nil
-- ROBLOX deviation END
local getNoTestsFoundMessage = require(script.Parent.getNoTestsFoundMessage).default
-- ROBLOX deviation START: no global hooks supported yet
-- local runGlobalHook = require(script.Parent.runGlobalHook).default
-- ROBLOX deviation END
local typesModule = require(script.Parent.types)
type Filter = typesModule.Filter
type TestRunData = typesModule.TestRunData

-- ROBLOX deviation START: added missing variables to limit nr deviations
local RobloxShared = require(Packages.RobloxShared)
local nodeUtils = RobloxShared.nodeUtils
local process = nodeUtils.process
local exit = nodeUtils.exit
type NodeJS_WriteStream = RobloxShared.NodeJS_WriteStream
local JSON = nodeUtils.JSON
local ensureDirectoryExists = RobloxShared.ensureDirectoryExists
local getDataModelService = RobloxShared.getDataModelService
local FileSystemService = getDataModelService("FileSystemService")
local CoreScriptSyncService = getDataModelService("CoreScriptSyncService")
-- ROBLOX deviation END

local function getTestPaths(
	globalConfig: Config_GlobalConfig,
	source: SearchSource,
	_outputStream: NodeJS_WriteStream,
	changedFiles: ChangedFiles | nil,
	_jestHooks: JestHookEmitter,
	filter: Filter?
)
	return Promise.resolve():andThen(function()
		local data = source:getTestPaths(globalConfig, changedFiles, filter):expect()

		-- ROBLOX deviation START: no support for running only changed files
		-- if #data.tests ~= 0 and globalConfig.onlyChanged and data.noSCM then
		-- 	CustomConsole.new(outputStream, outputStream):log(
		-- 		"Jest can only find uncommitted changed files in a git or hg "
		-- 			.. "repository. If you make your project a git or hg "
		-- 			.. "repository (`git init` or `hg init`), Jest will be able "
		-- 			.. "to only run tests related to files changed since the last "
		-- 			.. "commit."
		-- 	)
		-- end
		-- ROBLOX deviation END

		local shouldTestArray = Promise.all(Array.map(data.tests, function(_test)
			-- ROBLOX deviation START: no jestHooks support
			return Promise.resolve(true)
			-- return jestHooks:shouldRunTestSuite({
			-- 	config = test.context.config,
			-- 	duration = test.duration,
			-- 	testPath = test.path,
			-- })
			-- ROBLOX deviation END
		end)):expect()

		local filteredTests = Array.filter(data.tests, function(_test, i)
			return shouldTestArray[i]
		end)

		return Object.assign({}, data, { allTests = #filteredTests, tests = filteredTests })
	end)
end

type ProcessResultOptions =
	-- ROBLOX deviation START: inline Pick<Config_GlobalConfig, "json" | "outputFile" | "testResultsProcessor"> as Luau doesn't support Pick type
	{
		json: boolean,
		outputFile: Config_Path?,
		-- testResultsProcessor: string?,
	}
	-- ROBLOX deviation END
	& {
		-- ROBLOX deviation START: not supported
		-- collectHandles: HandleCollectionResult?,
		-- ROBLOX deviation END
		onComplete: ((result: AggregatedResult) -> ())?,
		-- ROBLOX deviation START: not supported
		-- outputStream: NodeJS_WriteStream,
		-- ROBLOX deviation END
	}

local function processResults(runResults: AggregatedResult, options: ProcessResultOptions)
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: not supported: outputStream testResultsProcessor, collectHandles
		local _outputFile, isJSON, onComplete --[[ , _outputStream, _testResultsProcessor, _collectHandles ]] =
			options.outputFile, options.json, options.onComplete
		-- options.outputStream,
		-- options.testResultsProcessor,
		-- options.collectHandles
		-- ROBLOX deviation END

		-- ROBLOX deviation START no collectHandles supported
		-- if collectHandles ~= nil then
		-- 	runResults.openHandles = collectHandles():expect()
		-- else
		-- 	runResults.openHandles = {}
		-- end
		runResults.openHandles = {}
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no testResultsProcessor handling
		-- if Boolean.toJSBoolean(testResultsProcessor) then
		-- 	local processor = requireOrImportModule(testResultsProcessor):expect()
		-- 	runResults = processor(runResults)
		-- end
		-- ROBLOX deviation END

		if isJSON then
			if _outputFile and FileSystemService and Boolean.toJSBoolean(_outputFile) then
				ensureDirectoryExists(_outputFile)
				FileSystemService:WriteFile(_outputFile, JSON.stringify(formatTestResults(runResults)))
				process.stdout:write(("Test results written to: %s\n"):format(tostring(_outputFile)))
			else
				process.stdout:write(JSON.stringify(formatTestResults(runResults)))
			end
		end

		if onComplete ~= nil then
			onComplete(runResults)
		end
	end)
end

local testSchedulerContext: TestSchedulerContext = { firstRun = true, previousSuccess = true }

local function runJest(ref: {
	globalConfig: Config_GlobalConfig,
	contexts: Array<TestContext>,
	outputStream: NodeJS_WriteStream,
	testWatcher: TestWatcher,
	jestHooks: JestHookEmitter?,
	startRun: (globalConfig: Config_GlobalConfig) -> (),
	changedFilesPromise: ChangedFilesPromise?,
	onComplete: (testResults: AggregatedResult) -> (),
	failedTestsCache: FailedTestsCache?,
	filter: Filter?,
}): Promise<nil>
	-- ROBLOX FIXME Stylua
	-- stylua: ignore
	local contexts, globalConfig, outputStream, testWatcher, jestHooks, startRun, _changedFilesPromise, onComplete, _failedTestsCache, filter =
		ref.contexts,
		ref.globalConfig,
		ref.outputStream,
		ref.testWatcher,
		-- ROBLOX deviation START: no JestHook support
		nil,
		-- if ref.jestHooks == nil then JestHook.new():getEmitter() else ref.jestHooks,
		-- ROBLOX deviation END
		ref.startRun,
		ref.changedFilesPromise,
		ref.onComplete,
		ref.failedTestsCache,
		ref.filter
	return Promise.resolve():andThen(function()
		-- Clear cache for required modules - there might be different resolutions
		-- from Jest's config loading to running the tests

		-- ROBLOX deviation START: no Resolver caching and TestSequencer support
		-- Resolver:clearDefaultResolverCache()
		-- local Sequencer: typeof(TestSequencer) = requireOrImportModule(globalConfig.testSequencer):expect()
		-- local sequencer = Sequencer.new()
		-- ROBLOX deviation END
		local allTests: Array<Test> = {}

		-- ROBLOX deviation START: no watch tests supported
		-- if changedFilesPromise ~= nil and globalConfig.watch then
		-- 	local repos = changedFilesPromise:expect().repos
		-- 	local noSCM = Array.every(
		-- 		Object.keys(repos) :: Array<any> --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof ChangedFiles['repos'] ]],
		-- 		function(scm)
		-- 			return repos[scm].size == 0
		-- 		end
		-- 	)
		-- 	if noSCM then
		-- 		process.stderr:write(
		-- 			"\n" .. chalk.bold("--watch") .. " is not supported without git/hg, please use --watchAll " .. "\n"
		-- 		)
		-- 		exit(1)
		-- 	end
		-- end
		-- ROBLOX deviation END

		local searchSources = Array.map(contexts, function(context)
			return SearchSource.new(context)
		end)

		local testRunData: TestRunData = Promise.all(Array.map(contexts, function(context, index)
			return Promise.resolve():andThen(function()
				local searchSource = searchSources[index]
				local matches = getTestPaths(
					globalConfig,
					searchSource,
					outputStream,
					-- ROBLOX deviation START: changed files not supported
					nil,
					-- if changedFilesPromise ~= nil then changedFilesPromise:expect() else changedFilesPromise,
					-- ROBLOX deviation END
					jestHooks,
					filter
				):expect()
				allTests = Array.concat(allTests, matches.tests)

				return { context = context, matches = matches }
			end)
		end)):expect()

		-- ROBLOX deviation START: no TestSequencer support
		allTests = allTests
		-- sequencer:sort(allTests):expect()
		-- ROBLOX deviation END

		if globalConfig.listTests then
			local testsPaths = Array.from(Set.new(Array.map(allTests, function(test)
				-- ROBLOX deviation: resolve to a FS path if CoreScriptSyncService is available
				if CoreScriptSyncService then
					return CoreScriptSyncService:GetScriptFilePath(test.script)
				end
				return test.path
			end)))
			--[[ eslint-disable no-console ]]
			if globalConfig.json then
				console.log(JSON.stringify(testsPaths))
			else
				console.log(Array.join(testsPaths, "\n"))
			end
			--[[ eslint-enable ]]

			if onComplete ~= nil then
				onComplete(makeEmptyAggregatedTestResult())
			end
			return
		end

		-- ROBLOX deviation START: no support for running only failed tests
		-- if Boolean.toJSBoolean(globalConfig.onlyFailures) then
		-- 	if Boolean.toJSBoolean(failedTestsCache) then
		-- 		allTests = failedTestsCache:filterTests(allTests)
		-- 	else
		-- 		allTests = sequencer:allFailedTests(allTests):expect()
		-- 	end
		-- end
		-- ROBLOX deviation END

		local hasTests = #allTests > 0

		if not hasTests then
			local noTestsFound = getNoTestsFoundMessage(testRunData, globalConfig)

			local exitWith0 = noTestsFound.exitWith0
			local noTestsFoundMessage = noTestsFound.message

			if
				globalConfig.passWithNoTests
				-- ROBLOX deviation START: not supported
				-- or globalConfig.findRelatedTests
				-- or globalConfig.lastCommit
				-- or globalConfig.onlyChanged
				-- ROBLOX deviation END
			then
				CustomConsole.new(outputStream, outputStream):log(noTestsFoundMessage)
			else
				CustomConsole.new(outputStream, outputStream):error(noTestsFoundMessage)

				exit(1)
			end
		elseif #allTests == 1 and globalConfig.silent ~= true and globalConfig.verbose ~= false then
			local newConfig: Config_GlobalConfig = Object.assign({}, globalConfig, { verbose = true })
			globalConfig = Object.freeze(newConfig)
		end

		-- ROBLOX deviation START: detectOpenHandles not supported
		local collectHandles = nil

		-- if globalConfig.detectOpenHandles then
		-- 	collectHandles = collectNodeHandles()
		-- end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no global hooks supported yet
		-- if hasTests then
		-- 	runGlobalHook({
		-- 		allTests = allTests,
		-- 		globalConfig = globalConfig,
		-- 		moduleName = "globalSetup",
		-- 	}):expect()
		-- end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: changedFilesPromise not supported yet
		-- if changedFilesPromise ~= nil then
		-- 	local changedFilesInfo = changedFilesPromise:expect()
		-- 	if Boolean.toJSBoolean(changedFilesInfo.changedFiles) then
		-- 		testSchedulerContext.changedFiles = changedFilesInfo.changedFiles
		-- 		local sourcesRelatedToTestsInChangedFilesArray = Array.reduce(
		-- 			Promise.all(Array.map(contexts, function(_, index)
		-- 				return Promise.resolve():andThen(function()
		-- 					local searchSource = searchSources[index]
		-- 					return searchSource:findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo)
		-- 				end)
		-- 			end)):expect(),
		-- 			function(total, paths)
		-- 				return Array.concat(total, paths)
		-- 			end,
		-- 			{}
		-- 		)
		-- 		testSchedulerContext.sourcesRelatedToTestsInChangedFiles = Set.new(
		-- 			sourcesRelatedToTestsInChangedFilesArray
		-- 		)
		-- 	end
		-- end
		-- ROBLOX deviation END

		local scheduler =
			createTestScheduler(globalConfig, Object.assign({}, { startRun = startRun }, testSchedulerContext)):expect()

		local results = scheduler:scheduleTests(allTests, testWatcher):expect()

		-- ROBLOX deviation START: no TestSequencer support
		-- sequencer:cacheResults(allTests, results):expect()
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no global hooks supported yet
		-- if hasTests then
		-- 	runGlobalHook({
		-- 		allTests = allTests,
		-- 		globalConfig = globalConfig,
		-- 		moduleName = "globalTeardown",
		-- 	}):expect()
		-- end
		-- ROBLOX deviation END

		processResults(results, {
			collectHandles = collectHandles,
			json = globalConfig.json,
			onComplete = onComplete,
			outputFile = globalConfig.outputFile,
			outputStream = outputStream,
			-- ROBLOX deviation START: not supported
			-- testResultsProcessor = globalConfig.testResultsProcessor,
			-- ROBLOX deviation END
		}):expect()
	end)
end
exports.default = runJest

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="315">
              <Properties>
                <string name="Name">testSchedulerHelper</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/testSchedulerHelper.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
local exports = {}
local test_resultModule = require(Packages.JestTestResult)
type Test = test_resultModule.Test
local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
-- ROBLOX deviation START: always run in band
-- local SLOW_TEST_TIME = 1000
local function shouldRunInBand(_tests: Array<Test>, _timings: Array<number>, _ref: Config_GlobalConfig): boolean
	return true
	-- local detectOpenHandles, maxWorkers, watch, watchAll =
	-- 	ref.detectOpenHandles, ref.maxWorkers, ref.watch, ref.watchAll
	-- -- detectOpenHandles makes no sense without runInBand, because it cannot detect leaks in workers
	-- if detectOpenHandles then
	-- 	return true
	-- end
	-- --[[
	--  * Run in band if we only have one test or one worker available, unless we
	--  * are using the watch mode, in which case the TTY has to be responsive and
	--  * we cannot schedule anything in the main thread. Same logic applies to
	--  * watchAll.
	--  * Also, if we are confident from previous runs that the tests will finish
	--  * quickly we also run in band to reduce the overhead of spawning workers.
	--  * Finally, the user can provide the runInBand argument in the CLI to
	--  * force running in band.
	--  * https://github.com/facebook/jest/blob/700e0dadb85f5dc8ff5dac6c7e98956690049734/packages/jest-config/src/getMaxWorkers.js#L14-L17
	--  ]]
	-- local isWatchMode = watch or watchAll
	-- local areFastTests = Array.every(timings, function(timing)
	-- 	return timing < SLOW_TEST_TIME
	-- end)
	-- local oneWorkerOrLess = maxWorkers <= 1
	-- local oneTestOrLess = #tests <= 1
	-- if isWatchMode then
	-- 	return oneWorkerOrLess or (oneTestOrLess and areFastTests)
	-- end
	-- return oneWorkerOrLess or oneTestOrLess or (#tests <= 20 and #timings > 0 and areFastTests)
end
-- ROBLOX deviation END
exports.shouldRunInBand = shouldRunInBand
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="316">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-core/src/types.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>

local test_resultModule = require(Packages.JestTestResult)
type Test = test_resultModule.Test
local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path
local jest_runtimeModule = require(Packages.JestRuntime)
type Context = jest_runtimeModule.Context

-- ROBLOX deviation START: add additional imports and types
local reportersModule = require(Packages.JestReporters)
type JestReporter = reportersModule.BaseReporter
type ReporterContext = reportersModule.ReporterContext
type Config_GlobalConfig = typesModule.Config_GlobalConfig

type Record<K, T> = { [K]: T }
-- ROBLOX deviation END

export type Stats = {
	roots: number,
	testMatch: number,
	testPathIgnorePatterns: number,
	testRegex: number,
	testPathPattern: number?,
}

export type TestRunData = Array<{
	context: Context,
	matches: { allTests: number, tests: Array<Test>, total: number?, stats_: Stats? },
}>

-- ROBLOX deviation START: unroll `keyof Stats` as this operation is not supported in Luau
type KeyOfStats = "roots" | "testMatch" | "testPathIgnorePatterns" | "testRegex" | "testPathPattern"
export type TestPathCases = Array<{
	stat: KeyOfStats,
	isMatch: (path: Config_Path) -> boolean,
}>
-- ROBLOX deviation END

export type TestPathCasesWithPathPattern = TestPathCases & { testPathPattern: (path: Config_Path) -> boolean }

export type FilterResult = { test: string, message: string }

export type Filter = (testPaths: Array<string>) -> Promise<{ filtered: Array<FilterResult> }>

-- ROBLOX deviation START: add types moved from other files to avoid cyclic dependencies
export type ReporterConstructor = {
	new: (
		globalConfig: Config_GlobalConfig,
		reporterConfig: Record<string, any>,
		reporterContext: ReporterContext
	) -> JestReporter,
}
-- ROBLOX deviation END

return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="317">
            <Properties>
              <string name="Name">JestDiff</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local String = LuauPolyfill.String
local Symbol = LuauPolyfill.Symbol

type Record<T, V> = { [T]: V }

local PrettyFormat = require(Packages.PrettyFormat)
local prettyFormat = PrettyFormat.format
local PrettyFormat_ = require(CurrentModule.PrettyFormat)
-- ROBLOX TODO: fix PrettyFormat types imports
type PrettyFormatOptions = PrettyFormat_.PrettyFormatOptions

local chalk = require(Packages.ChalkLua)

local getType = require(Packages.JestGetType).getType

local cleanupSemanticModule = require(CurrentModule.CleanupSemantic)
local DIFF_DELETE = cleanupSemanticModule.DIFF_DELETE
local DIFF_EQUAL = cleanupSemanticModule.DIFF_EQUAL
local DIFF_INSERT = cleanupSemanticModule.DIFF_INSERT
local Diff = cleanupSemanticModule.Diff
export type Diff = cleanupSemanticModule.Diff

local normalizeDiffOptions = require(CurrentModule.NormalizeDiffOptions).normalizeDiffOptions

local diffLinesRaw = require(CurrentModule.DiffLines).diffLinesRaw
local diffLinesUnified = require(CurrentModule.DiffLines).diffLinesUnified
local diffLinesUnified2 = require(CurrentModule.DiffLines).diffLinesUnified2

local diffStringsRaw = require(CurrentModule.PrintDiffs).diffStringsRaw
local diffStringsUnified = require(CurrentModule.PrintDiffs).diffStringsUnified

local typesModule = require(CurrentModule.types)
export type DiffOptions = typesModule.DiffOptions
export type DiffOptionsColor = typesModule.DiffOptionsColor

local NO_DIFF_MESSAGE = require(CurrentModule.Constants).NO_DIFF_MESSAGE
local SIMILAR_MESSAGE = require(CurrentModule.Constants).SIMILAR_MESSAGE

-- ROBLOX deviation start: predefine functions
local comparePrimitive
local compareObjects
local getFormatOptions
local getObjectsDifference
-- ROBLOX deviation end

local function getCommonMessage(message: string, options: DiffOptions?)
	local commonColor = normalizeDiffOptions(options)["commonColor"]
	return commonColor(message)
end

-- ROBLOX TODO: continue to add prettyFormat plugins
local prettyFormatPlugins = PrettyFormat.plugins
local PLUGINS = {
	prettyFormatPlugins.AsymmetricMatcher,
	-- ROBLOX deviation: Roblox Instance matchers
	prettyFormatPlugins.RobloxInstance,
}
local FORMAT_OPTIONS = {
	plugins = PLUGINS,
}
local FALLBACK_FORMAT_OPTIONS = {
	callToJSON = false,
	maxDepth = 10,
	plugins = PLUGINS,
}

-- local sortTable

-- Generate a string that will highlight the difference between two values
-- with green and red. (similar to how github does code diffing)
-- eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
local function diff(a: any, b: any, options: DiffOptions?): string?
	if Object.is(a, b) then
		return getCommonMessage(NO_DIFF_MESSAGE, options)
	end

	local aType = getType(a)
	local expectedType = aType
	local omitDifference = false

	if aType == "table" and getType(a.asymmetricMatch) == "function" then
		if a["$$typeof"] ~= Symbol.for_("jest.asymmetricMatcher") then
			-- Do not know expected type of user-defined asymmetric matcher.
			return nil
		end
		if typeof(a.getExpectedType) ~= "function" then
			-- For example, expect.anything() matches either null or undefined
			return nil
		end
		expectedType = a:getExpectedType()
		-- Primitive types boolean and number omit difference below.
		-- For example, omit difference for expect.stringMatching(regexp)
		omitDifference = expectedType == "string"
	end

	if expectedType ~= getType(b) then
		return string.format(
			"  Comparing two different types of values." .. " Expected %s but " .. "received %s.",
			chalk.green(expectedType),
			chalk.red(getType(b))
		)
	end

	if omitDifference then
		return nil
	end

	if aType == "string" then
		return diffLinesUnified(string.split(a, "\n"), string.split(b, "\n"), options)
	elseif aType == "boolean" or aType == "number" then
		return comparePrimitive(a, b, options)
		-- ROBLOX deviation: omitted, no ordered tables in lua
		-- elseif aType == 'table' then
		-- 	return compareObjects(sortTable(a), sortTable(b), options)
	end
	return compareObjects(a, b, options)
end

function comparePrimitive(a: number | boolean, b: number | boolean, options: DiffOptions?)
	local aFormat = prettyFormat(a, FORMAT_OPTIONS)
	local bFormat = prettyFormat(b, FORMAT_OPTIONS)
	if aFormat == bFormat then
		return getCommonMessage(NO_DIFF_MESSAGE, options)
	end
	return diffLinesUnified(string.split(aFormat, "\n"), string.split(bFormat, "\n"), options)
end

-- ROBLOX deviation: omitted, no ordered tables in lua

function compareObjects(a, b, options: DiffOptions?)
	local difference
	local hasThrown = false

	local ok, _ = pcall(function()
		local formatOptions = getFormatOptions(FORMAT_OPTIONS, options)
		difference = getObjectsDifference(a, b, formatOptions, options)
		-- local aCompare = prettyFormat(a, FORMAT_OPTIONS_0)
		-- local bCompare = prettyFormat(b, FORMAT_OPTIONS_0)

		-- if aCompare == bCompare then
		-- 	difference = noDiffMessage
		-- else
		-- 	local aDisplay = prettyFormat(a, FORMAT_OPTIONS)
		-- 	local bDisplay = prettyFormat(b, FORMAT_OPTIONS)
		-- 	difference = diffLinesUnified2(
		-- 		string.split(aDisplay, '\n'),
		-- 		string.split(bDisplay, '\n'),
		-- 		string.split(aCompare, '\n'),
		-- 		string.split(bCompare, '\n'),
		-- 		options
		-- 	)
		-- end
	end)
	if not ok then
		hasThrown = true
	end

	local noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options)
	-- If the comparison yields no results, compare again but this time
	-- without calling `toJSON`. It's also possible that toJSON might throw.
	if difference == nil or difference == noDiffMessage then
		local formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options)
		difference = getObjectsDifference(a, b, formatOptions, options)
		-- local aCompare = prettyFormat(a, FALLBACK_FORMAT_OPTIONS_0)
		-- local bCompare = prettyFormat(b, FALLBACK_FORMAT_OPTIONS_0)

		-- if aCompare == bCompare then
		-- 	difference = noDiffMessage
		-- else
		-- 	local aDisplay = prettyFormat(a, FALLBACK_FORMAT_OPTIONS)
		-- 	local bDisplay = prettyFormat(b, FALLBACK_FORMAT_OPTIONS)

		-- 	difference = diffLinesUnified2(
		-- 		string.split(aDisplay, '\n'),
		-- 		string.split(bDisplay, '\n'),
		-- 		string.split(aCompare, '\n'),
		-- 		string.split(bCompare, '\n'),
		-- 		options
		-- 	)
		-- end

		if difference ~= noDiffMessage and not hasThrown then
			difference = getCommonMessage(SIMILAR_MESSAGE, options) .. "\n\n" .. difference
		end
	end

	return difference
end

function getFormatOptions(formatOptions: PrettyFormatOptions, options: DiffOptions?): PrettyFormatOptions
	local compareKeys = normalizeDiffOptions(options).compareKeys
	return Object.assign({}, formatOptions, { compareKeys = compareKeys })
end

function getObjectsDifference(
	a: Record<string, any>,
	b: Record<string, any>,
	formatOptions: PrettyFormatOptions,
	options: DiffOptions?
): string
	local formatOptionsZeroIndent = Object.assign({}, formatOptions, { indent = 0 })
	local aCompare = prettyFormat(a, formatOptionsZeroIndent)
	local bCompare = prettyFormat(b, formatOptionsZeroIndent)
	if aCompare == bCompare then
		return getCommonMessage(NO_DIFF_MESSAGE, options)
	else
		local aDisplay = prettyFormat(a, formatOptions)
		local bDisplay = prettyFormat(b, formatOptions)
		return diffLinesUnified2(
			String.split(aDisplay, "\n"),
			String.split(bDisplay, "\n"),
			String.split(aCompare, "\n"),
			String.split(bCompare, "\n"),
			options
		)
	end
end

return {
	diffLinesRaw = diffLinesRaw,
	diffLinesUnified = diffLinesUnified,
	diffLinesUnified2 = diffLinesUnified2,

	diffStringsRaw = diffStringsRaw,
	diffStringsUnified = diffStringsUnified,

	DIFF_DELETE = DIFF_DELETE,
	DIFF_EQUAL = DIFF_EQUAL,
	DIFF_INSERT = DIFF_INSERT,
	Diff = Diff,

	diff = diff,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="318">
              <Properties>
                <string name="Name">CleanupSemantic</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/cleanupSemantic.ts
-- implementation adapted from:
-- https://github.com/google/diff-match-patch/blob/858b3812cc02e7d48da4beebb21d4d80dc1d3062/lua/diff_match_patch.lua
-- /**
--  * Diff Match and Patch
--  * Copyright 2018 The diff-match-patch Authors.
--  * https://github.com/google/diff-match-patch
--  *
--  * Licensed under the Apache License, Version 2.0 (the "License");
--  * you may not use this file except in compliance with the License.
--  * You may obtain a copy of the License at
--  *
--  *   http://www.apache.org/licenses/LICENSE-2.0
--  *
--  * Unless required by applicable law or agreed to in writing, software
--  * distributed under the License is distributed on an "AS IS" BASIS,
--  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
--  * See the License for the specific language governing permissions and
--  * limitations under the License.
--  */

-- /**
--  * @fileoverview Computes the difference between two texts to create a patch.
--  * Applies the patch onto another text, allowing for errors.
--  * @author fraser@google.com (Neil Fraser)
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

-- /**
--  * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:
--  *
--  * 1. Delete anything not needed to use diff_cleanupSemantic method
--  * 2. Convert from prototype properties to var declarations
--  * 3. Convert Diff to class from constructor and prototype
--  * 4. Add type annotations for arguments and return values
--  * 5. Add exports
--  */

local _diff_cleanupSemanticLossless, _diff_cleanupMerge

local strsub, strbyte = string.sub, string.byte
local strmatch, strfind = string.match, string.find
local max, min, floor = math.max, math.min, math.floor
local tinsert, tremove = table.insert, table.remove

-- /**
--  * The data structure representing a diff is an array of tuples:
--  * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
--  * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
--  */
local DIFF_DELETE = -1
local DIFF_INSERT = 1
local DIFF_EQUAL = 0

-- /**
--  * Class representing one diff tuple.
--  * Attempts to look like a two-element array (which is what this used to be).
--  * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
--  * @param {string} text Text to be deleted, inserted, or retained.
--  * @constructor
--  */
-- ROBLOX FIXME Luau: Luau can't represent [1]: number, [2]: string
export type Diff = Array<any>
local Diff = {}
Diff.__index = Diff
function Diff.new(op: number, text: string): Diff
	return (setmetatable({ op :: any, text }, Diff) :: any) :: Diff
end

--[[
* Determine the common prefix of two strings.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the start of each
*    string.
--]]
local function _diff_commonPrefix(text1: string, text2: string): number
	-- Quick check for common null cases.
	if #text1 == 0 or #text2 == 0 or strbyte(text1, 1, 1) ~= strbyte(text2, 1, 1) then
		return 0
	end
	-- Binary search.
	-- Performance analysis: https://neil.fraser.name/news/2007/10/09/
	local pointermin = 1
	local pointermax = min(#text1, #text2)
	local pointermid = pointermax
	local pointerstart = 1
	while pointermin < pointermid do
		if strsub(text1, pointerstart, pointermid) == strsub(text2, pointerstart, pointermid) then
			pointermin = pointermid
			pointerstart = pointermin
		else
			pointermax = pointermid
		end
		pointermid = floor(pointermin + (pointermax - pointermin) / 2)
	end
	return pointermid
end

--[[
* Determine the common suffix of two strings.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the end of each string.
--]]
local function _diff_commonSuffix(text1: string, text2: string): number
	-- Quick check for common null cases.
	if #text1 == 0 or #text2 == 0 or strbyte(text1, -1) ~= strbyte(text2, -1) then
		return 0
	end
	-- Binary search.
	-- Performance analysis: https://neil.fraser.name/news/2007/10/09/
	local pointermin = 1
	local pointermax = min(#text1, #text2)
	local pointermid = pointermax
	local pointerend = 1
	while pointermin < pointermid do
		if strsub(text1, -pointermid, -pointerend) == strsub(text2, -pointermid, -pointerend) then
			pointermin = pointermid
			pointerend = pointermin
		else
			pointermax = pointermid
		end
		pointermid = floor(pointermin + (pointermax - pointermin) / 2)
	end
	return pointermid
end

--[[
* Determine if the suffix of one string is the prefix of another.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the end of the first
*     string and the start of the second string.
* @private
--]]
local function _diff_commonOverlap(text1: string, text2: string): number
	-- Cache the text lengths to prevent multiple calls.
	local text1_length = #text1
	local text2_length = #text2
	-- Eliminate the null case.
	if text1_length == 0 or text2_length == 0 then
		return 0
	end
	-- Truncate the longer string.
	if text1_length > text2_length then
		text1 = strsub(text1, text1_length - text2_length + 1)
	elseif text1_length < text2_length then
		text2 = strsub(text2, 1, text1_length)
	end
	local text_length = min(text1_length, text2_length)
	-- Quick check for the worst case.
	if text1 == text2 then
		return text_length
	end

	-- Start by looking for a single character match
	-- and increase length until no match is found.
	-- Performance analysis: https://neil.fraser.name/news/2010/11/04/
	local best = 0
	local length = 1
	while true do
		local pattern = strsub(text1, text_length - length + 1)
		local found = strfind(text2, pattern, 1, true)
		if found == nil then
			return best
		end
		-- ROBLOX FIXME Luau: narrowing/type state should make this cast unnecessary
		length += (found :: number - 1)
		if found == 1 or strsub(text1, text_length - length + 1) == strsub(text2, 1, length) then
			best = length
			length += 1
		end
	end
	return best
end

--[[
* Reduce the number of edits by eliminating semantically trivial equalities.
* @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
--]]
local function diff_cleanupSemantic(diffs: Array<Diff>)
	local changes = false
	local equalities = {} -- Stack of indices where equalities are found.
	local equalitiesLength = 0 -- Keeping our own length var is faster.
	local lastEquality = nil
	-- Always equal to diffs[equalities[equalitiesLength]][2]
	local pointer = 1 -- Index of current position.
	-- Number of characters that changed prior to the equality.
	local length_insertions1 = 0
	local length_deletions1 = 0
	-- Number of characters that changed after the equality.
	local length_insertions2 = 0
	local length_deletions2 = 0

	while diffs[pointer] do
		if diffs[pointer][1] == DIFF_EQUAL then -- Equality found.
			equalitiesLength = equalitiesLength + 1
			equalities[equalitiesLength] = pointer
			length_insertions1 = length_insertions2
			length_deletions1 = length_deletions2
			length_insertions2 = 0
			length_deletions2 = 0
			lastEquality = diffs[pointer][2]
		else -- An insertion or deletion.
			if diffs[pointer][1] == DIFF_INSERT then
				length_insertions2 = length_insertions2 + #diffs[pointer][2]
			else
				length_deletions2 = length_deletions2 + #diffs[pointer][2]
			end
			-- Eliminate an equality that is smaller or equal to the edits on both
			-- sides of it.
			if
				lastEquality
				and #lastEquality <= max(length_insertions1, length_deletions1)
				and #lastEquality <= max(length_insertions2, length_deletions2)
			then
				-- Duplicate record.
				tinsert(diffs, equalities[equalitiesLength], Diff.new(DIFF_DELETE, lastEquality))
				-- Change second copy to insert.
				diffs[equalities[equalitiesLength] + 1][1] = DIFF_INSERT
				-- Throw away the equality we just deleted.
				equalitiesLength = equalitiesLength - 1
				-- Throw away the previous equality (it needs to be reevaluated).
				equalitiesLength = equalitiesLength - 1
				pointer = (equalitiesLength > 0) and equalities[equalitiesLength] or 0
				length_insertions1, length_deletions1 = 0, 0 -- Reset the counters.
				length_insertions2, length_deletions2 = 0, 0
				lastEquality = nil
				changes = true
			end
		end
		pointer = pointer + 1
	end

	-- Normalize the diff.
	if changes then
		_diff_cleanupMerge(diffs)
	end
	_diff_cleanupSemanticLossless(diffs)

	-- Find any overlaps between deletions and insertions.
	-- e.g: <del>abcxxx</del><ins>xxxdef</ins>
	--   -> <del>abc</del>xxx<ins>def</ins>
	-- e.g: <del>xxxabc</del><ins>defxxx</ins>
	--   -> <ins>def</ins>xxx<del>abc</del>
	-- Only extract an overlap if it is as big as the edit ahead or behind it.
	pointer = 2
	while diffs[pointer] do
		if diffs[pointer - 1][1] == DIFF_DELETE and diffs[pointer][1] == DIFF_INSERT then
			local deletion = diffs[pointer - 1][2]
			local insertion = diffs[pointer][2]
			local overlap_length1 = _diff_commonOverlap(deletion, insertion)
			local overlap_length2 = _diff_commonOverlap(insertion, deletion)
			if overlap_length1 >= overlap_length2 then
				if overlap_length1 >= #deletion / 2 or overlap_length1 >= #insertion / 2 then
					-- Overlap found.  Insert an equality and trim the surrounding edits.
					tinsert(diffs, pointer, Diff.new(DIFF_EQUAL, strsub(insertion, 1, overlap_length1)))
					diffs[pointer - 1][2] = strsub(deletion, 1, #deletion - overlap_length1)
					diffs[pointer + 1][2] = strsub(insertion, overlap_length1 + 1)
					pointer = pointer + 1
				end
			else
				if overlap_length2 >= #deletion / 2 or overlap_length2 >= #insertion / 2 then
					-- Reverse overlap found.
					-- Insert an equality and swap and trim the surrounding edits.
					tinsert(diffs, pointer, Diff.new(DIFF_EQUAL, strsub(deletion, 1, overlap_length2)))
					diffs[pointer - 1] = { DIFF_INSERT, strsub(insertion, 1, #insertion - overlap_length2) }
					diffs[pointer + 1] = { DIFF_DELETE, strsub(deletion, overlap_length2 + 1) }
					pointer = pointer + 1
				end
			end
			pointer = pointer + 1
		end
		pointer = pointer + 1
	end
end

--[[
* Given two strings, compute a score representing whether the internal
* boundary falls on logical boundaries.
* Scores range from 6 (best) to 0 (worst).
* @param {string} one First string.
* @param {string} two Second string.
* @return {number} The score.
* @private
--]]
local function _diff_cleanupSemanticScore(one: string, two: string): number
	if #one == 0 or #two == 0 then
		-- Edges are the best.
		return 6
	end

	-- Each port of this function behaves slightly differently due to
	-- subtle differences in each language's definition of things like
	-- 'whitespace'.  Since this function's purpose is largely cosmetic,
	-- the choice has been made to use each language's native features
	-- rather than force total conformity.
	local char1 = strsub(one, -1)
	local char2 = strsub(two, 1, 1)
	local nonAlphaNumeric1 = strmatch(char1, "%W")
	local nonAlphaNumeric2 = strmatch(char2, "%W")
	local whitespace1 = nonAlphaNumeric1 and strmatch(char1, "%s")
	local whitespace2 = nonAlphaNumeric2 and strmatch(char2, "%s")
	local lineBreak1 = whitespace1 and strmatch(char1, "%c")
	local lineBreak2 = whitespace2 and strmatch(char2, "%c")
	local blankLine1 = lineBreak1 and strmatch(one, "\n\r?\n$")
	local blankLine2 = lineBreak2 and strmatch(two, "^\r?\n\r?\n")

	if blankLine1 or blankLine2 then
		-- Five points for blank lines.
		return 5
	elseif lineBreak1 or lineBreak2 then
		-- Four points for line breaks.
		return 4
	elseif nonAlphaNumeric1 and not whitespace1 and whitespace2 then
		-- Three points for end of sentences.
		return 3
	elseif whitespace1 or whitespace2 then
		-- Two points for whitespace.
		return 2
	elseif nonAlphaNumeric1 or nonAlphaNumeric2 then
		-- One point for non-alphanumeric.
		return 1
	end
	return 0
end

--[[
* Look for single edits surrounded on both sides by equalities
* which can be shifted sideways to align the edit to a word boundary.
* e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
* @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
--]]
_diff_cleanupSemanticLossless = function(diffs: Array<Diff>)
	local pointer = 2
	-- Intentionally ignore the first and last element (don't need checking).
	while diffs[pointer + 1] do
		local prevDiff, nextDiff = diffs[pointer - 1], diffs[pointer + 1]
		if prevDiff[1] == DIFF_EQUAL and nextDiff[1] == DIFF_EQUAL then
			-- This is a single edit surrounded by equalities.
			local diff = diffs[pointer]

			local equality1 = prevDiff[2]
			local edit = diff[2]
			local equality2 = nextDiff[2]

			-- First, shift the edit as far left as possible.
			local commonOffset = _diff_commonSuffix(equality1, edit)
			if commonOffset > 0 then
				local commonString = strsub(edit, -commonOffset)
				equality1 = strsub(equality1, 1, -commonOffset - 1)
				edit = commonString .. strsub(edit, 1, -commonOffset - 1)
				equality2 = commonString .. equality2
			end

			-- Second, step character by character right, looking for the best fit.
			local bestEquality1 = equality1
			local bestEdit = edit
			local bestEquality2 = equality2
			local bestScore = _diff_cleanupSemanticScore(equality1, edit) + _diff_cleanupSemanticScore(edit, equality2)

			while strbyte(edit, 1) == strbyte(equality2, 1) do
				equality1 = equality1 .. strsub(edit, 1, 1)
				edit = strsub(edit, 2) .. strsub(equality2, 1, 1)
				equality2 = strsub(equality2, 2)
				local score = _diff_cleanupSemanticScore(equality1, edit) + _diff_cleanupSemanticScore(edit, equality2)
				-- The >= encourages trailing rather than leading whitespace on edits.
				if score >= bestScore then
					bestScore = score
					bestEquality1 = equality1
					bestEdit = edit
					bestEquality2 = equality2
				end
			end
			if prevDiff[2] ~= bestEquality1 then
				-- We have an improvement, save it back to the diff.
				if #bestEquality1 > 0 then
					diffs[pointer - 1][2] = bestEquality1
				else
					tremove(diffs, pointer - 1)
					pointer = pointer - 1
				end
				diffs[pointer][2] = bestEdit
				if #bestEquality2 > 0 then
					diffs[pointer + 1][2] = bestEquality2
				else
					tremove(diffs, pointer + 1)
					pointer -= 1
				end
			end
		end
		pointer += 1
	end
end

-- ROBLOX deviation: no need for regex patterns

_diff_cleanupMerge = function(diffs: Array<Diff>)
	diffs[#diffs + 1] = Diff.new(DIFF_EQUAL, "") -- Add a dummy entry at the end.
	local pointer = 1
	local count_delete, count_insert = 0, 0
	local text_delete, text_insert = "", ""
	local commonlength
	while diffs[pointer] do
		local diff_type = diffs[pointer][1]
		if diff_type == DIFF_INSERT then
			count_insert = count_insert + 1
			text_insert = text_insert .. diffs[pointer][2]
			pointer = pointer + 1
		elseif diff_type == DIFF_DELETE then
			count_delete = count_delete + 1
			text_delete = text_delete .. diffs[pointer][2]
			pointer = pointer + 1
		elseif diff_type == DIFF_EQUAL then
			-- Upon reaching an equality, check for prior redundancies.
			if count_delete + count_insert > 1 then
				if count_delete > 0 and count_insert > 0 then
					-- Factor out any common prefixies.
					commonlength = _diff_commonPrefix(text_insert, text_delete)
					if commonlength > 0 then
						local back_pointer = pointer - count_delete - count_insert
						if back_pointer > 1 and diffs[back_pointer - 1][1] == DIFF_EQUAL then
							diffs[back_pointer - 1][2] = diffs[back_pointer - 1][2]
								.. strsub(text_insert, 1, commonlength)
						else
							tinsert(diffs, 1, Diff.new(DIFF_EQUAL, strsub(text_insert, 1, commonlength)))
							pointer = pointer + 1
						end
						text_insert = strsub(text_insert, commonlength + 1)
						text_delete = strsub(text_delete, commonlength + 1)
					end
					-- Factor out any common suffixies.
					commonlength = _diff_commonSuffix(text_insert, text_delete)
					if commonlength ~= 0 then
						diffs[pointer][2] = strsub(text_insert, -commonlength) .. diffs[pointer][2]
						text_insert = strsub(text_insert, 1, -commonlength - 1)
						text_delete = strsub(text_delete, 1, -commonlength - 1)
					end
				end
				-- Delete the offending records and add the merged ones.
				pointer = pointer - count_delete - count_insert
				for i = 1, count_delete + count_insert do
					tremove(diffs, pointer)
				end
				if #text_delete > 0 then
					tinsert(diffs, pointer, Diff.new(DIFF_DELETE, text_delete))
					pointer = pointer + 1
				end
				if #text_insert > 0 then
					tinsert(diffs, pointer, Diff.new(DIFF_INSERT, text_insert))
					pointer = pointer + 1
				end
				pointer = pointer + 1
			elseif pointer > 1 and diffs[pointer - 1][1] == DIFF_EQUAL then
				-- Merge this equality with the previous one.
				diffs[pointer - 1][2] = diffs[pointer - 1][2] .. diffs[pointer][2]
				tremove(diffs, pointer)
			else
				pointer = pointer + 1
			end
			count_insert, count_delete = 0, 0
			text_delete, text_insert = "", ""
		end
	end
	if diffs[#diffs][2] == "" then
		diffs[#diffs] = nil -- Remove the dummy entry at the end.
	end

	-- Second pass: look for single edits surrounded on both sides by equalities
	-- which can be shifted sideways to eliminate an equality.
	-- e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	local changes = false
	pointer = 2
	-- Intentionally ignore the first and last element (don't need checking).
	while pointer < #diffs do
		local prevDiff, nextDiff = diffs[pointer - 1], diffs[pointer + 1]
		if prevDiff[1] == DIFF_EQUAL and nextDiff[1] == DIFF_EQUAL then
			-- This is a single edit surrounded by equalities.
			local diff = diffs[pointer]
			local currentText = diff[2]
			local prevText = prevDiff[2]
			local nextText = nextDiff[2]
			if #prevText == 0 then
				tremove(diffs, pointer - 1)
				changes = true
			elseif strsub(currentText, -#prevText) == prevText then
				-- Shift the edit over the previous equality.
				diff[2] = prevText .. strsub(currentText, 1, -#prevText - 1)
				nextDiff[2] = prevText .. nextDiff[2]
				tremove(diffs, pointer - 1)
				changes = true
			elseif strsub(currentText, 1, #nextText) == nextText then
				-- Shift the edit over the next equality.
				prevDiff[2] = prevText .. nextText
				diff[2] = strsub(currentText, #nextText + 1) .. nextText
				tremove(diffs, pointer + 1)
				changes = true
			end
		end
		pointer = pointer + 1
	end
	-- If shifts were made, the diff needs reordering and another shift sweep.
	if changes then
		-- LUANOTE: no return value, but necessary to use 'return' to get
		-- tail calls.
		return _diff_cleanupMerge(diffs)
	end
	return
end

return {
	Diff = Diff,
	DIFF_EQUAL = DIFF_EQUAL,
	DIFF_DELETE = DIFF_DELETE,
	DIFF_INSERT = DIFF_INSERT,
	cleanupSemantic = diff_cleanupSemantic,

	-- private, used for testing only
	_diff_commonPrefix = _diff_commonPrefix,
	_diff_commonSuffix = _diff_commonSuffix,
	_diff_commonOverlap = _diff_commonOverlap,
	_diff_cleanupMerge = _diff_cleanupMerge,
	_diff_cleanupSemanticLossless = _diff_cleanupSemanticLossless,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="319">
              <Properties>
                <string name="Name">Constants</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/constants.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local NO_DIFF_MESSAGE = "Compared values have no visual difference."

local SIMILAR_MESSAGE = "Compared values serialize to the same structure.\n"
	.. "Printing internal object structure without calling `toJSON` instead."

return {
	NO_DIFF_MESSAGE = NO_DIFF_MESSAGE,
	SIMILAR_MESSAGE = SIMILAR_MESSAGE,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="320">
              <Properties>
                <string name="Name">DiffLines</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/diffLines.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

local diff = require(Packages.DiffSequences)

local CleanupSemantic = require(CurrentModule.CleanupSemantic)
local DIFF_DELETE = CleanupSemantic.DIFF_DELETE
local DIFF_EQUAL = CleanupSemantic.DIFF_EQUAL
local DIFF_INSERT = CleanupSemantic.DIFF_INSERT
local Diff = CleanupSemantic.Diff
type Diff = CleanupSemantic.Diff

local joinAlignedDiffsExpand = require(CurrentModule.JoinAlignedDiffs).joinAlignedDiffsExpand
local joinAlignedDiffsNoExpand = require(CurrentModule.JoinAlignedDiffs).joinAlignedDiffsNoExpand

local normalizeDiffOptions = require(CurrentModule.NormalizeDiffOptions).normalizeDiffOptions

local Types = require(CurrentModule.types)
type DiffOptions = Types.DiffOptions
type DiffOptionsNormalized = Types.DiffOptionsNormalized

local diffLinesRaw

local function isEmptyString(lines: { [number]: string }): boolean
	return #lines == 1 and #lines[1] == 0
end

export type ChangeCounts = { a: number, b: number }

local function countChanges(diffs: Array<Diff>): ChangeCounts
	local a = 0
	local b = 0

	for _, d in ipairs(diffs) do
		local case = d[1]
		if case == DIFF_DELETE then
			a += 1
		elseif case == DIFF_INSERT then
			b += 1
		end
	end

	return { a = a, b = b }
end

local function printAnnotation(options: DiffOptionsNormalized, changeCounts: ChangeCounts): string
	local aAnnotation = options.aAnnotation
	local aColor = options.aColor
	local aIndicator = options.aIndicator
	local bAnnotation = options.bAnnotation
	local bColor = options.bColor
	local bIndicator = options.bIndicator
	local includeChangeCounts = options.includeChangeCounts
	local omitAnnotationLines = options.omitAnnotationLines

	if omitAnnotationLines then
		return ""
	end

	local aRest = ""
	local bRest = ""

	if includeChangeCounts then
		local aCount = tostring(changeCounts.a)
		local bCount = tostring(changeCounts.b)

		-- Padding right aligns the ends of the annotations.
		local baAnnotationLengthDiff = #bAnnotation - #aAnnotation
		local aAnnotationPadding = string.rep(" ", math.max(0, baAnnotationLengthDiff))
		local bAnnotationPadding = string.rep(" ", math.max(0, -baAnnotationLengthDiff))

		-- Padding left aligns the ends of the counts.
		local baCountLengthDiff = #bCount - #aCount
		local aCountPadding = string.rep(" ", math.max(0, baCountLengthDiff))
		local bCountPadding = string.rep(" ", math.max(0, -baCountLengthDiff))

		aRest = aAnnotationPadding .. "  " .. aIndicator .. " " .. aCountPadding .. aCount
		bRest = bAnnotationPadding .. "  " .. bIndicator .. " " .. bCountPadding .. bCount
	end

	return aColor(aIndicator .. " " .. aAnnotation .. aRest)
		.. "\n"
		.. bColor(bIndicator .. " " .. bAnnotation .. bRest)
		.. "\n\n"
end

local function printDiffLines(diffs: Array<Diff>, options: DiffOptionsNormalized): string
	if options.expand then
		return printAnnotation(options, countChanges(diffs)) .. joinAlignedDiffsExpand(diffs, options)
	end
	return printAnnotation(options, countChanges(diffs)) .. joinAlignedDiffsNoExpand(diffs, options)
end

-- Compare two arrays of strings line-by-line. Format as comparison lines.
local function diffLinesUnified(
	aLines: { [number]: string },
	bLines: { [number]: string },
	options: DiffOptions?
): string
	if isEmptyString(aLines) then
		aLines = {}
	end
	if isEmptyString(bLines) then
		bLines = {}
	end

	return printDiffLines(diffLinesRaw(aLines, bLines), normalizeDiffOptions(options))
end

-- Given two pairs of arrays of strings:
-- Compare the pair of comparison arrays line-by-line.
-- Format the corresponding lines in the pair of displayable arrays.
local function diffLinesUnified2(
	aLinesDisplay: { [number]: string },
	bLinesDisplay: { [number]: string },
	aLinesCompare: { [number]: string },
	bLinesCompare: { [number]: string },
	options: DiffOptions?
): string
	if isEmptyString(aLinesDisplay) and isEmptyString(aLinesCompare) then
		aLinesDisplay = {}
		aLinesCompare = {}
	end
	if isEmptyString(bLinesDisplay) and isEmptyString(bLinesCompare) then
		bLinesDisplay = {}
		bLinesCompare = {}
	end

	if #aLinesDisplay ~= #aLinesCompare or #bLinesDisplay ~= #bLinesCompare then
		-- Fall back to diff of display lines.
		return diffLinesUnified(aLinesDisplay, bLinesDisplay, options)
	end

	local diffs = diffLinesRaw(aLinesCompare, bLinesCompare)

	-- Replace comparison lines with displayable lines.
	local aIndex = 0
	local bIndex = 0
	for _, d in ipairs(diffs) do
		local case = d[1]
		if case == DIFF_DELETE then
			d[2] = aLinesDisplay[aIndex + 1]
			aIndex += 1
		elseif case == DIFF_INSERT then
			d[2] = bLinesDisplay[bIndex + 1]
			bIndex += 1
		else
			d[2] = bLinesDisplay[bIndex + 1]
			aIndex += 1
			bIndex += 1
		end
	end

	return printDiffLines(diffs, normalizeDiffOptions(options))
end

-- Compare two arrays of strings line-by-line.
function diffLinesRaw(aLines: { [number]: string }, bLines: { [number]: string }): Array<Diff>
	local aLength = #aLines
	local bLength = #bLines

	local isCommon = function(aIndex: number, bIndex: number)
		return aLines[aIndex + 1] == bLines[bIndex + 1]
	end

	local diffs = {}
	local aIndex = 0
	local bIndex = 0

	local foundSubsequence = function(nCommon: number, aCommon: number, bCommon: number)
		while aIndex ~= aCommon do
			table.insert(diffs, Diff.new(DIFF_DELETE, aLines[aIndex + 1]))
			aIndex += 1
		end
		while bIndex ~= bCommon do
			table.insert(diffs, Diff.new(DIFF_INSERT, bLines[bIndex + 1]))
			bIndex += 1
		end
		while nCommon ~= 0 do
			table.insert(diffs, Diff.new(DIFF_EQUAL, bLines[bIndex + 1]))
			nCommon -= 1
			aIndex += 1
			bIndex += 1
		end
	end

	diff(aLength, bLength, isCommon, foundSubsequence)

	-- After the last common subsequence, push remaining change items.
	while aIndex ~= aLength do
		table.insert(diffs, Diff.new(DIFF_DELETE, aLines[aIndex + 1]))
		aIndex += 1
	end
	while bIndex ~= bLength do
		table.insert(diffs, Diff.new(DIFF_INSERT, bLines[bIndex + 1]))
		bIndex += 1
	end

	return diffs
end

return {
	printDiffLines = printDiffLines,
	diffLinesUnified = diffLinesUnified,
	diffLinesUnified2 = diffLinesUnified2,
	diffLinesRaw = diffLinesRaw,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="321">
              <Properties>
                <string name="Name">DiffStrings</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/diffStrings.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

local diffSequences = require(Packages.DiffSequences)

local CleanupSemantic = require(CurrentModule.CleanupSemantic)
local DIFF_DELETE = CleanupSemantic.DIFF_DELETE
local DIFF_EQUAL = CleanupSemantic.DIFF_EQUAL
local DIFF_INSERT = CleanupSemantic.DIFF_INSERT
local Diff = CleanupSemantic.Diff
type Diff = CleanupSemantic.Diff

return function(a: string, b: string): Array<Diff>
	local isCommon = function(aIndex: number, bIndex: number)
		return a:sub(aIndex + 1, aIndex + 1) == b:sub(bIndex + 1, bIndex + 1)
	end

	local aIndex = 0
	local bIndex = 0
	local diffs = {}

	local foundSubsequence = function(nCommon: number, aCommon: number, bCommon: number)
		if aIndex ~= aCommon then
			table.insert(diffs, Diff.new(DIFF_DELETE, a:sub(aIndex + 1, aCommon)))
		end
		if bIndex ~= bCommon then
			table.insert(diffs, Diff.new(DIFF_INSERT, b:sub(bIndex + 1, bCommon)))
		end

		aIndex = aCommon + nCommon -- number of characters compared in a
		bIndex = bCommon + nCommon -- number of characters compared in b
		table.insert(diffs, Diff.new(DIFF_EQUAL, b:sub(bCommon + 1, bIndex)))
	end

	diffSequences(#a, #b, isCommon, foundSubsequence)

	-- After the last common subsequence, push remaining change items.
	if aIndex ~= #a then
		table.insert(diffs, Diff.new(DIFF_DELETE, a:sub(aIndex + 1)))
	end
	if bIndex ~= #b then
		table.insert(diffs, Diff.new(DIFF_INSERT, b:sub(bIndex + 1)))
	end

	return diffs
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="322">
              <Properties>
                <string name="Name">GetAlignedDiffs</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/getAlignedDiffs.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

local CleanupSemantic = require(CurrentModule.CleanupSemantic)
local DIFF_DELETE = CleanupSemantic.DIFF_DELETE
local DIFF_EQUAL = CleanupSemantic.DIFF_EQUAL
local DIFF_INSERT = CleanupSemantic.DIFF_INSERT
local Diff = CleanupSemantic.Diff
type Diff = CleanupSemantic.Diff

local Types = require(CurrentModule.types)
type DiffOptionsColor = Types.DiffOptionsColor

-- Given change op and array of diffs, return concatenated string:
-- * include common strings
-- * include change strings which have argument op with changeColor
-- * exclude change strings which have opposite op
local function concatenateRelevantDiffs(op: number, diffs: Array<Diff>, changeColor: DiffOptionsColor): string
	return Array.reduce(diffs, function(
		-- ROBLOX FIXME Luau: should be inferred from reduce's initial value
		reduced: string,
		diff
	)
		if diff[1] == DIFF_EQUAL then
			return reduced .. diff[2]
		elseif diff[1] == op and #diff[2] ~= 0 then -- empty if change is newline
			return reduced .. changeColor(diff[2])
		end
		return reduced .. ""
	end, "")
end

export type ChangeBuffer = {
	op: number,
	line: Array<Diff>,
	lines: Array<Diff>,
	changeColor: DiffOptionsColor,
	pushSubstring: (self: ChangeBuffer, substring: string) -> (),
	pushLine: (self: ChangeBuffer) -> (),
	isLineEmpty: (self: ChangeBuffer) -> boolean,
	pushDiff: (self: ChangeBuffer, diff: Diff) -> (),
	align: (self: ChangeBuffer, diff: Diff) -> (),
	moveLinesTo: (self: ChangeBuffer, lines: Array<Diff>) -> (),
}

-- Encapsulate change lines until either a common newline or the end.
local ChangeBuffer = {}
ChangeBuffer.__index = ChangeBuffer
function ChangeBuffer.new(op: number, changeColor: DiffOptionsColor): ChangeBuffer
	local self = (setmetatable({}, ChangeBuffer) :: any) :: ChangeBuffer
	self.op = op
	self.line = {}
	self.lines = {}
	self.changeColor = changeColor

	return self
end

function ChangeBuffer:pushSubstring(substring: string): ()
	self:pushDiff(Diff.new(self.op, substring))
end

function ChangeBuffer:pushLine(): ()
	-- Assume call only if line has at least one diff,
	-- therefore an empty line must have a diff which has an empty string.

	-- If line has multiple diffs, then assume it has a common diff,
	-- therefore change diffs have change color;
	-- otherwise then it has line color only.
	table.insert(
		self.lines,
		if #self.line ~= 1
			then Diff.new(self.op, concatenateRelevantDiffs(self.op, self.line, self.changeColor))
			else if self.line[1][1] == self.op
				then self.line[1] -- can use instance
				else Diff.new(self.op, self.line[1][2]) -- was common diff
	)
	self.line = {}
end

function ChangeBuffer:isLineEmpty(): boolean
	return #self.line == 0
end

-- Minor input to buffer.
function ChangeBuffer:pushDiff(diff: Diff): ()
	table.insert(self.line, diff)
end

-- Main input to buffer.
function ChangeBuffer:align(diff: Diff): ()
	local s = diff[2]

	if s:match("\n") then
		local substrings = s:split("\n")
		-- ROBLOX deviation: 1-indexing
		local iLast = #substrings
		for i, substring in ipairs(substrings) do
			if i < iLast then
				-- The first substring completes the current change line.
				-- A middle substring is a change line.
				self:pushSubstring(substring)
				self:pushLine()
			elseif #substring ~= 0 then
				-- The last substring starts a change line, if it is not empty.
				-- Important: This non-empty condition also automatically omits
				-- the newline appended to the end of expected and received strings.
				self:pushSubstring(substring)
			end
		end
	else
		-- Append non-multiline string to current change line.
		self:pushDiff(diff)
	end
end

-- Output from buffer.
function ChangeBuffer:moveLinesTo(lines: Array<Diff>): ()
	if not self:isLineEmpty() then
		self:pushLine()
	end

	for _, value in ipairs(self.lines) do
		table.insert(lines, value)
	end
	self.lines = {}
end

-- Encapsulate common and change lines
local CommonBuffer = {}
CommonBuffer.__index = CommonBuffer
function CommonBuffer.new(deleteBuffer, insertBuffer)
	local self = {}
	self.deleteBuffer = deleteBuffer
	self.insertBuffer = insertBuffer
	self.lines = {}
	setmetatable(self, CommonBuffer)
	return self
end

function CommonBuffer:pushDiffCommonLine(diff: Diff): ()
	table.insert(self.lines, diff)
end

function CommonBuffer:pushDiffChangeLines(diff: Diff): ()
	local isDiffEmpty = #diff[2] == 0

	-- An empty diff string is redundant, unless a change line is empty.
	if not isDiffEmpty or self.deleteBuffer:isLineEmpty() then
		self.deleteBuffer:pushDiff(diff)
	end
	if not isDiffEmpty or self.insertBuffer:isLineEmpty() then
		self.insertBuffer:pushDiff(diff)
	end
end

function CommonBuffer:flushChangeLines(): ()
	self.deleteBuffer:moveLinesTo(self.lines)
	self.insertBuffer:moveLinesTo(self.lines)
end

function CommonBuffer:align(diff: Diff): ()
	local op = diff[1]
	local s = diff[2]

	if s:match("\n") then
		local substrings = s:split("\n")
		-- ROBLOX deviation: 1-indexing
		local iLast = #substrings
		for i, substring in ipairs(substrings) do
			if i == 1 then
				local subdiff = Diff.new(op, substring)
				if self.deleteBuffer:isLineEmpty() and self.insertBuffer:isLineEmpty() then
					-- If both current change lines are empty,
					-- then the first substring is a common line.
					self:flushChangeLines()
					self:pushDiffCommonLine(subdiff)
				else
					-- If either current change line is non-empty,
					-- then the first substring completes the change lines.
					self:pushDiffChangeLines(subdiff)
					self:flushChangeLines()
				end
			elseif i < iLast then
				-- A middle substring is a common line.
				self:pushDiffCommonLine(Diff.new(op, substring))
			elseif #substring ~= 0 then
				-- The last substring starts a change line, if it is not empty.
				-- Important: This non-empty condition also automatically omits
				-- the newline appended to the end of expected and received strings.
				self:pushDiffChangeLines(Diff.new(op, substring))
			end
		end
	else
		-- Append non-multiline string to current change lines.
		-- Important: It cannot be at the end following empty change lines,
		-- because newline appended to the end of expected and received strings.
		self:pushDiffChangeLines(diff)
	end
end

function CommonBuffer:getLines(): Array<Diff>
	self:flushChangeLines()
	return self.lines
end

-- Given diffs from expected and received strings,
-- return new array of diffs split or joined into lines.
--
-- To correctly align a change line at the end, the algorithm:
-- * assumes that a newline was appended to the strings
-- * omits the last newline from the output array
--
-- Assume the function is not called:
-- * if either expected or received is empty string
-- * if neither expected nor received is multiline string
return function(diffs: Array<Diff>, changeColor: DiffOptionsColor): Array<Diff>
	local deleteBuffer = ChangeBuffer.new(DIFF_DELETE, changeColor)
	local insertBuffer = ChangeBuffer.new(DIFF_INSERT, changeColor)
	-- ROBLOX FIXME Luau: another issue with normalization: Property 'deleteBuffer' is not compatible
	local commonBuffer = CommonBuffer.new(deleteBuffer, insertBuffer) :: any

	for _, diff in ipairs(diffs) do
		local case = diff[1]
		if case == DIFF_DELETE then
			deleteBuffer:align(diff)
		elseif case == DIFF_INSERT then
			insertBuffer:align(diff)
		else
			commonBuffer:align(diff)
		end
	end

	return commonBuffer:getLines()
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="323">
              <Properties>
                <string name="Name">JoinAlignedDiffs</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/joinAlignedDiffs.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

local CleanupSemantic = require(CurrentModule.CleanupSemantic)
local DIFF_DELETE = CleanupSemantic.DIFF_DELETE
local DIFF_EQUAL = CleanupSemantic.DIFF_EQUAL
local DIFF_INSERT = CleanupSemantic.DIFF_INSERT
type Diff = CleanupSemantic.Diff

local Types = require(CurrentModule.types)
type DiffOptionsNormalized = Types.DiffOptionsNormalized
type DiffOptionsColor = Types.DiffOptionsColor

local function formatTrailingSpaces(line: string, trailingSpaceFormatter: DiffOptionsColor): string
	return line:gsub("%s+$", function(s)
		return trailingSpaceFormatter(s)
	end)
end

local function printDiffLine(
	line: string,
	isFirstOrLast: boolean,
	color: DiffOptionsColor,
	indicator: string,
	trailingSpaceFormatter: DiffOptionsColor,
	emptyFirstOrLastLinePlaceholder: string
): string
	if #line ~= 0 then
		return color(indicator .. " " .. formatTrailingSpaces(line, trailingSpaceFormatter))
	elseif indicator ~= " " then
		return color(indicator)
	elseif isFirstOrLast and #emptyFirstOrLastLinePlaceholder ~= 0 then
		return color(indicator .. " " .. emptyFirstOrLastLinePlaceholder)
	end
	return ""
end

local function printDeleteLine(line: string, isFirstOrLast: boolean, options: DiffOptionsNormalized): string
	return printDiffLine(
		line,
		isFirstOrLast,
		options.aColor,
		options.aIndicator,
		options.changeLineTrailingSpaceColor,
		options.emptyFirstOrLastLinePlaceholder
	)
end

local function printInsertLine(line: string, isFirstOrLast: boolean, options: DiffOptionsNormalized): string
	return printDiffLine(
		line,
		isFirstOrLast,
		options.bColor,
		options.bIndicator,
		options.changeLineTrailingSpaceColor,
		options.emptyFirstOrLastLinePlaceholder
	)
end

local function printCommonLine(line: string, isFirstOrLast: boolean, options: DiffOptionsNormalized): string
	return printDiffLine(
		line,
		isFirstOrLast,
		options.commonColor,
		options.commonIndicator,
		options.commonLineTrailingSpaceColor,
		options.emptyFirstOrLastLinePlaceholder
	)
end

-- In GNU diff format, indexes are one-based instead of zero-based.
local function createPatchMark(
	aStart: number,
	aEnd: number,
	bStart: number,
	bEnd: number,
	options: DiffOptionsNormalized
): string
	return options.patchColor(
		string.format("@@ -%d,%d +%d,%d @@", aStart + 1, aEnd - aStart, bStart + 1, bEnd - bStart)
	)
end

-- jest --no-expand
--
-- Given array of aligned strings with inverse highlight formatting,
-- return joined lines with diff formatting (and patch marks, if needed).
local function joinAlignedDiffsNoExpand(diffs: Array<Diff>, options: DiffOptionsNormalized): string
	local iLength = #diffs
	local nContextLines = options.contextLines
	local nContextLines2 = nContextLines + nContextLines

	-- First pass: count output lines and see if it has patches.
	local jLength = iLength
	local hasExcessAtStartOrEnd = false
	local nExcessesBetweenChanges = 0
	local i = 0
	while i ~= iLength do
		local iStart = i
		while i ~= iLength and diffs[i + 1][1] == DIFF_EQUAL do
			i += 1
		end

		if iStart ~= i then
			if iStart == 0 then
				-- at start
				if i > nContextLines then
					jLength -= i - nContextLines -- subtract excess common lines
					hasExcessAtStartOrEnd = true
				end
			elseif i == iLength then
				-- at end
				local n = i - iStart
				if n > nContextLines then
					jLength -= n - nContextLines -- subtract excess common lines
					hasExcessAtStartOrEnd = true
				end
			else
				-- between changes
				local n = i - iStart
				if n > nContextLines2 then
					jLength -= n - nContextLines2 -- subtract excess common lines
					nExcessesBetweenChanges += 1
				end
			end
		end

		while i ~= iLength and diffs[i + 1][1] ~= DIFF_EQUAL do
			i += 1
		end
	end

	local hasPatch = nExcessesBetweenChanges ~= 0 or hasExcessAtStartOrEnd
	if nExcessesBetweenChanges ~= 0 then
		jLength += nExcessesBetweenChanges + 1 -- add patch lines
	elseif hasExcessAtStartOrEnd then
		jLength += 1 -- add patch line
	end
	local jLast = jLength - 1

	local lines: { [number]: string } = {}

	local jPatchMark = 0 -- index of placeholder line for current patch mark
	if hasPatch then
		table.insert(lines, "") -- placeholder line for first patch mark
	end

	-- Indexes of expected or received lines in current patch:
	local aStart = 0
	local bStart = 0
	local aEnd = 0
	local bEnd = 0

	local pushCommonLine = function(line: string): ()
		local j = #lines
		table.insert(lines, printCommonLine(line, j == 0 or j == jLast, options))
		aEnd += 1
		bEnd += 1
	end

	local pushDeleteLine = function(line: string): ()
		local j = #lines
		table.insert(lines, printDeleteLine(line, j == 0 or j == jLast, options))
		aEnd += 1
	end

	local pushInsertLine = function(line: string): ()
		local j = #lines
		table.insert(lines, printInsertLine(line, j == 0 or j == jLast, options))
		bEnd += 1
	end

	-- Second pass: push lines with diff formatting (and patch marks, if needed).
	i = 0
	while i ~= iLength do
		local iStart = i
		while i ~= iLength and diffs[i + 1][1] == DIFF_EQUAL do
			i += 1
		end

		if iStart ~= i then
			if iStart == 0 then
				-- at beginning
				if i > nContextLines then
					iStart = i - nContextLines
					aStart = iStart
					bStart = iStart
					aEnd = aStart
					bEnd = bStart
				end

				local iCommon = iStart
				while iCommon ~= i do
					pushCommonLine(diffs[iCommon + 1][2])
					iCommon += 1
				end
			elseif i == iLength then
				-- at end
				local iEnd = i
				if i - iStart > nContextLines then
					iEnd = iStart + nContextLines
				end

				local iCommon = iStart
				while iCommon ~= iEnd do
					pushCommonLine(diffs[iCommon + 1][2])
					iCommon += 1
				end
			else
				-- between changes
				local nCommon = i - iStart

				if nCommon > nContextLines2 then
					local iEnd = iStart + nContextLines

					local iCommon = iStart
					while iCommon ~= iEnd do
						pushCommonLine(diffs[iCommon + 1][2])
						iCommon += 1
					end

					lines[jPatchMark + 1] = createPatchMark(aStart, aEnd, bStart, bEnd, options)
					jPatchMark = #lines
					table.insert(lines, "") -- placeholder line for next patch mark

					local nOmit = nCommon - nContextLines2
					aStart = aEnd + nOmit
					bStart = bEnd + nOmit
					aEnd = aStart
					bEnd = bStart

					iCommon = i - nContextLines
					while iCommon ~= i do
						pushCommonLine(diffs[iCommon + 1][2])
						iCommon += 1
					end
				else
					local iCommon = iStart
					while iCommon ~= i do
						pushCommonLine(diffs[iCommon + 1][2])
						iCommon += 1
					end
				end
			end
		end

		while i ~= iLength and diffs[i + 1][1] == DIFF_DELETE do
			pushDeleteLine(diffs[i + 1][2])
			i += 1
		end

		while i ~= iLength and diffs[i + 1][1] == DIFF_INSERT do
			pushInsertLine(diffs[i + 1][2])
			i += 1
		end
	end

	if hasPatch then
		lines[jPatchMark + 1] = createPatchMark(aStart, aEnd, bStart, bEnd, options)
	end

	return table.concat(lines, "\n")
end

-- jest --expand
--
-- Given array of aligned strings with inverse highlight formatting,
-- return joined lines with diff formatting.
local function joinAlignedDiffsExpand(diffs: Array<Diff>, options: DiffOptionsNormalized): string
	return table.concat(
		Array.map(diffs, function(diff, i: number, diffs_: { [number]: any }): string
			local line = diff[2]
			-- ROBLOX deviation: 1-indexing
			local isFirstOrLast = i == 1 or i == #diffs_

			local case = diff[1] :: number
			if case == DIFF_DELETE then
				return printDeleteLine(line, isFirstOrLast, options)
			elseif case == DIFF_INSERT then
				return printInsertLine(line, isFirstOrLast, options)
			else
				return printCommonLine(line, isFirstOrLast, options)
			end
		end),
		"\n"
	)
end

return {
	joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand,
	joinAlignedDiffsExpand = joinAlignedDiffsExpand,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="324">
              <Properties>
                <string name="Name">NormalizeDiffOptions</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/normalizeDiffOptions.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Number = LuauPolyfill.Number
local Object = LuauPolyfill.Object

local chalk = require(Packages.ChalkLua)
-- ROBLOX TODO: fix PrettyFormat types imports
type CompareKeys = ((a: string, b: string) -> number) | nil

local Types = require(CurrentModule.types)
type DiffOptions = Types.DiffOptions
type DiffOptionsNormalized = Types.DiffOptionsNormalized

local function noColor(s): string
	return s
end

local DIFF_CONTEXT_DEFAULT = 5

local OPTIONS_DEFAULT = {
	aAnnotation = "Expected",
	aColor = chalk.green,
	aIndicator = "-",
	bAnnotation = "Received",
	bColor = chalk.red,
	bIndicator = "+",
	changeColor = chalk.inverse,
	changeLineTrailingSpaceColor = noColor,
	commonColor = chalk.dim,
	commonIndicator = " ",
	commonLineTrailingSpaceColor = noColor,
	-- ROBLOX deviation: using Object.None instead of nil because assigning nil is no different from not assigning value at all
	compareKeys = Object.None,
	contextLines = DIFF_CONTEXT_DEFAULT,
	emptyFirstOrLastLinePlaceholder = "",
	expand = true,
	includeChangeCounts = false,
	omitAnnotationLines = false,
	patchColor = chalk.yellow,
}

local function getCompareKeys(compareKeys: CompareKeys?): CompareKeys
	return if compareKeys and typeof(compareKeys) == "function" then compareKeys else OPTIONS_DEFAULT.compareKeys
end

local function getContextLines(contextLines: number?): number
	if typeof(contextLines) == "number" and Number.isSafeInteger(contextLines) and contextLines >= 0 then
		return contextLines
	end
	return DIFF_CONTEXT_DEFAULT
end

-- Pure function returns options with all properties.
local function normalizeDiffOptions(options_: DiffOptions?): DiffOptionsNormalized
	-- ROBLOX FIXME Luau: needs a normalization fix to avoid Key 'compareKeys' is missing from '{  }' in the type 'DiffOptions | {  }'
	local options = if options_ then options_ else {} :: DiffOptions
	return Object.assign({}, OPTIONS_DEFAULT, options, {
		compareKeys = getCompareKeys(options.compareKeys),
		contextLines = getContextLines(options.contextLines),
	}) :: DiffOptionsNormalized
end

return {
	noColor = noColor,
	normalizeDiffOptions = normalizeDiffOptions,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="325">
              <Properties>
                <string name="Name">PrettyFormat</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream
-- ROBLOX TODO: fix PrettyFormat types imports

type CompareKeys = ((a: string, b: string) -> number) | nil

type Plugin = any

export type Plugins = { [number]: Plugin }

type ThemeReceived = {
	comment: string?,
	content: string?,
	prop: string?,
	tag: string?,
	value: string?,
}

export type PrettyFormatOptions = {
	callToJSON: boolean?,
	compareKeys: CompareKeys,
	escapeRegex: boolean?,
	escapeString: boolean?,
	highlight: boolean?,
	indent: number?,
	maxDepth: number?,
	min: boolean?,
	plugins: Plugins?,
	printBasicPrototype: boolean?,
	printInstanceDefaults: boolean?,
	printFunctionName: boolean?,
	redactStackTracesInStrings: boolean?,
	theme: ThemeReceived?,
}

export type OptionsReceived = PrettyFormatOptions

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="326">
              <Properties>
                <string name="Name">PrintDiffs</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/printDiffs.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

local CleanupSemantic = require(CurrentModule.CleanupSemantic)
local DIFF_EQUAL = CleanupSemantic.DIFF_EQUAL
local cleanupSemantic = CleanupSemantic.cleanupSemantic
type Diff = CleanupSemantic.Diff

local DiffLines = require(CurrentModule.DiffLines)
local diffLinesUnified = DiffLines.diffLinesUnified
local printDiffLines = DiffLines.printDiffLines

local diffStrings = require(CurrentModule.DiffStrings)

local getAlignedDiffs = require(CurrentModule.GetAlignedDiffs)

local normalizeDiffOptions = require(CurrentModule.NormalizeDiffOptions).normalizeDiffOptions

local Types = require(CurrentModule.types)
type DiffOptions = Types.DiffOptions

local diffStringsRaw

local function hasCommonDiff(diffs: Array<Diff>, isMultiline: boolean): boolean
	if isMultiline then
		-- Important: Ignore common newline that was appended to multiline strings!
		local iLast = #diffs
		return Array.some(diffs, function(diff, i)
			return diff[1] == DIFF_EQUAL and (i ~= iLast or diff[2] ~= "\n")
		end)
	end

	return Array.some(diffs, function(diff)
		return diff[1] == DIFF_EQUAL
	end)
end

-- Compare two strings character-by-character.
-- Format as comparison lines in which changed substrings have inverse colors.
local function diffStringsUnified(a: string, b: string, options: DiffOptions?): string
	if a ~= b and #a ~= 0 and #b ~= 0 then
		local isMultiline = a:find("\n") ~= nil or b:find("\n") ~= nil

		-- getAlignedDiffs assumes that a newline was appended to the strings.
		local diffs = diffStringsRaw(
			isMultiline and a .. "\n" or a,
			isMultiline and b .. "\n" or b,
			true -- cleanupSemantic
		)

		if hasCommonDiff(diffs, isMultiline) then
			local optionsNormalized = normalizeDiffOptions(options)
			local lines = getAlignedDiffs(diffs, optionsNormalized.changeColor)
			return printDiffLines(lines, optionsNormalized)
		end
	end

	-- Fall back to line-by-line diff.
	return diffLinesUnified(a:split("\n"), b:split("\n"), options)
end

-- Compare two strings character-by-character.
-- Optionally clean up small common substrings, also known as chaff.
function diffStringsRaw(a: string, b: string, cleanup: boolean): Array<Diff>
	local diffs = diffStrings(a, b)

	if cleanup then
		cleanupSemantic(diffs) -- impure function
	end

	return diffs
end

return {
	diffStringsUnified = diffStringsUnified,
	diffStringsRaw = diffStringsRaw,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="327">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-diff/src/types.ts
--[[*
	* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
]]

-- ROBLOX TODO: fix PrettyFormat types imports
type CompareKeys = ((a: string, b: string) -> number) | nil

export type DiffOptionsColor = (string) -> string

export type DiffOptions = {
	aAnnotation: string?,
	aColor: DiffOptionsColor?,
	aIndicator: string?,
	bAnnotation: string?,
	bColor: DiffOptionsColor?,
	bIndicator: string?,
	changeColor: DiffOptionsColor?,
	changeLineTrailingSpaceColor: DiffOptionsColor?,
	commonColor: DiffOptionsColor?,
	commonIndicator: string?,
	commonLineTrailingSpaceColor: DiffOptionsColor?,
	contextLines: number?,
	emptyFirstOrLastLinePlaceholder: string?,
	expand: boolean?,
	includeChangeCounts: boolean?,
	omitAnnotationLines: boolean?,
	patchColor: DiffOptionsColor?,
	compareKeys: CompareKeys?,
}

export type DiffOptionsNormalized = {
	aAnnotation: string,
	aColor: DiffOptionsColor,
	aIndicator: string,
	bAnnotation: string,
	bColor: DiffOptionsColor,
	bIndicator: string,
	changeColor: DiffOptionsColor,
	changeLineTrailingSpaceColor: DiffOptionsColor,
	commonColor: DiffOptionsColor,
	commonIndicator: string,
	commonLineTrailingSpaceColor: DiffOptionsColor,
	compareKeys: CompareKeys,
	contextLines: number,
	emptyFirstOrLastLinePlaceholder: string,
	expand: boolean,
	includeChangeCounts: boolean,
	omitAnnotationLines: boolean,
	patchColor: DiffOptionsColor,
}

return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="328">
            <Properties>
              <string name="Name">JestEach</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-each/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]

local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object

type ReturnType<T> = any

local NIL = require(script.nilPlaceholder)

local exports = {}

local typesModule = require(Packages.JestTypes)
type Global_BlockFn = typesModule.Global_BlockFn
type Global_Global = typesModule.Global_Global
type Global_EachTable = typesModule.Global_EachTable
type Global_EachTestFn<EachCallback> = typesModule.Global_EachTestFn<EachCallback>
type Global_TemplateData = typesModule.Global_TemplateData
type Global_TestFn = typesModule.Global_TestFn

local bind = require(script.bind).default

type Global = Global_Global

local function install(
	g: Global_Global,
	table_: Global_EachTable,
	...: any --[[ ROBLOX deviation: Upstream array type <Global.TemplateData>. Element type : unknown ]]
)
	local data = if select("#", ...) > 0 then { ... } else {}

	local bindingWithArray = #data == 0
	local bindingWithTemplate = Array.isArray(table_) and Boolean.toJSBoolean((table_ :: any).raw)
	if not bindingWithArray and not bindingWithTemplate then
		error(Error.new("`.each` must only be called with an Array or Tagged Template Literal."))
	end
	local test = setmetatable({}, {
		__call = function(_self, title: string, test: Global_EachTestFn<Global_TestFn>, timeout: number?)
			return bind(g.test)(table_, table.unpack(data))(title, test, timeout)
		end,
	})

	test.skip = bind(if g.test then g.test.skip else nil)(table_, table.unpack(data))
	test.only = bind(if g.test then g.test.only else nil)(table_, table.unpack(data))

	-- ROBLOX TODO: concurrent not available
	-- local testConcurrent = setmetatable({
	-- }, {
	-- 	__call = function(_self, title: string, test: Global_EachTestFn<Global_TestFn>, timeout: number?)
	-- 		return bind(g.test.concurrent)(table_, table.unpack(data))(title, test, timeout)
	-- 	end,
	-- })
	-- 	test.concurrent = testConcurrent,
	-- 	test.only = bind(g.test.concurrent.only)(table_, table.unpack(data)),
	-- 	test.skip = bind(g.test.concurrent.skip)(table_, table.unpack(data)),

	local it = setmetatable({}, {
		__call = function(_self, title: string, test: Global_EachTestFn<Global_TestFn>, timeout: number?)
			return bind(g.it)(table_, table.unpack(data))(title, test, timeout)
		end,
	})

	it.skip = bind(if g.it then g.it.skip else nil)(table_, table.unpack(data))
	it.only = bind(if g.it then g.it.only else nil)(table_, table.unpack(data))

	-- ROBLOX TODO: concurrent not available
	-- it.concurrent = testConcurrent;

	local xit = bind(g.xit)(table_, table.unpack(data))
	local fit = bind(g.fit)(table_, table.unpack(data))
	local xtest = bind(g.xtest)(table_, table.unpack(data))

	local describe = setmetatable({}, {
		__call = function(_self, title: string, suite: Global_EachTestFn<Global_BlockFn>, timeout: number?)
			return bind(g.describe, false)(table_, table.unpack(data))(title, suite, timeout)
		end,
	})

	describe.skip = bind(if g.describe then g.describe.skip else nil, false)(table_, table.unpack(data))
	describe.only = bind(if g.describe then g.describe.only else nil, false)(table_, table.unpack(data))

	local fdescribe = bind(g.fdescribe, false)(table_, table.unpack(data))
	local xdescribe = bind(g.xdescribe, false)(table_, table.unpack(data))

	-- ROBLOX deviation START: support testEZ methods
	local testSKIP = bind(g.testSKIP)(table_, table.unpack(data))
	local testFOCUS = bind(g.testFOCUS)(table_, table.unpack(data))
	local itSKIP = bind(g.itSKIP)(table_, table.unpack(data))
	local itFOCUS = bind(g.itFOCUS)(table_, table.unpack(data))
	local describeSKIP = bind(g.describeSKIP, false)(table_, table.unpack(data))
	local describeFOCUS = bind(g.describeFOCUS, false)(table_, table.unpack(data))
	-- ROBLOX deviation END

	return {
		describe = describe,
		fdescribe = fdescribe,
		fit = fit,
		it = it,
		test = test,
		xdescribe = xdescribe,
		xit = xit,
		xtest = xtest,
		-- ROBLOX deviation START: support TestEZ methods
		describeSKIP = describeSKIP,
		describeFOCUS = describeFOCUS,
		itSKIP = itSKIP,
		itFOCUS = itFOCUS,
		testSKIP = testSKIP,
		testFOCUS = testFOCUS,
		-- ROBLOX deviation END
	}
end

-- ROBLOX deviation START: handle template data
local function maybeHandleTemplateString(table_: any): Global_EachTable
	if typeof(table_) == "string" then
		local templateString = table_ :: string
		local raw = templateString
		local strings = {}
		local expressions = {}
		local startIndex = 1
		local endIndex = 1
		local expressionStarted = false
		for i = 1, #templateString do
			local current = string.sub(templateString, i, i)
			local next = if i < #templateString then string.sub(templateString, i + 1, i + 1) else nil
			if i == #templateString then
				if expressionStarted then
					error("expression not closed")
				end
				table.insert(strings, string.sub(templateString, startIndex))
			elseif not expressionStarted and current == "$" then
				if next == "{" then
					expressionStarted = true
					endIndex = i - 1
				end
			elseif expressionStarted and current == "}" then
				local str = string.sub(templateString, startIndex, endIndex)
				local exp = string.sub(templateString, endIndex + 3, i - 1)
				table.insert(strings, str)
				table.insert(expressions, exp)
				startIndex = i + 1
				expressionStarted = false
			end
		end

		return (setmetatable(strings, {
			__index = {
				raw = raw,
			},
		}) :: any) :: Global_EachTable
	else
		return table_
	end
end
-- ROBLOX deviation END

-- ROBLOX deviation: wrap in function to pass jests methods (it, describe, etc)
local each = function(jestMethods_: Object?)
	local jestMethods = (if jestMethods_ ~= nil then jestMethods_ else {}) :: Object
	--[[
		ROBLOX deviation START: TestEZ it/test/describe are functions, make them callable objects
		to handle them the same way as jest's API and support both.
	]]
	Array.forEach(Object.keys(jestMethods), function(key)
		local maybeMethod = jestMethods[key]
		jestMethods[key] = if typeof(maybeMethod) == "function"
			then setmetatable({}, {
				__call = function(_self, ...)
					return maybeMethod(...)
				end,
			})
			else maybeMethod
	end)
	-- ROBLOX deviation END
	return setmetatable({
		withGlobal = function(g: Global)
			return function(table_: Global_EachTable, ...)
				return install(g, maybeHandleTemplateString(table_), ...)
			end
		end,
	}, {
		__call = function(_self, table_: Global_EachTable, ...): ReturnType<typeof(install)>
			-- ROBLOX deviation: jestMethods, are passed as parameters, not taken from global
			return install(jestMethods :: Global, maybeHandleTemplateString(table_), ...)
		end,
	})
end

exports.bind = bind

exports.default = each

exports.NIL = NIL

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="329">
              <Properties>
                <string name="Name">bind</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-each/src/bind.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]
local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>

local NIL = require(script.Parent.nilPlaceholder)

local exports = {}

local typesModule = require(Packages.JestTypes)
type Global_ConcurrentTestFn = typesModule.Global_ConcurrentTestFn
type Global_EachTable = typesModule.Global_EachTable
type Global_EachTestFn<EachCallback> = typesModule.Global_EachTestFn<EachCallback>
type Global_TemplateData = typesModule.Global_TemplateData
type Global_ArrayTable = typesModule.Global_ArrayTable
type Global_DoneFn = typesModule.Global_DoneFn

local jestutilModule = require(Packages.JestUtil)
local ErrorWithStack = jestutilModule.ErrorWithStack
local convertDescriptorToString = jestutilModule.convertDescriptorToString

local convertArrayTable = require(script.Parent.table.array).default
local convertTemplateTable = require(script.Parent.table.template).default
local validationModule = require(script.Parent.validation)
local extractValidTemplateHeadings = validationModule.extractValidTemplateHeadings
local validateArrayTable = validationModule.validateArrayTable
local validateTemplateTableArguments = validationModule.validateTemplateTableArguments

-- ROBLOX deviation: add function to handle unavailable methods
local unavailableFn: GlobalCallback = function()
	error("Method unavailable")
end

-- ROBLOX deviation: predefine variables
local isArrayTable, buildArrayTests, buildTemplateTests, getHeadingKeys, applyArguments

export type EachTests = Array<{
	title: string,
	arguments: Array<any>,
}>

-- type TestFn = (done?: Global.DoneFn) => Promise<any> | void | undefined;
type GlobalCallbackFn = (testName: string, fn: Global_ConcurrentTestFn, timeout: number?) -> ()
type GlobalCallback = GlobalCallbackFn | typeof(setmetatable({}, {
	__call = function(_, testName: string, fn: Global_ConcurrentTestFn, timeout: number?): () end,
}))

-- ROBLOX TODO: add type constraint <EachCallback extends Global.TestCallback>
local function default<EachCallback>(cb_: GlobalCallback?, supportsDone_: boolean?)
	local supportsDone = if supportsDone_ ~= nil then supportsDone_ else true
	local cb = cb_ or unavailableFn
	return function(
		table_: Global_EachTable,
		...: any --[[ ROBLOX comment: Upstream type: <Global.TemplateData> (Array<unknown>) ]]
	)
		local taggedTemplateData = if select("#", ...) > 0 then { ... } else {}

		local function eachBind(title: string, test: Global_EachTestFn<EachCallback>, timeout: number?): ()
			title = convertDescriptorToString(title)

			local ok, result = pcall(function()
				local tests = if isArrayTable(taggedTemplateData)
					then buildArrayTests(title, table_)
					else buildTemplateTests(title, table_, taggedTemplateData)

				return Array.forEach(tests, function(row)
					-- ROBLOX FIXME Luau: supports done is known to be a boolean at this point
					return (cb :: GlobalCallbackFn)(
						row.title,
						applyArguments(supportsDone, row.arguments, test),
						timeout
					)
				end) :: any
			end)

			if not ok then
				local error_ = ErrorWithStack.new(result.message, eachBind)
				return (cb :: GlobalCallbackFn)(title, function()
					error(error_)
				end)
			end

			return result
		end
		return eachBind
	end
end
exports.default = default

function isArrayTable(data: Global_TemplateData)
	return #data == 0
end

function buildArrayTests(title: string, table_: Global_EachTable): EachTests
	validateArrayTable(table_)
	return convertArrayTable(title, table_ :: Global_ArrayTable)
end

function buildTemplateTests(title: string, table_: Global_EachTable, taggedTemplateData: Global_TemplateData): EachTests
	-- ROBLOX deviation START: API change support Array<string> or string as header
	local headingString = if Array.isArray(table_) then (table_ :: Array<string>)[1] :: string else table_ :: string
	local headings = getHeadingKeys(headingString)
	-- ROBLOX deviation END
	validateTemplateTableArguments(headings, taggedTemplateData)
	return convertTemplateTable(title, headings, taggedTemplateData)
end

function getHeadingKeys(headings: string): Array<string>
	return String.split(extractValidTemplateHeadings(headings):gsub("%s+", ""), "|")
end

-- ROBLOX TODO: add generic type constraints <EachCallback extends Global.TestCallback>
function applyArguments<EachCallback>(
	supportsDone: boolean,
	params: Array<any>,
	test: Global_EachTestFn<EachCallback>
): Global_EachTestFn<any>
	local argumentCount
	if typeof(test) == "function" then
		argumentCount = debug.info(test, "a")
	else
		argumentCount = 0 -- ROBLOX CHECK: jest.fn()?
	end

	-- ROBLOX deviation START: add logic to unpack and convert NIL placeholders
	local replaceNilPlaceholders
	function replaceNilPlaceholders(val: any): any
		if val == NIL then
			return nil
		elseif Array.isArray(val) then
			return Array.map(val, function(item)
				return replaceNilPlaceholders(item)
			end)
		elseif typeof(val) == "table" then
			Array.forEach(Object.keys(val), function(key)
				val[key] = replaceNilPlaceholders(val[key])
			end)
			return val
		end

		return val
	end

	local unpackTable
	function unpackTable(obj: Array<any>, i_: number?, ...: any)
		local i = if i_ ~= nil then i_ else #obj
		if i == 0 then
			return ...
		end
		return unpackTable(obj, i - 1, replaceNilPlaceholders(obj[i]), ...)
	end
	-- ROBLOX deviation END

	return if supportsDone and #params < argumentCount
		then function(done: Global_DoneFn)
			return test(unpackTable(params), done)
		end
		else function()
			return test(unpackTable(params))
		end
end
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="330">
              <Properties>
                <string name="Name">nilPlaceholder</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX upstream: no upstream

-- ROBLOX Comment: nil value placeholder
local NIL = newproxy(true)
local mt = getmetatable(NIL)
mt.__tostring = function()
	return "nil"
end

return NIL
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="331">
              <Properties>
                <string name="Name">table</string>
              </Properties>
              <Item class="ModuleScript" referent="332">
                <Properties>
                  <string name="Name">array</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-each/src/table/array.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]

local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>

local RegExp = require(Packages.RegExp)

local exports = {}

-- ROBLOX deviation START: package not available using local implementation
-- local util = require(Packages.util)
local format = require(script.Parent.format)
-- ROBLOX deviation END

local typesModule = require(Packages.JestTypes)
type Global_ArrayTable = typesModule.Global_ArrayTable
type Global_Col = typesModule.Global_Col
type Global_Row = typesModule.Global_Row
type Global_Table = typesModule.Global_Table
local pretty = require(Packages.PrettyFormat).format

-- ROBLOX devation: Circular dependency, inline type
-- local bindModule = require(script.Parent.Parent.bind)
-- type EachTests = bindModule.EachTests
type EachTests = Array<{
	title: string,
	arguments: Array<any>,
}>
local interpolationModule = require(script.Parent.interpolation)
type Templates = interpolationModule.Templates
local interpolateVariables = interpolationModule.interpolateVariables

--[[
	ROBLOX deviation START: some strings require escaped version
	depending where they are used
]]
local SUPPORTED_PLACEHOLDERS = RegExp("%[sdifjoOp]")
local SUPPORTED_PLACEHOLDERS_PATTERN = "%%[sdifjoOp#]"
local PRETTY_PLACEHOLDER = "%p"
local PRETTY_PLACEHOLDER_PATTERN = "%%p"
local INDEX_PLACEHOLDER = "%%#"
local PLACEHOLDER_PREFIX = "%%"
local ESCAPED_PLACEHOLDER_PREFIX = "%%"
local ESCAPED_PLACEHOLDER_PREFIX_PATTERN = "%%%%"
local JEST_EACH_PLACEHOLDER_ESCAPE = "@@__JEST_EACH_PLACEHOLDER_ESCAPE__@@"
-- ROBLOX deviation END

-- ROBLOX deviation: predeclare variables
local isTemplates, normaliseTable, formatTitle, interpolateEscapedPlaceholders, isTable, colToRow, normalisePlaceholderValue, getMatchingPlaceholders, interpolatePrettyPlaceholder, interpolateTitleIndex

local function array(title: string, arrayTable: Global_ArrayTable): EachTests
	if isTemplates(title, arrayTable) then
		return Array.map(arrayTable, function(template, index)
			return {
				arguments = { template },
				title = interpolateVariables(title, template, index):gsub(
					ESCAPED_PLACEHOLDER_PREFIX_PATTERN,
					PLACEHOLDER_PREFIX
				),
			}
		end)
	end
	return Array.map(normaliseTable(arrayTable), function(row, index)
		return {
			arguments = Array.map(row, function(element)
				return element
			end),
			title = formatTitle(title, row, index),
		}
	end)
end

exports.default = array

function isTemplates(
	title: string,
	arrayTable: Global_ArrayTable
): boolean --[[ ROBLOX TODO: Unhandled node for type: TSTypePredicate ]] --[[ arrayTable is Templates ]]
	return not SUPPORTED_PLACEHOLDERS:test(interpolateEscapedPlaceholders(title))
		and not isTable(arrayTable)
		and Array.every(arrayTable, function(col)
			return col ~= nil and typeof(col) == "table"
		end)
end

function normaliseTable(table_: Global_ArrayTable): Global_Table
	return if isTable(table_) then table_ else Array.map(table_, colToRow)
end

function isTable(
	table_: Global_ArrayTable
): boolean --[[ ROBLOX TODO: Unhandled node for type: TSTypePredicate ]] --[[ table is Global.Table ]]
	return Array.every(table_, Array.isArray)
end

function colToRow(col: Global_Col): Global_Row
	return { col }
end

function formatTitle(title: string, row: Global_Row, rowIndex: number): string
	return Array.reduce(row, function(formattedTitle, value)
		local placeholder = getMatchingPlaceholders(formattedTitle)[1]
		local normalisedValue = normalisePlaceholderValue(value)
		if not Boolean.toJSBoolean(placeholder) then
			return formattedTitle
		end
		if placeholder == PRETTY_PLACEHOLDER then
			return interpolatePrettyPlaceholder(formattedTitle, normalisedValue)
		end
		return format(formattedTitle, normalisedValue)
	end, interpolateTitleIndex(interpolateEscapedPlaceholders(title), rowIndex)):gsub(
		JEST_EACH_PLACEHOLDER_ESCAPE,
		ESCAPED_PLACEHOLDER_PREFIX
	)
end

function normalisePlaceholderValue(value: any)
	if typeof(value) == "string" then
		local ref = value:gsub(PLACEHOLDER_PREFIX, JEST_EACH_PLACEHOLDER_ESCAPE)
		return ref
	else
		return value
	end
end

function getMatchingPlaceholders(title: string): Array<string>
	-- ROBLOX deviation START: js .match with /g flag and :gmatch are used in a different way
	local ref
	for match in title:gmatch(SUPPORTED_PLACEHOLDERS_PATTERN) do
		if ref == nil then
			ref = {}
		end
		table.insert(ref, match)
	end
	-- ROBLOX deviation END
	return ref or {}
end

function interpolateEscapedPlaceholders(title: string)
	local ref = title:gsub(ESCAPED_PLACEHOLDER_PREFIX_PATTERN, JEST_EACH_PLACEHOLDER_ESCAPE)
	return ref
end

function interpolateTitleIndex(title: string, index: number)
	local ref = title:gsub(INDEX_PLACEHOLDER, tostring(index), 1)
	return ref
end

function interpolatePrettyPlaceholder(title: string, value: any)
	local ref = title:gsub(PRETTY_PLACEHOLDER_PATTERN, pretty(value, { maxDepth = 1, min = true }), 1)
	return ref
end

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="333">
                <Properties>
                  <string name="Name">format</string>
                  <string name="Source"><![CDATA[--[[
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
]]
-- ROBLOX comment: mostly ported from https://github.com/browserify/node-util/blob/master/util.js
local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Number = LuauPolyfill.Number
local NaN = Number.NaN

local HttpService = game:GetService("HttpService")

local format = function(...): any
	local formatRegExp = "%%[sdj%%]"
	local i = 2
	local args = { ... }
	local f = args[1]
	local len = #args
	local ref = f:gsub(formatRegExp, function(x)
		if x == "%%" then
			return "%"
		end
		if i > len then
			return x
		end
		if x == "%s" then
			local returnValue
			if typeof(args[i]) == "function" then
				returnValue = "Function"
			else
				returnValue = tostring(args[i])
			end
			i = i + 1
			return returnValue
		elseif x == "%d" then
			local returnValue = tonumber(args[i]) or NaN
			i = i + 1
			return tostring(returnValue)
		elseif x == "%j" then
			local ok, result = pcall(function()
				local returnValue = HttpService:JSONEncode(args[i])
				i = i + 1
				return returnValue
			end)

			if not ok then
				i = i + 1
				return "[Circular]"
			end

			return result
		else
			return x
		end
	end)
	return ref
end
return format
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="334">
                <Properties>
                  <string name="Name">interpolation</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-each/src/table/interpolation.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]

local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>

type Record<T, U> = { [T]: U }

local exports = {}

local isPrimitive = require(Packages.JestGetType).isPrimitive

local pretty = require(Packages.PrettyFormat).format

-- ROBLOX deviation START: predefine variables
local getMatchingKeyPaths, replaceKeyPathWithValue, getPath
-- ROBLOX deviation END

export type Template = Record<string, any>
export type Templates = Array<Template>
export type Headings = Array<string>

local function interpolateVariables(title: string, template: Template, index: number): string
	return Array.reduce(
		Array.reduce(Object.keys(template), getMatchingKeyPaths(title), {}), -- aka flatMap
		replaceKeyPathWithValue(template),
		title
		-- ROBLOX deviation START: use gsub to replace variable strings
		-- ):replace("$#", ("%s"):format(tostring(index)))
	)
		:gsub("%$#", tostring(index), 1)
		:gsub("%%#", tostring(index), 1)
	-- ROBLOX deviation END
end
exports.interpolateVariables = interpolateVariables

function getMatchingKeyPaths(title: string)
	return function(matches: Headings, key: string)
		return Array.concat(
			matches,
			(function()
				local ref = {}
				for match in title:gmatch(("%%$%s[%%.%%w]*"):format(key)) do -- ROBLOX deviation: escape characters
					table.insert(ref, match)
				end
				return ref
			end)()
		)
	end
end

function replaceKeyPathWithValue(template: Template): (title: string, match: string) -> string
	return function(title: string, match: string)
		local newMatch = match:gsub("%$", "", 1) -- ROBLOX deviation: escape string
		local keyPath = String.split(newMatch, ".")
		local value = getPath(template, keyPath)
		if isPrimitive(value) then
			return title:gsub(match, tostring(value), 1)
		end
		return title:gsub(match, pretty(value, { maxDepth = 1, min = true }), 1)
	end
end

--[[ eslint import/export: 0]]
--[[ ROBLOX deviation: function overloads not handled
export function getPath<
  Obj extends Template,
  A extends keyof Obj,
  B extends keyof Obj[A],
  C extends keyof Obj[A][B],
  D extends keyof Obj[A][B][C],
  E extends keyof Obj[A][B][C][D],
>(obj: Obj, path: [A, B, C, D, E]): Obj[A][B][C][D][E];
export function getPath<
  Obj extends Template,
  A extends keyof Obj,
  B extends keyof Obj[A],
  C extends keyof Obj[A][B],
  D extends keyof Obj[A][B][C],
>(obj: Obj, path: [A, B, C, D]): Obj[A][B][C][D];
export function getPath<
  Obj extends Template,
  A extends keyof Obj,
  B extends keyof Obj[A],
  C extends keyof Obj[A][B],
>(obj: Obj, path: [A, B, C]): Obj[A][B][C];
export function getPath<
  Obj extends Template,
  A extends keyof Obj,
  B extends keyof Obj[A],
>(obj: Obj, path: [A, B]): Obj[A][B];
export function getPath<Obj extends Template, A extends keyof Obj>(
  obj: Obj,
  path: [A],
): Obj[A];
export function getPath<Obj extends Template>(
  obj: Obj,
  path: Array<string>,
): unknown;
]]

function getPath(template: Template, ref: Array<string>): any
	local head = table.unpack(ref, 1, 1)
	local tail = if #ref > 1 then { table.unpack(ref, 2) } else {}
	if not Boolean.toJSBoolean(head) or template[head] == nil then
		return template
	end
	return getPath(template[head] :: Template, tail)
end
exports.getPath = getPath

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="335">
                <Properties>
                  <string name="Name">template</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-each/src/table/template.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]
local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

-- ROBLOX deviation: predefine variables
local convertRowToTable, convertTableToTemplates

local typesModule = require(Packages.JestTypes)
type Global_Row = typesModule.Global_Row
type Global_Table = typesModule.Global_Table

-- local bindModule = require(script.Parent.Parent.bind)
-- type EachTests = bindModule.EachTests
type EachTests = any
local interpolationModule = require(script.Parent.interpolation)
type Headings = interpolationModule.Headings
type Template = interpolationModule.Template
type Templates = interpolationModule.Templates
local interpolateVariables = require(script.Parent.interpolation).interpolateVariables

local function default(title: string, headings: Headings, row: Global_Row): EachTests
	local table_ = convertRowToTable(row, headings)
	local templates = convertTableToTemplates(table_, headings)
	return Array.map(templates, function(template, index)
		return {
			arguments = { Object.assign({}, template) },
			-- ROBLOX FIXME Luau: analyze should know this is Template because of the Array.map() generic's callbackFn
			title = interpolateVariables(title, template :: Template, index),
		}
	end)
end

exports.default = default

function convertRowToTable(row: Global_Row, _headings: Headings): Global_Table
	-- ROBLOX deviation: rows are already formatted as arrays (because there are no tagged templates)
	return row
end

function convertTableToTemplates(table_: Global_Table, headings: Headings): Templates
	return Array.map(table_, function(row)
		return Array.reduce(row, function(
			-- ROBLOX FIXME Luau: should be inferred from reduce's initial value
			acc: Template,
			value,
			index
		)
			return Object.assign(acc, { [headings[index]] = value })
		end, {} :: Template)
	end)
end

return exports
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="336">
              <Properties>
                <string name="Name">validation</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-each/src/validation.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]
local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local chalk = require(Packages.ChalkLua)

local typesModule = require(Packages.JestTypes)
type Global_TemplateData = typesModule.Global_TemplateData
local pretty = require(Packages.PrettyFormat).format

-- ROBLOX deviation: predefine variables
local isTaggedTemplateLiteral, isEmptyString, isEmptyTable, pluralize

type TemplateData = Global_TemplateData

local EXPECTED_COLOR = chalk.green
local RECEIVED_COLOR = chalk.red

local function validateArrayTable(table_: unknown): ()
	-- ROBLOX deviation START: need a tableArr variable to help Luau analyze
	if not Array.isArray(table_) then
		error(
			Error.new(
				"`.each` must be called with an Array or Tagged Template Literal.\n\n"
					.. ("Instead was called with: %s\n"):format(pretty(table_, { maxDepth = 1, min = true }))
			)
		)
	end

	local tableArr = table_ :: Array<unknown>
	-- ROBLOX deviation END

	if isTaggedTemplateLiteral(tableArr) then
		if isEmptyString(tableArr[1]) then
			error(Error.new("Error: `.each` called with an empty Tagged Template Literal of table data.\n"))
		end
		error(
			Error.new(
				"Error: `.each` called with a Tagged Template Literal with no data, remember to interpolate with ${expression} syntax.\n"
			)
		)
	end

	if isEmptyTable(tableArr) then
		error(Error.new("Error: `.each` called with an empty Array of table data.\n"))
	end
end
exports.validateArrayTable = validateArrayTable

function isTaggedTemplateLiteral(array: any)
	return array.raw ~= nil
end

function isEmptyTable(table_: Array<unknown>)
	return #table_ == 0
end

function isEmptyString(str: string | unknown)
	return typeof(str) == "string" and String.trim(str) == ""
end

local function validateTemplateTableArguments(headings: Array<string>, data: TemplateData): ()
	-- ROBLOX deviation START: dealing with arrays instead of a variadic list of values, error if any has less or more elements
	Array.forEach(data, function(array, index)
		local countDifference = #headings - #array
		local missingData = if countDifference >= 0 then countDifference else (countDifference - #headings)

		if missingData ~= 0 then
			error(
				Error.new(
					("%s arguments supplied for given headings:\n"):format(
						if countDifference > 0 then "Not enough" else "Too many"
					)
						.. tostring(EXPECTED_COLOR(Array.join(headings, " | ")))
						.. "\n\n"
						.. "Received:\n"
						.. tostring(RECEIVED_COLOR(pretty(data)))
						.. "\n\n"
						.. ("%s %s %s in row %d"):format(
							if countDifference > 0 then "Missing" else "Remove",
							RECEIVED_COLOR(tostring(missingData)),
							pluralize("argument", missingData),
							index
						)
				)
			)
		end
	end)
	-- ROBLOX deviation END
end
exports.validateTemplateTableArguments = validateTemplateTableArguments

function pluralize(word: string, count: number)
	return word .. (if count == 1 then "" else "s")
end

-- ROBLOX deviation: does not work the same as upstream (single lines supported/preferred)
local START_OF_LINE = "^"
-- local NEWLINE = "\n"
local HEADING = "s*[^%.*]+s*"
-- local PIPE = "|"
-- local REPEATABLE_HEADING = ("(%s%s)*"):format(PIPE, HEADING)
-- local HEADINGS_FORMAT = START_OF_LINE .. NEWLINE .. HEADING .. REPEATABLE_HEADING .. NEWLIN
local END_OF_LINE = "$"
local HEADINGS_FORMAT = START_OF_LINE .. HEADING .. END_OF_LINE
-- ROBLOX deviation END

local function extractValidTemplateHeadings(headings: string): string
	-- ROBLOX deviation START: get lines with value, return the first one, check for spaces in headings
	local match = headings:match(HEADINGS_FORMAT)
	local matches, hasEmptySpacesInHeading
	if match then
		matches = Array.filter(String.split(match, "\n"), function(line)
			return String.trim(line) ~= ""
		end)
	end
	if matches and #matches > 0 then
		local headings_ = Array.map(String.split(matches[1], "|"), function(heading)
			return String.trim(heading)
		end)
		hasEmptySpacesInHeading = Array.some(headings_, function(heading)
			return heading:match("%s") ~= nil
		end)
	end

	if match == nil or hasEmptySpacesInHeading then
		error(
			Error.new(
				"Table headings do not conform to expected format:\n\n"
					.. EXPECTED_COLOR("heading1 | headingN")
					.. "\n\n"
					.. "Received:\n\n"
					.. RECEIVED_COLOR(pretty(headings))
			)
		)
	end
	-- ROBLOX deviation END
	return matches[1]
end
exports.extractValidTemplateHeadings = extractValidTemplateHeadings

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="337">
            <Properties>
              <string name="Name">JestEnvironment</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-environment/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type Promise<T> = LuauPolyfill.Promise<T>

type Console = Object
type NodeModule = Object
type Record<T, U> = { [T]: U }
type void = nil

-- ROBLOX deviation START: module not available
-- local vmModule = require(rootWorkspace.vm)
-- type Context = vmModule.Context
type Context = Object
-- ROBLOX deviation END

local FakeTimersModule = require(Packages.JestFakeTimers)
-- ROBLOX deviation START: no Legacy/Modern timers
-- type LegacyFakeTimers<TimerRef> = FakeTimersModule.LegacyFakeTimers<TimerRef>
-- type ModernFakeTimers = FakeTimersModule.ModernFakeTimers
type FakeTimers = FakeTimersModule.FakeTimers
-- ROBLOX deviation END

local typesModule = require(Packages.JestTypes)
-- ROBLOX deviation START: Import types with namespace
type Circus_EventHandler = typesModule.Circus_EventHandler
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type Global_Global = typesModule.Global_Global
-- ROBLOX deviation END

local jestMockModule = require(Packages.JestMock)
-- ROBLOX deviation START: can't export globals from jest mock
type JestFuncFn = jestMockModule.JestFuncFn
type JestFuncMocked = jestMockModule.JestFuncMocked
type JestFuncSpyOn = jestMockModule.JestFuncSpyOn
-- ROBLOX deviation END

type ModuleMocker = jestMockModule.ModuleMocker

-- ROBLOX deviation: mocking globals
local jestMockGenvModule = require(Packages.JestMockGenv)

export type EnvironmentContext = {
	console: Console,
	-- docblockPragmas: Record<string, string | Array<string>>,
	-- ROBLOX deviation: accept ModuleScript instead of string
	testPath: ModuleScript,
}

-- Different Order than https://nodejs.org/api/modules.html#modules_the_module_wrapper , however needs to be in the form [jest-transform]ScriptTransformer accepts
export type ModuleWrapper = (
	this: any, --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ Module['exports'] ]]
	module: Module,
	exports: any, --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ Module['exports'] ]]
	require: Object, --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ Module['require'] ]]
	__dirname: string,
	__filename: string, --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ Module['filename'] ]]
	jest: Jest?,
	...any --[[ ROBLOX CHECK: check correct type of elements. Upstream type: <Array<Global.Global[keyof Global.Global]>> ]]
) -> any

export type JestEnvironment<Timer = any> = {
	new: (config: Config_ProjectConfig, context: EnvironmentContext?) -> JestEnvironment<Timer>,
	global: Global_Global,
	-- ROBLOX deviation START: no modern/legacy timers
	-- fakeTimers: LegacyFakeTimers<Timer> | nil,
	-- fakeTimersModern: ModernFakeTimers | nil,
	fakeTimers: FakeTimers | nil,
	-- ROBLOX deviation END
	moduleMocker: ModuleMocker | nil,
	getVmContext: (self: JestEnvironment<Timer>) -> Context | nil,
	setup: (self: JestEnvironment<Timer>) -> Promise<void>,
	teardown: (self: JestEnvironment<Timer>) -> Promise<void>,
	handleTestEvent: Circus_EventHandler?,
	exportConditions: (() -> Array<string>)?,
}

export type Module = NodeModule

-- TODO: Move to some separate package
export type Jest = {
	--[[*
	* Advances all timers by the needed milliseconds so that only the next timeouts/intervals will run.
	* Optionally, you can provide steps, so it will run steps amount of next timeouts/intervals.
	]]
	advanceTimersToNextTimer: (steps: number?) -> (),
	--[[*
	* Disables automatic mocking in the module loader.
	]]
	autoMockOff: () -> Jest,
	--[[*
	* Enables automatic mocking in the module loader.
	]]
	autoMockOn: () -> Jest,
	--[[*
	* Clears the mock.calls and mock.instances properties of all mocks.
	* Equivalent to calling .mockClear() on every mocked function.
	]]
	clearAllMocks: () -> Jest,
	--[[*
	* Removes any pending timers from the timer system. If any timers have been
	* scheduled, they will be cleared and will never have the opportunity to
	* execute in the future.
	]]
	clearAllTimers: () -> (),
	--[[*
	* Indicates that the module system should never return a mocked version
	* of the specified module, including all of the specified module's
	* dependencies.
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	deepUnmock: (moduleName: ModuleScript) -> Jest,
	--[[*
	* Disables automatic mocking in the module loader.
	*
	* After this method is called, all `require()`s will return the real
	* versions of each module (rather than a mocked version).
	]]
	disableAutomock: () -> Jest,
	--[[*
	* When using `babel-jest`, calls to mock will automatically be hoisted to
	* the top of the code block. Use this method if you want to explicitly avoid
	* this behavior.
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	doMock: (moduleName: ModuleScript, moduleFactory: (() -> any)?) -> Jest,
	--[[*
	* Indicates that the module system should never return a mocked version
	* of the specified module from require() (e.g. that it should always return
	* the real module).
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	dontMock: (moduleName: ModuleScript) -> Jest,
	--[[*
	* Enables automatic mocking in the module loader.
	]]
	enableAutomock: () -> Jest,
	--[[*
	* Creates a mock function. Optionally takes a mock implementation.
	]]
	-- ROBLOX deviation: can't export globals from jest mock
	fn: JestFuncFn,
	-- ROBLOX deviation START: mocking globals
	--[[*
	* Represents the global environment and its libraries, for use with the
	* `spyOn()` function. This can be used to spy on Lua globals.
	]]
	globalEnv: jestMockGenvModule.GlobalEnv,
	-- ROBLOX deviation END
	--[[*
	* Given the name of a module, use the automatic mocking system to generate a
	* mocked version of the module for you.
	*
	* This is useful when you want to create a manual mock that extends the
	* automatic mock's behavior.
	*
	* @deprecated Use `jest.createMockFromModule()` instead
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	genMockFromModule: (moduleName: ModuleScript) -> any,
	--[[*
	* Given the name of a module, use the automatic mocking system to generate a
	* mocked version of the module for you.
	*
	* This is useful when you want to create a manual mock that extends the
	* automatic mock's behavior.
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	createMockFromModule: (moduleName: ModuleScript) -> any,
	--[[*
	* Determines if the given function is a mocked function.
	]]
	isMockFunction: (fn: (...any) -> any) -> boolean,
	--[[*
	* Mocks a module with an auto-mocked version when it is being required.
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	mock: (moduleName: ModuleScript, moduleFactory: (() -> any)?, options: { virtual: boolean? }?) -> Jest,
	--[[*
	* Mocks a module with the provided module factory when it is being imported.
	]]
	-- ROBLOX TODO: add default generic. <T = any>
	unstable_mockModule: <T>(
		-- ROBLOX deviation: using ModuleScript instead of string
		moduleName: ModuleScript,
		moduleFactory: () -> Promise<T> | T,
		options: { virtual: boolean? }?
	) -> Jest,
	--[[*
	* Returns the actual module instead of a mock, bypassing all checks on
	* whether the module should receive a mock implementation or not.
	*
	* @example
	```
	 jest.mock('../myModule', () => {
	 // Require the original module to not be mocked...
	 const originalModule = jest.requireActual(moduleName);
	   return {
	     __esModule: true, // Use it when dealing with esModules
	     ...originalModule,
	     getRandom: jest.fn().mockReturnValue(10),
	   };
	 });
	  const getRandom = require('../myModule').getRandom;
	  getRandom(); // Always returns 10
	 ```
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	requireActual: (moduleName: ModuleScript) -> any,
	--[[*
	* Returns a mock module instead of the actual module, bypassing all checks
	* on whether the module should be required normally or not.
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	requireMock: (moduleName: ModuleScript) -> any,
	--[[*
	* Resets the state of all mocks.
	* Equivalent to calling .mockReset() on every mocked function.
	]]
	resetAllMocks: () -> Jest,
	--[[*
	* Resets the module registry - the cache of all required modules. This is
	* useful to isolate modules where local state might conflict between tests.
	]]
	resetModules: () -> Jest,
	--[[*
	* Restores all mocks back to their original value. Equivalent to calling
	* `.mockRestore` on every mocked function.
	*
	* Beware that jest.restoreAllMocks() only works when the mock was created with
	* jest.spyOn; other mocks will require you to manually restore them.
	]]
	restoreAllMocks: () -> Jest,
	-- ROBLOX deviation: can't export globals from jest mock
	mocked: JestFuncMocked,
	--[[*
	* Runs failed tests n-times until they pass or until the max number of
	* retries is exhausted. This only works with `jest-circus`!
	]]
	retryTimes: (numRetries: number) -> Jest,
	--[[*
	* Exhausts tasks queued by setImmediate().
	*
	* > Note: This function is not available when using Lolex as fake timers implementation
	]]
	runAllImmediates: () -> (),
	--[[*
	* Exhausts the micro-task queue (usually interfaced in node via
	* process.nextTick).
	]]
	runAllTicks: () -> (),
	--[[*
	* Exhausts the macro-task queue (i.e., all tasks queued by setTimeout()
	* and setInterval()).
	]]
	runAllTimers: () -> (),
	--[[*
	* Executes only the macro-tasks that are currently pending (i.e., only the
	* tasks that have been queued by setTimeout() or setInterval() up to this
	* point). If any of the currently pending macro-tasks schedule new
	* macro-tasks, those new tasks will not be executed by this call.
	]]
	runOnlyPendingTimers: () -> (),
	--[[*
	* Advances all timers by msToRun milliseconds. All pending "macro-tasks"
	* that have been queued via setTimeout() or setInterval(), and would be
	* executed within this timeframe will be executed.
	]]
	advanceTimersByTime: (msToRun: number) -> void,
	--[[*
	* Returns the number of fake timers still left to run.
	]]
	getTimerCount: () -> number,
	--[[*
	* Explicitly supplies the mock object that the module system should return
	* for the specified module.
	*
	* Note It is recommended to use `jest.mock()` instead. The `jest.mock`
	* API's second argument is a module factory instead of the expected
	* exported module object.
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	setMock: (moduleName: ModuleScript, moduleExports: any) -> Jest,
	--[[*
	* Set the default timeout interval for tests and before/after hooks in
	* milliseconds.
	*
	* Note: The default timeout interval is 5 seconds if this method is not
	* called.
	]]
	setTimeout: (timeout: number) -> Jest,
	--[[*
	* Creates a mock function similar to `jest.fn` but also tracks calls to
	* `object[methodName]`.
	*
	* Note: By default, jest.spyOn also calls the spied method. This is
	* different behavior from most other test libraries.
	]]
	-- ROBLOX deviation: can't export globals from jest mock
	spyOn: JestFuncSpyOn,
	--[[*
	* Indicates that the module system should never return a mocked version of
	* the specified module from require() (e.g. that it should always return the
	* real module).
	]]
	-- ROBLOX deviation: using ModuleScript instead of string
	unmock: (moduleName: ModuleScript) -> Jest,
	--[[*
	* Instructs Jest to use fake versions of the standard timer functions.
	]]
	--[[
		ROBLOX deviation: because there is no modern/legacy timers it doesn't make sense to pick one, removing 'implementation' parameter
		Original fn: useFakeTimers: (implementation: ("modern" | "legacy")?) -> Jest,
	]]
	useFakeTimers: () -> Jest,
	--[[*
	* Instructs Jest to use the real versions of the standard timer functions.
	]]
	useRealTimers: () -> Jest,
	--[[*
	* `jest.isolateModules(fn)` goes a step further than `jest.resetModules()`
	* and creates a sandbox registry for the modules that are loaded inside
	* the callback function. This is useful to isolate specific modules for
	* every test so that local module state doesn't conflict between tests.
	]]
	isolateModules: (fn: () -> ()) -> Jest,
	--[[*
	* ROBLOX deviation START: configurable engine frame time
	* Because the Roblox game engine processes things in frames rather than in continuous time, users can configure
	* an engine frame time when using fake timers to more simulate engine timer behavior more accurately.
	]]
	--[[*
	* When using the fake versions of the standard timer functions, returns the frame time (in ms). By default, this is 0 (i.e. continuous time).
	]]
	getEngineFrameTime: () -> number,
	--[[*
	* When using the fake versions of the standard timer functions, set the frame time (in ms) for processing timeouts. Simulates the way
	* the engine scheduler processes timeouts (i.e. in batches delineated by frames). Timers process in the first frame greater than their set time.
	]]
	setEngineFrameTime: (frameTimeMs: number) -> (),
	-- ROBLOX deviation END
	--[[*
	* When mocking time, `Date.now()` will also be mocked. If you for some reason need access to the real current time, you can invoke this function.
	*
	* > Note: This function is only available when using Lolex as fake timers implementation
	]]
	getRealSystemTime: () -> number,
	--[[*
	*  Set the current system time used by fake timers. Simulates a user changing the system clock while your program is running. It affects the current time but it does not in itself cause e.g. timers to fire; they will fire exactly as they would have done without the call to `jest.setSystemTime()`.
	*
	*  > Note: This function is only available when using Lolex as fake timers implementation
	]]
	setSystemTime: (now: (number | DateTime)?) -> (),
}
return {}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="338">
            <Properties>
              <string name="Name">JestEnvironmentLuau</string>
              <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	ROBLOX NOTE: no upstream
	based on: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-environment-node/src/index.ts
]]

local Packages = script.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object
local Promise = require(Packages.Promise)
type Promise<T> = LuauPolyfill.Promise<T>

type Context = Object

local JestEnvironmentModule = require(Packages.JestEnvironment)
type JestEnvironment = JestEnvironmentModule.JestEnvironment

local JestFakeTimers = require(Packages.JestFakeTimers)

local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type Global_Global = typesModule.Global_Global

local FakeTimersModule = require(Packages.JestFakeTimers)
type FakeTimers = FakeTimersModule.FakeTimers

local jestMockModule = require(Packages.JestMock)
type ModuleMocker = jestMockModule.ModuleMocker

-- ROBLOX NOTE: redefine props and methods to have proper `self` typing
type JestEnvironmentLuau = {
	new: (config: Config_ProjectConfig) -> JestEnvironmentLuau,
	global: Global_Global,
	-- ROBLOX deviation START: no modern/legacy timers
	-- fakeTimers: LegacyFakeTimers<Timer> | nil,
	-- fakeTimersModern: ModernFakeTimers | nil,
	fakeTimers: FakeTimers | nil,
	-- ROBLOX deviation END
	moduleMocker: ModuleMocker | nil,
	getVmContext: (self: JestEnvironmentLuau) -> Context | nil,
	setup: (self: JestEnvironmentLuau) -> Promise<nil>,
	teardown: (self: JestEnvironmentLuau) -> Promise<nil>,
	context: any,
}

local JestEnvironmentLuau = {} :: JestEnvironmentLuau;
(JestEnvironmentLuau :: any).__index = JestEnvironmentLuau

function JestEnvironmentLuau.new(config: Config_ProjectConfig): JestEnvironmentLuau
	local self = setmetatable({}, JestEnvironmentLuau)

	self.context = {}
	local global = Object.assign(self.context, config.testEnvironmentOptions)
	self.global = global
	global.global = global

	self.fakeTimers = JestFakeTimers.new()

	return (self :: any) :: JestEnvironmentLuau
end

function JestEnvironmentLuau:getVmContext()
	return self.context
end

function JestEnvironmentLuau:setup()
	return Promise.resolve()
end

function JestEnvironmentLuau:teardown()
	return Promise.resolve():andThen(function()
		if self.fakeTimers ~= nil then
			self.fakeTimers:dispose()
		end
		self.context = {}
		self.fakeTimers = nil
	end)
end

return JestEnvironmentLuau
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="339">
            <Properties>
              <string name="Name">JestFakeTimers</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX derived from: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-fake-timers/src/modernFakeTimers.ts
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	ROBLOX deviation: API aligned with the upstream
	major implementation deviation, refer to README for more info
]]

local CurrentModule = script
local Packages = CurrentModule.Parent

local getType = require(Packages.JestGetType).getType

local jestMock = require(Packages.JestMock).ModuleMocker

local realDelay = delay
local realTick = tick
local realTime = time
local realDateTime = DateTime
local realOs = os
local realTask = task

type Timeout = {
	time: number,
	callback: () -> (),
	args: { any },
}

export type FakeTimers = {
	clearAllTimers: (self: FakeTimers) -> (),
	dispose: (self: FakeTimers) -> (),
	runAllTimers: (self: FakeTimers) -> (),
	runOnlyPendingTimers: (self: FakeTimers) -> (),
	advanceTimersToNextTimer: (self: FakeTimers, steps_: number?) -> (),
	advanceTimersByTime: (self: FakeTimers, msToRun: number) -> (),
	runAllTicks: (self: FakeTimers) -> (),
	useRealTimers: (self: FakeTimers) -> (),
	useFakeTimers: (self: FakeTimers) -> (),
	reset: (self: FakeTimers) -> (),
	setSystemTime: (self: FakeTimers, now: any) -> (),
	getRealSystemTime: (self: FakeTimers) -> (),
	getTimerCount: (self: FakeTimers) -> number,
	setEngineFrameTime: (self: FakeTimers, frameTimeMs: number) -> (),
	getEngineFrameTime: (self: FakeTimers) -> number,
	delayOverride: typeof(delay),
	tickOverride: typeof(tick),
	timeOverride: typeof(time),
	dateTimeOverride: typeof(DateTime),
	osOverride: typeof(os),
	taskOverride: typeof(task),
}

local FakeTimers = {}
FakeTimers.__index = FakeTimers
function FakeTimers.new(): FakeTimers
	local mock = jestMock.new()

	local delayOverride = mock:fn(realDelay)
	local tickOverride = mock:fn(realTick)
	local timeOverride = mock:fn(realTime)
	local dateTimeOverride = {
		now = mock:fn(realDateTime.now),
		fromUnixTimestamp = realDateTime.fromUnixTimestamp,
		fromUnixTimestampMillis = realDateTime.fromUnixTimestampMillis,
		fromUniversalTime = realDateTime.fromUniversalTime,
		fromLocalTime = realDateTime.fromLocalTime,
		fromIsoDate = realDateTime.fromIsoDate,
	}
	local osOverride = {
		time = mock:fn(realOs.time),
		clock = mock:fn(realOs.clock),
	}
	setmetatable(osOverride, { __index = realOs })
	local taskOverride = {
		delay = mock:fn(realTask.delay),
		cancel = mock:fn(realTask.cancel),
		wait = mock:fn(realTask.wait),
	}
	setmetatable(taskOverride, { __index = realTask })

	local self = {
		_fakingTime = false,
		_timeouts = {},
		_mock = mock,
		_mockTimeMs = 0,
		_mockSystemTime = realDateTime.now().UnixTimestamp,
		_engineFrameTime = 0,
		delayOverride = delayOverride,
		tickOverride = tickOverride,
		timeOverride = timeOverride,
		dateTimeOverride = dateTimeOverride,
		osOverride = osOverride,
		taskOverride = taskOverride,
	}

	setmetatable(self, FakeTimers)
	return (self :: any) :: FakeTimers
end

function FakeTimers:_advanceToTime(time_): ()
	local targetTime = time_
	-- Make sure we don't go back in time due to a queued timer
	if time_ > self._mockTimeMs then
		if self._engineFrameTime > 0 then
			targetTime = math.floor(time_ / self._engineFrameTime) * self._engineFrameTime
		end
		local timeDiff = targetTime - self._mockTimeMs
		-- Move mockTime to target time, in case the callback reads it via `tick`
		self._mockTimeMs = targetTime
		-- _mockSystemTime is in s, while timeDiff is in ms
		self._mockSystemTime = self._mockSystemTime + timeDiff / 1000
	end
end

function FakeTimers:clearAllTimers(): ()
	if self._fakingTime then
		self._timeouts = {}
	end
end

function FakeTimers:dispose(): ()
	self:useRealTimers()
end

function FakeTimers:runAllTimers(): ()
	if self:_checkFakeTimers() then
		for _, timeout in self._timeouts do
			self:_advanceToTime(timeout.time + self._engineFrameTime)
			timeout.callback(unpack(timeout.args))
		end
	end
	self._timeouts = {}
end

function FakeTimers:runOnlyPendingTimers(): ()
	if self:_checkFakeTimers() then
		local pendingTimeouts = {}
		for _, timeout in self._timeouts do
			table.insert(pendingTimeouts, timeout)
		end

		-- Call all pending timeouts
		self._timeouts = {}
		for _, timeout in pendingTimeouts do
			self:_advanceToTime(timeout.time + self._engineFrameTime)
			timeout.callback(unpack(timeout.args))
		end
	end
end

function FakeTimers:advanceTimersToNextTimer(steps_: number?): ()
	-- FIXME: get rid of this extra step of creating a separate variable once
	-- CLI-41847 is done
	local steps: number = steps_ or 1
	if self:_checkFakeTimers() then
		local newTimeouts = {}
		local nextTime = -1
		for _, timeout in self._timeouts do
			if timeout.time > nextTime and steps > 0 then
				if self._engineFrameTime > 0 then
					nextTime = math.floor((timeout.time / self._engineFrameTime) + 1) * self._engineFrameTime
				else
					nextTime = timeout.time
				end
				self:_advanceToTime(nextTime)
				steps = steps - 1
			end
			if self._mockTimeMs >= timeout.time then
				timeout.callback(unpack(timeout.args))
			else
				table.insert(newTimeouts, timeout)
			end
		end
		self._timeouts = newTimeouts
	end
end

function FakeTimers:advanceTimersByTime(msToRun: number): ()
	if self:_checkFakeTimers() then
		local targetTime = self._mockTimeMs + msToRun
		if self._engineFrameTime > 0 then
			targetTime = (math.floor(targetTime / self._engineFrameTime) + 1) * self._engineFrameTime
		end
		local newTimeouts = {}
		for _, timeout in self._timeouts do
			if targetTime >= timeout.time then
				self:_advanceToTime(timeout.time + self._engineFrameTime)
				timeout.callback(unpack(timeout.args))
			else
				table.insert(newTimeouts, timeout)
			end
		end
		self:_advanceToTime(targetTime)
		self._timeouts = newTimeouts
	end
end

function FakeTimers:runAllTicks(): ()
	if self:_checkFakeTimers() then
		error("not implemented")
	end
end

function FakeTimers:useRealTimers(): ()
	if self._fakingTime then
		self.delayOverride.mockImplementation(realDelay)
		self.tickOverride.mockImplementation(realTick)
		self.timeOverride.mockImplementation(realTime)
		self.dateTimeOverride.now.mockImplementation(realDateTime.now)
		self.osOverride.time.mockImplementation(realOs.time)
		self.osOverride.clock.mockImplementation(realOs.clock)
		self.taskOverride.delay.mockImplementation(realTask.delay)
		self.taskOverride.cancel.mockImplementation(realTask.cancel)
		self.taskOverride.wait.mockImplementation(realTask.wait)
		self._fakingTime = false
	end
end

local function fakeClock(self): number
	return self._mockTimeMs / 1000
end

local function fakeDelay(self, delayTime, callback, ...): Timeout
	if delayTime == 0 and self._engineFrameTime == 0 then
		warn("Undefined behavior with a delay of 0 seconds and no engine frame time set.")
	end

	-- Small hack to make sure 0 second recursive timers don't trigger twice in a single frame
	local delayTimeMs = (self._engineFrameTime / 1000) + delayTime * 1000
	local targetTime = self._mockTimeMs + delayTimeMs
	local timeout = {
		time = targetTime,
		callback = callback,
		args = { ... },
	}
	local insertIndex = #self._timeouts + 1
	for i, timeout_ in self._timeouts do
		-- Timeouts are inserted in time order. As soon as we encounter a
		-- timeout that's _after_ our targetTime, we place ours in the list
		-- immediately before it. This way, timeouts with the exact same time
		-- will be queued up in insertion order to break ties
		if timeout_.time > targetTime then
			insertIndex = i
			break
		end
	end
	table.insert(self._timeouts, insertIndex, timeout)
	return timeout
end

local function fakeCancel(self, timeout)
	for i, timeout_ in self._timeouts do
		if timeout_ == timeout then
			table.remove(self._timeouts, i)
			break
		end
	end
end

local function fakeWait(self, timeToWait: number?)
	local running = coroutine.running()
	local clock = fakeClock(self)
	fakeDelay(self, timeToWait or 0, function()
		task.spawn(running, fakeClock(self) - clock)
	end)
	return coroutine.yield()
end

function FakeTimers:useFakeTimers(): ()
	if not self._fakingTime then
		self.delayOverride.mockImplementation(function(delayTime, callback)
			return fakeDelay(self, delayTime, callback)
		end)

		self.tickOverride.mockImplementation(function()
			return self._mockSystemTime
		end)

		self.timeOverride.mockImplementation(function()
			return fakeClock(self)
		end)

		self.dateTimeOverride.now.mockImplementation(function()
			return realDateTime.fromUnixTimestamp(self._mockSystemTime)
		end)

		self.osOverride.time.mockImplementation(function(time_)
			if typeof(time_) == "table" then
				local unixTime = realDateTime.fromUniversalTime(
					time_.year or 1970,
					time_.month or 1,
					time_.day or 1,
					time_.hour or 0,
					time_.min or 0,
					time_.sec or 0
				).UnixTimestamp
				return self._mockSystemTime - unixTime
			end
			return self._mockSystemTime
		end)

		self.osOverride.clock.mockImplementation(function()
			return fakeClock(self)
		end)

		self.taskOverride.delay.mockImplementation(function(delayTime, callback, ...)
			return fakeDelay(self, delayTime, callback, ...)
		end)

		self.taskOverride.cancel.mockImplementation(function(timeout)
			fakeCancel(self, timeout)
		end)

		self.taskOverride.wait.mockImplementation(function(timeToWait)
			return fakeWait(self, timeToWait)
		end)

		self._fakingTime = true
		self:reset()
	end
end

function FakeTimers:reset(): ()
	if self:_checkFakeTimers() then
		self._mock:clearAllMocks()
		self._timeouts = {}
		self._mockTimeMs = 0
		self._mockSystemTime = realDateTime.now().UnixTimestamp
		self._engineFrameTime = 0
	end
end

function FakeTimers:setSystemTime(now: any): ()
	if self:_checkFakeTimers() then
		if not now then
			now = realDateTime.now()
		end
		if getType(now) == "DateTime" then
			now = now.UnixTimestamp
		end
		self._mockSystemTime = now
	end
end

function FakeTimers:setEngineFrameTime(frameTimeMs: number): ()
	if self:_checkFakeTimers() then
		if frameTimeMs < 0 then
			error("Frame Time should be greater than 0")
		end

		self._engineFrameTime = frameTimeMs
	end
end

function FakeTimers:getEngineFrameTime(): number
	if self:_checkFakeTimers() then
		return self._engineFrameTime
	end
	return 0
end

function FakeTimers:getRealSystemTime(): ()
	return realDateTime.now()
end

function FakeTimers:getTimerCount(): number
	if self:_checkFakeTimers() then
		return #self._timeouts
	end

	return 0
end

function FakeTimers:_checkFakeTimers()
	if not self._fakingTime then
		error(
			"A function to advance timers was called but the timers API is not "
				.. "mocked with fake timers. Call `jest.useFakeTimers()` in this test."
		)
	end

	return self._fakingTime
end

return FakeTimers
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="340">
            <Properties>
              <string name="Name">JestGetType</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-get-type/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local Packages = script.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local instanceof = LuauPolyfill.instanceof
local RegExp
local Set = LuauPolyfill.Set
local Map = LuauPolyfill.Map

--[[
	ROBLOX deviation: checks for Roblox builtin data types
	https://developer.roblox.com/en-us/api-reference/data-types
]]
local function isRobloxBuiltin(value: any): boolean
	return type(value) ~= typeof(value)
end

local function getType(value: any): string
	--[[
		ROBLOX deviation: code omitted because lua has no primitive undefined type
		lua makes no distinction between null and undefined so we just return nil
	]]
	if value == nil then
		return "nil"
	end
	if typeof(value) == "boolean" then
		return "boolean"
	end
	if typeof(value) == "function" then
		return "function"
	end
	if typeof(value) == "number" then
		return "number"
	end
	if typeof(value) == "string" then
		return "string"
	end
	if typeof(value) == "DateTime" then
		return "DateTime"
	end
	if typeof(value) == "userdata" and tostring(value):match("Symbol%(.*%)") then
		return "symbol"
	end
	if typeof(value) == "table" then
		local ok, hasRegExpShape = pcall(function()
			return typeof(value.test) == "function" and typeof(value.exec) == "function"
		end)
		if ok and hasRegExpShape then
			RegExp = require(Packages.RegExp)

			if instanceof(value, RegExp) then
				return "regexp"
			end
		end
	end
	if instanceof(value, Error) then
		return "error"
	end
	if instanceof(value, Map) then
		return "map"
	end
	if instanceof(value, Set) then
		return "set"
	end
	--[[
		ROBLOX deviation: lua makes no distinction between tables, arrays, and objects
		we always return table here and consumers are expected to perform the check
	]]
	if typeof(value) == "table" then
		return "table"
	end

	--[[
		ROBLOX deviation: returns name of Roblox datatype
		https://developer.roblox.com/en-us/api-reference/data-types
	]]
	if isRobloxBuiltin(value) then
		return typeof(value)
	end

	-- ROBLOX deviation: added luau types for userdata and thread
	if type(value) == "userdata" then
		return "userdata"
	end
	if typeof(value) == "thread" then
		return "thread"
	end
	-- ROBLOX deviation: code omitted because lua has no primitive bigint type
	-- ROBLOX deviation: code omitted because lua makes no distinction between tables, arrays, and objects

	-- ROBLOX deviation: include the type in the error message
	error(string.format("value of unknown type: %s (%s)", typeof(value), tostring(value)))
end

local function isPrimitive(value: any): boolean
	-- ROBLOX deviation: explicitly define objects and functions and Instances as non primitives
	return typeof(value) ~= "table" and typeof(value) ~= "function" and not isRobloxBuiltin(value)
end

return {
	getType = getType,
	isPrimitive = isPrimitive,
	isRobloxBuiltin = isRobloxBuiltin,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="341">
            <Properties>
              <string name="Name">JestGlobals</string>
              <string name="Source"><![CDATA[-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

-- ROBLOX deviation START: add export for additional Expect types
local Packages = script.Parent
local ExpectModule = require(Packages.Expect)
export type MatcherState = ExpectModule.MatcherState
export type ExpectExtended<E, State = MatcherState> = ExpectModule.ExpectExtended<E, State>
-- ROBLOX deviation END

return require(script.index)
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="342">
              <Properties>
                <string name="Name">index</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-globals/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local JestEnvironment = require(Packages.JestEnvironment)
type Jest = JestEnvironment.Jest
local importedExpect = require(Packages.Expect)

-- ROBLOX deviation START: additional imports
local jestTypesModule = require(Packages.JestTypes)
type TestFrameworkGlobals = jestTypesModule.Global_TestFrameworkGlobals

local ExpectModule = require(Packages.Expect)
type MatcherState = ExpectModule.MatcherState
type ExpectExtended<E, State = MatcherState> = ExpectModule.ExpectExtended<E, State>
-- ROBLOX deviation END

type JestGlobals =
	{
		jest: Jest,
		expect: typeof(importedExpect),
		expectExtended: ExpectExtended<{ [string]: (...any) -> nil }>,
	}
	-- ROBLOX deviation START: using TestFrameworkGlobals instead of declaring variables one by one
	& TestFrameworkGlobals
-- ROBLOX deviation END

error(Error.new(
	-- ROBLOX deviation START: aligned message to make sense for jest-roblox
	"Do not import `JestGlobals` outside of the Jest 3 test environment.\n"
		.. "Tip: Jest 2 uses a different pattern - check your Jest version."
	-- ROBLOX deviation END
))

return ({} :: any) :: JestGlobals
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="343">
            <Properties>
              <string name="Name">JestMatcherUtils</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-matcher-utils/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
local Error = LuauPolyfill.Error
local Number = LuauPolyfill.Number
local Symbol = LuauPolyfill.Symbol

local chalk = require(Packages.ChalkLua)

local JestDiff = require(Packages.JestDiff)
local DIFF_DELETE = JestDiff.DIFF_DELETE
local DIFF_EQUAL = JestDiff.DIFF_EQUAL
local DIFF_INSERT = JestDiff.DIFF_INSERT
type Diff = JestDiff.Diff
type ImportDiffOptions = JestDiff.DiffOptions
local diffDefault = JestDiff.diff
local diffStringsRaw = JestDiff.diffStringsRaw
local diffStringsUnified = JestDiff.diffStringsUnified

local JestGetType = require(Packages.JestGetType)
local getType = JestGetType.getType
local isPrimitive = JestGetType.isPrimitive

local PrettyFormat = require(Packages.PrettyFormat)
local prettyFormat = PrettyFormat.format

local Replaceable = require(CurrentModule.Replaceable)
local deepCyclicCopyReplaceable = require(CurrentModule.deepCyclicCopyReplaceable)

-- ROBLOX TODO: continue to implement prettyFormat plugins
local prettyFormatPlugins = PrettyFormat.plugins
local PLUGINS = {
	prettyFormatPlugins.AsymmetricMatcher,
	-- ROBLOX deviation: Roblox Instance matchers
	prettyFormatPlugins.RobloxInstance,
}

type MatcherHintColor = (string) -> string -- subset of Chalk type

export type MatcherHintOptions = {
	comment: string?,
	-- ROBLOX TODO? should be MatcherHintColor like in upstream, but requires modeling Chalk differently
	expectedColor: MatcherHintColor?,
	isDirectExpectCall: boolean?,
	isNot: boolean?,
	promise: string?,
	receivedColor: MatcherHintColor?,
	secondArgument: string?,
	-- ROBLOX TODO? should be MatcherHintColor like in upstream, but requires modeling Chalk differently
	secondArgumentColor: MatcherHintColor?,
}

export type DiffOptions = ImportDiffOptions

local EXPECTED_COLOR = chalk.green
local RECEIVED_COLOR = chalk.red
local INVERTED_COLOR = chalk.inverse
local BOLD_WEIGHT = chalk.bold
local DIM_COLOR = chalk.dim

local MULTILINE_REGEXP = "\n"
local SPACE_SYMBOL = utf8.char(183) -- middle dot

local NUMBERS = {
	"zero",
	"one",
	"two",
	"three",
	"four",
	"five",
	"six",
	"seven",
	"eight",
	"nine",
	"ten",
	"eleven",
	"twelve",
	"thirteen",
}

local SUGGEST_TO_CONTAIN_EQUAL =
	"Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead."

local replaceTrailingSpaces, getCommonAndChangedSubstrings, isLineDiffable, shouldPrintDiff, replaceMatchedToAsymmetricMatcher, isAsymmetricMatcher
local matcherErrorMessage, matcherHint

local function stringify(object: unknown, maxDepth_: number?, maxWidth_: number?): string
	-- ROBLOX deviation START: Added this if logic to deal with handling nil values in Lua tables
	if object == Symbol.for_("$$nil") then
		object = nil
	end
	-- ROBLOX deviation END
	local maxDepth: number = if maxDepth_ ~= nil then maxDepth_ else 10
	local maxWidth: number = if maxWidth_ ~= nil then maxWidth_ else 10

	local MAX_LENGTH = 10000
	local result

	local ok = pcall(function()
		result = prettyFormat(object, {
			maxDepth = maxDepth,
			maxWidth = maxWidth,
			min = true,
			plugins = PLUGINS,
		})
	end)

	if not ok then
		result = prettyFormat(object, {
			callToJSON = false,
			maxDepth = maxDepth,
			maxWidth = maxWidth,
			min = true,
			plugins = PLUGINS,
		})
	end

	if
		-- ROBLOX deviation START: fix length check
		-- result.length >= MAX_LENGTH --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
		#result >= MAX_LENGTH
		-- ROBLOX deviation END
		and maxDepth > 1 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return stringify(object, math.floor(maxDepth / 2), maxWidth)
	elseif
		-- ROBLOX deviation START: fix length check
		-- result.length >= MAX_LENGTH --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
		#result >= MAX_LENGTH
		-- ROBLOX deviation END
		and maxWidth > 1 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return stringify(object, maxDepth, math.floor(maxWidth / 2))
	else
		return result
	end
end

local function highlightTrailingWhitespace(text: string): string
	return text:gsub("%s+$", function(s)
		return INVERTED_COLOR(s)
	end)
end

-- Replace common spaces with middle dot at the end of any line
function replaceTrailingSpaces(text: string): string
	return text:gsub("%s+$", function(spaces)
		return string.rep(SPACE_SYMBOL, #spaces)
	end)
end

local function printReceived(object: any): string
	return RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)))
end

local function printExpected(value: any): string
	return EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)))
end

local function printWithType(
	name: string, -- 'Expected' or 'Received'
	value: any,
	print_: (any) -> string -- printExpected or printReceived
): string
	local type_ = getType(value)
	local hasType
	if type_ ~= "nil" then
		hasType = string.format("%s has type:  %s\n", name, type_)
	else
		hasType = ""
	end

	local hasValue = string.format("%s has value: %s", name, print_(value))
	return hasType .. hasValue
end

local function ensureNoExpected(expected: any, matcherName: string, options: MatcherHintOptions?): ()
	if typeof(expected) ~= "nil" then
		-- Prepend maybe not only for backward compatibility
		local matcherString = matcherName

		if not options then
			matcherString = "[.never]" .. matcherString
		end

		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherString, nil, "", options),
					"this matcher must not have an expected argument",
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end
end

-- Ensures that 'actual' is of type 'number'
local function ensureActualIsNumber(actual: any, matcherName: string, options: MatcherHintOptions?): ()
	-- ROBLOX deviation: we do not support a "bigint" type
	if typeof(actual) ~= "number" then
		-- Prepend maybe not only for backward compatibility
		local matcherString = matcherName

		if not options then
			matcherString = "[.never]" .. matcherString
		end

		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherString, nil, nil, options),
					RECEIVED_COLOR("received") .. " value must be a number",
					printWithType("Received", actual, printReceived)
				)
			)
		)
	end
end

-- Ensures that 'expected' is of type 'number'
local function ensureExpectedIsNumber(expected: any, matcherName: string, options: MatcherHintOptions?): ()
	-- ROBLOX deviation: we do not support a "bigint" type
	if typeof(expected) ~= "number" then
		-- Prepend maybe not only for backward compatibility
		local matcherString = matcherName

		if not options then
			matcherString = "[.never]" .. matcherString
		end

		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherString, nil, nil, options),
					EXPECTED_COLOR("expected") .. " value must be a number",
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end
end

-- Ensures that 'actual' & 'expected' are of type 'number'
local function ensureNumbers(actual: any, expected: any, matcherName: string, options: MatcherHintOptions?): ()
	ensureActualIsNumber(actual, matcherName, options)
	ensureExpectedIsNumber(expected, matcherName, options)
end

local function ensureExpectedIsNonNegativeInteger(expected: any, matcherName: string, options: MatcherHintOptions?): ()
	if typeof(expected) ~= "number" or not Number.isSafeInteger(expected) or expected < 0 then
		local matcherString = matcherName

		if not options then
			matcherString = "[.never]" .. matcherString
		end

		error(
			Error(
				matcherErrorMessage(
					matcherHint(matcherString, nil, nil, options),
					EXPECTED_COLOR("expected") .. " value must be a non-negative integer",
					printWithType("Expected", expected, printExpected)
				)
			)
		)
	end
end

-- Given array of diffs, return concatenated string:
-- * include common substrings
-- * exclude change substrings which have opposite op
-- * include change substrings which have argument op
--   with inverse highlight only if there is a common substring
function getCommonAndChangedSubstrings(diffs: Array<Diff>, op: number, hasCommonDiff: boolean): string
	return Array.reduce(diffs, function(reduced: string, diff: Diff): string
		if diff[1] == DIFF_EQUAL then
			return reduced .. diff[2]
		elseif diff[1] ~= op then
			return reduced
		elseif hasCommonDiff then
			return reduced .. INVERTED_COLOR(diff[2])
		else
			return reduced .. diff[2]
		end
	end, "")
end

function isLineDiffable(expected: any, received: any): boolean
	local expectedType = getType(expected)
	local receivedType = getType(received)

	if expectedType ~= receivedType then
		return false
	end

	if isPrimitive(expected) then
		-- Print generic line diff for strings only:
		-- * if neither string is empty
		-- * if either string has more than one line
		return (
			typeof(expected) == "string"
			and typeof(received) == "string"
			and #expected ~= 0
			and #received ~= 0
			and not not (string.find(expected, MULTILINE_REGEXP) or string.find(received, MULTILINE_REGEXP))
		)
	end

	if expectedType == "DateTime" or expectedType == "function" then
		return false
	end

	if expectedType == "table" and typeof(expected.asymmetricMatch) == "function" then
		return false
	end

	if receivedType == "table" and typeof(received.asymmetricMatch) == "function" then
		return false
	end

	return true
end

local MAX_DIFF_STRING_LENGTH = 20000

function printDiffOrStringify(
	expected: any,
	received: any,
	expectedLabel: string,
	receivedLabel: string,
	expand: boolean -- CLI options: true if '--expand' or false if '--no-expand'
): string
	if
		typeof(expected) == "string"
		and typeof(received) == "string"
		and #expected ~= 0
		and #received ~= 0
		and #expected <= MAX_DIFF_STRING_LENGTH
		and #received <= MAX_DIFF_STRING_LENGTH
		and expected ~= received
	then
		if string.find(expected, MULTILINE_REGEXP) or string.find(received, MULTILINE_REGEXP) then
			return diffStringsUnified(expected, received, {
				aAnnotation = expectedLabel,
				bAnnotation = receivedLabel,
				changeLineTrailingSpaceColor = chalk.bgYellow,
				commonLineTrailingSpaceColor = chalk.bgYellow,
				emptyFirstOrLastLinePlaceholder = utf8.char(8629),
				expand = expand,
				includeChangeCounts = true,
			})
		end

		local diffs = diffStringsRaw(expected, received, true)
		local hasCommonDiff = Array.some(diffs, function(diff)
			return diff[1] == DIFF_EQUAL
		end)

		local printLabel = getLabelPrinter(expectedLabel, receivedLabel)
		local expectedLine = printLabel(expectedLabel)
			.. printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff))

		local receivedLine = printLabel(receivedLabel)
			.. printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff))

		return expectedLine .. "\n" .. receivedLine
	end

	if isLineDiffable(expected, received) then
		local replaced = replaceMatchedToAsymmetricMatcher(
			deepCyclicCopyReplaceable(expected),
			deepCyclicCopyReplaceable(received),
			{},
			{}
		)
		local replacedExpected = replaced.replacedExpected
		local replacedReceived = replaced.replacedReceived
		local difference = diffDefault(replacedExpected, replacedReceived, {
			aAnnotation = expectedLabel,
			bAnnotation = receivedLabel,
			expand = expand,
			includeChangeCounts = true,
		})

		if
			typeof(difference) == "string"
			and string.find(difference, "%- " .. expectedLabel)
			and string.find(difference, "%+ " .. receivedLabel)
		then
			return difference
		end
	end

	local printLabel = getLabelPrinter(expectedLabel, receivedLabel)
	local expectedLine = printLabel(expectedLabel) .. printExpected(expected)
	local receivedLine
	if stringify(expected) == stringify(received) then
		receivedLine = printLabel(receivedLabel) .. "serializes to the same string"
	else
		receivedLine = printLabel(receivedLabel) .. printReceived(received)
	end

	return expectedLine .. "\n" .. receivedLine
end

-- Sometimes, e.g. when comparing two numbers, the output from jest-diff
-- does not contain more information than the 'Expected:' / 'Received:' already gives.
-- In those cases, we do not print a diff to make the output shorter and  not redundant.
function shouldPrintDiff(actual: any, expected: any)
	if typeof(actual) == "number" and typeof(expected) == "number" then
		return false
	end

	-- ROBLOX deviation: excluded if statement checking bigint types

	if typeof(actual) == "boolean" and typeof(expected) == "boolean" then
		return false
	end

	return true
end

function replaceMatchedToAsymmetricMatcher(
	replacedExpected: any,
	replacedReceived: any,
	expectedCycles: Array<any>,
	receivedCycles: Array<any>
)
	if not Replaceable.isReplaceable(replacedExpected, replacedReceived) then
		return {
			replacedExpected = replacedExpected,
			replacedReceived = replacedReceived,
		}
	end

	if
		Array.indexOf(expectedCycles, replacedExpected) ~= -1
		or Array.indexOf(receivedCycles, replacedReceived) ~= -1
	then
		return {
			replacedExpected = replacedExpected,
			replacedReceived = replacedReceived,
		}
	end

	table.insert(expectedCycles, replacedExpected)
	table.insert(receivedCycles, replacedReceived)

	local expectedReplaceable = Replaceable.new(replacedExpected)
	local receivedReplaceable = Replaceable.new(replacedReceived)

	expectedReplaceable:forEach(function(expectedValue: any, key: any)
		local receivedValue = receivedReplaceable:get(key)
		if isAsymmetricMatcher(expectedValue) then
			if expectedValue:asymmetricMatch(receivedValue) then
				receivedReplaceable:set(key, expectedValue)
			end
		elseif isAsymmetricMatcher(receivedValue) then
			if receivedValue:asymmetricMatch(expectedValue) then
				expectedReplaceable:set(key, receivedValue)
			end
		elseif Replaceable.isReplaceable(expectedValue, receivedValue) then
			local replaced =
				replaceMatchedToAsymmetricMatcher(expectedValue, receivedValue, expectedCycles, receivedCycles)
			expectedReplaceable:set(key, replaced.replacedExpected)
			receivedReplaceable:set(key, replaced.replacedReceived)
		end
	end)

	return {
		replacedExpected = expectedReplaceable.object,
		replacedReceived = receivedReplaceable.object,
	}
end

-- ROBLOX deviation: excluded type annotation for AsymmetricMatcher because Luau does
-- not yet support type annotations for a generic function

function isAsymmetricMatcher(data: any)
	local type_ = getType(data)
	return type_ == "table" and typeof(data.asymmetricMatch) == "function"
end

local function diff(
	a: any,
	b: any,
	options -- ROBLOX deviation: omitted type annotation since we don't have DiffOptions translated
): string | nil
	return shouldPrintDiff(a, b) and diffDefault(a, b, options) or nil
end

function pluralize(word: string, count: number): string
	if count == 1 then
		return (NUMBERS[count + 1] or count) .. " " .. word
	else
		return (NUMBERS[count + 1] or count) .. " " .. word .. "s"
	end
end

-- To display lines of labeled values as two columns with monospac alignment:
-- given the strings which will describe the values,
-- return function which given each string, returns the label:
-- stirng, colon, space, and enough padding spaces to align the value.

type PrintLabel = (string) -> string

-- ROBLOX deviation: no annotation for "..." args
function getLabelPrinter(...): PrintLabel
	local strings: Array<string> = { ... }

	local maxLength = Array.reduce(strings, function(max, string_)
		return math.max(#string_, max)
	end, 0)

	return function(string_: string): string
		-- ROBLOX deviation: We need to throw an error since string.rep called for
		-- a negative repetition doesn't actually throw whereas upstream
		-- would throw
		if #string_ > maxLength then
			error("Cannot print label for string with length larger than the max allowed of " .. maxLength)
		end
		return string.format("%s: %s", string_, string.rep(" ", maxLength - #string_))
	end
end

function matcherErrorMessage(
	hint: string, -- assertion returned from call to matcherHint
	generic: string, -- condition which correct value must fulfill
	specific: string? -- incorrect value returned from call to printWithType
): string
	if typeof(specific) == "string" then
		return string.format("%s\n\n%s: %s%s", hint, BOLD_WEIGHT("Matcher error"), generic, "\n\n" .. specific)
	else
		return string.format("%s\n\n%s: %s%s", hint, BOLD_WEIGHT("Matcher error"), generic, "")
	end
end

-- Display assertion for the report when a test fails.
-- New format: rejects/resolves, not, and matcher name have black color
-- Old format: matcher name has dim color
function matcherHint(matcherName: string, received: string?, expected: string?, options: MatcherHintOptions?): string
	received = received or "received"
	expected = expected or "expected"
	options = options or {}

	--[[
		ROBLOX TODO: Remove the "if options" check once it can pass through
		Luau cleanly and define all of the variables in-line i.e.
		local comment = options.comment or ""
	]]
	local comment, expectedColor, isDirectExpectCall, isNot, promise, receivedColor, secondArgument, secondArgumentColor
	if options then
		comment = options.comment or ""
		expectedColor = options.expectedColor or EXPECTED_COLOR
		isDirectExpectCall = options.isDirectExpectCall or false
		isNot = options.isNot or false
		promise = options.promise or ""
		receivedColor = options.receivedColor or RECEIVED_COLOR
		secondArgument = options.secondArgument or ""
		secondArgumentColor = options.secondArgumentColor or EXPECTED_COLOR
	end

	local hint = ""
	local dimString = "expect" -- concatenate adjacent dim substrings

	if not isDirectExpectCall and received ~= "" then
		hint = hint .. DIM_COLOR(dimString .. "(") .. receivedColor(received)
		dimString = ")"
	end

	if promise ~= "" then
		hint = hint .. DIM_COLOR(dimString .. ".") .. promise
		dimString = ""
	end

	if isNot then
		hint = hint .. DIM_COLOR(dimString .. ".") .. "never"
		dimString = ""
	end

	if string.find(matcherName, "%.") then
		-- Old format: for backward compatibility,
		-- especially without promise or isNot options
		dimString = dimString .. matcherName
	else
		-- New format: omit period from matcherName arg
		hint = hint .. DIM_COLOR(dimString .. ".") .. matcherName
		dimString = ""
	end

	if expected == "" then
		dimString = dimString .. "()"
	else
		hint = hint .. DIM_COLOR(dimString .. "(") .. expectedColor(expected)
		if secondArgument ~= "" then
			hint = hint .. DIM_COLOR(", ") .. secondArgumentColor(secondArgument)
		end
		dimString = ")"
	end

	if comment ~= "" then
		dimString = dimString .. " -- " .. comment
	end

	if dimString ~= "" then
		hint = hint .. DIM_COLOR(dimString)
	end

	return hint
end

return {
	EXPECTED_COLOR = EXPECTED_COLOR,
	RECEIVED_COLOR = RECEIVED_COLOR,
	INVERTED_COLOR = INVERTED_COLOR,
	BOLD_WEIGHT = BOLD_WEIGHT,
	DIM_COLOR = DIM_COLOR,

	SUGGEST_TO_CONTAIN_EQUAL = SUGGEST_TO_CONTAIN_EQUAL,

	stringify = stringify,
	highlightTrailingWhitespace = highlightTrailingWhitespace,
	printReceived = printReceived,
	printExpected = printExpected,
	printWithType = printWithType,
	ensureNoExpected = ensureNoExpected,
	ensureActualIsNumber = ensureActualIsNumber,
	ensureExpectedIsNumber = ensureExpectedIsNumber,
	ensureNumbers = ensureNumbers,
	ensureExpectedIsNonNegativeInteger = ensureExpectedIsNonNegativeInteger,
	printDiffOrStringify = printDiffOrStringify,
	diff = diff,
	pluralize = pluralize,
	getLabelPrinter = getLabelPrinter,
	matcherErrorMessage = matcherErrorMessage,
	matcherHint = matcherHint,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="344">
              <Properties>
                <string name="Name">Replaceable</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-matcher-utils/src/Replaceable.ts
-- /**
-- * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
-- *
-- * This source code is licensed under the MIT license found in the
-- * LICENSE file in the root directory of this source tree.
-- */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local getType = require(Packages.JestGetType).getType

type ReplaceableForEachCallBack = (any, any, any) -> nil

local Replaceable = {}

Replaceable.__index = Replaceable
function Replaceable.new(object: any)
	local self = {}
	self.object = object
	self.type = getType(object)

	if self.type ~= "table" then
		error("Type " .. self.type .. " is not supported in Replaceable!")
	end

	setmetatable(self, Replaceable)

	return self
end

function Replaceable.isReplaceable(obj1: any, obj2: any): boolean
	local obj1Type = getType(obj1)
	local obj2Type = getType(obj2)

	return obj1Type == obj2Type and obj1Type == "table"
end

function Replaceable:forEach(callback: ReplaceableForEachCallBack)
	for key, value in pairs(self.object) do
		callback(value, key, self.object)
	end
end

function Replaceable:get(key: any): any
	return self.object[key]
end

function Replaceable:set(key: any, value: any)
	self.object[key] = value
end

return Replaceable
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="345">
              <Properties>
                <string name="Name">deepCyclicCopyReplaceable</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-matcher-utils/src/deepCyclicCopyReplaceable.ts
-- /**
-- * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
-- *
-- * This source code is licensed under the MIT license found in the
-- * LICENSE file in the root directory of this source tree.
-- */

-- ROBLOX deviation: omitted isBuiltInObject and isMap functions because Lua only has one type, the table,
-- for structuring data

local deepCyclicCopyTable, deepCyclicCopyReplaceable

type anyTable = { [any]: any }

function deepCyclicCopyTable(tableToCopy: anyTable, cycles: anyTable)
	local newTable: anyTable = {}

	cycles[tableToCopy] = newTable

	for key, value in pairs(tableToCopy) do
		newTable[key] = deepCyclicCopyReplaceable(value, cycles)
	end

	return newTable
end

function deepCyclicCopyReplaceable(value: any, cycles: anyTable)
	if typeof(value) ~= "table" then
		return value
	elseif cycles[value] then
		return cycles[value]
	else
		local t = deepCyclicCopyTable(value, cycles)
		local mt = getmetatable(value)
		if mt and typeof(mt) == "table" then
			setmetatable(t, mt)
		end
		return t
	end
end

return function(value, cycles_: anyTable?)
	local cycles = cycles_ or {}
	setmetatable(cycles :: any, { _mode = "kv" })

	return deepCyclicCopyReplaceable(value, cycles)
end
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="346">
            <Properties>
              <string name="Name">JestMessageUtil</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-message-util/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
local RegExp = require(Packages.RegExp)

local exports = {}

local chalk = require(Packages.ChalkLua)
local jestTypesModule = require(Packages.JestTypes)
type Config_Path = jestTypesModule.Config_Path
type TestResult_SerializableError = jestTypesModule.TestResult_SerializableError
type TestResult_AssertionResult = jestTypesModule.TestResult_AssertionResult
local prettyFormat = require(Packages.PrettyFormat).format

type Path = Config_Path

-- ROBLOX deviation START: additional dependencies
local RobloxShared = require(Packages.RobloxShared)
local normalizePromiseError = RobloxShared.normalizePromiseError
local cleanLoadStringStack = RobloxShared.cleanLoadStringStack
-- ROBLOX deviation END

-- ROBLOX deviation: forward declarations
local formatStackTrace, getStackTraceLines, separateMessageFromStack

-- ROBLOX deviation: omitting imports since they're mostly fs related

-- ROBLOX deviation: static definition for StackTraceConfig
export type StackTraceConfig = {
	-- ROBLOX deviation START: using Instance instead of string
	rootDir: Instance?,
	-- ROBLOX deviation END
	testMatch: Array<string>,
}

export type StackTraceOptions = { noStackTrace: boolean, noCodeFrame: boolean? }

--[[
	ROBLOX deviation: rewrote regex patterns and split up patterns for alternations
	original code:
	const JASMINE_IGNORE =
	  /^\s+at(?:(?:.jasmine\-)|\s+jasmine\.buildExpectationResult)/;
]]
-- filter for noisy stack trace lines
local JASMINE_IGNORE = "%s+at(.jasmine%-)"
local JASMINE_IGNORE_BUILDEXPECTATIONRESULT = "%s+at(%s+jasmine%.buildExpectationResult)"
--[[
	ROBLOX deviation: skipping JEST_INTERNALS_IGNORE
	original code:
	const JEST_INTERNALS_IGNORE =
	  /^\s+at.*?jest(-.*?)?(\/|\\)(build|node_modules|packages)(\/|\\)/;
]]
local ANONYMOUS_FN_IGNORE = "^%s+at <anonymous>.*$"
-- ROBLOX deviation: no optional capturing group in Lua string patterns so we try matching against both
local ANONYMOUS_PROMISE_IGNORE = "^%s+at Promise %(<anonymous>%).*$"
local ANONYMOUS_NEW_PROMISE_IGNORE = "^%s+at new Promise %(<anonymous>%).*$"
local ANONYMOUS_GENERATOR_IGNORE = "^%s+at Generator.next %(<anonymous>%).*$"
local NATIVE_NEXT_IGNORE = "^%s+at next %(native%).*$"
local TITLE_INDENT = "  "
local MESSAGE_INDENT = "    "
local STACK_INDENT = "      "
local ANCESTRY_SEPARATOR = " › "
local TITLE_BULLET = chalk.bold("● ")
local STACK_TRACE_COLOR = chalk.dim
local STACK_PATH_REGEXP = "%s*at.*%(?:%d*:%d*%)?"
local STACK_PATH_REGEXP_NATIVE = "%s*at.*%(?native%)?"
local EXEC_ERROR_MESSAGE = "Test suite failed to run"

-- ROBLOX deviation START: rewrote this because Lua doesn't have negative lookahead
local function indentAllLines(lines: string, indent: string?): string
	local t = string.split(lines, "\n")
	for i, l in t do
		t[i] = (indent or "") .. l
	end
	return table.concat(t, "\n")
end
exports.indentAllLines = indentAllLines
-- ROBLOX deviation END

-- string trim5 implementation from http://lua-users.org/wiki/StringTrim
local function trim(string_: string): string
	return String.trim(string_ or "")
end

-- Some errors contain not only line numbers in stack traces
-- e.g. SyntaxErrors can contain snippets of code, and we don't
-- want to trim those, because they may have pointers to the column/character
-- which will get misaligned.
local function trimPaths(string_: string): string
	-- ROBLOX deviation: match both since Lua doesn't have alternations
	if string_:find(STACK_PATH_REGEXP) or string_:find(STACK_PATH_REGEXP_NATIVE) then
		return trim(string_)
	end
	return string_
end

-- ROBLOX deviation START: can't match for blank string in Lua so we match for NOT blank string
local notBlankStringRegexp = "%S"
local blankStringRegexp = {
	test = function(_self, str: string): boolean
		return string.match(str, notBlankStringRegexp) == nil
	end,
}
-- ROBLOX deviation END

local function checkForCommonEnvironmentErrors(error_): string
	-- ROBLOX deviation START: no need to check for jsdom nor node specific environment errors
	-- if
	-- 	String.includes(error_, "ReferenceError: document is not defined")
	-- 	or String.includes(error_, "ReferenceError: window is not defined")
	-- 	or String.includes(error_, "ReferenceError: navigator is not defined")
	-- then
	-- 	return warnAboutWrongTestEnvironment(error_, "jsdom")
	-- elseif String.includes(error_, ".unref is not a function") then
	-- 	return warnAboutWrongTestEnvironment(error_, "node")
	-- end
	-- ROBLOX deviation END
	return error_
end

-- ROBLOX deviation START: not used
-- local function warnAboutWrongTestEnvironment(error_: string, env: "jsdom" | "node")
-- 	return chalk.red(
-- 		chalk.bold(
-- 			(
-- 				'The error below may be caused by using the wrong test environment, see %s.\nConsider using the "%s" test environment.\n\n'
-- 			):format(
-- 				chalk.underline(chalk.dim("https://jestjs.io/docs/configuration#testenvironment-string")),
-- 				tostring(env)
-- 			)
-- 		)
-- 	) .. error_
-- end
-- ROBLOX deviation END

-- ExecError is an error thrown outside of the test suite (not inside an `it` or
-- `before/after each` hooks). If it's thrown, none of the tests in the file
-- are executed.
local function formatExecError(
	error_: Error | TestResult_SerializableError | string | nil,
	config: StackTraceConfig,
	options: StackTraceOptions,
	testPath: string?,
	reuseMessage: boolean?
): string
	if not Boolean.toJSBoolean(error_) or typeof(error_) == "number" then
		error_ = Error.new(('Expected an Error, but "%s" was thrown'):format(tostring(error_)))
		error_.stack = ""
	end

	local message: string, stack: string

	if typeof(error_) == "string" or not Boolean.toJSBoolean(error_) or error_ == nil then
		if not Boolean.toJSBoolean(error_) then
			error_ = "EMPTY ERROR"
		end
		message = ""
		-- ROBLOX FIXME Luau: error_ is guaranteed to be string at this point
		stack = error_ :: string
	else
		-- ROBLOX deviation START: additional logic to handle Promise library error
		if (error_ :: any).kind == "ExecutionError" then
			error_ = normalizePromiseError(error_)
		end
		-- ROBLOX deviation END
		message = error_.message
		stack = if typeof(error_.stack) == "string"
			then error_.stack
			else ("thrown: %s"):format(prettyFormat(error_, { maxDepth = 3 }))
	end

	local separated = separateMessageFromStack(Boolean.toJSBoolean(stack) and stack or "")
	stack = separated.stack

	-- ROBLOX deviation START: using string.find instead
	-- 	if
	-- 		Boolean.toJSBoolean(
	-- 			Array.includes(separated.message, trim(message)) --[[ ROBLOX CHECK: check if 'separated.message' is an Array ]]
	-- 		)
	-- 	then
	if string.find(separated.message, trim(message), 1, true) ~= nil then
		-- ROBLOX deviation END
		-- Often stack trace already contains the duplicate of the message
		message = separated.message
	end

	message = checkForCommonEnvironmentErrors(message)

	message = indentAllLines(message, MESSAGE_INDENT)

	stack = if Boolean.toJSBoolean(stack) and not options.noStackTrace
		then "\n" .. formatStackTrace(stack, config, options, testPath)
		else ""

	if typeof(stack) ~= "string" or (blankStringRegexp:test(message) and blankStringRegexp:test(stack)) then
		-- this can happen if an empty object is thrown.
		message = ("thrown: %s"):format(tostring(prettyFormat(error_, { maxDepth = 3 })))
	end

	local messageToUse
	if reuseMessage then
		messageToUse = (" %s"):format(String.trim(message))
	else
		messageToUse = ("%s\n\n%s"):format(EXEC_ERROR_MESSAGE, message)
	end

	return TITLE_INDENT .. TITLE_BULLET .. messageToUse .. stack .. "\n"
end
exports.formatExecError = formatExecError

local function removeInternalStackEntries(lines: { string }, options: StackTraceOptions): { string }
	local pathCounter = 0

	return Array.filter(lines, function(line)
		if line:find(ANONYMOUS_FN_IGNORE) then
			return false
		end

		if line:find(ANONYMOUS_PROMISE_IGNORE) or line:find(ANONYMOUS_NEW_PROMISE_IGNORE) then
			return false
		end

		if line:find(ANONYMOUS_GENERATOR_IGNORE) then
			return false
		end

		if line:find(NATIVE_NEXT_IGNORE) then
			return false
		end

		-- ROBLOX deviation: omitting node specific stuff
		-- if (nodeInternals.some(internal => internal.test(line))) {
		-- 	return false;
		-- }

		-- ROBLOX deviation: match both since Lua doesn't have alternations
		if not line:find(STACK_PATH_REGEXP) or not line:find(STACK_PATH_REGEXP_NATIVE) then
			return true
		end

		-- ROBLOX deviation: match both since Lua doesn't have alternations
		if line:find(JASMINE_IGNORE) or line:find(JASMINE_IGNORE_BUILDEXPECTATIONRESULT) then
			return false
		end

		pathCounter += 1
		if pathCounter == 1 then
			return true -- always keep the first line even if it's from Jest
		end

		if options.noStackTrace then
			return false
		end

		-- if (JEST_INTERNALS_IGNORE.test(line)) {
		-- 	return false;
		-- }

		return true
	end)
end

-- ROBLOX deviation: config does not have StackTraceConfig type annotation
local function formatPaths(config, relativeTestPath, line: string): string
	-- ROBLOX deviation: if loadstring is used, format the loadstring stacktrace to look like a path
	return cleanLoadStringStack(line)
end

function getStackTraceLines(stack: string, options: StackTraceOptions): { string }
	if options == nil then
		options = { noCodeFrame = false, noStackTrace = false }
	end
	return removeInternalStackEntries(string.split(stack, "\n"), options)
end
exports.getStackTraceLines = getStackTraceLines

function formatStackTrace(stack: string, config, options: StackTraceOptions, testPath): string
	local lines = getStackTraceLines(stack, options)

	local relativeTestPath = nil
	if testPath then
		relativeTestPath = "unsupported"
	end

	local stacktrace = table.concat(
		Array.map(Array.filter(lines, Boolean.toJSBoolean), function(line)
			return STACK_INDENT .. formatPaths(config, relativeTestPath, trimPaths(line))
		end),
		"\n"
	)

	return string.format("\n%s", stacktrace)
end
exports.formatStackTrace = formatStackTrace

type FailedResults = Array<{
	content: string,
	result: TestResult_AssertionResult,
}>

local function formatResultsErrors(
	testResults: Array<TestResult_AssertionResult>,
	config: StackTraceConfig,
	options: StackTraceOptions,
	testPath: Path?
): string | nil
	local failedResults: FailedResults = Array.reduce(testResults, function(errors, result)
		Array.forEach(result.failureMessages, function(item)
			table.insert(errors, { content = checkForCommonEnvironmentErrors(item), result = result })
		end)
		return errors
	end, {})

	if not (#failedResults > 0) then
		return nil
	end

	return Array.join(
		Array.map(failedResults, function(ref)
			local result, content = ref.result, ref.content
			local ref_ = separateMessageFromStack(content)
			local message, stack = ref_.message, ref_.stack
			stack = if options.noStackTrace
				then ""
				else STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) .. "\n"
			message = indentAllLines(message, MESSAGE_INDENT)
			local title = chalk.bold(
				chalk.red(
					TITLE_INDENT
						.. TITLE_BULLET
						.. Array.join(result.ancestorTitles, ANCESTRY_SEPARATOR)
						.. (if #result.ancestorTitles > 0 then ANCESTRY_SEPARATOR else "")
						.. result.title
				)
			) .. "\n"
			return title .. "\n" .. message .. "\n" .. stack
		end),
		"\n"
	)
end
exports.formatResultsErrors = formatResultsErrors

local errorRegexp = "^Error:?%s*$"

local function removeBlankErrorLine(str: string): string
	return String.trimRight(table.concat(
		Array.filter(String.split(str, "\n"), function(line)
			return not line:find(errorRegexp)
		end),
		"\n"
	))
end

-- jasmine and worker farm sometimes don't give us access to the actual
-- Error object, so we have to regexp out the message from the stack string
-- to format it.
function separateMessageFromStack(content: string): { message: string, stack: string }
	if not content then
		return { message = "", stack = "" }
	end

	-- All lines up to what looks like a stack -- or if nothing looks like a stack
	-- (maybe it's a code frame instead), just the first non-empty line.
	-- If the error is a plain "Error:" instead of a SyntaxError or TypeError we
	-- remove the prefix from the message because it is generally not useful.
	--[[
		ROBLOX deviation START: adjusted the RegExp to look for Luau specific stacktrace - line starting with LoadedCode
		original regexp: RegExp([=[^(?:Error: )?([\s\S]*?(?=\n\s*at\s.*:\d*:\d*)|\s*.*)([\s\S]*)$]=])
	]]
	local re = RegExp([=[^(?:Error: )?([\s\S]*?(?=\n\s*LoadedCode.*:\d*)|\s*.*)([\s\S]*)$]=])
	-- ROBLOX deviation END
	local messageMatch = re:exec(content)
	if not messageMatch then
		-- For typescript
		error("If you hit this error, the regex above is buggy.")
	end
	local message = removeBlankErrorLine(messageMatch[2])
	local stack = removeBlankErrorLine(messageMatch[3])
	return { message = message, stack = stack }
end
exports.separateMessageFromStack = separateMessageFromStack

return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="347">
            <Properties>
              <string name="Name">JestMock</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-mock/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

-- ROBLOX deviation: Currently we have translated a limited subset of the jest-mock
-- functionality just to bootstrap the development of the spyMatchers. As we have
-- a need for more functionality, we will revisit this file and continue the translation
-- efforts.

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Set = LuauPolyfill.Set
local Symbol = LuauPolyfill.Symbol

-- ROBLOX deviation START: mocking globals
local JestMockGenv = require(Packages.JestMockGenv)
type GlobalMocker = JestMockGenv.GlobalMocker
type GlobalAutomocks = JestMockGenv.GlobalAutomocks
local GlobalMocker = JestMockGenv.GlobalMocker
-- ROBLOX deviation END

-- ROBLOX deviation START: inject alike types
local JestTypes = require(Packages.JestTypes)
type Config_ProjectConfig = JestTypes.Config_ProjectConfig
-- ROBLOX deviation END

-- ROBLOX deviation START: mock data model
local JestMockRbx = require(Packages.JestMockRbx)
local DataModelMocker = JestMockRbx.DataModelMocker
-- ROBLOX deviation END

type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local exports = {}

local ModuleMockerClass = {}

-- ROBLOX TODO: Uncomment this type once Luau has supported ... syntax
-- type Function = (...) -> any;
-- ROBLOX TODO: Fix once Luau has support for default type arguments
type MockDefaultY = Array<any>
type MockFunctionState<T, Y> = {
	calls: Array<Y>,
	instances: Array<T>,
	contexts: Array<T>,
	invocationCallOrder: Array<number>,
	lastCall: Array<T>?,
	results: Array<MockFunctionResult>,
}

--[[
	ROBLOX deviation: skipped code
	original code lines 35 - 67
]]

--[[
	ROBLOX deviation START: skipped unsupported TS functionality
	original code:
	export type MaybeMockedDeep<T> = T extends MockableFunction
	  ? MockedFunctionDeep<T>
	  : T extends object
	  ? MockedObjectDeep<T>
	  : T;

	export type MaybeMocked<T> = T extends MockableFunction
	  ? MockedFunction<T>
	  : T extends object
	  ? MockedObject<T>
	  : T;
	]]
export type MaybeMockedDeep<T> = T
export type MaybeMocked<T> = T
-- ROBLOX deviation END

--[[
	ROBLOX deviation: skipped code
	original code lines 81 - 103
]]

export type UnknownFunction = (...unknown) -> ...unknown
export type Mock<T = UnknownFunction> = any
-- ROBLOX TODO: Uncomment this type and use it once Luau has supported it
-- ROBLOX TODO: Un in-line the MockInstance type declaration once we have "extends" syntax in Luau
-- type Mock<T, Y> = {
-- 	_isMockFunction: boolean,
-- 	_protImpl: Function,
--     getMockName: () -> string,
--     getMockImplementation: () -> Function?,
--     mock: MockFunctionState<T, Y>,
--     mockClear: () -> Mock<T, Y>,
--     mockReset: () -> Mock<T, Y>,
--     -- ROBLOX deviation: Revisit after https://github.com/facebook/jest/issues/11244
--     mockRestore: any,
--     mockImplementation: (...) -> T) -> Mock<T, Y>,
--     mockImplementationOnce (...) -> T -> Mock<T, Y>,
--     mockName: (string) -> Mock<T, Y>,
--     mockReturnThis: () -> Mock<T, Y>,
--     mockReturnValue: (T) -> Mock<T, Y>,
--     mockReturnValueOnce: (T) -> Mock<T, Y>,
-- 	new: (...) -> T,
-- 	ROBLOX TODO: Use some form of this when Lua supports metamethod typing
-- 	__call: (...) -> T
-- };

-- ROBLOX deviation: MockFunctionResultType defined as string for now but
-- eventually should be = 'return' | 'throw' | 'incomplete';
type MockFunctionResultType = string
type MockFunctionResult = {
	type: MockFunctionResultType,
	value: any,
}
type MockFunctionConfig = {
	-- ROBLOX deviation: mockImpl defined as any for now but should be Function | nil if/when Luau supports general function type
	mockImpl: any,
	mockName: string,
	specificReturnValues: Array<any>,
	-- ROBLOX deviation: specificMockImpls defined as Array<any> for now but should be Array<Function> if/when Luau supports general function type
	specificMockImpls: Array<any>,
}

-- ROBLOX deviation START: mocking globals
-- ROBLOX deviation END

export type ModuleMocker = {
	isMockFunction: (_self: ModuleMocker, fn: any) -> boolean,
	fn: <T..., Y...>(_self: ModuleMocker, implementation: ((T...) -> Y...)?) -> (MockFn, (...any) -> ...any),
	clearAllMocks: (_self: ModuleMocker) -> (),
	resetAllMocks: (_self: ModuleMocker) -> (),
	restoreAllMocks: (_self: ModuleMocker) -> (),
	mocked: <T>(_self: ModuleMocker, item: T, _deep: boolean?) -> MaybeMocked<T> | MaybeMockedDeep<T>,
	-- ROBLOX deviation START: mock data model
	spyOn: <M>(
		_self: ModuleMocker,
		object: { [any]: any } | Instance,
		methodName: M,
		accessType: ("get" | "set")?
	) -> Mock<any>,
	protectDataModel: (_self: ModuleMocker, predicate: (Instance, methodName: string) -> boolean) -> (),
	dataModelMocker: JestMockRbx.DataModelMocker,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: mocking globals
	mockGlobals: (_self: ModuleMocker, globals: GlobalMocker, env: Object) -> (),
	unmockGlobals: (_self: ModuleMocker, globals: GlobalMocker) -> (),
	-- ROBLOX deviation END
}

ModuleMockerClass.__index = ModuleMockerClass
function ModuleMockerClass.new(
	-- ROBLOX deviation: inject alike types
	config: Config_ProjectConfig
): ModuleMocker
	local self = {
		-- ROBLOX deviation START: inject alike types
		_projectConfig = config,
		_mocksOnObjectsMap = setmetatable({}, {
			-- we have no use for knowledge about objects that user code has
			-- discarded, no need to hold our info in memory strongly
			-- we will have to revisit this for instance references
			__mode = "k",
		}),
		-- ROBLOX deviation END
		_mockState = {},
		_mockConfigRegistry = {},
		_invocationCallCounter = 1,
		_spyState = Set.new(),
		-- ROBLOX deviation START: mock data model
		dataModelMocker = DataModelMocker.new(),
		_dataModelProtector = function(_, _)
			return true
		end,
		-- ROBLOX deviation END
	}

	setmetatable(self, ModuleMockerClass)

	return (self :: any) :: ModuleMocker
end

-- ROBLOX deviation: omitting _getSlots as it is specific to JS prototypes

function ModuleMockerClass:_ensureMockConfig(f): MockFunctionConfig
	local config = self._mockConfigRegistry[f]
	if not config then
		config = self:_defaultMockConfig()
		self._mockConfigRegistry[f] = config
	end

	return config
end

-- how to annotate this function
function ModuleMockerClass:_ensureMockState(f): MockFunctionState<any, any>
	local state = self._mockState[f]
	if not state then
		state = self:_defaultMockState()
		self._mockState[f] = state
	end

	-- ROBLOX deviation START: replace .length usages
	-- if
	-- 	state.calls.length
	-- 	> 0 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	-- then
	-- 	state.lastCall = state.calls[tostring(state.calls.length - 1)]
	-- end
	if #state.calls > 0 then
		state.lastCall = state.calls[#state.calls]
	end
	-- ROBLOX deviation END

	return state
end

function ModuleMockerClass:_defaultMockConfig(): MockFunctionConfig
	return {
		mockImpl = nil,
		mockName = "jest.fn()",
		specificMockImpls = {},
		specificReturnValues = {},
	}
end

function ModuleMockerClass:_defaultMockState()
	return {
		calls = {},
		contexts = {},
		instances = {},
		invocationCallOrder = {},
		results = {},
	}
end

function ModuleMockerClass:_makeComponent(metadata: any, restore)
	if metadata.type == "function" then
		local mocker = self

		local mockConstructor = function(f, ...)
			local args = { ... }

			local mockState = mocker:_ensureMockState(f)
			local mockConfig = mocker:_ensureMockConfig(f)

			-- ROBLOX deviation START: upstream 'this' replaced with f and first arg
			-- table.insert(mockState.instances, self) --[[ ROBLOX CHECK: check if 'mockState.instances' is an Array ]]
			-- table.insert(mockState.contexts, self) --[[ ROBLOX CHECK: check if 'mockState.contexts' is an Array ]]
			table.insert(mockState.instances, f)
			table.insert(mockState.contexts, args[1])
			-- ROBLOX deviation END

			-- ROBLOX deviation: We use a Symbol meant to represent nil instead of
			-- actual nil values to help with handling nil values
			for i = 1, select("#", ...) do
				if args[i] == nil then
					args[i] = Symbol.for_("$$nil")
				end
			end
			table.insert(mockState.calls, args)

			-- Create and record an "incomplete" mock result immediately upon
			-- calling rather than waiting for the mock to return. This avoids
			-- issues caused by recursion where results can be recorded in the
			-- wrong order.
			local mockResult = {
				type = "incomplete",
				value = nil,
			}

			table.insert(mockState.results, mockResult)
			table.insert(mockState.invocationCallOrder, mocker._invocationCallCounter)
			mocker._invocationCallCounter = mocker._invocationCallCounter + 1

			-- ROBLOX deviation: omitted finalReturnValue, thrownError, and
			-- callDidThrowError as we get this state for free with our
			-- pcall error handling

			local ok, result = pcall(function(args_)
				-- ROBLOX deviation: omitted section of code dealing with calling
				-- function as constructor
				local specificMockImpl = Array.shift(mockConfig.specificMockImpls)
				if specificMockImpl == nil then
					specificMockImpl = mockConfig.mockImpl
				end

				if specificMockImpl then
					return specificMockImpl(unpack(args_))
				end

				-- ROBLOX deviation: omitted section on f._protoImpl
				return nil
			end, { ... })

			if not ok then
				mockResult.type = "throw"
				mockResult.value = result

				error(result)
			end

			mockResult.type = "return"
			mockResult.value = result

			return result
		end

		local f = setmetatable({}, { __call = mockConstructor })

		f._isMockFunction = true
		f.getMockImplementation = function()
			return mocker:_ensureMockConfig(f).mockImpl
		end

		if typeof(restore) == "function" then
			mocker._spyState:add(restore)
		end

		mocker._mockState[f] = mocker._defaultMockState()
		mocker._mockConfigRegistry[f] = mocker._defaultMockConfig()

		f.mock = setmetatable({}, {
			__index = function(tbl, key)
				return mocker:_ensureMockState(f)[key]
			end,
			-- ROBLOX deviation: for now we don't have newindex defined as we don't have any use cases
			-- but it should look something like the following
			-- __newindex = function(table, key, value)
			-- 		local state = self:_ensureMockState(f)
			-- 		state[key] = value
			-- 		return state
			-- 	end
		})

		f.mockClear = function()
			mocker._mockState[f] = nil
			return f
		end

		f.mockReset = function()
			f.mockClear()
			mocker._mockConfigRegistry[f] = nil
			return f
		end

		f.mockRestore = function()
			f.mockReset()
			if restore then
				return restore()
			else
				return nil
			end
		end

		-- ROBLOX deviation: omitted mockResolvedValue and mockRejectedValue

		f.mockImplementationOnce = function(fn)
			-- next function call will use this mock implementation return value
			-- or default mock implementation return value
			local mockConfig = mocker:_ensureMockConfig(f)
			table.insert(mockConfig.specificMockImpls, fn)
			return f
		end

		f.mockImplementation = function(fn)
			-- next function call will use mock implementation return value
			local mockConfig = mocker:_ensureMockConfig(f)
			mockConfig.mockImpl = fn
			return f
		end

		f.mockReturnValueOnce = function(value)
			-- next function call will return this value or default return value
			return f.mockImplementationOnce(function()
				return value
			end)
		end

		-- ROBLOX deviation: omitted mockResolvedValueOnce and mockRejectedValueOnce

		f.mockReturnValue = function(value)
			-- next function call will return specified return value or this one
			return f.mockImplementation(function()
				return value
			end)
		end

		f.mockReturnThis = function()
			return f.mockImplementation(function(this)
				return f
			end)
		end

		f.mockName = function(name)
			if name then
				local mockConfig = mocker:_ensureMockConfig(f)
				mockConfig.mockName = name
			end
			return f
		end

		f.getMockName = function()
			local mockConfig = mocker:_ensureMockConfig(f)
			return mockConfig.mockName or "jest.fn()"
		end

		-- ROBLOX deviation: Since we don't have the new keyword in Lua, we add a
		-- fn.new() function
		f.new = function(...)
			f(...)
			return f
		end

		if metadata.mockImpl then
			f.mockImplementation(metadata.mockImpl)
		end

		-- ROBLOX deviation: fn is a callable table, return a forwarding function
		return f,
			function(...)
				-- Should be identical to getmetatable(f).__call(f, ...)
				return mockConstructor(f, ...)
			end
	else
		error("Call to _makeComponent with non-function")
	end
end

function ModuleMockerClass:_createMockFunction(metadata, mockConstructor)
	local name = metadata.name
	if not name then
		return mockConstructor
	end

	-- ROBLOX TODO: Implement more advanced case for keeping name rather than just returning mockConstructor
	return mockConstructor
end

function ModuleMockerClass:isMockFunction(fn: any)
	return typeof(fn) == "table" and fn._isMockFunction == true
end

-- ROBLOX TODO: type return type as JestMock.Mock<any, any> when Mock type is implemented properly
type MockFn = any -- (...any) -> ...any
function ModuleMockerClass:fn<T..., Y...>(implementation: ((T...) -> Y...)?): (MockFn, (T...) -> Y...)
	local length = 0
	-- ROBLOX deviation: fn is a callable table, return a forwarding function
	local fn, mockFn = self:_makeComponent({ length = length, type = "function" })
	if implementation then
		fn.mockImplementation(implementation)
	end
	-- ROBLOX deviation: fn is a callable table, return a forwarding function
	return fn, mockFn
end

-- ROBLOX deviation START: mock data model
function ModuleMockerClass:protectDataModel(predicate: (Instance, string) -> boolean)
	self._dataModelProtector = predicate
end
-- ROBLOX deviation END

function ModuleMockerClass:spyOn<M>(
	-- ROBLOX deviation: mock data model
	object: { [any]: any } | Instance,
	methodName: M,
	accessType: ("get" | "set")?
): Mock<any>
	if Boolean.toJSBoolean(accessType) then
		return self:_spyOnProperty(object, methodName, accessType)
	end
	-- ROBLOX deviation START: custom `spyOn` implementation to support Luau
	-- and Roblox-native object types

	local projectConfig = self._projectConfig :: Config_ProjectConfig
	local mocksOnObject = self._mocksOnObjectsMap[object]
	if mocksOnObject == nil then
		mocksOnObject = {}
		self._mocksOnObjectsMap[object] = mocksOnObject
	end

	-- Case 1:
	-- Roblox-style instance spying
	local instanceProxy: JestMockRbx.InstanceProxy? = self.dataModelMocker:intoProxy(object)

	-- Explicitly test if it's an instance, in case there is no underlying
	-- InstanceProxy prepared for this instance.
	if typeof(object) == "Instance" or instanceProxy ~= nil then
		if not projectConfig.mockDataModel then
			error(Error.new("Can't spy on instances - the `mockDataModel` setting is not enabled."))
		elseif typeof(methodName) ~= "string" then
			error(Error.new(`Method names must be strings when spying on instances.`))
		elseif instanceProxy == nil or not self._dataModelProtector(instanceProxy.original, methodName) then
			error(Error.new(`Can't spy on {object.Name}:{methodName}() because it is not mockable.`))
		end

		-- `object` could be a spy, so for safety, disallow using it in favour
		-- of the more specific `instanceProxy` from here on out.
		local object = nil

		if mocksOnObject[methodName] == nil then
			local methodName: string = methodName :: any

			local unmock
			local mock, mockFn = self:_makeComponent({ type = "function" }, function()
				unmock()
			end)
			unmock = instanceProxy.controls:mockMethod(methodName, mockFn)
			mocksOnObject[methodName] = mock
			mock.mockImplementation(function(_, ...)
				return (instanceProxy.original :: any)[methodName](instanceProxy.original, ...)
			end)
		end

		return mocksOnObject[methodName]
	end

	-- Case 2:
	-- Global environment spying
	if GlobalMocker:isMockGlobalLibrary(object) then
		local object: JestMockGenv.GlobalEnvLibrary = object :: any
		local automocks = object._automocksRef
		-- note: indexing non-mockable functions in `globalEnv` will error,
		-- making this index operation subtly, but expectedly, fallible.
		local automockFn = automocks[methodName]
		if typeof(automockFn) ~= "table" or not automockFn._isGlobalAutomockFn then
			error(
				Error.new(
					("Cannot spy the %s property because it is not a function; %s given instead"):format(
						tostring(methodName),
						typeof(automockFn)
					)
				)
			)
		elseif automockFn._maybeMock == nil then
			error(Error.new("globalEnv has not been initialised by Jest here"))
		end

		return automockFn._maybeMock
	end

	-- Case 3:
	-- Jest-style object spying
	if typeof(object) == "table" then
		if mocksOnObject[methodName] == nil then
			local original = object[methodName]
			local isMethodOwner = rawget(object, methodName) ~= nil
			local callableMetatable = nil
			if typeof(original) == "table" then
				local meta = getmetatable(original)
				if typeof(meta) == "table" and meta.__call ~= nil then
					callableMetatable = meta
				end
			end
			local mock, mockFn = self:_makeComponent({ type = "function" }, function()
				object[methodName] = if isMethodOwner then original else nil
			end)
			if typeof(original) == "function" then
				-- Object method spying (closure as method)

				object[methodName] = if projectConfig.oldFunctionSpying then mock else mockFn
				mocksOnObject[methodName] = mock
				mock.mockImplementation(function(...)
					return original(...)
				end)
			elseif callableMetatable ~= nil then
				-- Object method spying (callable table as method)

				local ok, mockTable = pcall(table.clone, original)
				if not ok then
					error(
						Error.new(
							("Cannot spy the %s property because it cannot be cloned. (%s)"):format(
								tostring(methodName),
								mockTable:match("protected metatable") or mockTable
							)
						)
					)
				end
				local mockMetatable = table.clone(callableMetatable)
				mockMetatable.__call = mockFn
				-- It's unclear whether `original` should be deeply cloned here. See
				-- the APT-1914 ticket on Jira for a discussion of this.
				object[methodName] = setmetatable(mockTable, mockMetatable)
				mocksOnObject[methodName] = mock
				mock.mockImplementation(function(...)
					return callableMetatable.__call(...)
				end)
			else
				error(
					Error.new(
						("Cannot spy the %s property because it is not a function or callable table; %s given instead"):format(
							tostring(methodName),
							typeof(original)
						)
					)
				)
			end
		end

		return mocksOnObject[methodName]
	end

	-- Fallthrough case:
	error(Error.new(("Cannot spyOn on a primitive value; %s given"):format(typeof(object))))
	-- ROBLOX deviation END
end
function ModuleMockerClass:_spyOnProperty<T, M>(obj: T, propertyName: M, accessType_: ("get" | "set")?): Mock<() -> T>
	-- ROBLOX deviation: spyOnProperty not supported

	-- ROBLOX note: A version of this behavior _could_ be implemented using some
	-- elaborate metatable shenanigans, but we should find a compelling need
	-- before pursuing that route
	error("spyOn with accessors is not currently supported")
	-- local accessType: "get" | "set" = if accessType_ ~= nil then accessType_ else "get"
	-- if typeof(obj) ~= "table" and typeof(obj) ~= "function" then
	-- 	error(Error.new(("Cannot spyOn on a primitive value; %s given"):format(tostring(self:_typeOf(obj)))))
	-- end
	-- if not Boolean.toJSBoolean(obj) then
	-- 	error(Error.new(("spyOn could not find an object to spy upon for %s"):format(tostring(propertyName))))
	-- end
	-- if not Boolean.toJSBoolean(propertyName) then
	-- 	error(Error.new("No property name supplied"))
	-- end
	-- local descriptor = Object.getOwnPropertyDescriptor(obj, propertyName)
	-- local proto = Object.getPrototypeOf(obj)
	-- while not Boolean.toJSBoolean(descriptor) and proto ~= nil do
	-- 	descriptor = Object.getOwnPropertyDescriptor(proto, propertyName)
	-- 	proto = Object.getPrototypeOf(proto)
	-- end
	-- if not Boolean.toJSBoolean(descriptor) then
	-- 	error(Error.new(("%s property does not exist"):format(tostring(propertyName))))
	-- end
	-- if not Boolean.toJSBoolean(descriptor.configurable) then
	-- 	error(Error.new(("%s is not declared configurable"):format(tostring(propertyName))))
	-- end
	-- if not Boolean.toJSBoolean(descriptor[tostring(accessType)]) then
	-- 	error(
	-- 		Error.new(("Property %s does not have access type %s"):format(tostring(propertyName), tostring(accessType)))
	-- 	)
	-- end
	-- local original = descriptor[tostring(accessType)]
	-- if not Boolean.toJSBoolean(self:isMockFunction(original)) then
	-- 	if typeof(original) ~= "function" then
	-- 		error(
	-- 			Error.new(
	-- 				("Cannot spy the %s property because it is not a function; %s given instead"):format(
	-- 					tostring(propertyName),
	-- 					tostring(self:_typeOf(original))
	-- 				)
	-- 			)
	-- 		)
	-- 	end
	-- 	descriptor[tostring(accessType)] = self:_makeComponent({ type = "function" }, function()
	-- 		-- @ts-expect-error: mock is assignable
	-- 		(descriptor :: any)[tostring(accessType)] = original
	-- 		Object.defineProperty(obj, propertyName, descriptor :: any)
	-- 	end);
	-- 	(descriptor[tostring(accessType)] :: Mock<() -> T>):mockImplementation(function(this: unknown)
	-- 		-- @ts-expect-error
	-- 		return original(self, table.unpack(arguments))
	-- 	end)
	-- end
	-- Object.defineProperty(obj, propertyName, descriptor)
	-- return descriptor[tostring(accessType)] :: Mock<() -> T>
end

function ModuleMockerClass:clearAllMocks()
	self._mockState = {}
end

function ModuleMockerClass:resetAllMocks()
	self._mockConfigRegistry = {}
	self._mockState = {}
end

function ModuleMockerClass:restoreAllMocks()
	for _, value in self._spyState do
		value()
	end
	self._spyState = Set.new()
end

--[[
	ROBLOX deviation: skipped private _typeOf method
	original code:
	private _typeOf(value: any): string {
	  return value == null ? '' + value : typeof value;
	}
]]

function ModuleMockerClass:mocked<T>(item: T, _deep: boolean?): MaybeMocked<T> | MaybeMockedDeep<T>
	return item :: any
end

-- ROBLOX deviation START: mocking globals
function ModuleMockerClass:mockGlobals(globalMocker: GlobalMocker, env: Object)
	assert(not globalMocker.currentlyMocked, "Attempt to mock globals while they're already mocked")
	globalMocker.currentlyMocked = true
	local function implement(automocks: GlobalAutomocks, env: Object)
		for name, automock in automocks do
			if automock._isGlobalAutomockFn then
				local original = env[name]
				local mock
				local function mockOriginalImplementation()
					mock.mockImplementation(function(...)
						return original(...)
					end)
				end
				mock = self:_makeComponent({
					type = "function",
				}, mockOriginalImplementation)
				mockOriginalImplementation()
				automock._maybeUnmocked = original
				automock._maybeMock = mock
			else
				implement(automock, env[name])
			end
		end
	end
	implement(globalMocker.automocks, env)
end

function ModuleMockerClass:unmockGlobals(globalMocker: GlobalMocker)
	globalMocker.currentlyMocked = false
	local function unimplement(automocks: GlobalAutomocks)
		for name, automock in automocks do
			if automock._isGlobalAutomockFn then
				automock._maybeUnmocked = nil
				automock._maybeMock = nil
			else
				unimplement(automock)
			end
		end
	end
	unimplement(globalMocker.automocks)
end
-- ROBLOX deviation END

exports.ModuleMocker = ModuleMockerClass

-- ROBLOX deviation START: can't provide this globally because it needs a config
-- local JestMock = ModuleMockerClass.new()
-- local fn = function<T..., Y...>(implementation: ((T...) -> Y...)?)
-- 	return JestMock:fn(implementation)
-- end
-- exports.fn = fn
-- local spyOn = function<M>(object: { [any]: any }, methodName: M, accessType: ("get" | "set")?): Mock<any>
-- 	return JestMock:spyOn(object, methodName, accessType)
-- end
-- exports.spyOn = spyOn
-- local mocked = function<T>(item: T, _deep: boolean?): MaybeMocked<T> | MaybeMockedDeep<T>
-- 	return JestMock:mocked(item, _deep)
-- end
-- exports.mocked = mocked

export type JestFuncFn = <T..., Y...>(implementation: ((T...) -> Y...)?) -> (MockFn, (T...) -> Y...)
export type JestFuncSpyOn = <M>(object: { [any]: any }, methodName: M, accessType: ("get" | "set")?) -> Mock<any>
export type JestFuncMocked = <T>(item: T, _deep: boolean?) -> MaybeMocked<T> | MaybeMockedDeep<T>
-- ROBLOX deviation END

return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="348">
            <Properties>
              <string name="Name">JestMockGenv</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX NOTE: no upstream
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local exports = {}

local GlobalMockerClass = {}

export type GlobalAutomockFn = {
	_isGlobalAutomockFn: true,
	_maybeMock: any,
	_maybeUnmocked: any,
}
export type GlobalAutomocks = { [string]: GlobalAutomockFn | GlobalAutomocks }
export type GlobalEnvLibrary = {
	_isMockGlobalLibrary: true,
	_automocksRef: GlobalAutomocks,
}
-- The GlobalEnv type should always look like the MOCKABLE_GLOBALS table;
-- users depend on GlobalEnv for autocomplete and type checking.
export type GlobalEnv = GlobalEnvLibrary & {
	print: typeof(print),
	warn: typeof(warn),
	math: GlobalEnvLibrary & {
		random: typeof(math.random),
	},
}
local MOCKABLE_GLOBALS = {
	print = print,
	warn = warn,
	math = {
		random = math.random,
	},
}

export type GlobalMocker = {
	isMockGlobalLibrary: (_self: GlobalMocker, object: any) -> boolean,
	automocks: GlobalAutomocks,
	envObject: GlobalEnv,
	currentlyMocked: boolean,
}

GlobalMockerClass.__index = GlobalMockerClass
function GlobalMockerClass.new(): GlobalMocker
	local self = setmetatable({}, GlobalMockerClass)

	self.automocks = self:_createGlobalAutomocks()
	self.envObject = self:_createGlobalEnv(self.automocks)
	self.currentlyMocked = false

	return (self :: any) :: GlobalMocker
end

function GlobalMockerClass:isMockGlobalLibrary(object: any): boolean
	return typeof(object) == "table" and object._isMockGlobalLibrary == true
end

function GlobalMockerClass:_createGlobalAutomocks(): GlobalAutomocks
	local function implement(mockableGlobals: Object, into: GlobalAutomocks)
		for name, mockableGlobal in mockableGlobals do
			if typeof(mockableGlobal) == "function" then
				into[name] = {
					_isGlobalAutomockFn = true,
					_maybeMock = nil,
					_maybeUnmocked = nil,
				}
			elseif typeof(mockableGlobal) == "table" then
				local subAutomocks = {}
				implement(mockableGlobal, subAutomocks)
				into[name] = subAutomocks
			else
				error("Unexpected mockable global type - this is an internal bug")
			end
		end
	end
	local automocks = {}
	implement(MOCKABLE_GLOBALS, automocks)
	return automocks
end

function GlobalMockerClass:_createGlobalEnv(automocks: GlobalAutomocks): GlobalEnv
	local function makeSentinelForLibrary(automocks: GlobalAutomocks, globalPath: { string })
		local library: GlobalEnvLibrary = {
			_isMockGlobalLibrary = true,
			_automocksRef = automocks,
		}

		-- Allow users to access nested libraries like `math`.
		for name, automock in automocks do
			if typeof(automock) == "table" and not automock._isGlobalAutomockFn then
				local libraryGlobalPath = table.clone(globalPath)
				table.insert(libraryGlobalPath, name)
				library[name] = makeSentinelForLibrary(automock, libraryGlobalPath)
			end
		end

		-- Users might want to mock functions that don't have an underlying
		-- implementation in Jest. Detect that and throw an error here to inform
		-- them Jest must explicitly support individual globals to be mocked.
		setmetatable(library, {
			__index = function(_, name: string)
				-- name is actually `unknown` type; the type declaration is a
				-- convenient lie so our code type checks without a fuss
				if typeof(name) ~= "string" then
					error(`Cannot index globalEnv with {name} (expected string)`)
				end

				-- Give $$ names like $$typeof a free pass, because they're used
				-- internally in some Jest/LuauPolyfill functions, and probably
				-- aren't a user accidentally misusing `globalEnv`.
				if string.sub(name, 1, 2) == "$$" then
					return nil
				end

				-- Unmocked functions aren't included in the actual object, so
				-- simulate them being included here (where we can dynamically
				-- fetch which function to actually return)
				local automock = automocks[name]
				if typeof(automock) == "table" and automock._isGlobalAutomockFn then
					return automock._maybeUnmocked or error("globalEnv has not been initialised by Jest here")
				end

				-- In theory, what we want to do is `table.concat` the global
				-- path, but including `name` at the end. Instead of doing table
				-- manipulation, just implement that with a plain loop.
				local qualifiedName = ""
				for _, parentName in globalPath do
					qualifiedName ..= parentName .. "."
				end
				qualifiedName ..= name
				error(`Jest does not yet support mocking the {qualifiedName} global.`)
			end,
		})

		return table.freeze(library)
	end

	-- This will match `GlobalEnv` in the end, but it's difficult to
	-- statically type check that, so for code cleanliness, just cast to it.
	return makeSentinelForLibrary(automocks, {}) :: any
end

exports.GlobalMocker = GlobalMockerClass
exports.MOCKABLE_GLOBALS = MOCKABLE_GLOBALS

return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="349">
            <Properties>
              <string name="Name">JestMockRbx</string>
              <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!strict
-- ROBLOX NOTE: no upstream

local CurrentModule = script
local InstanceProxy = require(CurrentModule.InstanceProxy)
local DataModelMocker = require(CurrentModule.DataModelMocker)

export type InstanceProxy<ClassType = Instance> = InstanceProxy.InstanceProxy<ClassType>
export type Spied<ClassType = Instance> = InstanceProxy.Spied<ClassType>
export type ProxyControls<ClassType = Instance> = InstanceProxy.ProxyControls<ClassType>

export type DataModelMocker = DataModelMocker.DataModelMocker

local exports = {}

exports.DataModelMocker = DataModelMocker

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="350">
              <Properties>
                <string name="Name">DataModelMocker</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!strict
-- ROBLOX NOTE: no upstream

local CurrentModule = script.Parent
local InstanceProxy = require(CurrentModule.InstanceProxy)
type InstanceProxy<ClassType = Instance> = InstanceProxy.InstanceProxy<ClassType>

export type DataModelMocker = {
	mockInstance: <ClassType>(self: DataModelMocker, instance: ClassType & Instance) -> InstanceProxy<ClassType>,
	intoProxy: (self: DataModelMocker, object: unknown) -> InstanceProxy?,
}
type DataModelMocker_private = DataModelMocker & {
	_intoProxyMap: { [unknown]: InstanceProxy },
}

local DataModelMocker = {}
DataModelMocker.__index = DataModelMocker

function DataModelMocker.mockInstance<ClassType>(
	self: DataModelMocker_private,
	instance: ClassType & Instance
): InstanceProxy<ClassType>
	local proxy = self._intoProxyMap[instance]
	if proxy == nil then
		proxy = InstanceProxy.new(instance)
		-- This proxy is never removed from the table, and the strong reference
		-- is necessary so that the proxy is remembered even if the tested Luau
		-- code doesn't hold a reference for some time. This could cause a
		-- memory leak but this mocker is presumably destroyed at the end of the
		-- test suite, so this should be OK.
		self._intoProxyMap[instance] = proxy
		self._intoProxyMap[proxy] = proxy
		self._intoProxyMap[proxy.spy] = proxy
		self._intoProxyMap[proxy.controls] = proxy
		--[[
			ROBLOX TODO: mock ancestry/descendants to preserve instance proxies
			created in a hierarchy, not important for GetService mocking
		]]
	end
	return proxy :: any
end

function DataModelMocker.intoProxy(self: DataModelMocker_private, object: any): InstanceProxy?
	return self._intoProxyMap[object]
end

local exports = {}

function exports.new(): DataModelMocker
	local mocker: DataModelMocker_private = setmetatable({
		_intoProxyMap = {},
	}, DataModelMocker) :: any
	return mocker
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="351">
              <Properties>
                <string name="Name">InstanceProxy</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!strict
-- ROBLOX NOTE: no upstream

-- ROBLOX TODO: type checking lie - this should be replaced with something more
-- representative of the actual spy type when Luau has stable support for
-- metatables and type functions. For now, mimic the given instance for good
-- autocomplete support.
export type Spied<ClassType = Instance> = ClassType

type Function = (...any) -> ...any

type MockedMethodData = {
	methodFn: Function,
}

export type InstanceProxy<ClassType = Instance> = {
	spy: Spied<ClassType>,
	controls: ProxyControls<ClassType>,
	original: ClassType,
}

export type ProxyControls<ClassType = Instance> = {
	mockMethod: (self: ProxyControls<ClassType>, name: string, method: Function) -> () -> (),
	--[[
        ROBLOX TODO:
        * mock property / event / callback fields
        * figure out a strategy for mocking descendants and ancestry nicely
    ]]
}
type ProxyControls_private<ClassType = Instance> = ProxyControls<ClassType> & {
	_validSelfSet: { [unknown]: true },
	_mockedMethods: { [string]: MockedMethodData },
}

local function makeSpyInstance<ClassType>(
	original: ClassType & Instance,
	controls: ProxyControls_private<ClassType>
): Spied<ClassType>
	local meta = {}
	local spy = setmetatable({}, meta)
	-- Keep the spy empty to ensure metamethods run.
	table.freeze(spy)

	-- Separated from the main spy table to ensure that the metamethods always run.
	local wrappedOriginal = setmetatable({}, {
		__index = function(self, fieldName)
			local fieldValue = (original :: any)[fieldName]
			if typeof(fieldValue) == "function" then
				local wrapped = function(calledWithSelf: any, ...)
					assert(calledWithSelf == spy, `Expected ':' not '.' calling member function {fieldName}`)
					return fieldValue(original, ...)
				end
				-- Cache to ensure referential identity of methods.
				rawset(self, fieldName, wrapped)
				return wrapped
			else
				return fieldValue
			end
		end,
	})

	function meta:__index(key: string): unknown
		local mockedMethod = controls._mockedMethods[key]
		if mockedMethod ~= nil then
			return mockedMethod.methodFn
		else
			return wrappedOriginal[key]
		end
	end

	function meta:__newindex(key: unknown, value: unknown): ()
		(original :: any)[key] = value
	end

	function meta:__tostring(): string
		return tostring(meta.__index(self, "Name"))
	end

	meta.__metatable = "The metatable is locked"

	controls._validSelfSet[spy] = true

	-- ROBLOX TODO: type checking lie
	return spy :: any
end

local ProxyControls = {}
ProxyControls.__index = ProxyControls

function ProxyControls.mockMethod(self: ProxyControls_private, name: string, method: Function): () -> ()
	local data: MockedMethodData = {
		methodFn = function(calledWithSelf, ...)
			assert(self._validSelfSet[calledWithSelf], `Expected ':' not '.' calling member function {name}`)
			return method(calledWithSelf, ...)
		end,
	}
	self._mockedMethods[name] = data
	return function()
		-- don't overwrite a mock that was added in the meantime
		if self._mockedMethods[name] == data then
			self._mockedMethods[name] = nil
		end
	end
end

local exports = {}

function exports.new<ClassType>(original: ClassType & Instance): InstanceProxy<ClassType>
	local controls: ProxyControls_private<ClassType> = setmetatable({
		_validSelfSet = {},
		_mockedMethods = {},
	}, ProxyControls) :: any

	return {
		spy = makeSpyInstance(original, controls),
		controls = controls,
		original = original,
	}
end

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="352">
            <Properties>
              <string name="Name">JestReporters</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local CurrentModule = script
local Packages = CurrentModule.Parent
local testResultModule = require(Packages.JestTestResult)
type Test = testResultModule.Test
type TestCaseResult = testResultModule.TestCaseResult
type TestContext = testResultModule.TestContext

local getResultHeader = require(script.getResultHeader).default
local getSnapshotStatus = require(script.getSnapshotStatus).default
local getSnapshotSummary = require(script.getSnapshotSummary).default

local utilsModule = require(script.utils)
local formatTestPath = utilsModule.formatTestPath
local getSummary = utilsModule.getSummary
local printDisplayName = utilsModule.printDisplayName
local relativePath = utilsModule.relativePath
local trimAndFormatPath = utilsModule.trimAndFormatPath

local BaseReporterModule = require(script.BaseReporter)
exports.BaseReporter = BaseReporterModule.default
export type BaseReporter = BaseReporterModule.BaseReporter

local DefaultReporterModule = require(script.DefaultReporter)
exports.DefaultReporter = DefaultReporterModule.default
export type DefaultReporter = DefaultReporterModule.DefaultReporter

local GitHubActionsReporterModule = require(script.GitHubActionsReporter)
exports.GitHubActionsReporter = GitHubActionsReporterModule.default
export type GitHubActionsReporter = GitHubActionsReporterModule.GitHubActionsReporter

local SummaryReporterModule = require(script.SummaryReporter)
exports.SummaryReporter = SummaryReporterModule.default
export type SummaryReporter = SummaryReporterModule.SummaryReporter

local VerboseReporterModule = require(script.VerboseReporter)
exports.VerboseReporter = VerboseReporterModule.default
export type VerboseReporter = VerboseReporterModule.VerboseReporter

local typesModule = require(script.types)
export type Reporter = typesModule.Reporter
export type ReporterOnStartOptions = typesModule.ReporterOnStartOptions
export type ReporterContext = typesModule.ReporterContext
export type SummaryOptions = typesModule.SummaryOptions

local utils = {
	formatTestPath = formatTestPath,
	getResultHeader = getResultHeader,
	getSnapshotStatus = getSnapshotStatus,
	getSnapshotSummary = getSnapshotSummary,
	getSummary = getSummary,
	printDisplayName = printDisplayName,
	relativePath = relativePath,
	trimAndFormatPath = trimAndFormatPath,
}

exports.utils = utils

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="353">
              <Properties>
                <string name="Name">BaseReporter</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/BaseReporter.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
type Set<T> = LuauPolyfill.Set<T>
type Error = LuauPolyfill.Error

local exports = {}

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type Test = testResultModule.Test
type TestCaseResult = testResultModule.TestCaseResult
type TestContext = testResultModule.TestContext
type TestResult = testResultModule.TestResult

local preRunMessageRemove = require(Packages.JestUtil).remove

local typesModule = require(CurrentModule.types)
type Reporter = typesModule.Reporter
type ReporterOnStartOptions = typesModule.ReporterOnStartOptions
type NodeProcessMock = typesModule.NodeProcessMock

local RobloxShared = require(Packages.RobloxShared)
local Writeable = RobloxShared.Writeable
type Writeable = RobloxShared.Writeable

export type BaseReporter = {
	log: (self: BaseReporter, message: string) -> (),
	onRunStart: (self: BaseReporter, _results: AggregatedResult?, _options: ReporterOnStartOptions?) -> (),
	onTestCaseResult: (self: BaseReporter, _test: Test, _testCaseResult: TestCaseResult) -> (),
	onTestResult: (self: BaseReporter, _test: Test?, _testResult: TestResult?, _results: AggregatedResult?) -> (),
	onTestStart: (self: BaseReporter, _test: Test?) -> (),
	onRunComplete: (self: BaseReporter, _testContexts: Set<TestContext>?, _aggregatedResults: AggregatedResult?) -> (),
	getLastError: (self: BaseReporter) -> Error | nil,
	_process: NodeProcessMock,
} & Reporter

local BaseReporter = {}
BaseReporter.__index = BaseReporter

function BaseReporter.new(_process: any): BaseReporter
	local self = setmetatable({}, BaseReporter)
	-- ROBLOX deviation START: Replace process.stdout/stderr
	self._process = Object.assign({}, {
		env = {},
		stdout = Writeable.new(),
		stderr = Writeable.new(),
	}, _process or {})
	-- ROBLOX deviation END
	return (self :: any) :: BaseReporter
end

function BaseReporter:log(message: string): ()
	self._process.stderr:write(message)
end

function BaseReporter:onRunStart(_results: AggregatedResult?, _options: ReporterOnStartOptions?): ()
	preRunMessageRemove(self._process.stderr)
end

function BaseReporter:onTestCaseResult(_test: Test, _testCaseResult: TestCaseResult): () end

function BaseReporter:onTestResult(_test: Test?, _testResult: TestResult?, _results: AggregatedResult?): () end

function BaseReporter:onTestStart(_test: Test?): () end

function BaseReporter:onRunComplete(_testContexts: Set<TestContext>?, _aggregatedResults: AggregatedResult?): () end

function BaseReporter:_setError(error_): ()
	self._error = error_
end

-- Return an error that occurred during reporting. This error will
-- define whether the test run was successful or failed.
function BaseReporter:getLastError(): Error | nil
	return self._error
end

exports.default = BaseReporter

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="354">
              <Properties>
                <string name="Name">DefaultReporter</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/DefaultReporter.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Set = LuauPolyfill.Set
local setTimeout = LuauPolyfill.setTimeout
type Array<T> = LuauPolyfill.Array<T>
type Timeout = LuauPolyfill.Timeout
type Set<T> = LuauPolyfill.Set<T>

local exports = {}

local chalk = require(Packages.ChalkLua)

local getConsoleOutput = require(Packages.JestConsole).getConsoleOutput

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type Test = testResultModule.Test
type TestCaseResult = testResultModule.TestCaseResult
type TestResult = testResultModule.TestResult

local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
type Config_Path = jestTypesModule.Config_Path

local jestMessageUtilModule = require(Packages.JestMessageUtil)
local formatStackTrace = jestMessageUtilModule.formatStackTrace
local indentAllLines = jestMessageUtilModule.indentAllLines
local separateMessageFromStack = jestMessageUtilModule.separateMessageFromStack

local jestUtilModule = require(Packages.JestUtil)
local clearLine = jestUtilModule.clearLine

local BaseReporter = require(CurrentModule.BaseReporter).default
local statusModule = require(CurrentModule.Status)
local Status = statusModule.default
type Status = statusModule.Status
local getResultHeader = require(CurrentModule.getResultHeader).default
local getSnapshotStatus = require(CurrentModule.getSnapshotStatus).default

local typesModule = require(CurrentModule.types)
type ReporterOnStartOptions = typesModule.ReporterOnStartOptions
type NodeProcessMock = typesModule.NodeProcessMock

local RobloxShared = require(Packages.RobloxShared)
local Writeable = RobloxShared.Writeable
type Writeable = RobloxShared.Writeable

type write = (self: Writeable, data: string) -> ()
type FlushBufferedOutput = () -> ()

local TITLE_BULLET = chalk.bold("\u{25cf} ")

export type DefaultReporter = {
	forceFlushBufferedOutput: (self: DefaultReporter) -> (),
	onRunStart: (self: DefaultReporter, aggregatedResults: AggregatedResult, options: ReporterOnStartOptions) -> (),
	onTestStart: (self: DefaultReporter, test: Test) -> (),
	onTestCaseResult: (self: DefaultReporter, test: Test, testCaseResult: TestCaseResult) -> (),
	onRunComplete: (self: DefaultReporter) -> (),
	onTestResult: (
		self: DefaultReporter,
		test: Test,
		testResult: TestResult,
		aggregatedResults: AggregatedResult
	) -> (),
	testFinished: (
		self: DefaultReporter,
		config: Config_ProjectConfig,
		testResult: TestResult,
		aggregatedResults: AggregatedResult
	) -> (),
	printTestFileHeader: (
		self: DefaultReporter,
		testPath: string,
		config: Config_ProjectConfig,
		result: TestResult
	) -> (),
	printTestFileFailureMessage: (
		self: DefaultReporter,
		_testPath: string,
		_config: Config_ProjectConfig,
		result: TestResult
	) -> (),
}

type DefaultReporterPrivate = DefaultReporter & {
	_globalConfig: Config_GlobalConfig,
	_clear: string,
	_out: (_self: Writeable, message: string) -> (),
	_err: (_self: Writeable, message: string) -> (),
	_status: Status,
	_bufferedOutput: Set<() -> ()>,
	__wrapStdio: (self: DefaultReporter, stream: Writeable) -> (),
	__clearStatus: (self: DefaultReporter) -> (),
	__printStatus: (self: DefaultReporter) -> (),
	_process: NodeProcessMock,
	-- ROBLOX deviation: we need to store _isInteractive per reporter to not override isInteractive globally
	_isInteractive: boolean,
}

-- ROBLOX FIXME LUAU: Casting to any to prevent unwanted type narrowing
local DefaultReporter = setmetatable({}, { __index = BaseReporter }) :: any
DefaultReporter.__index = DefaultReporter
-- ROBLOX deviation: No __filename available - just using the module name
DefaultReporter.filename = "DefaultReporter"

-- ROBLOX deviation: Added _process arg to mock global node process for testing
function DefaultReporter.new(globalConfig: Config_GlobalConfig, _process: NodeProcessMock?): DefaultReporter
	local self = setmetatable((BaseReporter.new(_process) :: any) :: DefaultReporterPrivate, DefaultReporter)
	-- ROBLOX deviation: we need to store _isInteractive per reporter to not override isInteractive globally
	self._isInteractive = jestUtilModule.isInteractive

	-- ROBLOX deviation START: Added for tests otherwise isInteractive = false
	if _process ~= nil and _process.env.IS_INTERACTIVE ~= nil then
		self._isInteractive = Boolean.toJSBoolean(_process.env.IS_INTERACTIVE)
	end
	-- ROBLOX deviation END

	-- ROBLOX deviation START: Need a copy of stdout/stderr write since
	-- they get overwritten in _wrapStdio.
	local function defaultWrite()
		local writable = Writeable.new()

		return function(_self: Writeable, message: string)
			writable:write(message)
		end
	end
	--[[
		ROBLOX FIXME Luau START: added explicit type declaration.
		Otherwise Luau can't seem to unify 2 function type declaration
		and infers this as an union of function types which is not considered callable by CLI's analyze
	]]
	local _stdoutWrite: (Writeable, string) -> () = if _process and _process.stdout
		then _process.stdout.write
		else defaultWrite()
	local _stderrWrite: (Writeable, string) -> () = if _process and _process.stderr
		then _process.stderr.write
		else defaultWrite()
	-- ROBLOX FIXME Luau END
	-- ROBLOX deviation END

	self._globalConfig = globalConfig
	self._clear = ""
	self._out = function(_self: Writeable, message: string)
		_stdoutWrite(self._process.stdout, message)
	end
	self._err = function(_self: Writeable, message: string)
		_stderrWrite(self._process.stderr, message)
	end
	self._status = Status.new()
	self._bufferedOutput = Set.new()
	self:__wrapStdio(self._process.stdout)
	self:__wrapStdio(self._process.stderr)
	self._status:onChange(function()
		self:__clearStatus()
		self:__printStatus()
	end)

	return (self :: any) :: DefaultReporter
end

function DefaultReporter:__wrapStdio(stream: Writeable): ()
	local write = stream.write

	local buffer: Array<string> = {}
	local timeout: Timeout | nil = nil

	local function flushBufferedOutput()
		local string_ = Array.join(buffer, "")
		buffer = {}

		-- This is to avoid conflicts between random output and status text
		self:__clearStatus()
		if Boolean.toJSBoolean(string_) then
			write(stream, string_)
		end
		self:__printStatus()
		self._bufferedOutput:delete(flushBufferedOutput)
	end

	self._bufferedOutput:add(flushBufferedOutput)

	local function debouncedFlush()
		-- If the process blows up no errors would be printed.
		-- There should be a smart way to buffer stderr, but for now
		-- we just won't buffer it.
		if stream == self._process.stderr then
			flushBufferedOutput()
		elseif not Boolean.toJSBoolean(timeout) then
			timeout = setTimeout(function()
				flushBufferedOutput()
				timeout = nil
			end, 100)
		end
	end

	stream.write = function(_self: Writeable, chunk: string)
		table.insert(buffer, chunk)
		debouncedFlush()
		return true
	end
end

function DefaultReporter:forceFlushBufferedOutput(): ()
	Set.forEach(self._bufferedOutput, function(flushBufferedOutput)
		flushBufferedOutput()
	end)
end

function DefaultReporter:__clearStatus(): ()
	-- ROBLOX deviation: we need to store _isInteractive per reporter to not override isInteractive globally
	if self._isInteractive then
		if self._globalConfig.useStderr then
			self:_err(self._clear)
		else
			self:_out(self._clear)
		end
	end
end

function DefaultReporter:__printStatus(): ()
	local ref = self._status:get()
	local content, clear = ref.content, ref.clear
	self._clear = clear
	-- ROBLOX deviation: we need to store _isInteractive per reporter to not override isInteractive globally
	if self._isInteractive then
		if self._globalConfig.useStderr then
			self:_err(content)
		else
			self:_out(content)
		end
	end
end

function DefaultReporter:onRunStart(aggregatedResults: AggregatedResult, options: ReporterOnStartOptions): ()
	self._status:runStarted(aggregatedResults, options)
end

function DefaultReporter:onTestStart(test: Test): ()
	self._status:testStarted(test.path, test.context.config)
end

function DefaultReporter:onTestCaseResult(test: Test, testCaseResult: TestCaseResult): ()
	self._status:addTestCaseResult(test, testCaseResult)
end

function DefaultReporter:onRunComplete(): ()
	self:forceFlushBufferedOutput()
	self._status:runFinished()
	self._process.stdout.write = self._out
	self._process.stderr.write = self._err
	clearLine(self._process.stderr)
end

function DefaultReporter:onTestResult(test: Test, testResult: TestResult, aggregatedResults: AggregatedResult): ()
	self:testFinished(test.context.config, testResult, aggregatedResults)
	if not testResult.skipped then
		self:printTestFileHeader(testResult.testFilePath, test.context.config, testResult)
		self:printTestFileFailureMessage(testResult.testFilePath, test.context.config, testResult)
	end
	self:forceFlushBufferedOutput()
end

function DefaultReporter:testFinished(
	config: Config_ProjectConfig,
	testResult: TestResult,
	aggregatedResults: AggregatedResult
): ()
	self._status:testFinished(config, testResult, aggregatedResults)
end

function DefaultReporter:printTestFileHeader(
	_testPath: Config_Path,
	config: Config_ProjectConfig,
	result: TestResult
): ()
	-- log retry errors if any exist
	Array.forEach(result.testResults, function(testResult)
		local testRetryReasons = testResult.retryReasons
		if testRetryReasons and #testRetryReasons > 0 then
			self:log(
				("%s %s"):format(
					tostring(chalk.reset.inverse.bold:yellow(" LOGGING RETRY ERRORS ")),
					chalk.bold(testResult.fullName)
				)
			)
			Array.forEach(testRetryReasons, function(retryReasons, index: number)
				local message, stack
				do
					local ref = separateMessageFromStack(retryReasons)
					message, stack = ref.message, ref.stack
				end
				stack = if Boolean.toJSBoolean(self._globalConfig.noStackTrace)
					then ""
					else chalk.dim(formatStackTrace(stack, config, self._globalConfig, _testPath))
				message = indentAllLines(message)
				self:log(
					("%s\n"):format(
						tostring(chalk.reset.inverse.bold:blueBright((" RETRY %s "):format(tostring(index + 1))))
					)
				)
				self:log(("%s\n%s\n"):format(tostring(message), tostring(stack)))
			end) --[[ ROBLOX CHECK: check if 'testRetryReasons' is an Array ]]
		end
	end) --[[ ROBLOX CHECK: check if 'result.testResults' is an Array ]]
	self:log(getResultHeader(result, self._globalConfig, config))
	if result.console ~= nil then
		self:log("  " .. TITLE_BULLET .. "Console\n\n" .. getConsoleOutput(result.console, config, self._globalConfig))
	end
end

function DefaultReporter:printTestFileFailureMessage(
	_testPath: Config_Path,
	_config: Config_ProjectConfig,
	result: TestResult
): ()
	if Boolean.toJSBoolean(result.failureMessage) then
		self:log(result.failureMessage)
	end
	local didUpdate = self._globalConfig.updateSnapshot == "all"
	local snapshotStatuses = getSnapshotStatus(result.snapshot, didUpdate)
	Array.forEach(snapshotStatuses, self.log, self)
end

exports.default = DefaultReporter

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="355">
              <Properties>
                <string name="Name">GitHubActionsReporter</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/jestjs/jest/blob/v28.0.0/packages/jest-reporters/src/GitHubActionsReporter.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Set = LuauPolyfill.Set
type Array<T> = LuauPolyfill.Array<T>
type Set<T> = LuauPolyfill.Set<T>

local RegExp = require(Packages.RegExp)

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type TestContext = testResultModule.TestContext
type TestResult = testResultModule.TestResult

local RobloxShared = require(Packages.RobloxShared)
local stripAnsi = RobloxShared.stripAnsi

local exports = {}

local BaseReporter = require(script.Parent.BaseReporter).default

export type GitHubActionsReporter = {
	onRunComplete: (
		self: GitHubActionsReporter,
		_testContexts: Set<TestContext>?,
		aggregatedResults: AggregatedResult?
	) -> (),
}

local lineInStackTrace = RegExp("^.*?:([0-9]+).*$")

local GitHubActionsReporter = setmetatable({}, { __index = BaseReporter }) :: any
GitHubActionsReporter.__index = GitHubActionsReporter
GitHubActionsReporter.filename = "GithubActionsReporter"

function GitHubActionsReporter.new(globalConfig, _process: any?): GitHubActionsReporter
	local self = setmetatable(BaseReporter.new(_process) :: any, GitHubActionsReporter)
	self._globalConfig = globalConfig
	return (self :: any) :: GitHubActionsReporter
end

local function replaceEntities(s: string): string
	local substitutions = {
		{ "%%", "%%25" },
		{ "\r", "%%0D" },
		{ "\n", "%%0A" },
		{ "\t", "    " },
	}

	for _, sub in ipairs(substitutions) do
		s = s:gsub(sub[1], sub[2])
	end

	return s
end

local function getMessages(results: Array<TestResult>?): Array<string>
	if results == nil then
		return {}
	end

	return Array.flatMap(results, function(result)
		local testFilePath = result.testFilePath
		local testResults = result.testResults

		return Array.flatMap(
			Array.filter(testResults, function(r)
				return r.status == "failed"
			end),
			function(r)
				return Array.map(
					Array.map(
						Array.map(
							Array.map(r.failureMessages, function(m)
								return stripAnsi(m)
							end),
							function(m)
								return replaceEntities(m)
							end
						),
						function(m)
							return lineInStackTrace:exec(m)
						end
					),
					function(m)
						if m ~= nil then
							local message, line = m[1], tostring(m[2])
							return ("::error file=%s,line=%s::%s"):format(testFilePath, line, message)
						end
						return ""
					end
				)
			end
		)
	end) :: any
end

function GitHubActionsReporter:onRunComplete(_testContexts: Set<TestContext>?, aggregatedResults: AggregatedResult?)
	local messages = getMessages(if typeof(aggregatedResults) == "table" then aggregatedResults.testResults else nil)
	for _, message in messages do
		self:log(message)
	end
end

exports.default = GitHubActionsReporter

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="356">
              <Properties>
                <string name="Name">Status</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/Status.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local String = LuauPolyfill.String
local setTimeout = LuauPolyfill.setTimeout
local setInterval = LuauPolyfill.setInterval
local clearInterval = LuauPolyfill.clearInterval

type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local chalk = require(Packages.ChalkLua)

local stringLength = utf8.len

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type Test = testResultModule.Test
type TestCaseResult = testResultModule.TestCaseResult
type TestResult = testResultModule.TestResult

local jestTypesModule = require(Packages.JestTypes)
type Config_Path = jestTypesModule.Config_Path
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig

local typesModule = require(CurrentModule.types)
type ReporterOnStartOptions = typesModule.ReporterOnStartOptions

local utilsModule = require(CurrentModule.utils)
local getSummary = utilsModule.getSummary
local printDisplayName = utilsModule.printDisplayName
local trimAndFormatPath = utilsModule.trimAndFormatPath
local wrapAnsiString = utilsModule.wrapAnsiString

local RUNNING_TEXT = " RUNS "
local RUNNING = chalk.reset(chalk.inverse(chalk.yellow(chalk.bold(RUNNING_TEXT)))) .. " "

-- ROBLOX deviation: There is no console width since we only have log fn
local CONSOLE_WIDTH = 0

--[[*
 * This class is a perf optimization for sorting the list of currently
 * running tests. It tries to keep tests in the same positions without
 * shifting the whole list.
 ]]
type CurrentTestList = {
	add: (self: CurrentTestList, testPath: Config_Path, config: Config_ProjectConfig) -> (),
	delete: (self: CurrentTestList, testPath: Config_Path) -> (),
	get: (self: CurrentTestList) -> Array<{
		testPath: Config_Path,
		config: Config_ProjectConfig,
	} | nil>,
}

type CurrentTestListPrivate = {
	add: (self: CurrentTestListPrivate, testPath: Config_Path, config: Config_ProjectConfig) -> (),
	delete: (self: CurrentTestListPrivate, testPath: Config_Path) -> (),
	get: (self: CurrentTestListPrivate) -> Array<{
		testPath: Config_Path,
		config: Config_ProjectConfig,
	} | nil>,
	_array: Array<{
		testPath: Config_Path,
		config: Config_ProjectConfig,
	} | nil>,
}

type CurrentTestList_statics = {
	new: () -> CurrentTestList,
}

local CurrentTestList = {} :: CurrentTestListPrivate & CurrentTestList_statics;
(CurrentTestList :: any).__index = CurrentTestList

function CurrentTestList.new(): CurrentTestList
	local self = setmetatable({}, CurrentTestList)
	self._array = {}
	return (self :: any) :: CurrentTestList
end

function CurrentTestList:add(testPath: Config_Path, config: Config_ProjectConfig): ()
	local index = Array.indexOf(self._array, nil)
	local record = { config = config, testPath = testPath }
	if index ~= -1 then
		self._array[index] = record
	else
		table.insert(self._array, record)
	end
end

function CurrentTestList:delete(testPath: Config_Path): ()
	local record = Array.find(self._array, function(record)
		return record ~= nil and record.testPath == testPath
	end)
	self._array[Array.indexOf(self._array, Boolean.toJSBoolean(record) and record or nil)] = nil
end

function CurrentTestList:get(): Array<{
	testPath: Config_Path,
	config: Config_ProjectConfig,
} | nil>
	return self._array
end

type Cache = {
	content: string,
	clear: string,
}

--[[*
 * A class that generates the CLI status of currently running tests
 * and also provides an ANSI escape sequence to remove status lines
 * from the terminal.
 ]]
export type Status = {
	onChange: (self: Status, callback: () -> ()) -> (),
	runStarted: (self: Status, aggregatedResults: AggregatedResult, options: ReporterOnStartOptions) -> (),
	runFinished: (self: Status) -> (),
	addTestCaseResult: (self: Status, test: Test, testCaseResult: TestCaseResult) -> (),
	testStarted: (self: Status, testPath: string, config: Config_ProjectConfig) -> (),
	testFinished: (
		self: Status,
		_config: Config_ProjectConfig,
		testResult: TestResult,
		aggregatedResults: AggregatedResult
	) -> (),
	get: (self: Status) -> Cache,
}

local Status = {}
Status.__index = Status

function Status.new(): Status
	local self = setmetatable({}, Status)
	self._cache = nil
	self._currentTests = CurrentTestList.new()
	self._currentTestCases = {}
	self._done = false
	self._emitScheduled = false
	self._estimatedTime = 0
	self._showStatus = false
	return (self :: any) :: Status
end

function Status:onChange(callback: () -> ()): ()
	self._callback = callback
end

function Status:runStarted(aggregatedResults: AggregatedResult, options: ReporterOnStartOptions): ()
	self._estimatedTime = if Boolean.toJSBoolean(options) and Boolean.toJSBoolean(options.estimatedTime)
		then options.estimatedTime
		else 0
	self._showStatus = if Boolean.toJSBoolean(options) then options.showStatus else options
	self._interval = setInterval(function()
		return self:_tick()
	end, 1000)
	self._aggregatedResults = aggregatedResults
	self:_debouncedEmit()
end

function Status:runFinished(): ()
	self._done = true
	if Boolean.toJSBoolean(self._interval) then
		clearInterval(self._interval)
	end
	self:_emit()
end

function Status:addTestCaseResult(test: Test, testCaseResult: TestCaseResult): ()
	table.insert(self._currentTestCases, { test = test, testCaseResult = testCaseResult })
	if not Boolean.toJSBoolean(self._showStatus) then
		self:_emit()
	else
		self:_debouncedEmit()
	end
end

function Status:testStarted(testPath: Config_Path, config: Config_ProjectConfig): ()
	self._currentTests:add(testPath, config)
	if not self._showStatus then
		self:_emit()
	else
		self:_debouncedEmit()
	end
end

function Status:testFinished(
	_config: Config_ProjectConfig,
	testResult: TestResult,
	aggregatedResults: AggregatedResult
): ()
	local testFilePath = testResult.testFilePath
	self._aggregatedResults = aggregatedResults
	self._currentTests:delete(testFilePath)
	self._currentTestCases = Array.filter(self._currentTestCases, function(ref)
		local test = ref.test
		if _config ~= test.context.config then
			return true
		end
		return test.path ~= testFilePath
	end)
	self:_debouncedEmit()
end

function Status:get(): Cache
	if Boolean.toJSBoolean(self._cache) then
		return self._cache
	end
	if Boolean.toJSBoolean(self._done) then
		return { clear = "", content = "" }
	end
	local width = CONSOLE_WIDTH
	local content = "\n"
	Array.forEach(self._currentTests:get(), function(record)
		if Boolean.toJSBoolean(record) then
			local config, testPath = record.config, record.testPath
			local projectDisplayName = if Boolean.toJSBoolean(config.displayName)
				then ("%s "):format(tostring(printDisplayName(config)))
				else ""
			local prefix = RUNNING .. projectDisplayName
			-- ROBLOX deviation START: assert prefixLen is a valid number
			local prefixLen = stringLength(prefix)
			assert(prefixLen ~= nil)
			content ..= wrapAnsiString(prefix .. trimAndFormatPath(prefixLen, config, testPath, width), width) .. "\n"
			-- ROBLOX deviation END
		end
	end)
	if self._showStatus and Boolean.toJSBoolean(self._aggregatedResults) then
		content ..= "\n" .. tostring(getSummary(self._aggregatedResults, {
			currentTestCases = self._currentTestCases,
			estimatedTime = self._estimatedTime,
			roundTime = true,
			width = width,
		}))
	end
	local height = 0
	local i = 0
	-- ROBLOX deviation START - Check if utf8.len doesn't return nil because of invalid chars
	local contentLength = utf8.len(content)
	assert(contentLength ~= nil)
	while i < contentLength do
		-- ROBLOX deviation END
		if (String.charCodeAt(content, i) :: any) == "\n" then
			height += 1
		end
		i += 1
	end
	-- ROBLOX deviation: We don't have an operation to actually clear console
	local clear = ("\n"):rep(height)
	self._cache = { clear = clear, content = content }
	return self._cache
end

function Status:_emit(): ()
	self._cache = nil
	if Boolean.toJSBoolean(self._callback) then
		self:_callback()
	end
end

function Status:_debouncedEmit(): ()
	if not Boolean.toJSBoolean(self._emitScheduled) then
		-- Perf optimization to avoid two separate renders When
		-- one test finishes and another test starts executing.
		self._emitScheduled = true
		setTimeout(function()
			self:_emit()
			self._emitScheduled = false
		end, 100)
	end
end

function Status:_tick(): ()
	self:_debouncedEmit()
end

exports.default = Status

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="357">
              <Properties>
                <string name="Name">SummaryReporter</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/SummaryReporter.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Set = LuauPolyfill.Set
type Set<T> = LuauPolyfill.Set<T>

local exports = {}

local chalk = require(Packages.ChalkLua)

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type SnapshotSummary = testResultModule.SnapshotSummary
type TestContext = testResultModule.TestContext

local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
type Config_Path = jestTypesModule.Config_Path

local BaseReporter = require(CurrentModule.BaseReporter).default
local getResultHeader = require(CurrentModule.getResultHeader).default
local getSnapshotSummary = require(CurrentModule.getSnapshotSummary).default
local typesModule = require(CurrentModule.types)
type ReporterOnStartOptions = typesModule.ReporterOnStartOptions

local getSummary = require(CurrentModule.utils).getSummary

local TEST_SUMMARY_THRESHOLD = 20
local NPM_EVENTS = Set.new({
	"prepublish",
	"publish",
	"postpublish",
	"preinstall",
	"install",
	"postinstall",
	"preuninstall",
	"uninstall",
	"postuninstall",
	"preversion",
	"version",
	"postversion",
	"pretest",
	"test",
	"posttest",
	"prestop",
	"stop",
	"poststop",
	"prestart",
	"start",
	"poststart",
	"prerestart",
	"restart",
	"postrestart",
})

-- ROBLOX DEVIATION: These are assigned in the constructor for testing
local npm_config_user_agent, npm_lifecycle_event, npm_lifecycle_script

export type SummaryReporter = {
	onRunStart: (self: SummaryReporter, aggregatedResults: AggregatedResult, options: ReporterOnStartOptions) -> (),
	onRunComplete: (self: SummaryReporter, testContexts: Set<TestContext>, aggregatedResults: AggregatedResult) -> (),
}

type SummaryReporterPrivate = SummaryReporter & {
	_globalConfig: Config_GlobalConfig,
	_estimatedTime: number,
}

local SummaryReporter = setmetatable({}, { __index = BaseReporter }) :: any

SummaryReporter.__index = SummaryReporter
SummaryReporter.filename = "SummaryReporter"

function SummaryReporter.new(globalConfig: Config_GlobalConfig, _process: any?): SummaryReporter
	local self = setmetatable((BaseReporter.new(_process) :: any) :: SummaryReporterPrivate, SummaryReporter)

	-- ROBLOX deviation START: _process can be nil
	if _process then
		npm_lifecycle_script = _process.env.npm_lifecycle_script
		npm_lifecycle_event = _process.env.npm_lifecycle_event
		npm_config_user_agent = _process.env.npm_config_user_agent
	end
	-- ROBLOX deviation END
	self._globalConfig = globalConfig
	self._estimatedTime = 0

	return (self :: any) :: SummaryReporter
end

-- If we write more than one character at a time it is possible that
-- Node.js exits in the middle of printing the result. This was first observed
-- in Node.js 0.10 and still persists in Node.js 6.7+.
-- Let's print the test failure summary character by character which is safer
-- when hundreds of tests are failing.
function SummaryReporter:_write(string_: string)
	-- ROBLOX deviation START: print whole string at once
	self._process.stderr:write(string_)
	-- local i = 1
	-- local strLen = utf8.len(string_)
	-- assert(strLen ~= nil)
	-- while i < strLen do
	-- 	self._process.stderr:write(String.charCodeAt(string_, i))
	-- 	i += 1
	-- end
	-- ROBLOX deviation END
end

function SummaryReporter:onRunStart(aggregatedResults: AggregatedResult, options: ReporterOnStartOptions)
	BaseReporter.onRunStart(self, aggregatedResults, options)
	self._estimatedTime = options.estimatedTime
end

function SummaryReporter:onRunComplete(testContexts: Set<TestContext>, aggregatedResults: AggregatedResult)
	local numTotalTestSuites, testResults, wasInterrupted =
		aggregatedResults.numTotalTestSuites, aggregatedResults.testResults, aggregatedResults.wasInterrupted
	if Boolean.toJSBoolean(numTotalTestSuites) then
		local lastResult = testResults[#testResults]
		-- Print a newline if the last test did not fail to line up newlines
		-- similar to when an error would have been thrown in the test.
		if
			Boolean.toJSBoolean(self._globalConfig.verbose)
			and Boolean.toJSBoolean(lastResult)
			and not Boolean.toJSBoolean(lastResult.numFailingTests)
			and not Boolean.toJSBoolean(lastResult.testExecError)
		then
			self:log("")
		end
		self:_printSummary(aggregatedResults, self._globalConfig)
		self:_printSnapshotSummary(aggregatedResults.snapshot, self._globalConfig)
		if Boolean.toJSBoolean(numTotalTestSuites) then
			local message = getSummary(aggregatedResults, { estimatedTime = self._estimatedTime })
			if not Boolean.toJSBoolean(self._globalConfig.silent) then
				message ..= "\n" .. if Boolean.toJSBoolean(wasInterrupted)
					then chalk.bold(chalk.red("Test run was interrupted."))
					else self:_getTestSummary(testContexts, self._globalConfig)
			end
			self:log(message)
		end
	end
end

function SummaryReporter:_printSnapshotSummary(snapshots: SnapshotSummary, globalConfig: Config_GlobalConfig)
	if
		Boolean.toJSBoolean(snapshots.added)
		or Boolean.toJSBoolean(snapshots.filesRemoved)
		or Boolean.toJSBoolean(snapshots.unchecked)
		or Boolean.toJSBoolean(snapshots.unmatched)
		or Boolean.toJSBoolean(snapshots.updated)
	then
		local updateCommand
		local event = Boolean.toJSBoolean(npm_lifecycle_event) and npm_lifecycle_event or ""
		local prefix = Boolean.toJSBoolean(NPM_EVENTS:has(event)) and "" or "run "
		local isYarn = typeof(npm_config_user_agent) == "string"
			and string.match(npm_config_user_agent or "", "yarn") ~= nil
		local client = if Boolean.toJSBoolean(isYarn) then "yarn" else "npm"
		local scriptUsesJest = typeof(npm_lifecycle_script) == "string"
			and Boolean.toJSBoolean(string.match(npm_lifecycle_script or "", "jest"))
		-- ROBLOX deviation START: not supported
		-- if globalConfig.watch or globalConfig.watchAll then
		-- 	updateCommand = "press `u`"
		-- else
		-- ROBLOX deviation END
		if Boolean.toJSBoolean(event) and scriptUsesJest then
			updateCommand = ("run `%s -u`"):format(client .. " " .. prefix .. event .. (isYarn and "" or " --"))
		else
			updateCommand = "re-run jest with `-u`"
		end
		local snapshotSummary = getSnapshotSummary(snapshots, globalConfig, updateCommand)
		Array.forEach(snapshotSummary, function(summary)
			self:log(summary)
		end)
		self:log("") -- print empty line
	end
end

function SummaryReporter:_printSummary(aggregatedResults: AggregatedResult, globalConfig: Config_GlobalConfig)
	-- If there were any failing tests and there was a large number of tests
	-- executed, re-print the failing results at the end of execution output.
	local failedTests = aggregatedResults.numFailedTests or 0
	local runtimeErrors = aggregatedResults.numRuntimeErrorTestSuites or 0
	if failedTests + runtimeErrors > 0 and aggregatedResults.numTotalTestSuites > TEST_SUMMARY_THRESHOLD then
		self:log(chalk.bold("Summary of all failing tests"))
		Array.forEach(aggregatedResults.testResults, function(testResult)
			local failureMessage = testResult.failureMessage
			if Boolean.toJSBoolean(failureMessage) then
				self:_write(getResultHeader(testResult, globalConfig) .. "\n" .. failureMessage .. "\n")
			end
		end)
		self:log("") -- print empty line
	end
end

function SummaryReporter:_getTestSummary(contexts: Set<TestContext>, globalConfig: Config_GlobalConfig)
	local function getMatchingTestsInfo()
		-- ROBLOX deviation START: not supported: findRelatedTests
		-- local prefix = Boolean.toJSBoolean(globalConfig.findRelatedTests) and " related to files matching "
		-- 	or " matching "
		local prefix = " matching"
		-- ROBLOX deviation END
		-- ROBLOX deviation START: testPathPatternToRegExp not implemented (and not needed I don't think)
		return chalk.dim(prefix)
		-- ROBLOX deviation END
	end
	local testInfo = ""
	if globalConfig.runTestsByPath then
		testInfo = chalk.dim(" within paths")
		-- ROBLOX deviation START: not supported
		-- elseif Boolean.toJSBoolean(globalConfig.onlyChanged) then
		-- 	testInfo = chalk.dim(" related to changed files")
		-- ROBLOX deviation END
	elseif Boolean.toJSBoolean(globalConfig.testPathPattern) then
		testInfo = getMatchingTestsInfo()
	end
	local nameInfo = ""
	if globalConfig.runTestsByPath then
		nameInfo = " "
			.. Array.join(
				Array.map(globalConfig.nonFlagArgs, function(p)
					return ('"%s"'):format(p)
				end),
				", "
			)
	elseif globalConfig.testNamePattern ~= nil then
		nameInfo = chalk.dim(" with tests matching ") .. ('"%s"'):format(globalConfig.testNamePattern)
	end
	local contextInfo = if contexts.size > 1
		then chalk.dim(" in ") .. tostring(contexts.size) .. chalk.dim(" projects")
		else ""
	return chalk.dim("Ran all test suites") .. testInfo .. nameInfo .. contextInfo .. chalk.dim(".")
end

exports.default = SummaryReporter

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="358">
              <Properties>
                <string name="Name">VerboseReporter</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/VerboseReporter.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local chalk = require(Packages.ChalkLua)
local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type AssertionResult = testResultModule.AssertionResult
type Suite = testResultModule.Suite
type Test = testResultModule.Test
type TestResult = testResultModule.TestResult

local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
type Config_Path = jestTypesModule.Config_Path

local jestUtilModule = require(Packages.JestUtil)
local formatTime = jestUtilModule.formatTime
local ICONS = jestUtilModule.ICONS

local DefaultReporterModule = require(CurrentModule.DefaultReporter)
local DefaultReporter = DefaultReporterModule.default
type DefaultReporter = DefaultReporterModule.DefaultReporter

local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable

export type VerboseReporter = DefaultReporter & {
	onTestResult: (self: VerboseReporter, test: Test, result: TestResult, aggregatedResults: AggregatedResult) -> (),
	filterTestResults: (self: VerboseReporter, testResults: Array<AssertionResult>) -> Array<AssertionResult>,
	groupTestsBySuites: (self: VerboseReporter, testResults: Array<AssertionResult>) -> Array<Suite>,
}

type VerboseReporterPrivate = VerboseReporter & {
	_logTestResults: (self: VerboseReporterPrivate, testResults: Array<AssertionResult>) -> (),
	_getIcon: (self: VerboseReporterPrivate, status: string) -> string,
	_logTest: (self: VerboseReporterPrivate, test: AssertionResult, indentLevel: number) -> (),
	_logTests: (self: VerboseReporterPrivate, tests: Array<AssertionResult>, indentLevel: number) -> (),
	_logTodoOrPendingTest: (self: VerboseReporterPrivate, indentLevel: number) -> (test: AssertionResult) -> (),
	_logLine: (self: VerboseReporterPrivate, str: string?, indentLevel: number?) -> (),
	__wrapStdio: (self: VerboseReporterPrivate, stream: Writeable) -> (),
	_globalConfig: Config_GlobalConfig,
}

local VerboseReporter = setmetatable({}, { __index = DefaultReporter }) :: any
VerboseReporter.__index = VerboseReporter
VerboseReporter.filename = "VerboseReporter"

-- ROBLOX deviation START: added round function
local function round(num: number)
	local mult = 10 ^ 0
	return math.floor(num * mult + 0.5) / mult
end
-- ROBLOX deviation END

function VerboseReporter.new(globalConfig: Config_GlobalConfig): VerboseReporter
	local self = setmetatable((DefaultReporter.new(globalConfig) :: any) :: VerboseReporterPrivate, VerboseReporter)
	self._globalConfig = globalConfig
	return (self :: any) :: VerboseReporter
end

-- Verbose mode is for debugging. Buffering of output is undesirable.
-- See https://github.com/facebook/jest/issues/8208
function VerboseReporter:__wrapStdio(stream: Writeable): ()
	local write = stream.write
	stream.write = function(_self: Writeable, chunk: string)
		self:__clearStatus()
		write(stream, chunk)
		self:__printStatus()
		return true
	end
end

function VerboseReporter.filterTestResults(testResults: Array<AssertionResult>): Array<AssertionResult>
	return Array.filter(testResults, function(ref)
		local status = ref.status
		return status ~= "pending"
	end)
end

function VerboseReporter.groupTestsBySuites(testResults: Array<AssertionResult>): Array<Suite>
	local root: Suite = { suites = {}, tests = {}, title = "" }

	Array.forEach(testResults, function(testResult)
		local targetSuite = root

		-- Find the target suite for this test,
		-- creating nested suites as necessary.
		for _, title in ipairs(testResult.ancestorTitles) do
			local matchingSuite = Array.find(targetSuite.suites, function(s)
				return s.title == title
			end)
			if matchingSuite == nil then
				matchingSuite = { suites = {}, tests = {}, title = title }
				table.insert(targetSuite.suites, matchingSuite :: Suite)
			end
			targetSuite = matchingSuite :: Suite
		end
		table.insert(targetSuite.tests, testResult)
	end)

	return root
end

function VerboseReporter:onTestResult(test: Test, result: TestResult, aggregatedResults: AggregatedResult): ()
	-- ROBLOX NOTE: Current way of using 'super', might change in the future
	DefaultReporter.testFinished(self, test.context.config, result, aggregatedResults)

	if not Boolean.toJSBoolean(result.skipped) then
		self:printTestFileHeader(result.testFilePath, test.context.config, result)
		if not Boolean.toJSBoolean(result.testExecError) and not Boolean.toJSBoolean(result.skipped) then
			self:_logTestResults(result.testResults)
		end
		self:printTestFileFailureMessage(result.testFilePath, test.context.config, result)
	end

	-- ROBLOX NOTE: Current way of using 'super', might change in the future
	DefaultReporter.forceFlushBufferedOutput(self)
end

function VerboseReporter:_logTestResults(testResults: Array<AssertionResult>): ()
	self:_logSuite(VerboseReporter.groupTestsBySuites(testResults), 0)
	self:_logLine()
end

function VerboseReporter:_logSuite(suite: Suite, indentLevel: number): ()
	if Boolean.toJSBoolean(suite.title) then
		self:_logLine(suite.title, indentLevel)
	end
	self:_logTests(suite.tests, indentLevel + 1)
	Array.forEach(suite.suites, function(suite)
		self:_logSuite(suite, indentLevel + 1)
	end)
end

function VerboseReporter:_getIcon(status: string): string
	if status == "failed" then
		return chalk.red(ICONS.failed)
	elseif status == "pending" then
		return chalk.yellow(ICONS.pending)
	elseif status == "todo" then
		return chalk.magenta(ICONS.todo)
	else
		return chalk.green(ICONS.success)
	end
end

function VerboseReporter:_logTest(test: AssertionResult, indentLevel: number): ()
	local status = self:_getIcon(test.status)
	local time = if test.duration ~= nil then (" (%s)"):format(tostring(formatTime(round(test.duration)))) else ""
	self:_logLine(status .. " " .. chalk.dim(test.title .. time), indentLevel)
end

function VerboseReporter:_logTests(tests: Array<AssertionResult>, indentLevel: number): ()
	if Boolean.toJSBoolean(self._globalConfig.expand) then
		Array.forEach(tests, function(test)
			return self:_logTest(test, indentLevel)
		end)
	else
		local summedTests = Array.reduce(tests, function(result, test)
			if test.status == "pending" then
				table.insert(result.pending, test)
			elseif test.status == "todo" then
				table.insert(result.todo, test)
			else
				self:_logTest(test, indentLevel)
			end
			return result
		end, { pending = {}, todo = {} })
		if #summedTests.pending > 0 then
			Array.forEach(summedTests.pending, self:_logTodoOrPendingTest(indentLevel))
		end
		if #summedTests.todo > 0 then
			Array.forEach(summedTests.todo, self:_logTodoOrPendingTest(indentLevel))
		end
	end
end

function VerboseReporter:_logTodoOrPendingTest(indentLevel: number): (test: AssertionResult) -> ()
	return function(test: AssertionResult): ()
		local printedTestStatus = test.status == "pending" and "skipped" or test.status
		local icon = self:_getIcon(test.status)
		local text = chalk.dim(("%s %s"):format(printedTestStatus, test.title))
		self:_logLine(("%s %s"):format(icon, text), indentLevel)
	end
end

function VerboseReporter:_logLine(str: string?, indentLevel: number?): ()
	local indentation = ("  "):rep(Boolean.toJSBoolean(indentLevel) and indentLevel or 0)
	self:log(indentation .. (str or ""))
end

exports.default = VerboseReporter

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="359">
              <Properties>
                <string name="Name">getResultHeader</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/getResultHeader.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean

local exports = {}

local chalk = require(Packages.ChalkLua)

-- ROBLOX deviation: Makes urls clickable in the terminal. Not able to support
-- local terminalLink = require(Packages["terminal-link"])
local testResultModule = require(Packages.JestTestResult)
type TestResult = testResultModule.TestResult

local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig

local formatTime = require(Packages.JestUtil).formatTime

local utilsModule = require(CurrentModule.utils)
local formatTestPath = utilsModule.formatTestPath
local printDisplayName = utilsModule.printDisplayName

-- ROBLOX deviation START chalk_chainable: Lua Chalk doesn't support chainable calls. Using nested calls instead
-- Explicitly reset for these messages since they can get written out in the
-- middle of error logging
local LONG_TEST_COLOR = function(...)
	return chalk.reset(chalk.bold(chalk.bgRed(...)))
end
local FAIL_TEXT = "FAIL"
local PASS_TEXT = "PASS"

--[[
	ROBLOX deviation START chalk_supportsColor: chalk.supportsColor isn't defined so we'll assume
	it supports colors unless it is explicitly set to false
]]
local FAIL = if chalk.supportsColor == nil or chalk.supportsColor == true
	then chalk.reset(chalk.inverse(chalk.bold(chalk.red(string.format(" %s ", FAIL_TEXT)))))
	else FAIL_TEXT

local PASS = if chalk.supportsColor == nil or chalk.supportsColor == true
	then chalk.reset(chalk.inverse(chalk.bold(chalk.green(string.format(" %s ", PASS_TEXT)))))
	else PASS_TEXT
-- ROBLOX deviation END chalk_supportsColor
-- ROBLOX deviation END chalk_chainable

exports.default = function(result: TestResult, globalConfig: Config_GlobalConfig, projectConfig: Config_ProjectConfig?)
	local testPath = result.testFilePath
	local formattedTestPath = formatTestPath(projectConfig or globalConfig, testPath)
	-- ROBLOX deviation START: no terminal-link package available just use the path
	local fileLink = formattedTestPath
	-- ROBLOX deviation END
	if result.numFailingTests == nil then
		result.numFailingTests = 0
	end
	local status = if result.numFailingTests > 0 or result.testExecError ~= nil then FAIL else PASS
	local testDetail = {}

	if result.perfStats ~= nil and Boolean.toJSBoolean(result.perfStats.slow) then
		local runTime = result.perfStats.runtime / 1000
		table.insert(testDetail, LONG_TEST_COLOR(formatTime(runTime, 0)))
	end

	if result.memoryUsage ~= nil then
		local toMB = function(bytes: number)
			return math.floor(bytes / 1024 / 1024)
		end
		table.insert(testDetail, (" %sMB heap size"):format(tostring(toMB(result.memoryUsage))))
	end

	local projectDisplayName = if projectConfig ~= nil and Boolean.toJSBoolean(projectConfig.displayName)
		then printDisplayName(projectConfig) .. " "
		else ""

	return string.format("%s %s%s %s", status, projectDisplayName, fileLink, table.concat(testDetail, " "))
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="360">
              <Properties>
                <string name="Name">getSnapshotStatus</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/getSnapshotStatus.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local chalk = require(Packages.ChalkLua)
local testResultModule = require(Packages.JestTestResult)
type Snapshot = testResultModule.Snapshot

local pluralize = require(Packages.JestUtil).pluralize

local ARROW = " \u{203A} "
local DOT = " \u{2022} "
-- ROBLOX deviation START: chalk doesn't support chaining methods. Using nested calls instead
local FAIL_COLOR = function(...)
	return chalk.bold(chalk.red(...))
end
local SNAPSHOT_ADDED = function(...)
	return chalk.bold(chalk.green(...))
end
local SNAPSHOT_UPDATED = function(...)
	return chalk.bold(chalk.green(...))
end
local SNAPSHOT_OUTDATED = function(...)
	return chalk.bold(chalk.yellow(...))
end
-- ROBLOX deviation END

exports.default = function(snapshot: Snapshot, afterUpdate: boolean): Array<string>
	local statuses = {}

	if Boolean.toJSBoolean(snapshot.added) then
		table.insert(statuses, SNAPSHOT_ADDED(ARROW .. pluralize("snapshot", snapshot.added) .. " written."))
	end

	if Boolean.toJSBoolean(snapshot.updated) then
		table.insert(statuses, SNAPSHOT_UPDATED(ARROW .. pluralize("snapshot", snapshot.updated) .. " updated."))
	end

	if Boolean.toJSBoolean(snapshot.unmatched) then
		table.insert(statuses, FAIL_COLOR(ARROW .. pluralize("snapshot", snapshot.unmatched) .. " failed."))
	end

	if Boolean.toJSBoolean(snapshot.unchecked) then
		if afterUpdate then
			table.insert(statuses, SNAPSHOT_UPDATED(ARROW .. pluralize("snapshot", snapshot.unchecked) .. " removed."))
		else
			table.insert(
				statuses,
				SNAPSHOT_OUTDATED(ARROW .. pluralize("snapshot", snapshot.unchecked) .. " obsolete.")
			)
		end

		Array.forEach(snapshot.uncheckedKeys, function(key: string)
			table.insert(statuses, "	" .. DOT .. key)
		end)
	end

	if snapshot.fileDeleted then
		table.insert(statuses, SNAPSHOT_UPDATED(ARROW .. "snapshot file removed."))
	end

	return statuses
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="361">
              <Properties>
                <string name="Name">getSnapshotSummary</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/getSnapshotSummary.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local exports = {}

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean

local chalk = require(Packages.ChalkLua)

local testResultModule = require(Packages.JestTestResult)
type SnapshotSummary = testResultModule.SnapshotSummary

local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type Config_Path = typesModule.Config_Path

local pluralize = require(Packages.JestUtil).pluralize
local formatTestPath = require(CurrentModule.utils).formatTestPath

local ARROW = " \u{203A} "
local DOWN_ARROW = " \u{21B3} "
local DOT = " \u{2022} "
-- ROBLOX deviation START: chalk doesn't support chaining methods. Using nested calls instead
local FAIL_COLOR = function(...)
	return chalk.bold(chalk.red(...))
end
local OBSOLETE_COLOR = function(...)
	return chalk.bold(chalk.yellow(...))
end
local SNAPSHOT_ADDED = function(...)
	return chalk.bold(chalk.green(...))
end
local SNAPSHOT_NOTE = chalk.dim
local SNAPSHOT_REMOVED = function(...)
	return chalk.bold(chalk.green(...))
end
local SNAPSHOT_SUMMARY = chalk.bold
local SNAPSHOT_UPDATED = function(...)
	return chalk.bold(chalk.green(...))
end
-- ROBLOX deviation END

exports.default = function(snapshots: SnapshotSummary, globalConfig: Config_GlobalConfig, updateCommand: string)
	local summary = {}
	table.insert(summary, SNAPSHOT_SUMMARY("Snapshot Summary"))

	if Boolean.toJSBoolean(snapshots.added) then
		table.insert(
			summary,
			SNAPSHOT_ADDED(ARROW .. pluralize("snapshot", snapshots.added) .. " written ")
				.. "from "
				.. pluralize("test suite", snapshots.filesAdded)
				.. "."
		)
	end

	if Boolean.toJSBoolean(snapshots.unmatched) then
		table.insert(
			summary,
			FAIL_COLOR(ARROW .. pluralize("snapshot", snapshots.unmatched) .. " failed")
				.. " from "
				.. pluralize("test suite", snapshots.filesUnmatched)
				.. ". "
				.. SNAPSHOT_NOTE("Inspect your code changes or " .. updateCommand .. " to update them.")
		)
	end

	if Boolean.toJSBoolean(snapshots.updated) then
		table.insert(
			summary,
			SNAPSHOT_UPDATED(ARROW .. pluralize("snapshot", snapshots.updated) .. " updated ")
				.. "from "
				.. pluralize("test suite", snapshots.filesUpdated)
				.. "."
		)
	end

	if Boolean.toJSBoolean(snapshots.filesRemoved) then
		if snapshots.didUpdate then
			table.insert(
				summary,
				SNAPSHOT_REMOVED(ARROW .. pluralize("snapshot file", snapshots.filesRemoved) .. " removed ")
					.. "from "
					.. pluralize("test suite", snapshots.filesRemoved)
					.. "."
			)
		else
			table.insert(
				summary,
				OBSOLETE_COLOR(ARROW .. pluralize("snapshot file", snapshots.filesRemoved) .. " obsolete ")
					.. "from "
					.. pluralize("test suite", snapshots.filesRemoved)
					.. ". "
					.. SNAPSHOT_NOTE(
						"To remove "
							.. (if snapshots.filesRemoved == 1 then "it" else "them all")
							.. ", "
							.. updateCommand
							.. "."
					)
			)
		end
	end

	if snapshots.filesRemovedList and #snapshots.filesRemovedList > 0 then
		local head = snapshots.filesRemovedList[1]
		local tail = table.pack(table.unpack(snapshots.filesRemovedList, 2))
		table.insert(summary, "  " .. DOWN_ARROW .. " " .. DOT .. formatTestPath(globalConfig, head))
		Array.forEach(tail, function(key)
			table.insert(summary, "    " .. DOT .. formatTestPath(globalConfig, key))
		end)
	end

	if Boolean.toJSBoolean(snapshots.unchecked) then
		if snapshots.didUpdate then
			table.insert(
				summary,
				SNAPSHOT_REMOVED(ARROW .. pluralize("snapshot", snapshots.unchecked) .. " removed ")
					.. "from "
					.. pluralize("test suite", #snapshots.uncheckedKeysByFile)
					.. "."
			)
		else
			table.insert(
				summary,
				OBSOLETE_COLOR(ARROW .. pluralize("snapshot", snapshots.unchecked) .. " obsolete ")
					.. "from "
					.. pluralize("test suite", #snapshots.uncheckedKeysByFile)
					.. ". "
					.. SNAPSHOT_NOTE(
						"To remove "
							.. (if snapshots.unchecked == 1 then "it" else "them all")
							.. ", "
							.. updateCommand
							.. "."
					)
			)
		end
	end

	Array.forEach(snapshots.uncheckedKeysByFile, function(uncheckedFile)
		table.insert(summary, "  " .. DOWN_ARROW .. formatTestPath(globalConfig, uncheckedFile.filePath))

		Array.forEach(uncheckedFile.keys, function(key)
			table.insert(summary, "    " .. DOT .. key)
		end)
	end)

	return summary
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="362">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/types.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

type void = nil

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>
type Set<T> = LuauPolyfill.Set<T>

local exports = {}

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type Test = testResultModule.Test
type TestCaseResult = testResultModule.TestCaseResult
type TestContext = testResultModule.TestContext
type TestResult = testResultModule.TestResult

local jestTypesModule = require(Packages.JestTypes)
type Config_Path = jestTypesModule.Config_Path
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig

-- ROBLOX deviation START: any types that aren't ported and we don't need
-- local jest_haste_mapModule = require(Packages["jest-haste-map"])
type HasteFS = any
type ModuleMap = any

-- local jest_resolveModule = require(Packages["jest-resolve"])
type Resolver = any

-- local CoverageWorkerModule = require(CurrentModule.CoverageWorker)
-- type worker = CoverageWorkerModule.worker
type worker = any
-- ROBLOX deviation END

-- ROBLOX deviation START: type for mock process param used added to Reporters
local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable
export type NodeProcessMock = {
	env: {
		[string]: unknown,
	},
	stdout: Writeable,
	stderr: Writeable,
}
-- ROBLOX deviation END

export type ReporterOnStartOptions = { estimatedTime: number, showStatus: boolean }

export type CoverageWorker = { worker: worker }

export type Reporter = {
	onTestResult: ((
		self: Reporter,
		test: Test,
		testResult: TestResult,
		aggregatedResult: AggregatedResult
	) -> Promise<void> | void)?,
	onTestFileResult: ((
		self: Reporter,
		test: Test,
		testResult: TestResult,
		aggregatedResult: AggregatedResult
	) -> Promise<void> | void)?,
	onTestCaseResult: ((self: Reporter, test: Test, testCaseResult: TestCaseResult) -> Promise<void> | void)?,
	onRunStart: (self: Reporter, results: AggregatedResult, options: ReporterOnStartOptions) -> Promise<void> | void,
	onTestStart: ((self: Reporter, test: Test) -> Promise<void> | void)?,
	onTestFileStart: ((self: Reporter, test: Test) -> Promise<void> | void)?,
	onRunComplete: (self: Reporter, testContexts: Set<TestContext>, results: AggregatedResult) -> Promise<void> | void,
	getLastError: (self: Reporter) -> Error | void,
}

export type ReporterContext = {
	firstRun: boolean,
	previousSuccess: boolean,
	changedFiles: Set<Config_Path>?,
	sourcesRelatedToTestsInChangedFiles: Set<Config_Path>?,
	startRun: ((globalConfig: Config_GlobalConfig) -> unknown)?,
}

export type SummaryOptions = {
	currentTestCases: Array<{ test: Test, testCaseResult: TestCaseResult }>?,
	estimatedTime: number?,
	roundTime: boolean?,
	width: number?,
}

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="363">
              <Properties>
                <string name="Name">utils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-reporters/src/utils.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>

local exports = {}

local path = require(Packages.Path).path
local chalk = require(Packages.ChalkLua)

-- ROBLOX deviation START: not supporting windows path separator
-- local slash = require(Packages.slash)
local slash = function(path_: string): string
	return path_:gsub("\\", "/")
end
-- ROBLOX deviation END

local testResultModule = require(Packages.JestTestResult)
type AggregatedResult = testResultModule.AggregatedResult
type Test = testResultModule.Test
type TestCaseResult = testResultModule.TestCaseResult

local jestTypesModule = require(Packages.JestTypes)
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_Path = jestTypesModule.Config_Path

local jestUtilModule = require(Packages.JestUtil)
local formatTime = jestUtilModule.formatTime
local pluralize = jestUtilModule.pluralize

local typesModule = require(CurrentModule.types)
type SummaryOptions = typesModule.SummaryOptions

local relativePath
local renderTime

local PROGRESS_BAR_WIDTH = 40

local function printDisplayName(config: Config_ProjectConfig): string
	local displayName = config.displayName

	-- ROBLOX deviation: Lua Chalk doesn't support chaining. Using nested calls
	local white = function(...)
		return chalk.reset(chalk.inverse(chalk.white(...)))
	end
	if not Boolean.toJSBoolean(displayName) then
		return ""
	end

	local name, color
	if displayName ~= nil then
		name, color = displayName.name, displayName.color
	end
	local chosenColor = function(...)
		if Boolean.toJSBoolean(color) and chalk[color] ~= nil then
			return chalk.reset(chalk.inverse(chalk[color](...)))
		else
			return white(...)
		end
	end

	-- ROBLOX deviation: chalk.supportsColor isn't defined so we'll assume
	-- it supports colors unless it is explicitly set to false
	return if chalk.supportsColor == nil or chalk.supportsColor == true
		then chosenColor((" %s "):format(name))
		else name
end
exports.printDisplayName = printDisplayName

local function trimAndFormatPath(
	pad: number,
	config: Config_ProjectConfig | Config_GlobalConfig,
	testPath: string,
	columns: number
): string
	local maxLength = columns - pad
	local relative = relativePath(config, testPath)
	local basename = relative.basename
	local dirname = relative.dirname

	-- ROBLOX deviation START: assert pathLength is valid
	-- length is ok
	local pathLength = utf8.len(dirname .. path.sep .. basename)
	assert(pathLength ~= nil)
	if pathLength <= maxLength then
		-- ROBLOX deviation END
		return slash(chalk.dim(dirname .. path.sep) .. chalk.bold(basename))
	end

	-- ROBLOX deviation START: assert basenameLength is valid
	-- we can fit trimmed dirname and full basename
	local basenameLength = utf8.len(basename)
	assert(basenameLength)
	if basenameLength + 4 < maxLength then
		local dirnameLength = maxLength - 4 - basenameLength
		dirname = "..."
			.. String.slice(
				dirname,
				(utf8.len(dirname) :: number) - dirnameLength + 1,
				(utf8.len(dirname) :: number) + 1
			)
		return slash(chalk.dim(dirname .. path.sep) .. chalk.bold(basename))
	end

	if basenameLength + 4 == maxLength then
		return slash(chalk.dim("..." .. path.sep) .. chalk.bold(basename))
	end

	-- can't fit dirname, but can fit trimmed basename
	return slash(chalk.bold("..." .. String.slice(basename, basenameLength - maxLength - 4, basenameLength + 1)))
	-- ROBLOX deviation END
end
exports.trimAndFormatPath = trimAndFormatPath

local function formatTestPath(config: Config_GlobalConfig | Config_ProjectConfig, testPath: Config_Path): string
	local ref = relativePath(config, testPath)
	local dirname, basename = ref.dirname, ref.basename
	return slash(chalk.dim(dirname .. path.sep) .. chalk.bold(basename))
end
exports.formatTestPath = formatTestPath

function relativePath(
	config: Config_GlobalConfig | Config_ProjectConfig,
	testPath: string
): { basename: string, dirname: string }
	-- this function can be called with ProjectConfigs or GlobalConfigs. GlobalConfigs
	-- do not have config.cwd, only config.rootDir. Try using config.cwd, fallback
	-- to config.rootDir. (Also, some unit just use config.rootDir, which is ok)
	-- ROBLOX FIXME START
	testPath = testPath
	-- path:relative(
	-- 	Boolean.toJSBoolean((config :: Config_ProjectConfig).cwd) and (config :: Config_ProjectConfig).cwd
	-- 		or config.rootDir,
	-- 	testPath
	-- )
	-- ROBLOX FIXME END
	local dirname = path:dirname(testPath) :: string
	local basename = path:basename(testPath) :: string
	return { basename = basename, dirname = dirname }
end
exports.relativePath = relativePath

local function getValuesCurrentTestCases(currentTestCases: Array<{ test: Test, testCaseResult: TestCaseResult }>?)
	if currentTestCases == nil then
		currentTestCases = {}
	end
	local numFailingTests = 0
	local numPassingTests = 0
	local numPendingTests = 0
	local numTodoTests = 0
	local numTotalTests = 0
	Array.forEach(currentTestCases :: Array<{ test: Test, testCaseResult: TestCaseResult }>, function(testCase)
		local condition_ = testCase.testCaseResult.status
		if condition_ == "failed" then
			numFailingTests = numFailingTests + 1
		elseif condition_ == "passed" then
			numPassingTests = numPassingTests + 1
		elseif condition_ == "skipped" then
			numPendingTests = numPendingTests + 1
		elseif condition_ == "todo" then
			numTodoTests = numTodoTests + 1
		end
		numTotalTests += 1
	end)

	return {
		numFailingTests = numFailingTests,
		numPassingTests = numPassingTests,
		numPendingTests = numPendingTests,
		numTodoTests = numTodoTests,
		numTotalTests = numTotalTests,
	}
end

local function getSummary(aggregatedResults: AggregatedResult, options: SummaryOptions?): string
	local runTime = (DateTime.now().UnixTimestampMillis - aggregatedResults.startTime) / 1000
	if options ~= nil and options.roundTime then
		runTime = math.floor(runTime)
	end

	local valuesForCurrentTestCases =
		getValuesCurrentTestCases(if options ~= nil then options.currentTestCases else nil)

	local estimatedTime = options ~= nil and options.estimatedTime or 0
	local snapshotResults = aggregatedResults.snapshot
	local snapshotsAdded = snapshotResults.added
	local snapshotsFailed = snapshotResults.unmatched
	local snapshotsOutdated = snapshotResults.unchecked
	local snapshotsFilesRemoved = snapshotResults.filesRemoved
	local snapshotsDidUpdate = snapshotResults.didUpdate
	local snapshotsPassed = snapshotResults.matched
	local snapshotsTotal = snapshotResults.total
	local snapshotsUpdated = snapshotResults.updated
	local suitesFailed = aggregatedResults.numFailedTestSuites or 0
	local suitesPassed = aggregatedResults.numPassedTestSuites or 0
	local suitesPending = aggregatedResults.numPendingTestSuites or 0
	local suitesRun = suitesFailed + suitesPassed
	local suitesTotal = aggregatedResults.numTotalTestSuites or 0
	local testsFailed = aggregatedResults.numFailedTests or 0
	local testsPassed = aggregatedResults.numPassedTests or 0
	local testsPending = aggregatedResults.numPendingTests or 0
	local testsTodo = aggregatedResults.numTodoTests or 0
	local testsTotal = aggregatedResults.numTotalTests or 0
	local width = options ~= nil and options.width or 0

	local suites = chalk.bold("Test Suites: ")
		.. (if suitesFailed > 0 then chalk.bold(chalk.red(("%d failed"):format(suitesFailed))) .. ", " else "")
		.. (if suitesPending > 0 then chalk.bold(chalk.yellow(("%d skipped"):format(suitesPending))) .. ", " else "")
		.. (if suitesPassed > 0 then chalk.bold(chalk.green(("%d passed"):format(suitesPassed))) .. ", " else "")
		.. (if suitesRun ~= suitesTotal
			then tostring(suitesRun) .. " of " .. tostring(suitesTotal)
			else tostring(suitesTotal))
		.. " total"

	local updatedTestsFailed = testsFailed + valuesForCurrentTestCases.numFailingTests
	local updatedTestsPending = testsPending + valuesForCurrentTestCases.numPendingTests
	local updatedTestsTodo = testsTodo + valuesForCurrentTestCases.numTodoTests
	local updatedTestsPassed = testsPassed + valuesForCurrentTestCases.numPassingTests
	local updatedTestsTotal = testsTotal + valuesForCurrentTestCases.numTotalTests

	local tests = chalk.bold("Tests:       ")
		.. (if updatedTestsFailed > 0
			then chalk.bold(chalk.red(("%d failed"):format(updatedTestsFailed))) .. ", "
			else "")
		.. (if updatedTestsPending > 0
			then chalk.bold(chalk.yellow(("%d skipped"):format(updatedTestsPending))) .. ", "
			else "")
		.. (if updatedTestsTodo > 0 then chalk.bold(chalk.magenta(("%d todo"):format(updatedTestsTodo))) .. ", " else "")
		.. (if updatedTestsPassed > 0
			then chalk.bold(chalk.green(("%d passed"):format(updatedTestsPassed))) .. ", "
			else "")
		.. ("%d total"):format(updatedTestsTotal)

	local snapshots = chalk.bold("Snapshots:   ")
		.. (if snapshotsFailed > 0 then chalk.bold(chalk.red(("%d failed"):format(snapshotsFailed))) .. ", " else "")
		.. (if Boolean.toJSBoolean(snapshotsOutdated) and not snapshotsDidUpdate
			then chalk.bold(chalk.yellow(("%d obsolete"):format(snapshotsOutdated))) .. ", "
			else "")
		.. (if Boolean.toJSBoolean(snapshotsOutdated) and snapshotsDidUpdate
			then chalk.bold(chalk.green(("%d removed"):format(snapshotsOutdated))) .. ", "
			else "")
		.. (if Boolean.toJSBoolean(snapshotsFilesRemoved) and not snapshotsDidUpdate
			then chalk.bold(chalk.yellow((pluralize("file", snapshotsFilesRemoved)) .. " obsolete")) .. ", "
			else "")
		.. (if Boolean.toJSBoolean(snapshotsFilesRemoved) and snapshotsDidUpdate
			then chalk.bold(chalk.green((pluralize("file", snapshotsFilesRemoved)) .. " removed")) .. ", "
			else "")
		.. (if Boolean.toJSBoolean(snapshotsUpdated)
			then chalk.bold(chalk.green(("%d updated"):format(snapshotsUpdated))) .. ", "
			else "")
		.. (if Boolean.toJSBoolean(snapshotsAdded)
			then chalk.bold(chalk.green(("%d written"):format(snapshotsAdded))) .. ", "
			else "")
		.. (if Boolean.toJSBoolean(snapshotsPassed)
			then chalk.bold(chalk.green(("%d passed"):format(snapshotsPassed))) .. ", "
			else "")
		.. ("%d total"):format(snapshotsTotal)

	local time = renderTime(runTime, estimatedTime, width)
	return Array.join({ suites, tests, snapshots, time }, "\n")
end
exports.getSummary = getSummary

function renderTime(runTime: number, estimatedTime: number, width: number)
	-- If we are more than one second over the estimated time, highlight it.
	local renderedTime = if Boolean.toJSBoolean(estimatedTime) and runTime >= estimatedTime + 1
		then chalk.bold(chalk.yellow(formatTime(runTime, 0)))
		else formatTime(runTime, 0)

	local time = chalk.bold("Time:") .. ("        %s"):format(renderedTime)

	if runTime < estimatedTime then
		time ..= (", estimated %s"):format(formatTime(estimatedTime, 0))
	end

	-- Only show a progress bar if the test run is actually going to take
	-- some time.
	if Boolean.toJSBoolean(estimatedTime > 2 and runTime < estimatedTime and width) then
		local availableWidth = math.min(PROGRESS_BAR_WIDTH, width)
		local length = math.min(math.floor(runTime / estimatedTime * availableWidth), availableWidth)

		if availableWidth >= 2 then
			time ..= "\n" .. chalk.green("\u{2588}"):rep(length) .. tostring(
				chalk.white("\u{2588}"):rep(availableWidth - length)
			)
		end
	end

	return time
end

-- ROBLOX deviation START: We don't need to wrap lines so return the string as-is.
-- word-wrap a string that contains ANSI escape sequences.
-- ANSI escape sequences do not add to the string length.
local function wrapAnsiString(string: string, terminalWidth: number): string
	return string
end
exports.wrapAnsiString = wrapAnsiString
-- ROBLOX deviation END

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="364">
            <Properties>
              <string name="Name">JestRunner</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-runner/src/index.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Map<T, U> = LuauPolyfill.Map<T, U>
type Promise<T> = LuauPolyfill.Promise<T>

local Promise = require(Packages.Promise)

local exports = {}

-- ROBLOX deviation: chalk used only in parallel tests
-- local chalk = require(Packages.ChalkLua)
local emitteryModule = require(Packages.Emittery)
local Emittery = emitteryModule.default
type Emittery = emitteryModule.Emittery
type Emittery_UnsubscribeFn = emitteryModule.Emittery_UnsubscribeFn

-- ROBLOX deviation: exit used only in parallel tests
-- local exit = require(Packages.exit)
local throatModule = require(Packages.Throat)
local throat = throatModule.default
type ThroatLateBound<TResult, TArgs> = throatModule.ThroatLateBound<TResult, TArgs>
local test_resultModule = require(Packages.JestTestResult)
type SerializableError = test_resultModule.SerializableError
type Context = test_resultModule.Context
export type Test = test_resultModule.Test
export type TestEvents = test_resultModule.TestEvents
export type TestFileEvent = test_resultModule.TestFileEvent
type TestResult = test_resultModule.TestResult
local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
local deepCyclicCopy = require(Packages.JestUtil).deepCyclicCopy
-- ROBLOX deviation START: Worker not used yet
-- local jest_workerModule = require(Packages.JestWorker)
-- local PromiseWithCustomMessage = jest_workerModule.PromiseWithCustomMessage
-- local Worker = jest_workerModule.Worker
-- ROBLOX deviation END
local runTest = require(script.runTest).default
-- ROBLOX deviation START: Worker not used yet
-- local testWorkerModule = require(script.testWorker)
-- type SerializableResolver = testWorkerModule.SerializableResolver
-- type worker = testWorkerModule.worker
-- ROBLOX deviation END

-- ROBLOX deviation START: types are exported above
-- -- TODO: remove re-export in Jest 28
-- exports.Test = test_resultModule.Test
-- exports.TestFileEvent = test_resultModule.TestFileEvent
-- exports.TestEvents = test_resultModule.TestEvents
-- ROBLOX deviation END

-- ROBLOX deviation START: Worker not used yet
-- local TEST_WORKER_PATH = require_:resolve("./testWorker")

-- type WorkerInterface = Worker & { worker: typeof(worker) }
-- ROBLOX deviation END

local typesModule = require(script.types)
export type OnTestFailure = typesModule.OnTestFailure
export type OnTestStart = typesModule.OnTestStart
export type OnTestSuccess = typesModule.OnTestSuccess
export type TestWatcher = typesModule.TestWatcher
export type TestRunnerContext = typesModule.TestRunnerContext
export type TestRunnerOptions = typesModule.TestRunnerOptions

-- ROBLOX deviation START: predefine variables
local CancelRun
-- ROBLOX deviation END

export type TestRunner = {
	new: (globalConfig: Config_GlobalConfig, context: TestRunnerContext?) -> TestRunner,

	__PRIVATE_UNSTABLE_API_supportsEventEmitters__: boolean,
	isSerial: boolean,
	runTests: (
		self: TestRunner,
		tests: Array<Test>,
		watcher: TestWatcher,
		onStart: OnTestStart | nil,
		onResult: OnTestSuccess | nil,
		onFailure: OnTestFailure | nil,
		options: TestRunnerOptions
	) -> Promise<nil>,
	on: <Name>(
		self: TestRunner,
		eventName: Name,
		listener: (
			eventData: any
			--[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]]
			--[[ TestEvents[Name] ]]
		) -> ...Promise<nil>
	) -> Emittery_UnsubscribeFn,

	-- ROBLOX NOTE: private
	_globalConfig: Config_GlobalConfig,
	_context: TestRunnerContext,
	-- ROBLOX deviation START: add cache of loaded module functions to a test runner
	_loadedModuleFns: Map<ModuleScript, { any }>,
	cleanup: (self: TestRunner) -> (),
	-- ROBLOX deviation END
	eventEmitter: Emittery,
	_createInBandTestRun: (
		self: TestRunner,
		tests: Array<Test>,
		watcher: TestWatcher,
		onStart: OnTestStart?,
		onResult: OnTestSuccess?,
		onFailure: OnTestFailure?
	) -> Promise<nil>,
	_createParallelTestRun: (
		self: TestRunner,
		tests: Array<Test>,
		watcher: TestWatcher,
		onStart: OnTestStart?,
		onResult: OnTestSuccess?,
		onFailure: OnTestFailure?
	) -> Promise<nil>,
}

local TestRunner = {} :: TestRunner;
(TestRunner :: any).__index = TestRunner

function TestRunner.new(globalConfig: Config_GlobalConfig, context: TestRunnerContext?): TestRunner
	local self = setmetatable({}, TestRunner)
	self.eventEmitter = Emittery.new()
	self.__PRIVATE_UNSTABLE_API_supportsEventEmitters__ = true
	self._globalConfig = globalConfig
	self._context = Boolean.toJSBoolean(context) and context or {}
	-- ROBLOX deviation START: add cache of loaded module functions to a test runner
	self._loadedModuleFns = Map.new()
	-- ROBLOX deviation END
	return (self :: any) :: TestRunner
end

function TestRunner:runTests(
	tests: Array<Test>,
	watcher: TestWatcher,
	onStart: OnTestStart | nil,
	onResult: OnTestSuccess | nil,
	onFailure: OnTestFailure | nil,
	options: TestRunnerOptions
): Promise<nil>
	return Promise.resolve():andThen(function()
		return (
			if Boolean.toJSBoolean(options.serial)
				then self:_createInBandTestRun(tests, watcher, onStart, onResult, onFailure):expect()
				else self:_createParallelTestRun(tests, watcher, onStart, onResult, onFailure):expect()
		)
	end)
end
function TestRunner:_createInBandTestRun(
	tests: Array<Test>,
	watcher: TestWatcher,
	onStart: OnTestStart?,
	onResult: OnTestSuccess?,
	onFailure: OnTestFailure?
)
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation: no process available in Luau
		-- process.env.JEST_WORKER_ID = "1"
		local mutex = throat(1) :: ThroatLateBound<nil, nil>
		return Array.reduce(tests, function(promise: Promise<nil>, test: Test)
			return mutex(function()
				-- ROBLOX FIXME START: Promise type doesn't support changing return type with :andThen call
				return (promise :: Promise<any>)
					:andThen(function(): Promise<TestResult>
						return Promise.resolve():andThen(function()
							if watcher:isInterrupted() then
								error(CancelRun.new())
							end
							local sendMessageToJest

							-- Remove `if(onStart)` in Jest 27: TestFileEvent
							if onStart ~= nil then
								onStart(test):expect()
								return runTest(
									-- ROBLOX deviation: using `script` instead of `path`
									test.script,
									self._globalConfig,
									test.context.config,
									-- ROBLOX deviation START: resolver no supported
									nil,
									-- test.context.resolver,
									-- ROBLOX deviation END
									self._context,
									nil,
									-- ROBLOX deviation START: add cache of loaded module functions to a test runner
									self._loadedModuleFns
									-- ROBLOX deviation END
								)
							else
								-- `deepCyclicCopy` used here to avoid mem-leak
								sendMessageToJest = function(eventName: string, args)
									return self.eventEmitter:emit(
										eventName,
										deepCyclicCopy(args, { keepPrototype = false })
									)
								end
								self.eventEmitter:emit("test-file-start", { test }):expect()
								return runTest(
									-- ROBLOX deviation: using `script` instead of `path`
									test.script,
									self._globalConfig,
									test.context.config,
									-- ROBLOX deviation START: resolver no supported
									nil,
									-- test.context.resolver,
									-- ROBLOX deviation END
									self._context,
									sendMessageToJest,
									-- ROBLOX deviation START: add cache of loaded module functions to a test runner
									self._loadedModuleFns
									-- ROBLOX deviation END
								)
							end
						end)
					end)
					:andThen(function(result: TestResult)
						if onResult ~= nil then
							return onResult(test, result)
						else
							return self.eventEmitter:emit("test-file-success", { test :: any, result })
						end
					end)
					:catch(function(err)
						if onFailure ~= nil then
							return onFailure(test, err)
						else
							return self.eventEmitter:emit("test-file-failure", { test :: any, err })
						end
					end) :: Promise<nil>
				-- ROBLOX FIXME END
			end)
		end, Promise.resolve())
	end)
end

function TestRunner:_createParallelTestRun(
	tests: Array<Test>,
	watcher: TestWatcher,
	onStart: OnTestStart?,
	onResult: OnTestSuccess?,
	onFailure: OnTestFailure?
)
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: parallel test run not implemented yet
		console.warn("Parallel tests run not implemented yet\nRunning tests in band instead")
		return self:_createInBandTestRun(tests, watcher, onStart, onResult, onFailure)
		-- local resolvers: Map<string, SerializableResolver> = Map.new()
		-- for _, test in tests do
		-- 	if not resolvers:has(test.context.config.name) then
		-- 		resolvers:set(test.context.config.name, {
		-- 			config = test.context.config,
		-- 			serializableModuleMap = test.context.moduleMap:toJSON(),
		-- 		})
		-- 	end
		-- end

		-- local worker = Worker.new(TEST_WORKER_PATH, {
		-- 	exposedMethods = { "worker" },
		-- 	forkOptions = { stdio = "pipe" },
		-- 	maxRetries = 3,
		-- 	numWorkers = self._globalConfig.maxWorkers,
		-- 	setupArgs = { { serializableResolvers = Array.from(resolvers:values()) } },
		-- }) :: WorkerInterface

		-- if Boolean.toJSBoolean(worker:getStdout()) then
		-- 	worker:getStdout():pipe(process.stdout)
		-- end
		-- if Boolean.toJSBoolean(worker:getStderr()) then
		-- 	worker:getStderr():pipe(process.stderr)
		-- end

		-- local mutex = throat(self._globalConfig.maxWorkers)

		-- -- Send test suites to workers continuously instead of all at once to track
		-- -- the start time of individual tests.
		-- local function runTestInWorker(test: Test)
		-- 	return mutex(function()
		-- 		return Promise.resolve():andThen(function()
		-- 			if Boolean.toJSBoolean(watcher:isInterrupted()) then
		-- 				return Promise:reject()
		-- 			end

		-- 			-- Remove `if(onStart)` in Jest 27
		-- 			if Boolean.toJSBoolean(onStart) then
		-- 				onStart(test):expect()
		-- 			else
		-- 				self.eventEmitter:emit("test-file-start", { test }):expect()
		-- 			end

		-- 			local promise = worker:worker({
		-- 				config = test.context.config,
		-- 				context = Object.assign({}, self._context, {
		-- 					changedFiles = if Boolean.toJSBoolean(self._context.changedFiles)
		-- 						then Array.from(self._context.changedFiles)
		-- 						else self._context.changedFiles,
		-- 					sourcesRelatedToTestsInChangedFiles = if Boolean.toJSBoolean(
		-- 							self._context.sourcesRelatedToTestsInChangedFiles
		-- 						)
		-- 						then Array.from(self._context.sourcesRelatedToTestsInChangedFiles)
		-- 						else self._context.sourcesRelatedToTestsInChangedFiles,
		-- 				}),
		-- 				globalConfig = self._globalConfig,
		-- 				path = test.path,
		-- 			}) :: PromiseWithCustomMessage<TestResult>

		-- 			if Boolean.toJSBoolean(promise.UNSTABLE_onCustomMessage) then
		-- 				-- TODO: Get appropriate type for `onCustomMessage`
		-- 				promise:UNSTABLE_onCustomMessage(function(ref: any)
		-- 					local event, payload = table.unpack(ref, 1, 2)
		-- 					self.eventEmitter:emit(event, payload)
		-- 				end)
		-- 			end

		-- 			return promise
		-- 		end)
		-- 	end)
		-- end

		-- local function onError(err: SerializableError, test: Test)
		-- 	return Promise.resolve():andThen(function()
		-- 		-- Remove `if(onFailure)` in Jest 27
		-- 		if onFailure ~= nil then
		-- 			onFailure(test, err):expect()
		-- 		else
		-- 			self.eventEmitter:emit("test-file-failure", { test, err }):expect()
		-- 		end
		-- 		if err.type == "ProcessTerminatedError" then
		-- 			console.error(
		-- 				"A worker process has quit unexpectedly! " .. "Most likely this is an initialization error."
		-- 			)
		-- 			exit(1)
		-- 		end
		-- 	end)
		-- end

		-- local onInterrupt = Promise.new(function(_, reject)
		-- 	watcher:on("change", function(state)
		-- 		if state.interrupted then
		-- 			reject(CancelRun.new())
		-- 		end
		-- 	end)
		-- end)

		-- local runAllTests = Promise:all(Array.map(tests, function(test)
		-- 	return runTestInWorker(test)
		-- 		:andThen(function(result)
		-- 			if onResult ~= nil then
		-- 				return onResult(test, result)
		-- 			else
		-- 				return self.eventEmitter:emit("test-file-success", { test, result })
		-- 			end
		-- 		end)
		-- 		:catch(function(error_)
		-- 			return onError(error_, test)
		-- 		end)
		-- end))

		-- local function cleanup()
		-- 	return Promise.resolve():andThen(function()
		-- 		local forceExited = worker:end_():expect().forceExited
		-- 		if Boolean.toJSBoolean(forceExited) then
		-- 			console.error(
		-- 				chalk.yellow(
		-- 					"A worker process has failed to exit gracefully and has been force exited. "
		-- 						.. "This is likely caused by tests leaking due to improper teardown. "
		-- 						.. "Try running with --detectOpenHandles to find leaks. "
		-- 						.. "Active timers can also cause this, ensure that .unref() was called on them."
		-- 				)
		-- 			)
		-- 		end
		-- 	end)
		-- end
		-- return Promise.race({ runAllTests, onInterrupt }):andThen(cleanup, cleanup)
		-- ROBLOX deviation END
	end)
end

function TestRunner:on<Name>(
	eventName: Name,
	listener: (
		eventData: any
		--[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]]
		--[[ TestEvents[Name] ]]
	) -> () | Promise<nil>
): Emittery_UnsubscribeFn
	return self.eventEmitter:on(eventName, listener)
end

-- ROBLOX deviation START: add cache of loaded module functions to a test runner
-- test runner should call clean up functions when it is done
function TestRunner:cleanup()
	self._loadedModuleFns:forEach(function(val)
		local cleanup = val[3]
		if cleanup ~= nil then
			cleanup()
		end
	end)
end
-- ROBLOX deviation END

exports.default = TestRunner

type CancelRun = Error & {}
CancelRun = setmetatable({}, { __index = Error })
CancelRun.__index = CancelRun
function CancelRun.new(message: string?): CancelRun
	local self = setmetatable(Error.new(message), CancelRun)
	self.name = "CancelRun"
	return (self :: any) :: CancelRun
end
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="365">
              <Properties>
                <string name="Name">runTest</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-runner/src/runTest.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local setTimeout = LuauPolyfill.setTimeout
type Map<T, U> = LuauPolyfill.Map<T, U>
local setImmediate = setTimeout
local Promise = require(Packages.Promise)
type Promise<T> = LuauPolyfill.Promise<T>

-- ROBLOX deviation START: additional function to construct file path from ModuleScript
local getRelativePath = require(Packages.RobloxShared).getRelativePath
local getDataModelService = require(Packages.RobloxShared).getDataModelService
local CoreScriptSyncService = getDataModelService("CoreScriptSyncService")
-- ROBLOX deviation END

local exports = {}

local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation START: unnecessary variables
-- local fs = require(Packages["graceful-fs"])
-- local sourcemapSupport = require(Packages["source-map-support"])
-- ROBLOX deviation END
local consoleModule = require(Packages.JestConsole)
local BufferedConsole = consoleModule.BufferedConsole
type BufferedConsole = consoleModule.BufferedConsole
local CustomConsole = consoleModule.CustomConsole
type CustomConsole = consoleModule.CustomConsole
type LogMessage = consoleModule.LogMessage
type LogType = consoleModule.LogType
local NullConsole = consoleModule.NullConsole
type NullConsole = consoleModule.NullConsole
local getConsoleOutput = consoleModule.getConsoleOutput
local environmentModule = require(Packages.JestEnvironment)
type JestEnvironment = environmentModule.JestEnvironment
local test_resultModule = require(Packages.JestTestResult)
type TestFileEvent = test_resultModule.TestFileEvent
type TestResult = test_resultModule.TestResult
-- ROBLOX deviation: unnecessary variable
-- local createScriptTransformer = require(Packages.JestTransform).createScriptTransformer
local jestTypesModule = require(Packages.JestTypes)
type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
-- ROBLOX deviation: running test based on ModuleScript rather than file
type Config_Path = ModuleScript --jestTypesModule.Config_Path
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
-- local docblock = require(Packages["jest-docblock"])
-- local LeakDetector = require(Packages["jest-leak-detector"]).default
-- ROBLOX TODO START: implement
-- local formatExecError = require(Packages.JestMessageUtil).formatExecError
-- local jest_resolveModule = require(Packages["jest-resolve"])
-- local Resolver = jest_resolveModule.default
type Resolver = any
-- local resolveTestEnvironment = jest_resolveModule.resolveTestEnvironment
-- local jest_runtimeModule = require(Packages.JestRuntime)
-- type RuntimeClass = jest_runtimeModule.default
type RuntimeClass = typeof(require(Packages.JestRuntime))
-- ROBLOX TODO END
local jest_utilModule = require(Packages.JestUtil)
local ErrorWithStack = jest_utilModule.ErrorWithStack
-- ROBLOX deviation: unnecessary variable
-- local interopRequireDefault = jest_utilModule.interopRequireDefault
local setGlobal = jest_utilModule.setGlobal
local typesModule = require(script.Parent.types)
type TestFramework = typesModule.TestFramework
type TestRunnerContext = typesModule.TestRunnerContext

local Writeable = require(Packages.RobloxShared).Writeable
type LeakDetector = nil
type RunTestInternalResult = {
	leakDetector: LeakDetector | nil,
	result: TestResult,
}
local function freezeConsole(testConsole: BufferedConsole | CustomConsole | NullConsole, config: Config_ProjectConfig)
	-- @ts-expect-error: `_log` is `private` - we should figure out some proper API here
	local function fakeConsolePush(self: any, _type: LogType, message: LogMessage)
		local _error_ = ErrorWithStack.new(
			('%s\nAttempted to log "%s".'):format(
				chalk.red(
					("%s Did you forget to wait for something async in your test?"):format(
						chalk.bold("Cannot log after tests are done.")
					)
				),
				message
			),
			fakeConsolePush
		)
		-- local formattedError = formatExecError(error_, config, { noStackTrace = false }, nil, true)
		-- process.stderr:write("\n" .. tostring(formattedError) .. "\n")
		-- process.exitCode = 1
	end
	(testConsole :: any)._log = fakeConsolePush
end

-- Keeping the core of "runTest" as a separate function (as "runTestInternal")
-- is key to be able to detect memory leaks. Since all variables are local to
-- the function, when "runTestInternal" finishes its execution, they can all be
-- freed, UNLESS something else is leaking them (and that's why we can detect
-- the leak!).
--
-- If we had all the code in a single function, we should manually nullify all
-- references to verify if there is a leak, which is not maintainable and error
-- prone. That's why "runTestInternal" CANNOT be inlined inside "runTest".
local function runTestInternal(
	-- ROBLOX deviation: accept ModuleScript instead of string
	path: ModuleScript,
	globalConfig: Config_GlobalConfig,
	projectConfig: Config_ProjectConfig,
	resolver: Resolver,
	context: TestRunnerContext,
	sendMessageToJest: TestFileEvent?,
	loadedModuleFns: Map<ModuleScript, { any }>
): Promise<RunTestInternalResult>
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: unnecessary variables
		-- local testSource = fs:readFileSync(path, "utf8")
		-- local docblockPragmas = docblock:parse(docblock:extract(testSource))
		-- local customEnvironment = docblockPragmas["jest-environment"]
		-- ROBLOX deviation END
		local testEnvironment = projectConfig.testEnvironment
		-- ROBLOX deviation START: no custom environment handling
		-- if customEnvironment ~= nil then
		-- 	if Array.isArray(customEnvironment) then
		-- 		error(
		-- 			Error.new(
		-- 				('You can only define a single test environment through docblocks, got "%s"'):format(
		-- 					(Array.join(customEnvironment, ", "))
		-- 				)
		-- 			)
		-- 		)
		-- 	end
		-- 	testEnvironment = resolveTestEnvironment(Object.assign({}, config, {
		-- 		requireResolveFunction = require_.resolve,
		-- 		testEnvironment = customEnvironment,
		-- 	}))
		-- end
		-- ROBLOX deviation END
		-- ROBLOX deviation START: unnecessary variables
		-- local cacheFS = Map.new({ { path, testSource } })
		-- local transformer = createScriptTransformer(config, cacheFS):expect()
		-- ROBLOX deviation END
		local TestEnvironment: JestEnvironment =
			-- ROBLOX deviation: need to cast as require doesn't allow to import unknown paths
			(require :: any)(testEnvironment)
		-- transformer:requireAndTranspileModule(testEnvironment):expect()
		-- ROBLOX deviation START: use only JestCircus runner
		local testFramework: TestFramework = require(Packages.JestCircus).runner
		-- local testFramework: TestFramework = transformer
		-- 	:requireAndTranspileModule(
		-- 		if process.env.JEST_JASMINE == "1" then require_:resolve("jest-jasmine2") else config.testRunner
		-- 	)
		-- 	:expect()
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use only JestRuntime
		local Runtime: RuntimeClass = require(Packages.JestRuntime)
		-- interopRequireDefault(
		-- 	if Boolean.toJSBoolean(config.moduleLoader) then require_(config.moduleLoader) else require_("jest-runtime")
		-- ).default
		-- ROBLOX deviation END

		-- ROBLOX deviation START: using writable instead of process.stdout or process.stdin
		local consoleOut = Writeable.new()
		-- local consoleOut = if Boolean.toJSBoolean(globalConfig.useStderr) then process.stderr else process.stdout
		-- ROBLOX deviation END
		local function consoleFormatter(type_, message: LogMessage)
			return getConsoleOutput(
				-- 4 = the console call is buried 4 stack frames deep
				BufferedConsole.write({}, type_, message, 4),
				projectConfig,
				globalConfig
			)
		end

		local testConsole

		if globalConfig.silent then
			testConsole = NullConsole.new(consoleOut, consoleOut, consoleFormatter)
		elseif globalConfig.verbose then
			testConsole = CustomConsole.new(consoleOut, consoleOut, consoleFormatter)
		else
			testConsole = BufferedConsole.new()
		end

		local environment = TestEnvironment.new(projectConfig, {
			console = testConsole,
			-- docblockPragmas = docblockPragmas,
			testPath = path,
		})

		if typeof(environment.getVmContext) ~= "function" then
			console.error(
				('Test environment found at "%s" does not export a "getVmContext" method, which is mandatory from Jest 27. This method is a replacement for "runScript".'):format(
					tostring(testEnvironment)
				)
			)
			-- ROBLOX deviation START: no process.exit in Luau
			error(1)
			-- process.exit(1)
			-- ROBLOX deviation END
		end

		-- ROBLOX deviation START: no leak detector implemented
		local leakDetector = nil
		-- local leakDetector = if config.detectLeaks then LeakDetector.new(environment) else nil
		-- ROBLOX deviation END

		setGlobal((environment.global :: unknown) :: typeof(_G), "console", testConsole)

		local runtime = Runtime.new(
			projectConfig,
			loadedModuleFns
			-- ROBLOX TODO START: no params to Runtime.new so far
			-- environment, resolver, transformer, cacheFS, {
			-- 	changedFiles = if typeof(context) == "table" then context.changedFiles else nil,
			-- 	collectCoverage = globalConfig.collectCoverage,
			-- 	collectCoverageFrom = globalConfig.collectCoverageFrom,
			-- 	collectCoverageOnlyFrom = globalConfig.collectCoverageOnlyFrom,
			-- 	coverageProvider = globalConfig.coverageProvider,
			-- 	sourcesRelatedToTestsInChangedFiles = if typeof(context) == "table"
			-- 		then context.sourcesRelatedToTestsInChangedFiles
			-- 		else nil,
			-- }, path
			-- ROBLOX TODO END
		)

		local start = DateTime.now().UnixTimestampMillis

		for _, path_ in projectConfig.setupFiles do
			-- ROBLOX deviation START: no esm modules in Lua
			runtime:requireModule(path_)
			-- local esm = runtime:unstable_shouldLoadAsEsm(path)
			-- if esm ~= nil then
			-- 	runtime:unstable_importModule(path):expect()
			-- else
			-- 	runtime:requireModule(path)
			-- end
			-- ROBLOX deviation END
		end

		-- ROBLOX deviation START: no source map supported
		-- local sourcemapOptions: sourcemapSupport_Options = {
		-- 	environment = "node",
		-- 	handleUncaughtExceptions = false,
		-- 	retrieveSourceMap = function(source)
		-- 		local ref = if typeof(runtime:getSourceMaps()) == "table" then runtime:getSourceMaps().get else nil
		-- 		local sourceMapSource = if ref ~= nil then ref(source) else nil
		-- 		if Boolean.toJSBoolean(sourceMapSource) then
		-- 			local _ok, result, hasReturned = pcall(function()
		-- 				return {
		-- 					map = JSON:parse(fs:readFileSync(sourceMapSource, "utf8")),
		-- 					url = source,
		-- 				},
		-- 					true
		-- 			end)
		-- 			if hasReturned then
		-- 				return result
		-- 			end
		-- 		end
		-- 		return nil
		-- 	end,
		-- }

		-- -- For tests
		-- runtime
		-- 	:requireInternalModule(require_:resolve("source-map-support"), "source-map-support")
		-- 	:install(sourcemapOptions)

		-- -- For runtime errors
		-- sourcemapSupport:install(sourcemapOptions)
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no process.exit in Luau
		-- if
		-- 	Boolean.toJSBoolean(environment.global)
		-- 	and Boolean.toJSBoolean(environment.global.process)
		-- 	and Boolean.toJSBoolean(environment.global.process.exit)
		-- then
		-- 	local realExit = environment.global.process.exit

		-- 	environment.global.process.exit = function(...: any)
		-- 		local args = { ... }
		-- 		local error_ = ErrorWithStack.new(
		-- 			('process.exit called with "%s"'):format(tostring(Array.join(args, ", "))),
		-- 			exit
		-- 		)

		-- 		local formattedError = formatExecError(error_, config, { noStackTrace = false }, nil, true)

		-- 		process.stderr:write(formattedError)

		-- 		return realExit(table.unpack(args))
		-- 	end
		-- end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: no v8Coverage
		-- -- if we don't have `getVmContext` on the env skip coverage
		-- local collectV8Coverage = globalConfig.coverageProvider == "v8"
		-- 	and typeof(environment.getVmContext) == "function"
		-- ROBLOX deviation END

		local ok, result = pcall(function()
			environment:setup():expect()
			local result: TestResult

			local ok_, result_ = pcall(function()
				-- ROBLOX deviation START: no v8Coverage
				-- if collectV8Coverage then
				-- 	runtime:collectV8Coverage():expect()
				-- end
				-- ROBLOX deviation END
				result =
					testFramework(globalConfig, projectConfig, environment, runtime, path, sendMessageToJest):expect()
			end)
			if not ok_ then
				local err = result_

				-- Access stack before uninstalling sourcemaps
				local _ = err.stack
			end
			-- ROBLOX deviation START: no v8Coverage
			-- if collectV8Coverage then
			-- 	runtime:stopCollectingV8Coverage():expect()
			-- end
			-- ROBLOX deviation END
			if not ok_ then
				local err = result_
				error(err)
			end

			freezeConsole(testConsole, projectConfig)

			local testCount = result.numPassingTests
				+ result.numFailingTests
				+ result.numPendingTests
				+ result.numTodoTests

			local end_ = DateTime.now().UnixTimestampMillis
			local testRuntime = end_ - start
			result.perfStats = {
				["end"] = end_,
				runtime = testRuntime,
				slow = testRuntime / 1000 > projectConfig.slowTestThreshold,
				start = start,
			}
			-- ROBLOX deviation: resolve to a FS path if CoreScriptSyncService is available
			if CoreScriptSyncService then
				result.testFilePath = CoreScriptSyncService:GetScriptFilePath(path)
			else
				result.testFilePath = getRelativePath(path, projectConfig.rootDir)
			end
			result.console = testConsole:getBuffer()
			result.skipped = testCount == result.numPendingTests
			result.displayName = projectConfig.displayName

			-- #region
			-- ROBLOX deviation START: no coverage support
			-- local coverage = runtime:getAllCoverageInfoCopy()
			-- if Boolean.toJSBoolean(coverage) then
			-- 	local coverageKeys = Object.keys(coverage)
			-- 	if #coverageKeys > 0 then
			-- 		result.coverage = coverage
			-- 	end
			-- end
			-- ROBLOX deviation END

			-- ROBLOX deviation START: no v8Coverage
			-- if collectV8Coverage then
			-- 	local v8Coverage = runtime:getAllV8CoverageInfoCopy()
			-- 	if Boolean.toJSBoolean(v8Coverage) and #v8Coverage > 0 then
			-- 		result.v8Coverage = v8Coverage
			-- 	end
			-- end
			-- ROBLOX deviation END

			-- ROBLOX deviation START: no gc available in Luau
			-- if globalConfig.logHeapUsage then
			-- 	if global.gc then
			-- 		global:gc()
			-- 	end
			-- 	result.memoryUsage = process:memoryUsage().heapUsed
			-- end
			-- ROBLOX deviation END
			--#endregion
			-- Delay the resolution to allow log messages to be output.
			return Promise.new(function(resolve)
				setImmediate(function()
					return resolve({ leakDetector = leakDetector, result = result })
				end)
			end)
		end)
		runtime:teardown()
		environment:teardown():expect()

		-- ROBLOX deviation: no source map supported
		-- sourcemapSupport:resetRetrieveHandlers()

		if not ok then
			error(result)
		end
		return result
	end)
end

local function runTest(
	path: ModuleScript,
	globalConfig: Config_GlobalConfig,
	config: Config_ProjectConfig,
	resolver: Resolver,
	context: TestRunnerContext,
	sendMessageToJest: TestFileEvent?,
	loadedModuleFns: Map<ModuleScript, { any }>
): Promise<TestResult>
	return Promise.resolve():andThen(function()
		local ref =
			runTestInternal(path, globalConfig, config, resolver, context, sendMessageToJest, loadedModuleFns):expect()
		local leakDetector, result = ref.leakDetector, ref.result
		if leakDetector ~= nil then
			-- We wanna allow a tiny but time to pass to allow last-minute cleanup
			Promise.new(function(resolve)
				return setTimeout(resolve, 100)
			end):expect()

			-- Resolve leak detector, outside the "runTestInternal" closure.
			result.leaks = leakDetector:isLeaking():expect()
		else
			result.leaks = false
		end
		return result
	end)
end
exports.default = runTest

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="366">
              <Properties>
                <string name="Name">testWorker</string>
                <string name="Source"><![CDATA[local function worker() end

return {
	worker = worker,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="367">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-runner/src/types.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Promise<T> = LuauPolyfill.Promise<T>
type Set<T> = LuauPolyfill.Set<T>

type void = nil

-- ROBLOX deviation: no emittery available
type Emittery<T> = any
local environmentModule = require(Packages.JestEnvironment)
type JestEnvironment = environmentModule.JestEnvironment
local test_resultModule = require(Packages.JestTestResult)
type SerializableError = test_resultModule.SerializableError
type Context = test_resultModule.Context
type Test = test_resultModule.Test
type TestFileEvent = test_resultModule.TestFileEvent
type TestResult = test_resultModule.TestResult
local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
-- ROBLOX TODO:
-- local jest_runtimeModule = require(Packages.JestRuntime)
type RuntimeType = any -- jest_runtimeModule.default

export type ErrorWithCode = Error & { code: string? }

export type OnTestStart = (test: Test) -> Promise<nil>
export type OnTestFailure = (test: Test, serializableError: SerializableError) -> Promise<nil>
export type OnTestSuccess = (test: Test, testResult: TestResult) -> Promise<nil>

export type TestFramework = (
	globalConfig: Config_GlobalConfig,
	config: Config_ProjectConfig,
	environment: JestEnvironment,
	runtime: RuntimeType,
	-- ROBLOX deviation: accept ModuleScript instead of string
	testPath: ModuleScript,
	sendMessageToJest: TestFileEvent?
) -> Promise<TestResult>

export type TestRunnerOptions = { serial: boolean }

-- make sure all props here are present in the type below it as well
export type TestRunnerContext = {
	changedFiles: Set<Config_Path>?,
	sourcesRelatedToTestsInChangedFiles: Set<Config_Path>?,
}
type SerializeSet<T> = any --[[ ROBLOX TODO: Unhandled node for type: TSConditionalType ]] --[[ T extends Set<infer U> ? Array<U> : T ]]
export type TestRunnerSerializedContext = any --[[ ROBLOX TODO: Unhandled node for type: TSMappedType ]] --[[ {
  [K in keyof TestRunnerContext]: SerializeSet<TestRunnerContext[K]>;
} ]]
export type UnsubscribeFn = () -> ()
export type CallbackTestRunnerInterface = {
	isSerial: boolean?,
	supportsEventEmitters: boolean?,
	runTests: (
		self: CallbackTestRunnerInterface,
		tests: Array<Test>,
		watcher: TestWatcher,
		onStart: OnTestStart,
		onResult: OnTestSuccess,
		onFailure: OnTestFailure,
		options: TestRunnerOptions
	) -> Promise<void>,
}

-- TODO: Should live in `@jest/core` or `jest-watcher`
type WatcherState = { interrupted: boolean }
export type TestWatcher = Emittery<{ change: WatcherState }> & {
	state: WatcherState,
	setState: (self: TestWatcher, state: WatcherState) -> (),
	isInterrupted: (self: TestWatcher) -> boolean,
	isWatchMode: (self: TestWatcher) -> boolean,
}
return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="368">
            <Properties>
              <string name="Name">JestRuntime</string>
              <string name="Source"><![CDATA[--!nonstrict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-runtime/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
-- ROBLOX deviation START: skipped
-- type void = nil --[[ ROBLOX FIXME: adding `void` type alias to make it easier to use Luau `void` equivalent when supported ]]
-- ROBLOX deviation END
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: skipped
-- local Array = LuauPolyfill.Array
-- ROBLOX deviation END
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local Object = LuauPolyfill.Object
-- ROBLOX deviation START: skipped
-- local Set = LuauPolyfill.Set
-- local WeakMap = LuauPolyfill.WeakMap
-- local console = LuauPolyfill.console
-- local instanceof = LuauPolyfill.instanceof
-- ROBLOX deviation END
type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX deviation START: skipped
-- type Error = LuauPolyfill.Error
-- ROBLOX deviation END
type Map<T, U> = LuauPolyfill.Map<T, U>
type Promise<T> = LuauPolyfill.Promise<T>
-- ROBLOX deviation START: skipped
-- type Set<T> = LuauPolyfill.Set<T>
-- type WeakMap<T, U> = LuauPolyfill.WeakMap<T, U>
-- ROBLOX deviation END
type Omit<T, K> = T --[[ ROBLOX TODO: TS 'Omit' built-in type is not available in Luau ]]
-- ROBLOX deviation START: skipped
-- type Parameters<T> = any --[[ ROBLOX TODO: TS 'Parameters' built-in type is not available in Luau ]]
-- local Promise = require(Packages.Promise)
-- local exports = {}
-- local nativeModule = require(Packages.module)
-- local path = require(Packages.path)
-- local urlModule = require(Packages.url)
-- local URL = urlModule.URL
-- local fileURLToPath = urlModule.fileURLToPath
-- local pathToFileURL = urlModule.pathToFileURL
-- local vmModule = require(Packages.vm)
-- local Script = vmModule.Script
-- -- @ts-expect-error: experimental, not added to the types
-- local SourceTextModule = vmModule.SourceTextModule
-- -- @ts-expect-error: experimental, not added to the types
-- local SyntheticModule = vmModule.SyntheticModule
-- local VMContext = vmModule.Context
-- -- @ts-expect-error: experimental, not added to the types
-- local VMModule = vmModule.Module
-- local parseCjs = require(Packages["cjs-module-lexer"]).parse
-- local collectV8CoverageModule = require(Packages["collect-v8-coverage"])
-- local CoverageInstrumenter = collectV8CoverageModule.CoverageInstrumenter
-- local V8Coverage = collectV8CoverageModule.V8Coverage
-- local execa = require(Packages.execa)
-- local fs = require(Packages["graceful-fs"])
-- local slash = require(Packages.slash)
-- local stripBOM = require(Packages["strip-bom"])
-- local jestEnvironmentModule = require(Packages.JestEnvironment)
-- type Jest = jestEnvironmentModule.Jest
-- type JestEnvironment = jestEnvironmentModule.JestEnvironment
-- type Module = jestEnvironmentModule.Module
-- type ModuleWrapper = jestEnvironmentModule.ModuleWrapper
-- local jestFakeTimersModule = require(Packages.JestFakeTimers)
-- type LegacyFakeTimers = jestFakeTimersModule.LegacyFakeTimers
-- type ModernFakeTimers = jestFakeTimersModule.ModernFakeTimers
-- local jestGlobalsModule = require(Packages.Dev.JestGlobals)
-- local JestGlobals = jestGlobalsModule
-- local jestSourceMapModule = require(Packages["@jest"]["source-map"])
-- type SourceMapRegistry = jestSourceMapModule.SourceMapRegistry
-- local jestTestResultModule = require(Packages.JestTestResult)
-- type RuntimeTransformResult = jestTestResultModule.RuntimeTransformResult
-- type V8CoverageResult = jestTestResultModule.V8CoverageResult
-- local jestTransformModule = require(Packages["@jest"].transform)
-- local CallerTransformOptions = jestTransformModule.CallerTransformOptions
-- local ScriptTransformer = jestTransformModule.ScriptTransformer
-- local ShouldInstrumentOptions = jestTransformModule.ShouldInstrumentOptions
-- local TransformResult = jestTransformModule.TransformResult
-- local TransformationOptions = jestTransformModule.TransformationOptions
-- local handlePotentialSyntaxError = jestTransformModule.handlePotentialSyntaxError
-- local shouldInstrument = jestTransformModule.shouldInstrument
local jestTypesModule = require(Packages.JestTypes)
-- type Config = jestTypesModule.Config
-- type Config_Path = jestTypesModule.Config_Path
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig
-- type Global = jestTypesModule.Global
-- type Global_TestFrameworkGlobals = jestTypesModule.Global_TestFrameworkGlobals
-- local jestHasteMapModule = require(Packages["jest-haste-map"])
-- type IModuleMap = jestHasteMapModule.IModuleMap
-- local HasteMap = require(Packages["jest-haste-map"]).default
-- local jestMessageUtilModule = require(Packages.JestMessageUtil)
-- local formatStackTrace = jestMessageUtilModule.formatStackTrace
-- local separateMessageFromStack = jestMessageUtilModule.separateMessageFromStack
-- ROBLOX deviation END
local jestMockModule = require(Packages.JestMock)
-- ROBLOX deviation: not implemented yet
-- type MockFunctionMetadata = jestMockModule.MockFunctionMetadata
-- ROBLOX deviation END
type ModuleMocker = jestMockModule.ModuleMocker
-- ROBLOX deviation START: (addition) importing ModuleMocker class instead of injecting it via runTests
local ModuleMocker = jestMockModule.ModuleMocker
-- ROBLOX deviation END
-- ROBLOX deviation START: mocking globals
local jestMockGenvModule = require(Packages.JestMockGenv)
local GlobalMocker = jestMockGenvModule.GlobalMocker
type GlobalMocker = jestMockGenvModule.GlobalMocker
-- ROBLOX deviation START: skipped
-- local escapePathForRegex = require(Packages["jest-regex-util"]).escapePathForRegex
-- local jestResolveModule = require(Packages["jest-resolve"])
-- local Resolver = jestResolveModule.default
-- local ResolveModuleConfig = jestResolveModule.ResolveModuleConfig
-- local Snapshot = require(Packages.JestSnapshot)
-- local jestUtilModule = require(Packages.JestUtil)
-- local createDirectory = jestUtilModule.createDirectory
-- local deepCyclicCopy = jestUtilModule.deepCyclicCopy
-- local helpersModule = require(script.helpers)
-- local createOutsideJestVmPath = helpersModule.createOutsideJestVmPath
-- local decodePossibleOutsideJestVmPath = helpersModule.decodePossibleOutsideJestVmPath
-- local findSiblingsWithFileExtension = helpersModule.findSiblingsWithFileExtension
-- ROBLOX deviation END
local typesModule = require(script.types)
export type Context = typesModule.Context
-- ROBLOX deviation START: skipped
-- local typesModule = require(script.types)
-- exports.Context = typesModule.Context

-- ROBLOX deviation START: adding mocked ResolveModuleConfig type until implemented
type ResolveModuleConfig = any
-- ROBLOX deviation END

-- ROBLOX deviation START: additional dependencies
local TypeError = Error
local _typesModule = require(script._types)
export type Jest = _typesModule.Jest
type MockFactory = _typesModule.MockFactory

local jestExpectModule = require(Packages.Expect)
type Expect = jestExpectModule.Expect
local JestFakeTimers = require(Packages.JestFakeTimers)
type FakeTimers = JestFakeTimers.FakeTimers
-- ROBLOX deviation END
-- local esmIsAvailable = typeof(SourceTextModule) == "function"
-- ROBLOX deviation END
-- ROBLOX deviation START: inline type
-- type JestGlobals = Global_TestFrameworkGlobals & {
-- 	expect: typeof(__unhandledIdentifier__ --[[ ROBLOX TODO: Unhandled node for type: TSQualifiedName ]] --[[ JestGlobals.expect ]]),
-- }
type JestGlobals = {
	expect: any,
	expectExtended: any,
	jestSnapshot: {
		toMatchSnapshot: (...any) -> any,
		toThrowErrorMatchingSnapshot: (...any) -> any,
	},
}
-- ROBLOX deviation END
type JestGlobalsWithJest = JestGlobals & {
	-- ROBLOX deviation START: use Jest type
	-- jest: typeof(__unhandledIdentifier__ --[[ ROBLOX TODO: Unhandled node for type: TSQualifiedName ]] --[[ JestGlobals.jest ]]),
	jest: Jest,
	-- ROBLOX deviation END
}
-- ROBLOX deviation START: skipped
-- type HasteMapOptions = {
-- 	console: Console?,
-- 	maxWorkers: number,
-- 	resetCache: boolean,
-- 	watch: boolean?,
-- 	watchman: boolean,
-- }
-- ROBLOX deviation END
-- ROBLOX deviation START: define as Object for now
-- type InternalModuleOptions = Required<CallerTransformOptions> & { isInternalModule: boolean }
type Object = LuauPolyfill.Object
type InternalModuleOptions = Object
-- ROBLOX deviation END
-- ROBLOX deviation START: skipped
-- local defaultTransformOptions: InternalModuleOptions = {
-- 	isInternalModule = false,
-- 	supportsDynamicImport = esmIsAvailable,
-- 	supportsExportNamespaceFrom = false,
-- 	supportsStaticESM = false,
-- 	supportsTopLevelAwait = false,
-- }
-- ROBLOX deviation END

-- ROBLOX deviation START: custom type implementation
-- type InitialModule = Omit<Module, "require" | "parent" | "paths">
type Module = {
	exports: any,
	filename: ModuleScript,
	id: ModuleScript,
	loaded: boolean,
}
type InitialModule = Omit<Module, "require" | "parent" | "paths">
-- ROBLOX deviation END
-- ROBLOX deviation START: using ModuleScript instead of string
-- type ModuleRegistry = Map<string, InitialModule | Module>
type ModuleRegistry = Map<ModuleScript, InitialModule | Module>
-- ROBLOX deviation END
-- ROBLOX deviation START: skipped
-- -- These are modules that we know
-- -- * are safe to require from the outside (not stateful, not prone to errors passing in instances from different realms), and
-- -- * take sufficiently long to require to warrant an optimization.
-- -- When required from the outside, they use the worker's require cache and are thus
-- -- only loaded once per worker, not once per test file.
-- -- Use /benchmarks/test-file-overhead to measure the impact.
-- -- Note that this only applies when they are required in an internal context;
-- -- users who require one of these modules in their tests will still get the module from inside the VM.
-- -- Prefer listing a module here only if it is impractical to use the jest-resolve-outside-vm-option where it is required,
-- -- e.g. because there are many require sites spread across the dependency graph.
-- local INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES = Set.new({ "chalk" })
-- local JEST_RESOLVE_OUTSIDE_VM_OPTION = Symbol:for_("jest-resolve-outside-vm-option")
-- type ResolveOptions =
-- 	typeof((
-- 		(
-- 			{} :: any
-- 		) :: Parameters<typeof(__unhandledIdentifier__ --[[ ROBLOX TODO: Unhandled node for type: TSQualifiedName ]] --[[ require.resolve ]])>
-- 	)[1]) --[[ ROBLOX CHECK: Resulting type may differ ]] --[[ Upstream: Parameters<typeof require.resolve>[1] ]]
-- 	& { JEST_RESOLVE_OUTSIDE_VM_OPTION: (true)? }
-- local testTimeoutSymbol = Symbol:for_("TEST_TIMEOUT_SYMBOL")
-- local retryTimesSymbol = Symbol:for_("RETRY_TIMES")
-- local NODE_MODULES = tostring(path.sep) .. "node_modules" .. tostring(path.sep)
-- local function getModuleNameMapper(config: Config_ProjectConfig)
-- 	if
-- 		Boolean.toJSBoolean((function()
-- 			local ref = Array.isArray(config.moduleNameMapper)
-- 			return if Boolean.toJSBoolean(ref) then config.moduleNameMapper.length else ref
-- 		end)())
-- 	then
-- 		return Array.map(config.moduleNameMapper, function(ref0)
-- 			local regex, moduleName = table.unpack(ref0, 1, 2)
-- 			return { moduleName = moduleName, regex = RegExp.new(regex) }
-- 		end) --[[ ROBLOX CHECK: check if 'config.moduleNameMapper' is an Array ]]
-- 	end
-- 	return nil
-- end
-- local unmockRegExpCache = WeakMap.new()
-- local EVAL_RESULT_VARIABLE = "Object.<anonymous>"
-- type RunScriptEvalResult = { EVAL_RESULT_VARIABLE: ModuleWrapper }
-- local runtimeSupportsVmModules = typeof(SyntheticModule) == "function"
-- local supportsTopLevelAwait = if Boolean.toJSBoolean(runtimeSupportsVmModules)
-- 	then (function()
-- 		do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 			local ok, result, hasReturned = xpcall(function()
-- 				-- eslint-disable-next-line no-new
-- 				SourceTextModule.new("await Promise.resolve()")
-- 				return true, true
-- 			end, function()
-- 				return false, true
-- 			end)
-- 			if hasReturned then
-- 				return result
-- 			end
-- 		end
-- 	end)()
-- 	else runtimeSupportsVmModules
-- local supportsNodeColonModulePrefixInRequire = (function()
-- 	do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 		local ok, result, hasReturned = xpcall(function()
-- 			require_("node:fs")
-- 			return true, true
-- 		end, function()
-- 			return false, true
-- 		end)
-- 		if hasReturned then
-- 			return result
-- 		end
-- 	end
-- end)()
-- local supportsNodeColonModulePrefixInImport = (function()
-- 	local stdout = execa:sync(
-- 		"node",
-- 		{ "--eval", 'import("node:fs").then(() => console.log(true), () => console.log(false));' },
-- 		{ reject = false }
-- 	).stdout
-- 	return stdout == "true"
-- end)()
-- ROBLOX deviation END
export type Runtime = { -- unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it
	-- ROBLOX deviation START: skipped
	-- unstable_shouldLoadAsEsm: (self: Runtime, path: Config_Path) -> boolean,
	-- unstable_importModule: (self: Runtime, from: Config_Path, moduleName: string?) -> Promise<void>,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	requireModule: <T>(
		self: Runtime,
		from: ModuleScript,
		moduleName: ModuleScript?,
		options: InternalModuleOptions?,
		isRequireActual_: boolean?,
		-- ROBLOX NOTE: additional param to not require return from test files
		noModuleReturnRequired: boolean?
	) -> T,
	requireInternalModule: <T>(self: Runtime, from: ModuleScript, to: ModuleScript?) -> T,
	requireActual: <T>(self: Runtime, from: ModuleScript, moduleName: ModuleScript) -> T,
	requireMock: <T>(self: Runtime, from: ModuleScript, moduleName: ModuleScript) -> T,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: modified signature, use ModuleScript instead of string
	requireModuleOrMock: <T>(self: Runtime, moduleName: ModuleScript) -> T,
	-- ROBLOX deviation END
	isolateModules: (self: Runtime, fn: () -> ()) -> (),
	resetModules: (self: Runtime) -> (),
	-- ROBLOX deviation START: skipped
	-- collectV8Coverage: (self: Runtime) -> Promise<void>,
	-- stopCollectingV8Coverage: (self: Runtime) -> Promise<void>,
	-- getAllCoverageInfoCopy: (
	-- 	self: Runtime
	-- ) -> typeof((({} :: any) :: typeof((({} :: any) :: JestEnvironment).global)).__coverage__),
	-- getAllV8CoverageInfoCopy: (self: Runtime) -> V8CoverageResult,
	-- getSourceMaps: (self: Runtime) -> SourceMapRegistry,
	-- ROBLOX deviation END
	setMock: (
		self: Runtime,
		-- ROBLOX deviation START: using ModuleScript instead of string
		from: ModuleScript,
		moduleName: ModuleScript,
		-- ROBLOX deviation END
		mockFactory: () -> unknown,
		options: { virtual: boolean? }?
	) -> (),
	restoreAllMocks: (self: Runtime) -> (),
	resetAllMocks: (self: Runtime) -> (),
	clearAllMocks: (self: Runtime) -> (),
	teardown: (self: Runtime) -> (),
	setGlobalsForRuntime: (self: Runtime, globals: JestGlobals) -> (),
}
type Runtime_private = { --
	-- *** PUBLIC ***
	--
	-- ROBLOX deviation START: skipped
	-- unstable_shouldLoadAsEsm: (self: Runtime_private, path: Config_Path) -> boolean,
	-- unstable_importModule: (self: Runtime_private, from: Config_Path, moduleName: string?) -> Promise<void>,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	requireModule: <T>(
		self: Runtime_private,
		from: ModuleScript,
		moduleName: ModuleScript?,
		options: InternalModuleOptions?,
		isRequireActual_: boolean?,

		-- ROBLOX NOTE: additional param to not require return from test files
		noModuleReturnRequired: boolean?
	) -> T,
	requireInternalModule: <T>(self: Runtime_private, from: ModuleScript, to: ModuleScript?) -> T,
	requireActual: <T>(self: Runtime_private, from: ModuleScript, moduleName: ModuleScript) -> T,
	requireMock: <T>(self: Runtime_private, from: ModuleScript, moduleName: ModuleScript) -> T,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: modified signature, use ModuleScript instead of string
	requireModuleOrMock: <T>(self: Runtime_private, moduleName: ModuleScript) -> T,
	-- ROBLOX deviation END
	isolateModules: (self: Runtime_private, fn: () -> ()) -> (),
	resetModules: (self: Runtime_private) -> (),
	-- ROBLOX deviation START: skipped
	-- collectV8Coverage: (self: Runtime_private) -> Promise<void>,
	-- stopCollectingV8Coverage: (self: Runtime_private) -> Promise<void>,
	-- getAllCoverageInfoCopy: (
	-- 	self: Runtime_private
	-- ) -> typeof((({} :: any) :: typeof((({} :: any) :: JestEnvironment).global)).__coverage__),
	-- getAllV8CoverageInfoCopy: (self: Runtime_private) -> V8CoverageResult,
	-- getSourceMaps: (self: Runtime_private) -> SourceMapRegistry,
	-- ROBLOX deviation END
	setMock: (
		self: Runtime_private,
		-- ROBLOX deviation START: using ModuleScript instead of string
		from: ModuleScript,
		moduleName: ModuleScript,
		-- ROBLOX deviation END
		mockFactory: () -> unknown,
		options: { virtual: boolean? }?
	) -> (),
	restoreAllMocks: (self: Runtime_private) -> (),
	resetAllMocks: (self: Runtime_private) -> (),
	clearAllMocks: (self: Runtime_private) -> (),
	teardown: (self: Runtime_private) -> (),
	setGlobalsForRuntime: (self: Runtime_private, globals: JestGlobals) -> (),
	--
	-- *** PRIVATE ***
	--
	-- ROBLOX deviation START: skipped
	-- _cacheFS: Map<string, string>,
	_config: Config_ProjectConfig,
	-- _coverageOptions: ShouldInstrumentOptions,
	-- _currentlyExecutingModulePath: string,
	-- ROBLOX deviation END
	--[[
		ROBLOX deviation START: There's no actual Jest Environment so we are just
		mocking some values in here for now.
	]]
	-- _environment: JestEnvironment,
	_environment: {
		fakeTimersModern: FakeTimers,
	},
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	-- _explicitShouldMock: Map<string, boolean>,
	-- _explicitShouldMockModule: Map<string, boolean>,
	_explicitShouldMock: Map<ModuleScript, boolean>,
	_explicitShouldMockModule: Map<ModuleScript, boolean>,
	-- ROBLOX deviation END
	-- ROBLOX deviation: no Legacy/Modern timers
	-- _fakeTimersImplementation: LegacyFakeTimers<unknown> | ModernFakeTimers | nil, --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
	_fakeTimersImplementation: FakeTimers,
	-- ROBLOX deviation END
	_internalModuleRegistry: ModuleRegistry,
	-- ROBLOX deviation START: skipped
	-- _isCurrentlyExecutingManualMock: string | nil, --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
	-- _mainModule: Module | nil, --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	-- _mockFactories: Map<string, () -> unknown>,
	_mockFactories: Map<ModuleScript, () -> unknown>,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- _mockMetaDataCache: Map<string, MockFunctionMetadata<unknown, Array<unknown>>>,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	-- _mockRegistry: Map<string, any>,
	-- _isolatedMockRegistry: Map<string, any> | nil,
	_mockRegistry: Map<ModuleScript, any>,
	-- ROBLOX deviation START: add cache of loaded module functions to a test runner
	_loadedModuleFns: Map<ModuleScript, { any }> | nil,
	-- ROBLOX deviation END
	_isolatedMockRegistry: Map<ModuleScript, any> | nil,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- _moduleMockRegistry: Map<string, VMModule>,
	-- _moduleMockFactories: Map<string, () -> unknown>,
	-- ROBLOX deviation END
	_moduleMocker: ModuleMocker,
	-- ROBLOX deviation: mocking globals
	_globalMocker: GlobalMocker,
	_isolatedModuleRegistry: ModuleRegistry | nil,
	_moduleRegistry: ModuleRegistry,
	-- ROBLOX deviation START: skipped
	-- _esmoduleRegistry: Map<Config_Path, VMModule>,
	-- _cjsNamedExports: Map<Config_Path, Set<string>>,
	-- _esmModuleLinkingMap: WeakMap<VMModule, Promise<unknown>>,
	-- _testPath: Config_Path,
	-- _resolver: Resolver,
	-- ROBLOX deviation END
	_shouldAutoMock: boolean,
	-- ROBLOX deviation START: using ModuleScript instead of string
	-- _shouldMockModuleCache: Map<string, boolean>,
	_shouldMockModuleCache: Map<ModuleScript, boolean>,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- _shouldUnmockTransitiveDependenciesCache: Map<string, boolean>,
	-- _sourceMapRegistry: SourceMapRegistry,
	-- _scriptTransformer: ScriptTransformer,
	-- _fileTransforms: Map<string, RuntimeTransformResult>,
	-- _fileTransformsMutex: Map<string, Promise<void>>,
	-- _v8CoverageInstrumenter: CoverageInstrumenter | nil,
	-- _v8CoverageResult: V8Coverage | nil,
	-- _transitiveShouldMock: Map<string, boolean>,
	-- _unmockList: RegExp | nil,
	-- _virtualMocks: Map<string, boolean>,
	-- _virtualModuleMocks: Map<string, boolean>,
	-- _moduleImplementation: typeof(__unhandledIdentifier__ --[[ ROBLOX TODO: Unhandled node for type: TSQualifiedName ]] --[[ nativeModule.Module ]]),
	-- jestObjectCaches: Map<string, Jest>,
	-- ROBLOX deviation END
	jestGlobals: JestGlobals,
	-- ROBLOX deviation START: skipped
	-- esmConditions: Array<string>,
	-- cjsConditions: Array<string>,
	-- ROBLOX deviation END
	isTornDown: boolean,
	-- ROBLOX deviation START: additional properties
	_jestObject: Jest,
	_cleanupFns: Array<(...any) -> ...any>,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- loadEsmModule: (self: Runtime_private, modulePath: Config_Path, query_: string?) -> Promise<VMModule>,
	-- resolveModule: (
	-- 	self: Runtime_private,
	-- 	specifier: string,
	-- 	referencingIdentifier: string,
	-- 	context: VMContext
	-- ) -> Promise<T> | T | void,
	-- linkAndEvaluateModule: (self: Runtime_private, module: VMModule) -> Promise<VMModule | void>,
	-- loadCjsAsEsm: (
	-- 	self: Runtime_private,
	-- 	from: Config_Path,
	-- 	modulePath: Config_Path,
	-- 	context: VMContext
	-- ) -> any,
	-- importMock: (
	-- 	self: Runtime_private,
	-- 	from: Config_Path,
	-- 	moduleName: ModuleScript,
	-- 	context: VMContext
	-- ) -> Promise<T>,
	-- getExportsOfCjs: (self: Runtime_private, modulePath: Config_Path) -> any,
	-- ROBLOX deviation END
	_loadModule: (
		self: Runtime_private,
		localModule: InitialModule,
		-- ROBLOX deviation START: using ModuleScript instead of string
		from: ModuleScript,
		moduleName: ModuleScript | nil,
		modulePath: ModuleScript,
		-- ROBLOX deviation END
		options: InternalModuleOptions | nil,
		moduleRegistry: ModuleRegistry,
		-- ROBLOX deviation START: additional param to not require return from test files
		noModuleReturnRequired: boolean?
		-- ROBLOX deviation END
	) -> (),
	-- ROBLOX deviation START: skipped
	-- _getFullTransformationOptions: (
	-- 	self: Runtime_private,
	-- 	options_: InternalModuleOptions?
	-- ) -> TransformationOptions,
	-- ROBLOX deviation END
	setModuleMock: (
		self: Runtime_private,
		-- ROBLOX deviation START: using ModuleScript instead of string
		from: ModuleScript,
		moduleName: ModuleScript,
		-- ROBLOX deviation END
		mockFactory: () -> Promise<unknown> | unknown,
		options: { virtual: boolean? }?
	) -> (),
	-- ROBLOX deviation START: skipped
	-- _resolveModule: (
	-- 	self: Runtime_private,
	-- 	from: Config_Path,
	-- 	to: string | nil,
	-- 	options: ResolveModuleConfig?
	-- ) -> any,
	-- _requireResolve: (
	-- 	self: Runtime_private,
	-- 	from: Config_Path,
	-- 	moduleName: ModuleScript?,
	-- 	options_: ResolveOptions?
	-- ) -> any,
	-- _requireResolvePaths: (self: Runtime_private, from: Config_Path, moduleName: ModuleScript?) -> any,
	-- ROBLOX deviation END
	_execModule: (
		self: Runtime_private,
		localModule: InitialModule,
		options: InternalModuleOptions | nil,
		moduleRegistry: ModuleRegistry,
		-- ROBLOX deviation START: using ModuleScript instead of string
		-- from: Config_Path | nil --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
		from: ModuleScript | nil,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: additional param to not require return from test files
		noModuleReturnRequired: boolean?
		-- ROBLOX deviation END
	) -> any,
	-- ROBLOX deviation START: skipped
	-- transformFile: (self: Runtime_private, filename: string, options: InternalModuleOptions?) -> string,
	-- transformFileAsync: (
	-- 	self: Runtime_private,
	-- 	filename: string,
	-- 	options: InternalModuleOptions?
	-- ) -> Promise<string>,
	-- createScriptFromCode: (self: Runtime_private, scriptSource: string, filename: string) -> any,
	-- _requireCoreModule: (self: Runtime_private, moduleName: ModuleScript, supportPrefix: boolean) -> any,
	-- _importCoreModule: (self: Runtime_private, moduleName: ModuleScript, context: VMContext) -> any,
	-- _getMockedNativeModule: (
	-- 	self: Runtime_private
	-- ) -> typeof(__unhandledIdentifier__ --[[ ROBLOX TODO: Unhandled node for type: TSQualifiedName ]] --[[ nativeModule.Module ]]),
	-- _generateMock: (self: Runtime_private, from: Config_Path, moduleName: ModuleScript) -> any,
	-- ROBLOX deviation END
	_shouldMock: (
		self: Runtime_private,
		-- ROBLOX deviation: accept ModuleScript instead of string
		from: ModuleScript,
		moduleName: ModuleScript,
		explicitShouldMock: Map<ModuleScript, boolean>,
		-- ROBLOX deviation END
		options: ResolveModuleConfig
	) -> boolean,
	-- ROBLOX deviation START: skipped
	-- _createRequireImplementation: (
	-- 	self: Runtime_private,
	-- 	from: InitialModule,
	-- 	options: InternalModuleOptions?
	-- ) -> NodeRequire,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of Config_Path
	-- _createJestObjectFor: (self: Runtime_private, from: Config_Path) -> Jest,
	_createJestObjectFor: (self: Runtime_private, from: ModuleScript) -> Jest,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- _logFormattedReferenceError: (self: Runtime_private, errorMessage: string) -> any,
	-- wrapCodeInModuleWrapper: (self: Runtime_private, content: string) -> any,
	-- constructModuleWrapperStart: (self: Runtime_private) -> any,
	-- constructInjectedModuleParameters: (self: Runtime_private) -> Array<string>,
	-- handleExecutionError: (self: Runtime_private, e: Error, module: Module) -> never,
	-- getGlobalsForCjs: (self: Runtime_private, from: Config_Path) -> JestGlobalsWithJest,
	-- getGlobalsForEsm: (self: Runtime_private, from: Config_Path, context: VMContext) -> Promise<VMModule>,
	-- ROBLOX deviation END
	getGlobalsFromEnvironment: (self: Runtime_private) -> JestGlobals,
	-- ROBLOX deviation START: skipped
	-- readFile: (self: Runtime_private, filename: Config_Path) -> string,
	-- ROBLOX deviation END
}
type Runtime_statics = {
	-- ROBLOX deviation: no arguments for constructor
	-- new: (
	-- 	config: Config_ProjectConfig,
	-- 	environment: JestEnvironment,
	-- 	resolver: Resolver,
	-- 	transformer: ScriptTransformer,
	-- 	cacheFS: Map<string, string>,
	-- 	coverageOptions: ShouldInstrumentOptions,
	-- 	testPath: Config_Path
	-- ) -> Runtime,
	new: (loadedModuleFns: Map<ModuleScript, any>?) -> Runtime,
	-- ROBLOX deviation END
}

local Runtime = {} :: Runtime & Runtime_statics
local Runtime_private = Runtime :: Runtime_private & Runtime_statics;
(Runtime :: any).__index = Runtime
-- ROBLOX deviation START: skipped
-- Runtime.shouldInstrument = shouldInstrument
-- ROBLOX deviation END
-- ROBLOX deviation: no arguments for constructor
-- function Runtime_private.new(
-- 	config: Config_ProjectConfig,
-- 	environment: JestEnvironment,
-- 	resolver: Resolver,
-- 	transformer: ScriptTransformer,
-- 	cacheFS: Map<string, string>,
-- 	coverageOptions: ShouldInstrumentOptions,
-- 	testPath: Config_Path
-- ): Runtime
function Runtime.new(config: Config_ProjectConfig, loadedModuleFns: Map<ModuleScript, { any }>?): Runtime
	-- ROBLOX deviation START: cast to private type to access methods properly
	-- local self = setmetatable({}, Runtime)
	local self = (setmetatable({}, Runtime) :: any) :: Runtime_private
	-- ROBLOX deviation END
	self.isTornDown = false
	-- ROBLOX deviation START: skipped
	-- self._cacheFS = cacheFS
	self._config = config
	-- self._coverageOptions = coverageOptions
	-- self._currentlyExecutingModulePath = ""
	-- ROBLOX deviation END
	--[[
		ROBLOX deviation START: There's no actual Jest Environment so we are just
		mocking some values in here for now.
	]]
	-- self._environment = environment
	self._environment = {
		fakeTimersModern = JestFakeTimers.new(),
	}
	-- ROBLOX deviation END
	self._explicitShouldMock = Map.new()
	self._explicitShouldMockModule = Map.new()
	self._internalModuleRegistry = Map.new()
	-- ROBLOX deviation START: skipped
	-- self._isCurrentlyExecutingManualMock = nil
	-- self._mainModule = nil
	-- ROBLOX deviation END
	self._mockFactories = Map.new()
	self._mockRegistry = Map.new()
	-- ROBLOX deviation START: add cache of loaded module functions to a test runner
	self._loadedModuleFns = loadedModuleFns
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- self._moduleMockRegistry = Map.new()
	-- self._moduleMockFactories = Map.new()
	-- invariant(self._environment.moduleMocker, "`moduleMocker` must be set on an environment when created")
	-- ROBLOX deviation END
	-- ROBLOX deviation START: instantiate the module mocker here instead of being passed in as an arg from runTest
	-- self._moduleMocker = self._environment.moduleMocker
	self._moduleMocker = ModuleMocker.new(config)
	-- ROBLOX deviation END
	-- ROBLOX deviation START: mock data model
	self._moduleMocker:protectDataModel(function(instance, method)
		if instance:IsA("DataModel") then
			if method == "GetService" then
				return true
			end
		end
		return false
	end)
	-- ROBLOX deviation END
	-- ROBLOX deviation START: mocking globals
	self._globalMocker = GlobalMocker.new(jestMockGenvModule.MOCKABLE_GLOBALS)
	-- TODO: if we want to mock more specific function environment members then
	-- this will have to be rethought, but for what's being mocked now, it's
	-- fine to draw from the global function environment.
	self._moduleMocker:mockGlobals(self._globalMocker, getfenv(0))
	-- ROBLOX deviation END
	self._isolatedModuleRegistry = nil
	self._isolatedMockRegistry = nil
	self._moduleRegistry = Map.new()
	-- ROBLOX deviation START: skipped
	-- self._esmoduleRegistry = Map.new()
	-- self._cjsNamedExports = Map.new()
	-- self._esmModuleLinkingMap = WeakMap.new()
	-- self._testPath = testPath
	-- self._resolver = resolver
	-- self._scriptTransformer = transformer
	-- ROBLOX deviation END
	-- ROBLOX deviation START: automocking not supported
	-- self._shouldAutoMock = config.automock
	self._shouldAutoMock = false
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- self._sourceMapRegistry = Map.new()
	-- self._fileTransforms = Map.new()
	-- self._fileTransformsMutex = Map.new()
	-- self._virtualMocks = Map.new()
	-- self._virtualModuleMocks = Map.new()
	-- self.jestObjectCaches = Map.new()
	-- self._mockMetaDataCache = Map.new()
	-- ROBLOX deviation END
	self._shouldMockModuleCache = Map.new()
	-- ROBLOX deviation START: skipped
	-- self._shouldUnmockTransitiveDependenciesCache = Map.new()
	-- self._transitiveShouldMock = Map.new()
	-- ROBLOX deviation END
	-- ROBLOX deviation: no Legacy/Modern timers
	-- self._fakeTimersImplementation = if config.timers == "legacy"
	-- 	then self._environment.fakeTimers
	-- 	else self._environment.fakeTimersModern
	self._fakeTimersImplementation = self._environment.fakeTimersModern
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- self._unmockList = unmockRegExpCache:get(config)
	-- if Boolean.toJSBoolean(not Boolean.toJSBoolean(self._unmockList) and config.unmockedModulePathPatterns) then
	-- 	self._unmockList = RegExp.new(
	-- 		Array.join(config.unmockedModulePathPatterns, "|") --[[ ROBLOX CHECK: check if 'config.unmockedModulePathPatterns' is an Array ]]
	-- 	)
	-- 	unmockRegExpCache:set(config, self._unmockList)
	-- end
	-- local ref = if self._environment.exportConditions ~= nil then self._environment.exportConditions() else nil
	-- local envExportConditions = if ref ~= nil then ref else {}
	-- self.esmConditions =
	-- 	Array.from(Set.new(Array.concat({}, { "import", "default" }, Array.spread(envExportConditions))))
	-- self.cjsConditions =
	-- 	Array.from(Set.new(Array.concat({}, { "require", "default" }, Array.spread(envExportConditions))))
	-- if Boolean.toJSBoolean(config.automock) then
	-- 	Array.forEach(config.setupFiles, function(filePath)
	-- 		if
	-- 			Boolean.toJSBoolean(
	-- 				Array.includes(filePath, NODE_MODULES) --[[ ROBLOX CHECK: check if 'filePath' is an Array ]]
	-- 			)
	-- 		then
	-- 			local moduleID = self._resolver:getModuleID(
	-- 				self._virtualMocks,
	-- 				filePath,
	-- 				nil, -- shouldn't really matter, but in theory this will make sure the caching is correct
	-- 				{
	-- 					conditions = if Boolean.toJSBoolean(self:unstable_shouldLoadAsEsm(filePath))
	-- 						then self.esmConditions
	-- 						else self.cjsConditions,
	-- 				}
	-- 			)
	-- 			self._transitiveShouldMock:set(moduleID, false)
	-- 		end
	-- 	end) --[[ ROBLOX CHECK: check if 'config.setupFiles' is an Array ]]
	-- end
	-- self:resetModules()
	-- ROBLOX deviation END
	--[[
		ROBLOX deviation START: normally a jest object gets created for each
		test file and inserted into a cache, an instance gets injected into each
		test module. Currently this implementation is global across all tests.
	]]
	local filename = script
	self._jestObject = self:_createJestObjectFor(filename)
	-- ROBLOX deviation END

	--[[
		ROBLOX deviation START: added to hold references to all the clean up
		functions from loaded modules. Is used in Runtime.teardown
	]]
	self._cleanupFns = {}
	-- ROBLOX deviation END

	return (self :: any) :: Runtime
end
-- ROBLOX deviation START: skipped
-- function Runtime_private.createContext(
-- 	config: Config_ProjectConfig,
-- 	options: {
-- 		console: Console?,
-- 		maxWorkers: number,
-- 		watch: boolean?,
-- 		watchman: boolean,
-- 	}
-- ): Promise<Context>
-- 	return Promise.resolve():andThen(function()
-- 		createDirectory(config.cacheDirectory)
-- 		local instance = Runtime:createHasteMap(config, {
-- 			console = options.console,
-- 			maxWorkers = options.maxWorkers,
-- 			resetCache = not Boolean.toJSBoolean(config.cache),
-- 			watch = options.watch,
-- 			watchman = options.watchman,
-- 		})
-- 		local hasteMap = instance:build():expect()
-- 		return {
-- 			config = config,
-- 			hasteFS = hasteMap.hasteFS,
-- 			moduleMap = hasteMap.moduleMap,
-- 			resolver = Runtime:createResolver(config, hasteMap.moduleMap),
-- 		}
-- 	end)
-- end
-- function Runtime_private.createHasteMap(config: Config_ProjectConfig, options: HasteMapOptions?): HasteMap
-- 	local ignorePatternParts = Array.filter(
-- 		Array.concat(
-- 			{},
-- 			Array.spread(config.modulePathIgnorePatterns),
-- 			Array.spread(
-- 				if Boolean.toJSBoolean(if Boolean.toJSBoolean(options) then options.watch else options)
-- 					then config.watchPathIgnorePatterns
-- 					else {}
-- 			),
-- 			{
-- 				(function()
-- 					local ref = config.cacheDirectory:startsWith(config.rootDir + path.sep)
-- 					return if Boolean.toJSBoolean(ref) then config.cacheDirectory else ref
-- 				end)(),
-- 			}
-- 		),
-- 		Boolean
-- 	)
-- 	local ignorePattern = if ignorePatternParts.length
-- 			> 0 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
-- 		then RegExp.new(
-- 			Array.join(ignorePatternParts, "|") --[[ ROBLOX CHECK: check if 'ignorePatternParts' is an Array ]]
-- 		)
-- 		else nil
-- 	local refProp0 = config.cacheDirectory
-- 	local refProp1 = config.haste.computeSha1
-- 	local refProp2 = if typeof(options) == "table" then options.console else nil
-- 	local refProp3 = config.dependencyExtractor
-- 	local refProp4 = config.haste.enableSymlinks
-- 	local refProp5 = Array.concat({ Snapshot.EXTENSION }, config.moduleFileExtensions)
-- 	local refProp6 = config.haste.forceNodeFilesystemAPI
-- 	local refProp7 = config.haste.hasteImplModulePath
-- 	local refProp8 = config.haste.hasteMapModulePath
-- 	local refProp9 = ignorePattern
-- 	local ref = if typeof(options) == "table" then options.maxWorkers else nil
-- 	local refProp10 = Boolean.toJSBoolean(ref) and ref or 1
-- 	return HasteMap:create({
-- 		cacheDirectory = refProp0,
-- 		computeSha1 = refProp1,
-- 		console = refProp2,
-- 		dependencyExtractor = refProp3,
-- 		enableSymlinks = refProp4,
-- 		extensions = refProp5,
-- 		forceNodeFilesystemAPI = refProp6,
-- 		hasteImplModulePath = refProp7,
-- 		hasteMapModulePath = refProp8,
-- 		ignorePattern = refProp9,
-- 		maxWorkers = refProp10,
-- 		mocksPattern = escapePathForRegex(tostring(path.sep) .. "__mocks__" .. tostring(path.sep)),
-- 		name = config.name,
-- 		platforms = Boolean.toJSBoolean(config.haste.platforms) and config.haste.platforms or {
-- 			"ios",
-- 			"android",
-- 		},
-- 		resetCache = if typeof(options) == "table" then options.resetCache else nil,
-- 		retainAllFiles = false,
-- 		rootDir = config.rootDir,
-- 		roots = config.roots,
-- 		throwOnModuleCollision = config.haste.throwOnModuleCollision,
-- 		useWatchman = if typeof(options) == "table" then options.watchman else nil,
-- 		watch = if typeof(options) == "table" then options.watch else nil,
-- 	})
-- end
-- function Runtime_private.createResolver(config: Config_ProjectConfig, moduleMap: IModuleMap): Resolver
-- 	return Resolver.new(moduleMap, {
-- 		defaultPlatform = config.haste.defaultPlatform,
-- 		extensions = Array.map(config.moduleFileExtensions, function(extension)
-- 			return "." .. tostring(extension)
-- 		end), --[[ ROBLOX CHECK: check if 'config.moduleFileExtensions' is an Array ]]
-- 		hasCoreModules = true,
-- 		moduleDirectories = config.moduleDirectories,
-- 		moduleNameMapper = getModuleNameMapper(config),
-- 		modulePaths = config.modulePaths,
-- 		platforms = config.haste.platforms,
-- 		resolver = config.resolver,
-- 		rootDir = config.rootDir,
-- 	})
-- end
-- function Runtime_private.runCLI(): Promise<never>
-- 	return Promise.resolve():andThen(function()
-- 		error(Error.new("The jest-runtime CLI has been moved into jest-repl"))
-- 	end)
-- end
-- function Runtime_private.getCLIOptions(): never
-- 	error(Error.new("The jest-runtime CLI has been moved into jest-repl"))
-- end
-- function Runtime_private:unstable_shouldLoadAsEsm(path: Config_Path): boolean
-- 	return Resolver:unstable_shouldLoadAsEsm(path, self._config.extensionsToTreatAsEsm)
-- end
-- function Runtime_private:loadEsmModule(modulePath: Config_Path, query_: string?): Promise<VMModule>
-- 	local query: string = if query_ ~= nil then query_ else ""
-- 	return Promise.resolve():andThen(function()
-- 		local cacheKey = modulePath + query
-- 		if Boolean.toJSBoolean(self._fileTransformsMutex:has(cacheKey)) then
-- 			self._fileTransformsMutex:get(cacheKey):expect()
-- 		end
-- 		if not Boolean.toJSBoolean(self._esmoduleRegistry:has(cacheKey)) then
-- 			invariant(
-- 				typeof(self._environment.getVmContext) == "function",
-- 				"ES Modules are only supported if your test environment has the `getVmContext` function"
-- 			)
-- 			local context = self._environment:getVmContext()
-- 			invariant(context, "Test environment has been torn down")
-- 			local transformResolve: () -> ()
-- 			local transformReject: (error_: any) -> ()
-- 			self._fileTransformsMutex:set(
-- 				cacheKey,
-- 				Promise.new(function(resolve, reject)
-- 					transformResolve = resolve
-- 					transformReject = reject
-- 				end)
-- 			)
-- 			local ref = transformResolve :: any
-- 			invariant(
-- 				if Boolean.toJSBoolean(ref) then transformReject :: any else ref,
-- 				"Promise initialization should be sync - please report this bug to Jest!"
-- 			)
-- 			if Boolean.toJSBoolean(self._resolver:isCoreModule(modulePath)) then
-- 				local core = self:_importCoreModule(modulePath, context)
-- 				self._esmoduleRegistry:set(cacheKey, core)
-- 				transformResolve()
-- 				return core
-- 			end
-- 			local transformedCode = self:transformFileAsync(modulePath, {
-- 				isInternalModule = false,
-- 				supportsDynamicImport = true,
-- 				supportsExportNamespaceFrom = true,
-- 				supportsStaticESM = true,
-- 				supportsTopLevelAwait = supportsTopLevelAwait,
-- 			}):expect()
-- 			do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 				local ok, result, hasReturned = xpcall(function()
-- 					local module = SourceTextModule.new(transformedCode, {
-- 						context = context,
-- 						identifier = modulePath,
-- 						importModuleDynamically = function(specifier: string, referencingModule: VMModule)
-- 							return Promise.resolve():andThen(function()
-- 								invariant(
-- 									runtimeSupportsVmModules,
-- 									"You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules"
-- 								)
-- 								local module = self:resolveModule(
-- 									specifier,
-- 									referencingModule.identifier,
-- 									referencingModule.context
-- 								):expect()
-- 								return self:linkAndEvaluateModule(module)
-- 							end)
-- 						end,
-- 						initializeImportMeta = function(self, meta: ImportMeta)
-- 							meta.url = pathToFileURL(modulePath).href
-- 						end,
-- 					})
-- 					invariant(
-- 						not Boolean.toJSBoolean(self._esmoduleRegistry:has(cacheKey)),
-- 						("Module cache already has entry %s. This is a bug in Jest, please report it!"):format(
-- 							tostring(cacheKey)
-- 						)
-- 					)
-- 					self._esmoduleRegistry:set(cacheKey, module)
-- 					transformResolve()
-- 				end, function(error_)
-- 					transformReject(error_)
-- 					error(error_)
-- 				end)
-- 				if hasReturned then
-- 					return result
-- 				end
-- 			end
-- 		end
-- 		local module = self._esmoduleRegistry:get(cacheKey)
-- 		invariant(module, "Module cache does not contain module. This is a bug in Jest, please open up an issue")
-- 		return module
-- 	end)
-- end
-- function Runtime_private:resolveModule(
-- 	specifier: string,
-- 	referencingIdentifier: string,
-- 	context: VMContext
-- ): Promise<T> | T | void
-- 	if Boolean.toJSBoolean(self.isTornDown) then
-- 		self:_logFormattedReferenceError(
-- 			"You are trying to `import` a file after the Jest environment has been torn down."
-- 		)
-- 		process.exitCode = 1
-- 		return
-- 	end
-- 	if specifier == "@jest/globals" then
-- 		local fromCache = self._esmoduleRegistry:get("@jest/globals")
-- 		if Boolean.toJSBoolean(fromCache) then
-- 			return fromCache
-- 		end
-- 		local globals = self:getGlobalsForEsm(referencingIdentifier, context)
-- 		self._esmoduleRegistry:set("@jest/globals", globals)
-- 		return globals
-- 	end
-- 	if Boolean.toJSBoolean(specifier:startsWith("file://")) then
-- 		specifier = fileURLToPath(specifier)
-- 	end
-- 	local path, query = table.unpack(specifier:split("?"), 1, 2)
-- 	if
-- 		Boolean.toJSBoolean(
-- 			self:_shouldMock(
-- 				referencingIdentifier,
-- 				path,
-- 				self._explicitShouldMockModule,
-- 				{ conditions = self.esmConditions }
-- 			)
-- 		)
-- 	then
-- 		return self:importMock(referencingIdentifier, path, context)
-- 	end
-- 	local resolved = self:_resolveModule(referencingIdentifier, path, { conditions = self.esmConditions })
-- 	if
-- 		Boolean.toJSBoolean((function()
-- 			local ref = self._resolver:isCoreModule(resolved)
-- 			return Boolean.toJSBoolean(ref) and ref or self:unstable_shouldLoadAsEsm(resolved)
-- 		end)())
-- 	then
-- 		return self:loadEsmModule(resolved, query)
-- 	end
-- 	return self:loadCjsAsEsm(referencingIdentifier, resolved, context)
-- end
-- function Runtime_private:linkAndEvaluateModule(module: VMModule): Promise<VMModule | void>
-- 	return Promise.resolve():andThen(function()
-- 		if Boolean.toJSBoolean(self.isTornDown) then
-- 			self:_logFormattedReferenceError(
-- 				"You are trying to `import` a file after the Jest environment has been torn down."
-- 			)
-- 			process.exitCode = 1
-- 			return
-- 		end
-- 		if module.status == "unlinked" then
-- 			-- since we might attempt to link the same module in parallel, stick the promise in a weak map so every call to
-- 			-- this method can await it
-- 			self._esmModuleLinkingMap:set(
-- 				module,
-- 				module:link(function(specifier: string, referencingModule: VMModule)
-- 					return self:resolveModule(specifier, referencingModule.identifier, referencingModule.context)
-- 				end)
-- 			)
-- 		end
-- 		self._esmModuleLinkingMap:get(module):expect()
-- 		if module.status == "linked" then
-- 			module:evaluate():expect()
-- 		end
-- 		return module
-- 	end)
-- end
-- function Runtime_private:unstable_importModule(from: Config_Path, moduleName: ModuleScript?): Promise<void>
-- 	return Promise.resolve():andThen(function()
-- 		invariant(
-- 			runtimeSupportsVmModules,
-- 			"You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules"
-- 		)
-- 		local path, query = table.unpack((if moduleName ~= nil then moduleName else ""):split("?"), 1, 2)
-- 		local modulePath = self:_resolveModule(from, path, { conditions = self.esmConditions })
-- 		local module = self:loadEsmModule(modulePath, query):expect()
-- 		return self:linkAndEvaluateModule(module)
-- 	end)
-- end
-- function Runtime_private:loadCjsAsEsm(from: Config_Path, modulePath: Config_Path, context: VMContext)
-- 	-- CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503
-- 	local cjs = self:requireModuleOrMock(from, modulePath)
-- 	local parsedExports = self:getExportsOfCjs(modulePath)
-- 	local cjsExports = Array.filter(Array.concat({}, Array.spread(parsedExports)), function(exportName)
-- 		-- we don't wanna respect any exports _named_ default as a named export
-- 		if exportName == "default" then
-- 			return false
-- 		end
-- 		return Object.hasOwnProperty(cjs, exportName)
-- 	end)
-- 	local module = SyntheticModule.new(Array.concat({}, Array.spread(cjsExports), { "default" }), function()
-- 		Array.forEach(cjsExports, function(exportName)
-- 			-- @ts-expect-error
-- 			self:setExport(exportName, cjs[tostring(exportName)])
-- 		end) --[[ ROBLOX CHECK: check if 'cjsExports' is an Array ]] -- @ts-expect-error: TS doesn't know what `this` is
-- 		self:setExport("default", cjs)
-- 	end, { context = context, identifier = modulePath })
-- 	return evaluateSyntheticModule(module)
-- end
-- function Runtime_private:importMock(from: Config_Path, moduleName: ModuleScript, context: VMContext): Promise<T>
-- 	return Promise.resolve():andThen(function()
-- 		local moduleID =
-- 			self._resolver:getModuleID(self._virtualModuleMocks, from, moduleName, { conditions = self.esmConditions })
-- 		if Boolean.toJSBoolean(self._moduleMockRegistry:has(moduleID)) then
-- 			return self._moduleMockRegistry:get(moduleID)
-- 		end
-- 		if Boolean.toJSBoolean(self._moduleMockFactories:has(moduleID)) then
-- 			local invokedFactory: any = (self._moduleMockFactories:get(
-- 				moduleID -- has check above makes this ok
-- 			) :: any)():expect()
-- 			local module = SyntheticModule.new(Object.keys(invokedFactory), function()
-- 				Array.forEach(Object.entries(invokedFactory), function(ref0)
-- 					local key, value = table.unpack(ref0, 1, 2)
-- 					-- @ts-expect-error: TS doesn't know what `this` is
-- 					self:setExport(key, value)
-- 				end) --[[ ROBLOX CHECK: check if 'Object.entries(invokedFactory)' is an Array ]]
-- 			end, { context = context, identifier = moduleName })
-- 			self._moduleMockRegistry:set(moduleID, module)
-- 			return evaluateSyntheticModule(module)
-- 		end
-- 		error(Error.new("Attempting to import a mock without a factory"))
-- 	end)
-- end
-- function Runtime_private:getExportsOfCjs(modulePath: Config_Path)
-- 	local cachedNamedExports = self._cjsNamedExports:get(modulePath)
-- 	if Boolean.toJSBoolean(cachedNamedExports) then
-- 		return cachedNamedExports
-- 	end
-- 	local ref = if typeof(self._fileTransforms:get(modulePath)) == "table"
-- 		then self._fileTransforms:get(modulePath).code
-- 		else nil
-- 	local transformedCode = if ref ~= nil then ref else self:readFile(modulePath)
-- 	local exports, reexports
-- 	do
-- 		local ref = parseCjs(transformedCode)
-- 		exports, reexports = ref.exports, ref.reexports
-- 	end
-- 	local namedExports = Set.new(exports)
-- 	Array.forEach(reexports, function(reexport)
-- 		local resolved = self:_resolveModule(modulePath, reexport, { conditions = self.esmConditions })
-- 		local exports = self:getExportsOfCjs(resolved)
-- 		Array.forEach(exports, namedExports.add, namedExports) --[[ ROBLOX CHECK: check if 'exports' is an Array ]]
-- 	end) --[[ ROBLOX CHECK: check if 'reexports' is an Array ]]
-- 	self._cjsNamedExports:set(modulePath, namedExports)
-- 	return namedExports
-- end
-- ROBLOX deviation END
function Runtime_private:requireModule<T>(
	-- ROBLOX deviation START: using ModuleScript instead of string
	from: ModuleScript,
	moduleName_: ModuleScript?,
	-- ROBLOX deviation END
	options: InternalModuleOptions?,
	isRequireActual_: boolean?,
	-- ROBLOX deviation START: additional param to not require return from test files
	noModuleReturnRequired: boolean?
	-- ROBLOX deviation END
): any
	-- ROBLOX deviation START: additional logic
	local moduleName = if moduleName_ == nil then from else moduleName_
	-- ROBLOX deviation END
	-- ROBLOX deviation START: additional interception. We need to make sure Symbol is only loaded once
	if string.find(moduleName.Name, ".global$") then
		return (require :: any)(moduleName)
	end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- local isRequireActual: boolean = if isRequireActual_ ~= nil then isRequireActual_ else false
	-- ROBLOX deviation END
	-- ROBLOX deviation START: simplify
	-- local ref = if typeof(options) == "table" then options.isInternalModule else nil
	-- local isInternal = if ref ~= nil then ref else false
	local isInternal = if typeof(options) == "table" and options.isInternalModule ~= nil
		then options.isInternalModule
		else false
	-- ROBLOX deviation END
	-- ROBLOX deviation START: skipped
	-- local moduleID = self._resolver:getModuleID(
	-- 	self._virtualMocks,
	-- 	from,
	-- 	moduleName,
	-- 	if Boolean.toJSBoolean(isInternal) then nil else { conditions = self.cjsConditions }
	-- )
	-- local modulePath: string | nil -- Some old tests rely on this mocking behavior. Ideally we'll change this
	-- -- to be more explicit.
	-- local moduleResource = if Boolean.toJSBoolean(moduleName) then self._resolver:getModule(moduleName) else moduleName
	-- local manualMock = if Boolean.toJSBoolean(moduleName)
	-- 	then self._resolver:getMockModule(from, moduleName)
	-- 	else moduleName
	-- if
	-- 	Boolean.toJSBoolean((function()
	-- 		local ref = not Boolean.toJSBoolean(
	-- 				if typeof(options) == "table" then options.isInternalModule else nil
	-- 			)
	-- 			and not Boolean.toJSBoolean(isRequireActual)
	-- 			and not Boolean.toJSBoolean(moduleResource)
	-- 			and manualMock
	-- 		local ref = if Boolean.toJSBoolean(ref) then manualMock ~= self._isCurrentlyExecutingManualMock else ref
	-- 		return if Boolean.toJSBoolean(ref) then self._explicitShouldMock:get(moduleID) ~= false else ref
	-- 	end)())
	-- then
	-- 	modulePath = manualMock
	-- end
	-- if
	-- 	Boolean.toJSBoolean(
	-- 		if Boolean.toJSBoolean(moduleName) then self._resolver:isCoreModule(moduleName) else moduleName
	-- 	)
	-- then
	-- 	return self:_requireCoreModule(moduleName, supportsNodeColonModulePrefixInRequire)
	-- end
	-- if not Boolean.toJSBoolean(modulePath) then
	-- 	modulePath = self:_resolveModule(
	-- 		from,
	-- 		moduleName,
	-- 		if Boolean.toJSBoolean(isInternal) then nil else { conditions = self.cjsConditions }
	-- 	)
	-- end
	-- if Boolean.toJSBoolean(self:unstable_shouldLoadAsEsm(modulePath)) then
	-- 	-- Node includes more info in the message
	-- 	local error_ = Error.new(("Must use import to load ES Module: %s"):format(tostring(modulePath))) -- @ts-expect-error: `code` is not defined
	-- 	error_.code = "ERR_REQUIRE_ESM"
	-- 	error(error_)
	-- end
	local modulePath = moduleName
	-- ROBLOX deviation END
	-- ROBLOX deviation START: add type annotation
	-- local moduleRegistry
	local moduleRegistry: ModuleRegistry
	-- ROBLOX deviation END
	if isInternal then
		moduleRegistry = self._internalModuleRegistry
		-- ROBLOX deviation START: simplify
		-- elseif Boolean.toJSBoolean(self._isolatedModuleRegistry) then
	elseif self._isolatedModuleRegistry ~= nil then
		-- ROBLOX deviation END
		moduleRegistry = self._isolatedModuleRegistry
	else
		moduleRegistry = self._moduleRegistry
	end
	local module = moduleRegistry:get(modulePath)
	if module then
		return module.exports
	end -- We must register the pre-allocated module object first so that any
	-- circular dependencies that may arise while evaluating the module can
	-- be satisfied.
	local localModule: InitialModule = {
		-- ROBLOX deviation START: skipped
		-- children = {},
		-- ROBLOX deviation END
		exports = {},
		filename = modulePath,
		id = modulePath,
		loaded = false,
		-- ROBLOX deviation START: skipped
		-- path = path:dirname(modulePath),
		-- ROBLOX deviation END
	}
	moduleRegistry:set(modulePath, localModule)
	-- ROBLOX deviation START: use pcall instead of xpcall
	-- do --[[ ROBLOX COMMENT: try-catch block conversion ]]
	-- 	local ok, result, hasReturned = xpcall(function()
	-- 		self:_loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry)
	-- 	end, function(error_)
	-- 		moduleRegistry:delete(modulePath)
	-- 		error(error_)
	-- 	end)
	-- 	if hasReturned then
	-- 		return result
	-- 	end
	-- end
	local ok, result = pcall(function()
		self:_loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry, noModuleReturnRequired)
	end)
	if not ok then
		moduleRegistry:delete(modulePath)
		error(result)
	end
	-- ROBLOX deviation END
	return localModule.exports
end
-- ROBLOX deviation START: accept ModuleScript instead of string
-- function Runtime_private:requireInternalModule(from: Config_Path, to: string?): T
function Runtime_private:requireInternalModule<T>(from: ModuleScript, to: ModuleScript?): T
	-- ROBLOX deviation END
	-- ROBLOX deviation START: `to` not handled yet
	-- if Boolean.toJSBoolean(to) then
	-- 	local require_ = (if nativeModule.createRequire ~= nil
	-- 		then nativeModule.createRequire
	-- 		else nativeModule.createRequireFromPath)(from)
	-- 	if Boolean.toJSBoolean(INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES:has(to)) then
	-- 		return require_(to)
	-- 	end
	-- 	local outsideJestVmPath = decodePossibleOutsideJestVmPath(to)
	-- 	if Boolean.toJSBoolean(outsideJestVmPath) then
	-- 		return require_(outsideJestVmPath)
	-- 	end
	-- end
	-- ROBLOX deviation END
	return self:requireModule(from, to, {
		isInternalModule = true,
		-- ROBLOX deviation START: not supported
		-- supportsDynamicImport = esmIsAvailable,
		-- supportsExportNamespaceFrom = false,
		-- supportsStaticESM = false,
		-- supportsTopLevelAwait = false,
		-- ROBLOX deviation END
	})
end
-- ROBLOX deviation START: using ModuleScript instead of string
-- function Runtime_private:requireActual(from: Config_Path, moduleName: ModuleScript): T
function Runtime_private:requireActual<T>(from: ModuleScript, moduleName: ModuleScript): T
	-- ROBLOX deviation END
	return self:requireModule(from, moduleName, nil, true)
end
-- ROBLOX deviation START: using ModuleScript instead of string
-- 	local moduleID =
-- 		self._resolver:getModuleID(self._virtualMocks, from, moduleName, { conditions = self.cjsConditions })
function Runtime_private:requireMock<T>(from: ModuleScript, moduleName: ModuleScript): T
	local moduleID = moduleName
	-- ROBLOX deviation END
	-- ROBLOX deviation START: simplify
	-- if
	-- 	Boolean.toJSBoolean((function()
	-- 		local ref = if typeof(self._isolatedMockRegistry) == "table" then self._isolatedMockRegistry.has else nil
	-- 		return if ref ~= nil then ref(moduleID) else nil
	-- 	end)())
	-- then
	if self._isolatedMockRegistry ~= nil and self._isolatedMockRegistry:has(moduleID) then
		-- ROBLOX deviation END
		-- ROBLOX deviation START: this is guaranteed to not be nil as we set a registry above
		-- return self._isolatedMockRegistry:get(moduleID)
		return self._isolatedMockRegistry:get(moduleID) :: any
		-- ROBLOX deviation END
	elseif self._mockRegistry:has(moduleID) then
		-- ROBLOX deviation START: this is guaranteed to not be nil as we set a registry above
		-- return self._mockRegistry:get(moduleID)
		return self._mockRegistry:get(moduleID) :: any
		-- ROBLOX deviation END
	end
	-- ROBLOX deviation START: simplify because `self._isolatedMockRegistry` is either nil or a map object
	-- local mockRegistry = Boolean.toJSBoolean(self._isolatedMockRegistry) and self._isolatedMockRegistry
	-- 	or self._mockRegistry
	local mockRegistry: Map<ModuleScript, any> = self._isolatedMockRegistry or self._mockRegistry
	-- ROBLOX deviation END
	if self._mockFactories:has(moduleID) then
		-- has check above makes this ok
		local module = (self._mockFactories:get(moduleID) :: any)()
		mockRegistry:set(moduleID, module)
		return module :: T
	end
	-- ROBLOX deviation START: manual mocks are not implemented
	error("manual mocks not implemented yet")
	-- local manualMockOrStub = self._resolver:getMockModule(from, moduleName)
	-- local ref = self._resolver:getMockModule(from, moduleName)
	-- local modulePath = Boolean.toJSBoolean(ref) and ref
	-- 	or self:_resolveModule(from, moduleName, { conditions = self.cjsConditions })
	-- local isManualMock = if Boolean.toJSBoolean(manualMockOrStub)
	-- 	then not Boolean.toJSBoolean(self._resolver:resolveStubModuleName(from, moduleName))
	-- 	else manualMockOrStub
	-- if not Boolean.toJSBoolean(isManualMock) then
	-- 	-- If the actual module file has a __mocks__ dir sitting immediately next
	-- 	-- to it, look to see if there is a manual mock for this file.
	-- 	--
	-- 	-- subDir1/my_module.js
	-- 	-- subDir1/__mocks__/my_module.js
	-- 	-- subDir2/my_module.js
	-- 	-- subDir2/__mocks__/my_module.js
	-- 	--
	-- 	-- Where some other module does a relative require into each of the
	-- 	-- respective subDir{1,2} directories and expects a manual mock
	-- 	-- corresponding to that particular my_module.js file.
	-- 	local moduleDir = path:dirname(modulePath)
	-- 	local moduleFileName = path:basename(modulePath)
	-- 	local potentialManualMock = Array.join(path, moduleDir, "__mocks__", moduleFileName) --[[ ROBLOX CHECK: check if 'path' is an Array ]]
	-- 	if Boolean.toJSBoolean(fs:existsSync(potentialManualMock)) then
	-- 		isManualMock = true
	-- 		modulePath = potentialManualMock
	-- 	end
	-- end
	-- if Boolean.toJSBoolean(isManualMock) then
	-- 	local localModule: InitialModule = {
	-- 		children = {},
	-- 		exports = {},
	-- 		filename = modulePath,
	-- 		id = modulePath,
	-- 		loaded = false,
	-- 		path = path:dirname(modulePath),
	-- 	}
	-- 	self:_loadModule(localModule, from, moduleName, modulePath, nil, mockRegistry)
	-- 	mockRegistry:set(moduleID, localModule.exports)
	-- else
	-- 	-- Look for a real module to generate an automock from
	-- 	mockRegistry:set(moduleID, self:_generateMock(from, moduleName))
	-- end
	-- return mockRegistry:get(moduleID)
	-- ROBLOX deviation END
end
function Runtime_private:_loadModule(
	localModule: InitialModule,
	-- ROBLOX deviation START: using ModuleScript instead of string
	from: ModuleScript,
	moduleName: ModuleScript | nil,
	modulePath: ModuleScript,
	-- ROBLOX deviation END
	options: InternalModuleOptions | nil,
	moduleRegistry: ModuleRegistry,
	-- ROBLOX deviation START: additional param to not require return from test files
	noModuleReturnRequired: boolean?
	-- ROBLOX deviation END
)
	-- ROBLOX deviation START: custom implementation
	-- if path:extname(modulePath) == ".json" then
	-- 	local text = stripBOM(self:readFile(modulePath))
	-- 	local transformedFile =
	-- 		self._scriptTransformer:transformJson(modulePath, self:_getFullTransformationOptions(options), text)
	-- 	localModule.exports = self._environment.global.JSON:parse(transformedFile)
	-- elseif path:extname(modulePath) == ".node" then
	-- 	localModule.exports = require_(modulePath)
	-- else
	do
		-- ROBLOX deviation END
		-- Only include the fromPath if a moduleName is given. Else treat as root.
		local fromPath = if Boolean.toJSBoolean(moduleName) then from else nil
		-- ROBLOX deviation START: one additional param - noModuleReturnRequired
		-- 	self:_execModule(localModule, options, moduleRegistry, fromPath)
		self:_execModule(localModule, options, moduleRegistry, fromPath, noModuleReturnRequired)
		-- ROBLOX deviation END
	end
	-- ROBLOX deviation END
	localModule.loaded = true
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:_getFullTransformationOptions(options_: InternalModuleOptions?): TransformationOptions
-- 	local options: InternalModuleOptions = if options_ ~= nil then options_ else defaultTransformOptions
-- 	return Object.assign({}, options, self._coverageOptions)
-- end
-- ROBLOX deviation END
-- ROBLOX deviation START: modified signature, use ModuleScript instead of string
function Runtime_private:requireModuleOrMock<T>(moduleName: ModuleScript): T
	local from = moduleName
	-- ROBLOX deviation END
	-- ROBLOX deviation START: additional interception
	if moduleName == script or (typeof(script.Parent) == "ModuleScript" and moduleName == script.Parent) then
		-- ROBLOX NOTE: Need to cast require because analyze cannot figure out scriptInstance path
		return (require :: any)(moduleName)
	end
	-- ROBLOX deviation END

	-- ROBLOX deviation START: additional interception. We need to make sure Symbol is only loaded once
	if string.find(moduleName.Name, ".global$") then
		return (require :: any)(moduleName)
	end
	-- ROBLOX deviation END

	-- ROBLOX deviation START: custom JestGlobals interception
	-- -- this module is unmockable
	-- if moduleName == "@jest/globals" then
	-- 	-- @ts-expect-error: we don't care that it's not assignable to T
	-- 	return self:getGlobalsForCjs(from)
	-- end
	if moduleName.Name == "JestGlobals" then
		local globals = self:getGlobalsFromEnvironment()
		return Object.assign({}, globals, {
			jest = self._jestObject,
		}) :: T
	end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: use pcall instead of xpcall
	-- do --[[ ROBLOX COMMENT: try-catch block conversion ]]
	-- 	local ok, result, hasReturned = xpcall(function()
	-- 		if
	-- 			Boolean.toJSBoolean(
	-- 				self:_shouldMock(from, moduleName, self._explicitShouldMock, { conditions = self.cjsConditions })
	-- 			)
	-- 		then
	-- 			return self:requireMock(from, moduleName)
	-- 		else
	-- 			return self:requireModule(from, moduleName)
	-- 		end
	-- 	end, function(e: unknown)
	-- 		local moduleNotFound = Resolver:tryCastModuleNotFoundError(e)
	-- 		if Boolean.toJSBoolean(moduleNotFound) then
	-- 			if
	-- 				moduleNotFound.siblingWithSimilarExtensionFound == nil
	-- 				or moduleNotFound.siblingWithSimilarExtensionFound == nil
	-- 			then
	-- 				moduleNotFound.hint = findSiblingsWithFileExtension(
	-- 					self._config.moduleFileExtensions,
	-- 					from,
	-- 					Boolean.toJSBoolean(moduleNotFound.moduleName) and moduleNotFound.moduleName or moduleName
	-- 				)
	-- 				moduleNotFound.siblingWithSimilarExtensionFound = Boolean(moduleNotFound.hint)
	-- 			end
	-- 			moduleNotFound:buildMessage(self._config.rootDir)
	-- 			error(moduleNotFound)
	-- 		end
	-- 		error(e)
	-- 	end)
	-- 	if hasReturned then
	-- 		return result
	-- 	end
	-- end
	local ok, result = pcall(function()
		local shouldMock = self:_shouldMock(from, moduleName, self._explicitShouldMock, {
			conditions = nil,
		})
		if shouldMock then
			-- error("mocking is not implemented in JestRuntime yet")
			return self:requireMock(from, moduleName)
		else
			return self:requireModule(from, moduleName)
		end
	end)
	if not ok then
		error(result)
	end
	return result
	-- ROBLOX deviation END
end
function Runtime_private:isolateModules(fn: () -> ()): ()
	-- ROBLOX deviation START: simplify
	-- if
	-- 	Boolean.toJSBoolean(
	-- 		Boolean.toJSBoolean(self._isolatedModuleRegistry) and self._isolatedModuleRegistry
	-- 			or self._isolatedMockRegistry
	-- 	)
	-- then
	if self._isolatedModuleRegistry ~= nil or self._isolatedMockRegistry ~= nil then
		-- ROBLOX deviation END
		error(Error.new("isolateModules cannot be nested inside another isolateModules."))
	end
	self._isolatedModuleRegistry = Map.new()
	self._isolatedMockRegistry = Map.new()
	do --[[ ROBLOX COMMENT: try-finally block conversion ]]
		-- ROBLOX deviation START: function doesn't return
		-- local ok, result, hasReturned = pcall(function()
		-- 	fn()
		-- end)
		local ok, result = pcall(function()
			fn()
		end)
		-- ROBLOX deviation END
		do
			-- might be cleared within the callback
			-- ROBLOX deviation START: simplify
			-- local ref = if typeof(self._isolatedModuleRegistry) == "table"
			-- 	then self._isolatedModuleRegistry.clear
			-- 	else nil
			-- if ref ~= nil then
			-- 	ref()
			-- end
			-- local ref = if typeof(self._isolatedMockRegistry) == "table" then self._isolatedMockRegistry.clear else nil
			-- if ref ~= nil then
			-- 	ref()
			-- end
			if self._isolatedModuleRegistry then
				self._isolatedModuleRegistry:clear()
			end
			if self._isolatedMockRegistry then
				self._isolatedMockRegistry:clear()
			end
			-- ROBLOX deviation END
			self._isolatedModuleRegistry = nil
			self._isolatedMockRegistry = nil
		end
		-- ROBLOX deviation START: function doesn't return
		-- if hasReturned then
		-- 	return result
		-- end
		-- ROBLOX deviation END
		if not ok then
			error(result)
		end
	end
end
function Runtime_private:resetModules(): ()
	-- ROBLOX deviation START: simplify
	-- local ref = if typeof(self._isolatedModuleRegistry) == "table" then self._isolatedModuleRegistry.clear else nil
	-- if ref ~= nil then
	-- 	ref()
	-- end
	-- local ref = if typeof(self._isolatedMockRegistry) == "table" then self._isolatedMockRegistry.clear else nil
	-- if ref ~= nil then
	-- 	ref()
	-- end
	if self._isolatedModuleRegistry then
		self._isolatedModuleRegistry:clear()
	end
	if self._isolatedMockRegistry then
		self._isolatedMockRegistry:clear()
	end
	-- ROBLOX deviation END
	self._isolatedModuleRegistry = nil
	self._isolatedMockRegistry = nil
	self._mockRegistry:clear()
	self._moduleRegistry:clear()
	-- ROBLOX deviation START: skipped
	-- self._esmoduleRegistry:clear()
	-- self._cjsNamedExports:clear()
	-- self._moduleMockRegistry:clear()
	-- if Boolean.toJSBoolean(self._environment) then
	-- 	if Boolean.toJSBoolean(self._environment.global) then
	-- 		local envGlobal = self._environment.global
	-- 		Array.forEach(
	-- 			Object.keys(envGlobal) :: Array<any> --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof typeof globalThis ]],
	-- 			function(key)
	-- 				local globalMock = envGlobal[tostring(key)]
	-- 				if
	-- 					(typeof(globalMock) == "table" and globalMock ~= nil or typeof(globalMock) == "function")
	-- 					and globalMock._isMockFunction == true
	-- 				then
	-- 					globalMock:mockClear()
	-- 				end
	-- 			end
	-- 		) --[[ ROBLOX CHECK: check if 'Object.keys(envGlobal) as Array<keyof typeof globalThis>' is an Array ]]
	-- 	end
	-- 	if Boolean.toJSBoolean(self._environment.fakeTimers) then
	-- 		self._environment.fakeTimers:clearAllTimers()
	-- 	end
	-- end
	-- ROBLOX deviation END
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:collectV8Coverage(): Promise<void>
-- 	return Promise.resolve():andThen(function()
-- 		self._v8CoverageInstrumenter = CoverageInstrumenter.new()
-- 		self._v8CoverageInstrumenter:startInstrumenting():expect()
-- 	end)
-- end
-- function Runtime_private:stopCollectingV8Coverage(): Promise<void>
-- 	return Promise.resolve():andThen(function()
-- 		if not Boolean.toJSBoolean(self._v8CoverageInstrumenter) then
-- 			error(Error.new("You need to call `collectV8Coverage` first."))
-- 		end
-- 		self._v8CoverageResult = self._v8CoverageInstrumenter:stopInstrumenting():expect()
-- 	end)
-- end
-- function Runtime_private:getAllCoverageInfoCopy(
-- ): typeof((({} :: any) :: typeof((({} :: any) :: JestEnvironment).global)).__coverage__)
-- 	return deepCyclicCopy(self._environment.global.__coverage__)
-- end
-- function Runtime_private:getAllV8CoverageInfoCopy(): V8CoverageResult
-- 	if not Boolean.toJSBoolean(self._v8CoverageResult) then
-- 		error(Error.new("You need to `stopCollectingV8Coverage` first"))
-- 	end
-- 	return Array.map(
-- 		Array.filter(
-- 			Array.map(
-- 				Array.filter(self._v8CoverageResult, function(res)
-- 					return res.url:startsWith("file://")
-- 				end), --[[ ROBLOX CHECK: check if 'this._v8CoverageResult' is an Array ]]
-- 				function(res)
-- 					return Object.assign({}, res, { url = fileURLToPath(res.url) })
-- 				end
-- 			),
-- 			function(res)
-- 				local ref = res.url:startsWith(self._config.rootDir)
-- 				local ref = if Boolean.toJSBoolean(ref) then self._fileTransforms:has(res.url) else ref
-- 				return -- TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways
-- 					if Boolean.toJSBoolean(ref)
-- 					then shouldInstrument(res.url, self._coverageOptions, self._config)
-- 					else ref
-- 			end
-- 		),
-- 		function(result)
-- 			local transformedFile = self._fileTransforms:get(result.url)
-- 			return { codeTransformResult = transformedFile, result = result }
-- 		end
-- 	)
-- end
-- function Runtime_private:getSourceMaps(): SourceMapRegistry
-- 	return self._sourceMapRegistry
-- end
-- ROBLOX deviation END
function Runtime_private:setMock(
	-- ROBLOX deviation START: using module script instead of string moduleName
	from: ModuleScript,
	moduleName: ModuleScript,
	-- ROBLOX deviation END
	mockFactory: () -> unknown,
	options: { virtual: boolean? }?
): ()
	if Boolean.toJSBoolean(if typeof(options) == "table" then options.virtual else nil) then
		-- ROBLOX deviation START: virtual mocks are not supported
		-- local mockPath = self._resolver:getModulePath(from, moduleName)
		-- self._virtualMocks:set(mockPath, true)
		error("virtual mocks not supported")
		-- ROBLOX deviation END
	end
	-- ROBLOX deviation START: using module script instead of string moduleName
	-- local moduleID =
	-- 	self._resolver:getModuleID(self._virtualMocks, from, moduleName, { conditions = self.cjsConditions })
	local moduleID = moduleName
	-- ROBLOX deviation END
	self._explicitShouldMock:set(moduleID, true)
	self._mockFactories:set(moduleID, mockFactory)
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:setModuleMock(
-- 	from: string,
-- 	moduleName: ModuleScript,
-- 	mockFactory: () -> Promise<unknown> | unknown,
-- 	options: { virtual: boolean? }?
-- ): ()
-- 	if Boolean.toJSBoolean(if typeof(options) == "table" then options.virtual else nil) then
-- 		local mockPath = self._resolver:getModulePath(from, moduleName)
-- 		self._virtualModuleMocks:set(mockPath, true)
-- 	end
-- 	local moduleID =
-- 		self._resolver:getModuleID(self._virtualModuleMocks, from, moduleName, { conditions = self.esmConditions })
-- 	self._explicitShouldMockModule:set(moduleID, true)
-- 	self._moduleMockFactories:set(moduleID, mockFactory)
-- end
-- ROBLOX deviation END
function Runtime_private:restoreAllMocks(): ()
	self._moduleMocker:restoreAllMocks()
end
function Runtime_private:resetAllMocks(): ()
	self._moduleMocker:unmockGlobals(self._globalMocker)
	self._moduleMocker:resetAllMocks()
	self._moduleMocker:mockGlobals(self._globalMocker, getfenv(0))
end
function Runtime_private:clearAllMocks(): ()
	self._moduleMocker:clearAllMocks()
end
function Runtime_private:teardown(): ()
	-- ROBLOX deviation: mocking globals
	self._moduleMocker:unmockGlobals(self._globalMocker)
	self:restoreAllMocks()
	self:resetAllMocks()
	self:resetModules()
	self._internalModuleRegistry:clear()
	-- ROBLOX deviation START: not implemented yet
	-- self._mainModule = nil
	-- ROBLOX deviation END
	self._mockFactories:clear()
	-- ROBLOX deviation START: not implemented yet
	-- self._moduleMockFactories:clear()
	-- self._mockMetaDataCache:clear()
	-- ROBLOX deviation END
	self._shouldMockModuleCache:clear()
	-- ROBLOX deviation START: not implemented yet
	-- self._shouldUnmockTransitiveDependenciesCache:clear()
	-- ROBLOX deviation END
	self._explicitShouldMock:clear()
	self._explicitShouldMockModule:clear()
	-- ROBLOX deviation START: not implemented yet
	-- self._transitiveShouldMock:clear()
	-- self._virtualMocks:clear()
	-- self._virtualModuleMocks:clear()
	-- self._cacheFS:clear()
	-- self._unmockList = nil
	-- self._sourceMapRegistry:clear()
	-- self._fileTransforms:clear()
	-- self._fileTransformsMutex:clear()
	-- self.jestObjectCaches:clear()
	-- self._v8CoverageResult = {}
	-- self._v8CoverageInstrumenter = nil
	-- self._moduleImplementation = nil
	-- ROBLOX deviation END

	-- ROBLOX deviation START: additional cleanup logic for modules loaded with debug.loadmodule
	for _, cleanup in ipairs(self._cleanupFns) do
		cleanup()
	end
	-- ROBLOX deviation END
	self.isTornDown = true
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:_resolveModule(from: Config_Path, to: string | nil, options: ResolveModuleConfig?)
-- 	return if Boolean.toJSBoolean(to) then self._resolver:resolveModule(from, to, options) else from
-- end
-- function Runtime_private:_requireResolve(from: Config_Path, moduleName: ModuleScript?, options_: ResolveOptions?)
-- 	local options: ResolveOptions = if options_ ~= nil then options_ else {}
-- 	if
-- 		moduleName == nil --[[ ROBLOX CHECK: loose equality used upstream ]]
-- 	then
-- 		error(Error.new("The first argument to require.resolve must be a string. Received null or undefined."))
-- 	end
-- 	if Boolean.toJSBoolean(path:isAbsolute(moduleName)) then
-- 		local module = self._resolver:resolveModuleFromDirIfExists(
-- 			moduleName,
-- 			moduleName,
-- 			{ conditions = self.cjsConditions, paths = {} }
-- 		)
-- 		if Boolean.toJSBoolean(module) then
-- 			return module
-- 		end
-- 	else
-- 		local paths = options.paths
-- 		if Boolean.toJSBoolean(paths) then
-- 			for _, p in paths do
-- 				local absolutePath = path:resolve(from, "..", p)
-- 				local module = self._resolver:resolveModuleFromDirIfExists(
-- 					absolutePath,
-- 					moduleName, -- required to also resolve files without leading './' directly in the path
-- 					{ conditions = self.cjsConditions, paths = { absolutePath } }
-- 				)
-- 				if Boolean.toJSBoolean(module) then
-- 					return module
-- 				end
-- 			end
-- 			error(
-- 				Resolver.ModuleNotFoundError.new(
-- 					("Cannot resolve module '%s' from paths ['%s'] from %s"):format(
-- 						tostring(moduleName),
-- 						tostring(Array.join(paths, "', '") --[[ ROBLOX CHECK: check if 'paths' is an Array ]]),
-- 						tostring(from)
-- 					)
-- 				)
-- 			)
-- 		end
-- 	end
-- 	do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 		local ok, result, hasReturned = xpcall(function()
-- 			return self:_resolveModule(from, moduleName, { conditions = self.cjsConditions }), true
-- 		end, function(err: unknown)
-- 			local module = self._resolver:getMockModule(from, moduleName)
-- 			if Boolean.toJSBoolean(module) then
-- 				return module
-- 			else
-- 				error(err)
-- 			end
-- 		end)
-- 		if hasReturned then
-- 			return result
-- 		end
-- 	end
-- end
-- function Runtime_private:_requireResolvePaths(from: Config_Path, moduleName: ModuleScript?)
-- 	if
-- 		moduleName == nil --[[ ROBLOX CHECK: loose equality used upstream ]]
-- 	then
-- 		error(Error.new("The first argument to require.resolve.paths must be a string. Received null or undefined."))
-- 	end
-- 	if not Boolean.toJSBoolean(moduleName.length) then
-- 		error(Error.new("The first argument to require.resolve.paths must not be the empty string."))
-- 	end
-- 	if
-- 		moduleName[
-- 			1 --[[ ROBLOX adaptation: added 1 to array index ]]
-- 		] == "."
-- 	then
-- 		return { path:resolve(from, "..") }
-- 	end
-- 	if Boolean.toJSBoolean(self._resolver:isCoreModule(moduleName)) then
-- 		return nil
-- 	end
-- 	return self._resolver:getModulePaths(path:resolve(from, ".."))
-- end
function Runtime_private:_execModule(
	localModule: InitialModule,
	options: InternalModuleOptions | nil,
	moduleRegistry: ModuleRegistry,
	-- ROBLOX deviation START: using ModuleScript instead of string
	-- from: Config_Path | nil --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
	from: ModuleScript | nil, --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
	-- ROBLOX deviation END
	-- ROBLOX deviation START: additional param to not require return from test files
	noModuleReturnRequired: boolean?
	-- ROBLOX deviation END
): ()
	-- ROBLOX deviation START: custom implementation
	-- 	if Boolean.toJSBoolean(self.isTornDown) then
	-- 		self:_logFormattedReferenceError(
	-- 			"You are trying to `import` a file after the Jest environment has been torn down."
	-- 		)
	-- 		process.exitCode = 1
	-- 		return
	-- 	end -- If the environment was disposed, prevent this module from being executed.
	-- 	if not Boolean.toJSBoolean(self._environment.global) then
	-- 		return
	-- 	end
	-- 	local module = localModule :: Module
	-- 	local filename = module.filename
	-- 	local lastExecutingModulePath = self._currentlyExecutingModulePath
	-- 	self._currentlyExecutingModulePath = filename
	-- 	local origCurrExecutingManualMock = self._isCurrentlyExecutingManualMock
	-- 	self._isCurrentlyExecutingManualMock = filename
	-- 	module.children = {}
	-- 	Object.defineProperty(module, "parent", {
	-- 		enumerable = true,
	-- 		get = function(self)
	-- 			local key = Boolean.toJSBoolean(from) and from or ""
	-- 			local ref = moduleRegistry:get(key)
	-- 			return Boolean.toJSBoolean(ref) and ref or nil
	-- 		end,
	-- 	})
	-- 	module.paths = self._resolver:getModulePaths(module.path)
	-- 	Object.defineProperty(module, "require", { value = self:_createRequireImplementation(module, options) })
	-- 	local transformedCode = self:transformFile(filename, options)
	-- 	local compiledFunction: ModuleWrapper | nil --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]] =
	-- 		nil
	-- 	local script_ = self:createScriptFromCode(transformedCode, filename)
	-- 	local runScript: RunScriptEvalResult | nil --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]] =
	-- 		nil
	-- 	local vmContext = self._environment:getVmContext()
	-- 	if Boolean.toJSBoolean(vmContext) then
	-- 		runScript = script_:runInContext(vmContext, { filename = filename })
	-- 	end
	-- 	if runScript ~= nil then
	-- 		compiledFunction = runScript[tostring(EVAL_RESULT_VARIABLE)]
	-- 	end
	-- 	if compiledFunction == nil then
	-- 		self:_logFormattedReferenceError(
	-- 			"You are trying to `import` a file after the Jest environment has been torn down."
	-- 		)
	-- 		process.exitCode = 1
	-- 		return
	-- 	end
	-- 	local jestObject = self:_createJestObjectFor(filename)
	-- 	self.jestObjectCaches:set(filename, jestObject)
	-- 	local lastArgs: Array<Jest | nil | any> --[[ ROBLOX TODO: Unhandled node for type: TSRestType ]] --[[ ...Array<Global.Global> ]] = Array.concat(
	-- 		{},
	-- 		{
	-- 			if Boolean.toJSBoolean(self._config.injectGlobals) then jestObject else nil,
	-- 		}, -- jest object
	-- 		Array.spread(Array.map(self._config.extraGlobals, function(globalVariable)
	-- 			if Boolean.toJSBoolean(self._environment.global[tostring(globalVariable)]) then
	-- 				return self._environment.global[tostring(globalVariable)]
	-- 			end
	-- 			error(
	-- 				Error.new(
	-- 					("You have requested '%s' as a global variable, but it was not present. Please check your config or your global environment."):format(
	-- 						tostring(globalVariable)
	-- 					)
	-- 				)
	-- 			)
	-- 		end) --[[ ROBLOX CHECK: check if 'this._config.extraGlobals' is an Array ]])
	-- 	)
	-- 	if not Boolean.toJSBoolean(self._mainModule) and filename == self._testPath then
	-- 		self._mainModule = module
	-- 	end
	-- 	Object.defineProperty(module, "main", { enumerable = true, value = self._mainModule })
	-- 	do --[[ ROBLOX COMMENT: try-catch block conversion ]]
	-- 		local ok, result, hasReturned = xpcall(function()
	-- 			compiledFunction(
	-- 				module.exports,
	-- 				module, -- module object
	-- 				module.exports, -- module exports
	-- 				module.require, -- require implementation
	-- 				module.path, -- __dirname
	-- 				module.filename, -- __filename
	-- 				-- @ts-expect-error
	-- 				error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: SpreadElement ]] --[[ ...lastArgs.filter(notEmpty) ]]
	-- 			)
	-- 		end, function(error_)
	-- 			self:handleExecutionError(error_, module)
	-- 		end)
	-- 		if hasReturned then
	-- 			return result
	-- 		end
	-- 	end
	-- 	self._isCurrentlyExecutingManualMock = origCurrExecutingManualMock
	-- 	self._currentlyExecutingModulePath = lastExecutingModulePath
	-- ROBLOX note: each test runner stores its own cache of loaded module functions
	local moduleFunction, defaultEnvironment, errorMessage, cleanupFn

	local modulePath = localModule.filename
	local loadModuleEnabled = pcall((debug :: any).loadmodule, Instance.new("ModuleScript"))

	if self._loadedModuleFns and self._loadedModuleFns:has(modulePath) then
		local loadedModule = self._loadedModuleFns:get(modulePath) :: { any }
		moduleFunction = loadedModule[1]
		defaultEnvironment = loadedModule[2]
	else
		-- Narrowing this type here lets us appease the type checker while still
		-- counting on types for the rest of this file
		if loadModuleEnabled then
			local loadmodule: (ModuleScript) -> (any, string, () -> any) = debug["loadmodule"]
			moduleFunction, errorMessage, cleanupFn = loadmodule(modulePath)
		else
			moduleFunction = loadstring(modulePath.Source, modulePath:GetFullName())
		end
		-- ROBLOX NOTE: we are not using assert() as it throws a bare string and we need to throw an Error object
		if moduleFunction == nil then
			error(Error.new(errorMessage))
		end

		-- Cache initial environment table to inherit from later
		defaultEnvironment = getfenv(moduleFunction)

		if self._loadedModuleFns then
			self._loadedModuleFns:set(modulePath, { moduleFunction, defaultEnvironment, cleanupFn })
		else
			if cleanupFn ~= nil then
				table.insert(self._cleanupFns, cleanupFn)
			end
		end
	end

	-- The default behavior for function environments is to inherit the table instance from the
	-- parent environment. This means that each invocation of `moduleFunction()` will return
	-- a new module instance but with the same environment table as `moduleFunction` itself at the
	-- time of invocation. In order to properly sanbox module instances, we need to ensure that
	-- each instance has its own distinct environment table containing the specific overrides for it,
	-- but still inherits from the default parent environment for non-overriden
	-- environment goodies.
	-- local isInternal = false -- if options ~= nil and options.isInternalModule then options.isInternalModule else false
	local isInternal = if options ~= nil and options.isInternalModule then options.isInternalModule else false

	-- Data model references inside of sandbox
	local dmScript = if loadModuleEnabled then defaultEnvironment.script else modulePath
	local dmGame = defaultEnvironment.game
	local dmWorkspace = defaultEnvironment.workspace
	local dmPlugin = defaultEnvironment.plugin
	if self._config.mockDataModel then
		local dmMocker = self._moduleMocker.dataModelMocker
		local gameProxy = dmMocker:mockInstance(defaultEnvironment.game)
		dmGame = gameProxy.spy
	end

	-- This is the 'least mocked' environment that scripts will be able to see.
	-- The final function environment inherits from this sandbox.
	-- This is separate so that, in the future, `globalEnv` could expose these
	-- 'unmocked' functions instead of the ones in the global environment.
	local sandboxEnvironment = setmetatable({
		--[[
			ROBLOX NOTE:
			Adding `script` directly into a table so that it is accessible to the debugger
			It seems to be a similar issue to code inside of __index function not being debuggable
		]]
		script = dmScript,
		game = dmGame,
		workspace = dmWorkspace,
		plugin = dmPlugin,

		-- legacy aliases for data model
		Game = dmGame,
		Workspace = dmWorkspace,

		require = if isInternal
			then function(scriptInstance: ModuleScript | string)
				if typeof(scriptInstance) == "string" then
					-- Disabling this at the surface level of the API until we have
					-- deeper support in Jest.
					error("Require-by-string is not enabled for use inside Jest at this time.")
				end
				return self:requireInternalModule(scriptInstance)
			end
			else function(scriptInstance: ModuleScript | string)
				if typeof(scriptInstance) == "string" then
					-- Disabling this at the surface level of the API until we have
					-- deeper support in Jest.
					error("Require-by-string is not enabled for use inside Jest at this time.")
				end
				return self:requireModuleOrMock(scriptInstance)
			end,
	}, {
		__index = defaultEnvironment,
	})
	if not isInternal then
		Object.assign(sandboxEnvironment, {
			delay = self._fakeTimersImplementation.delayOverride,
			tick = self._fakeTimersImplementation.tickOverride,
			time = self._fakeTimersImplementation.timeOverride,
			DateTime = self._fakeTimersImplementation.dateTimeOverride,
			os = self._fakeTimersImplementation.osOverride,
			task = self._fakeTimersImplementation.taskOverride,
		})
	end

	-- This is the environment actually passed to scripts, including all global
	-- mocks and other customisations the user might choose to apply.
	local mockedSandboxEnvironment = setmetatable({}, {
		__index = sandboxEnvironment,
	})
	local function setupAutomocks(automocks: Object, sourceEnv: any, saveInto: any)
		for name, automock in automocks do
			if automock._isGlobalAutomockFn then
				local original = sourceEnv[name]
				-- Disguise the mock callable table as a function on the
				-- outside, so it retains the same behaviour when observed in
				-- various ways by almost all code (except debug library stuff)
				saveInto[name] = function(...)
					if automock._maybeMock == nil then
						error(Error.new("Code should not be running when globalEnv is uninitialised"))
					end
					return automock._maybeMock(...)
				end
			else
				local subSourceEnv = sourceEnv[name]
				local subSaveInto = setmetatable({}, {
					__index = subSourceEnv,
				})
				saveInto[name] = subSaveInto
				setupAutomocks(automock, subSourceEnv, subSaveInto)
			end
		end
	end
	setupAutomocks(self._globalMocker.automocks, sandboxEnvironment, mockedSandboxEnvironment)

	setfenv(moduleFunction, mockedSandboxEnvironment :: any)
	local moduleResult = table.pack(moduleFunction())

	if moduleResult.n ~= 1 and noModuleReturnRequired ~= true then
		error(
			string.format(
				"[Module Error]: %s did not return a valid result\n" .. "\tModuleScripts must return exactly one value",
				tostring(modulePath)
			)
		)
	end
	localModule.exports = moduleResult[1]
	-- ROBLOX deviation END
end
-- function Runtime_private:transformFile(filename: string, options: InternalModuleOptions?): string
-- 	local source = self:readFile(filename)
-- 	if Boolean.toJSBoolean(if typeof(options) == "table" then options.isInternalModule else nil) then
-- 		return source
-- 	end
-- 	local transformedFile: TransformResult | nil = self._fileTransforms:get(filename)
-- 	if Boolean.toJSBoolean(transformedFile) then
-- 		return transformedFile.code
-- 	end
-- 	transformedFile = self._scriptTransformer:transform(filename, self:_getFullTransformationOptions(options), source)
-- 	self._fileTransforms:set(
-- 		filename,
-- 		Object.assign({}, transformedFile, { wrapperLength = self:constructModuleWrapperStart().length })
-- 	)
-- 	if Boolean.toJSBoolean(transformedFile.sourceMapPath) then
-- 		self._sourceMapRegistry:set(filename, transformedFile.sourceMapPath)
-- 	end
-- 	return transformedFile.code
-- end
-- function Runtime_private:transformFileAsync(filename: string, options: InternalModuleOptions?): Promise<string>
-- 	return Promise.resolve():andThen(function()
-- 		local source = self:readFile(filename)
-- 		if Boolean.toJSBoolean(if typeof(options) == "table" then options.isInternalModule else nil) then
-- 			return source
-- 		end
-- 		local transformedFile: TransformResult | nil = self._fileTransforms:get(filename)
-- 		if Boolean.toJSBoolean(transformedFile) then
-- 			return transformedFile.code
-- 		end
-- 		transformedFile = self._scriptTransformer
-- 			:transformAsync(filename, self:_getFullTransformationOptions(options), source)
-- 			:expect()
-- 		self._fileTransforms:set(filename, Object.assign({}, transformedFile, { wrapperLength = 0 }))
-- 		if Boolean.toJSBoolean(transformedFile.sourceMapPath) then
-- 			self._sourceMapRegistry:set(filename, transformedFile.sourceMapPath)
-- 		end
-- 		return transformedFile.code
-- 	end)
-- end
-- function Runtime_private:createScriptFromCode(scriptSource: string, filename: string)
-- 	do --[[ ROBLOX COMMENT: try-catch block conversion ]]
-- 		local ok, result, hasReturned = xpcall(function()
-- 			local scriptFilename = if Boolean.toJSBoolean(self._resolver:isCoreModule(filename))
-- 				then ("jest-nodejs-core-%s"):format(tostring(filename))
-- 				else filename
-- 			return Script.new(self:wrapCodeInModuleWrapper(scriptSource), {
-- 				displayErrors = true,
-- 				filename = scriptFilename,
-- 				-- @ts-expect-error: Experimental ESM API
-- 				importModuleDynamically = function(specifier: string)
-- 					return Promise.resolve():andThen(function()
-- 						invariant(
-- 							runtimeSupportsVmModules,
-- 							"You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules"
-- 						)
-- 						local context = if self._environment.getVmContext ~= nil
-- 							then self._environment.getVmContext()
-- 							else nil
-- 						invariant(context, "Test environment has been torn down")
-- 						local module = self:resolveModule(specifier, scriptFilename, context):expect()
-- 						return self:linkAndEvaluateModule(module)
-- 					end)
-- 				end,
-- 			}),
-- 				true
-- 		end, function(e: any)
-- 			error(handlePotentialSyntaxError(e))
-- 		end)
-- 		if hasReturned then
-- 			return result
-- 		end
-- 	end
-- end
-- function Runtime_private:_requireCoreModule(moduleName: ModuleScript, supportPrefix: boolean)
-- 	local moduleWithoutNodePrefix = if Boolean.toJSBoolean(
-- 			if Boolean.toJSBoolean(supportPrefix) then moduleName:startsWith("node:") else supportPrefix
-- 		)
-- 		then Array.slice(moduleName, ("node:").length) --[[ ROBLOX CHECK: check if 'moduleName' is an Array ]]
-- 		else moduleName
-- 	if moduleWithoutNodePrefix == "process" then
-- 		return self._environment.global.process
-- 	end
-- 	if moduleWithoutNodePrefix == "module" then
-- 		return self:_getMockedNativeModule()
-- 	end
-- 	return require_(moduleWithoutNodePrefix)
-- end
-- function Runtime_private:_importCoreModule(moduleName: ModuleScript, context: VMContext)
-- 	local required = self:_requireCoreModule(moduleName, supportsNodeColonModulePrefixInImport)
-- 	local module = SyntheticModule.new(
-- 		Array.concat({}, { "default" }, Array.spread(Object.keys(required))),
-- 		function()
-- 			-- @ts-expect-error: TS doesn't know what `this` is
-- 			self:setExport("default", required)
-- 			Array.forEach(Object.entries(required), function(ref0)
-- 				local key, value = table.unpack(ref0, 1, 2)
-- 				-- @ts-expect-error: TS doesn't know what `this` is
-- 				self:setExport(key, value)
-- 			end) --[[ ROBLOX CHECK: check if 'Object.entries(required)' is an Array ]]
-- 		end, -- should identifier be `node://${moduleName}`?
-- 		{ context = context, identifier = moduleName }
-- 	)
-- 	return evaluateSyntheticModule(module)
-- end
-- function Runtime_private:_getMockedNativeModule(
-- ): typeof(__unhandledIdentifier__ --[[ ROBLOX TODO: Unhandled node for type: TSQualifiedName ]] --[[ nativeModule.Module ]])
-- 	if Boolean.toJSBoolean(self._moduleImplementation) then
-- 		return self._moduleImplementation
-- 	end
-- 	local function createRequire(modulePath: string | URL)
-- 		local filename = if typeof(modulePath) == "string"
-- 			then if Boolean.toJSBoolean(modulePath:startsWith("file:///"))
-- 				then fileURLToPath(URL.new(modulePath))
-- 				else modulePath
-- 			else fileURLToPath(modulePath)
-- 		if not Boolean.toJSBoolean(path:isAbsolute(filename)) then
-- 			local error_ = TypeError.new(
-- 				("The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '%s'"):format(
-- 					tostring(filename)
-- 				)
-- 			) -- @ts-expect-error
-- 			error_.code = "ERR_INVALID_ARG_TYPE"
-- 			error(error_)
-- 		end
-- 		return self:_createRequireImplementation({
-- 			children = {},
-- 			exports = {},
-- 			filename = filename,
-- 			id = filename,
-- 			loaded = false,
-- 			path = path:dirname(filename),
-- 		})
-- 	end -- should we implement the class ourselves?
-- 	type Module = {} --[[ ROBLOX comment: Unhandled superclass type: LuaMemberExpression ]]
-- 	type Module_statics = { new: () -> Module }
-- 	local Module = (setmetatable({}, { __index = nativeModule.Module }) :: any) :: Module & Module_statics;
-- 	(Module :: any).__index = Module
-- 	function Module.new(): Module
-- 		local self = setmetatable({}, Module) --[[ ROBLOX TODO: super constructor may be used ]]
-- 		return (self :: any) :: Module
-- 	end
-- 	Array.forEach(Object.entries(nativeModule.Module), function(ref0)
-- 		local key, value = table.unpack(ref0, 1, 2)
-- 		-- @ts-expect-error
-- 		Module[tostring(key)] = value
-- 	end) --[[ ROBLOX CHECK: check if 'Object.entries(nativeModule.Module)' is an Array ]]
-- 	Module.Module = Module
-- 	if Array.indexOf(Object.keys(nativeModule), "createRequire") ~= -1 then
-- 		Module.createRequire = createRequire
-- 	end
-- 	if Array.indexOf(Object.keys(nativeModule), "createRequireFromPath") ~= -1 then
-- 		Module.createRequireFromPath = function(self: any, filename: string | URL)
-- 			if typeof(filename) ~= "string" then
-- 				local error_ = TypeError.new(
-- 					("The argument 'filename' must be string. Received '%s'.%s"):format(
-- 						tostring(filename),
-- 						if instanceof(filename, URL) then " Use createRequire for URL filename." else ""
-- 					)
-- 				) -- @ts-expect-error
-- 				error_.code = "ERR_INVALID_ARG_TYPE"
-- 				error(error_)
-- 			end
-- 			return createRequire(filename)
-- 		end
-- 	end
-- 	if Array.indexOf(Object.keys(nativeModule), "syncBuiltinESMExports") ~= -1 then
-- 		-- cast since TS seems very confused about whether it exists or not
-- 		(Module :: any).syncBuiltinESMExports = function(self: any) end
-- 	end
-- 	self._moduleImplementation = Module
-- 	return Module
-- end
-- function Runtime_private:_generateMock(from: Config_Path, moduleName: ModuleScript)
-- 	local ref = self._resolver:resolveStubModuleName(from, moduleName)
-- 	local modulePath = Boolean.toJSBoolean(ref) and ref
-- 		or self:_resolveModule(from, moduleName, { conditions = self.cjsConditions })
-- 	if not Boolean.toJSBoolean(self._mockMetaDataCache:has(modulePath)) then
-- 		-- This allows us to handle circular dependencies while generating an
-- 		-- automock
-- 		local refArg0 = modulePath
-- 		local ref = self._moduleMocker:getMetadata({})
-- 		self._mockMetaDataCache:set(refArg0, Boolean.toJSBoolean(ref) and ref or {}) -- In order to avoid it being possible for automocking to potentially
-- 		-- cause side-effects within the module environment, we need to execute
-- 		-- the module in isolation. This could cause issues if the module being
-- 		-- mocked has calls into side-effectful APIs on another module.
-- 		local origMockRegistry = self._mockRegistry
-- 		local origModuleRegistry = self._moduleRegistry
-- 		self._mockRegistry = Map.new()
-- 		self._moduleRegistry = Map.new()
-- 		local moduleExports = self:requireModule(from, moduleName) -- Restore the "real" module/mock registries
-- 		self._mockRegistry = origMockRegistry
-- 		self._moduleRegistry = origModuleRegistry
-- 		local mockMetadata = self._moduleMocker:getMetadata(moduleExports)
-- 		if
-- 			mockMetadata == nil --[[ ROBLOX CHECK: loose equality used upstream ]]
-- 		then
-- 			error(
-- 				Error.new(
-- 					("Failed to get mock metadata: %s\n\n"):format(tostring(modulePath))
-- 						.. "See: https://jestjs.io/docs/manual-mocks#content"
-- 				)
-- 			)
-- 		end
-- 		self._mockMetaDataCache:set(modulePath, mockMetadata)
-- 	end
-- 	return self._moduleMocker:generateFromMetadata( -- added above if missing
-- 		self._mockMetaDataCache:get(modulePath) :: any
-- 	)
-- end
-- ROBLOX deviation END
function Runtime_private:_shouldMock(
	-- ROBLOX deviation: accept ModuleScript instead of string
	from: ModuleScript,
	moduleName: ModuleScript,
	explicitShouldMock: Map<ModuleScript, boolean>,
	-- ROBLOX deviation END
	options: ResolveModuleConfig
): boolean
	-- ROBLOX deviation START: using module script instead of string moduleName & key is moduleId since path is not available
	-- local moduleID = self._resolver:getModuleID(self._virtualMocks, from, moduleName, options)
	-- local key = from + path.delimiter + moduleID
	local moduleID = moduleName
	-- ROBLOX deviation END
	if explicitShouldMock:has(moduleID) then
		-- guaranteed by `has` above
		-- ROBLOX deviation START: cast as boolean
		-- return explicitShouldMock:get(moduleID) :: any
		return explicitShouldMock:get(moduleID) :: boolean
		-- ROBLOX deviation END
	end
	if
		-- ROBLOX deviation START: isCoreModule is not available in luau - nodeJS specific
		-- Boolean.toJSBoolean((function()
		-- 	local ref = not Boolean.toJSBoolean(self._shouldAutoMock) or self._resolver:isCoreModule(moduleName)
		-- 	return Boolean.toJSBoolean(ref) and ref or self._shouldUnmockTransitiveDependenciesCache:get(key)
		-- end)())
		not self._shouldAutoMock
		-- ROBLOX deviation END
	then
		return false
	end
	if self._shouldMockModuleCache:has(moduleID) then
		-- guaranteed by `has` above
		-- ROBLOX deviation START: cast as boolean
		-- return self._shouldMockModuleCache:get(moduleID) :: any
		return self._shouldMockModuleCache:get(moduleID) :: boolean
		-- ROBLOX deviation END
	end

	-- ROBLOX deviation START: skipped
	-- local modulePath
	-- do --[[ ROBLOX COMMENT: try-catch block conversion ]]
	-- 	local ok, result, hasReturned = xpcall(function()
	-- 		modulePath = self:_resolveModule(from, moduleName, options)
	-- 	end, function(e: unknown)
	-- 		local manualMock = self._resolver:getMockModule(from, moduleName)
	-- 		if Boolean.toJSBoolean(manualMock) then
	-- 			self._shouldMockModuleCache:set(moduleID, true)
	-- 			return true
	-- 		end
	-- 		error(e)
	-- 	end)
	-- 	if hasReturned then
	-- 		return result
	-- 	end
	-- end
	-- if
	-- 	Boolean.toJSBoolean(
	-- 		if Boolean.toJSBoolean(self._unmockList) then self._unmockList:test(modulePath) else self._unmockList
	-- 	)
	-- then
	-- 	self._shouldMockModuleCache:set(moduleID, false)
	-- 	return false
	-- end -- transitive unmocking for package managers that store flat packages (npm3)
	-- local currentModuleID = self._resolver:getModuleID(self._virtualMocks, from, nil, options)
	-- if
	-- 	Boolean.toJSBoolean(self._transitiveShouldMock:get(currentModuleID) == false or (function()
	-- 		local ref = Array.includes(from, NODE_MODULES) --[[ ROBLOX CHECK: check if 'from' is an Array ]]
	-- 		local ref = if Boolean.toJSBoolean(ref)
	-- 			then Array.includes(modulePath, NODE_MODULES) --[[ ROBLOX CHECK: check if 'modulePath' is an Array ]]
	-- 			else ref
	-- 		return if Boolean.toJSBoolean(ref)
	-- 			then (function()
	-- 				local ref = if Boolean.toJSBoolean(self._unmockList)
	-- 					then self._unmockList:test(from)
	-- 					else self._unmockList
	-- 				return Boolean.toJSBoolean(ref) and ref or explicitShouldMock:get(currentModuleID) == false
	-- 			end)()
	-- 			else ref
	-- 	end)())
	-- then
	-- 	self._transitiveShouldMock:set(moduleID, false)
	-- 	self._shouldUnmockTransitiveDependenciesCache:set(key, true)
	-- 	return false
	-- end
	-- self._shouldMockModuleCache:set(moduleID, true)
	-- ROBLOX deviation END
	return true
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:_createRequireImplementation(from: InitialModule, options: InternalModuleOptions?): NodeRequire
-- 	local function resolve(moduleName: ModuleScript, resolveOptions: ResolveOptions?)
-- 		local resolved = self:_requireResolve(from.filename, moduleName, resolveOptions)
-- 		if
-- 			Boolean.toJSBoolean((function()
-- 				local ref = if typeof(resolveOptions) == "table"
-- 					then resolveOptions[JEST_RESOLVE_OUTSIDE_VM_OPTION]
-- 					else nil
-- 				return if Boolean.toJSBoolean(ref)
-- 					then if typeof(options) == "table" then options.isInternalModule else nil
-- 					else ref
-- 			end)())
-- 		then
-- 			return createOutsideJestVmPath(resolved)
-- 		end
-- 		return resolved
-- 	end
-- 	resolve.paths = function(_self: any, moduleName: ModuleScript)
-- 		return self:_requireResolvePaths(from.filename, moduleName)
-- 	end
-- 	local moduleRequire = if Boolean.toJSBoolean(if typeof(options) == "table" then options.isInternalModule else nil)
-- 		then function(moduleName: ModuleScript)
-- 			return self:requireInternalModule(from.filename, moduleName)
-- 		end
-- 		else self.requireModuleOrMock:bind(self, from.filename) :: NodeRequire
-- 	moduleRequire.extensions = Object.create(nil)
-- 	moduleRequire.resolve = resolve
-- 	moduleRequire.cache = (function()
-- 		-- TODO: consider warning somehow that this does nothing. We should support deletions, anyways
-- 		local function notPermittedMethod()
-- 			return true
-- 		end
-- 		return Proxy.new(Object.create(nil), {
-- 			defineProperty = notPermittedMethod,
-- 			deleteProperty = notPermittedMethod,
-- 			get = function(_target, key)
-- 				return if typeof(key) == "string" then self._moduleRegistry:get(key) else nil
-- 			end,
-- 			getOwnPropertyDescriptor = function(self)
-- 				return { configurable = true, enumerable = true }
-- 			end,
-- 			has = function(_target, key)
-- 				return typeof(key) == "string" and self._moduleRegistry:has(key)
-- 			end,
-- 			ownKeys = function()
-- 				return Array.from(self._moduleRegistry:keys())
-- 			end,
-- 			set = notPermittedMethod,
-- 		})
-- 	end)()
-- 	Object.defineProperty(moduleRequire, "main", { enumerable = true, value = self._mainModule })
-- 	return moduleRequire
-- end
-- ROBLOX deviation END

-- ROBLOX deviation START: using ModuleScript instead of Config_Path
-- function Runtime_private:_createJestObjectFor(from: Config_Path): Jest
function Runtime_private:_createJestObjectFor(from: ModuleScript): Jest
	-- ROBLOX deviation END
	-- ROBLOX deviation START: additional predefined variables
	local setMockFactory
	local jestObject: Jest
	-- ROBLOX deviation END
	-- ROBLOX deviation START: not implemented yet
	-- local function disableAutomock()
	-- 	self._shouldAutoMock = false
	-- 	return jestObject
	-- end
	-- local function enableAutomock()
	-- 	self._shouldAutoMock = true
	-- 	return jestObject
	-- end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	local function unmock(moduleName: ModuleScript)
		-- ROBLOX deviation END
		-- ROBLOX deviation START: using module script instead of string moduleName
		-- local moduleID =
		-- 	self._resolver:getModuleID(self._virtualMocks, from, moduleName, { conditions = self.cjsConditions })
		local moduleID = moduleName
		-- ROBLOX deviation END
		self._explicitShouldMock:set(moduleID, false)
		return jestObject
	end
	-- ROBLOX deviation START: not implemented yet
	-- local function deepUnmock(moduleName: ModuleScript)
	-- 	local moduleID =
	-- 		self._resolver:getModuleID(self._virtualMocks, from, moduleName, { conditions = self.cjsConditions })
	-- 	self._explicitShouldMock:set(moduleID, false)
	-- 	self._transitiveShouldMock:set(moduleID, false)
	-- 	return jestObject
	-- end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: using ModuleScript instead of string
	-- local mock: typeof((({} :: any) :: Jest).mock)
	-- function mock(moduleName, mockFactory, options)
	local function mock(moduleName: ModuleScript, mockFactory, options)
		-- ROBLOX deviation END
		if mockFactory ~= nil then
			return setMockFactory(moduleName, mockFactory, options)
		end
		-- ROBLOX deviation START:
		-- local moduleID =
		-- 	self._resolver:getModuleID(self._virtualMocks, from, moduleName, { conditions = self.cjsConditions })
		local moduleID = moduleName
		-- ROBLOX deviation END
		self._explicitShouldMock:set(moduleID, true)
		return jestObject
	end
	-- ROBLOX deviation START: using ModuleScript instead of string and predefine function
	function setMockFactory(moduleName: ModuleScript, mockFactory: () -> unknown, options: { virtual: boolean? }?)
		-- ROBLOX deviation END
		self:setMock(from, moduleName, mockFactory, options)
		return jestObject
	end
	-- ROBLOX deviation START: not implemented yet
	-- local mockModule: typeof((({} :: any) :: Jest).unstable_mockModule)
	-- function mockModule(moduleName, mockFactory, options)
	-- 	if typeof(mockFactory) ~= "function" then
	-- 		error(Error.new("`unstable_mockModule` must be passed a mock factory"))
	-- 	end
	-- 	self:setModuleMock(from, moduleName, mockFactory, options)
	-- 	return jestObject
	-- end
	-- ROBLOX deviation END
	local function clearAllMocks()
		self:clearAllMocks()
		return jestObject
	end
	local function resetAllMocks()
		self:resetAllMocks()
		return jestObject
	end
	local function restoreAllMocks()
		self:restoreAllMocks()
		return jestObject
	end
	local function _getFakeTimers()
		-- ROBLOX deviation START: no legacy timers
		-- if
		-- 	Boolean.toJSBoolean(
		-- 		Boolean.toJSBoolean(self.isTornDown) and self.isTornDown
		-- 			or not Boolean.toJSBoolean(
		-- 				Boolean.toJSBoolean(self._environment.fakeTimers) and self._environment.fakeTimers
		-- 					or self._environment.fakeTimersModern
		-- 			)
		-- 	)
		-- then
		-- 	self:_logFormattedReferenceError(
		-- 		"You are trying to access a property or method of the Jest environment after it has been torn down."
		-- 	)
		-- 	process.exitCode = 1
		-- end
		-- return self._fakeTimersImplementation :: any
		return self._fakeTimersImplementation
		-- ROBLOX deviation END
	end
	-- ROBLOX deviation START: simplify function declaration
	-- local useFakeTimers: typeof((({} :: any) :: Jest).useFakeTimers)
	-- function useFakeTimers(type__: string?)
	local function useFakeTimers(): Jest
		-- ROBLOX deviation END
		-- ROBLOX deviation START: no legacy timers
		-- local type_: string = if type__ ~= nil then type__ else "modern"
		-- if type_ == "legacy" then
		-- 	self._fakeTimersImplementation = self._environment.fakeTimers
		-- else
		-- 	self._fakeTimersImplementation = self._environment.fakeTimersModern
		-- end
		-- (self._fakeTimersImplementation :: any):useFakeTimers()
		self._fakeTimersImplementation:useFakeTimers()
		-- ROBLOX deviation END
		return jestObject
	end
	local function useRealTimers()
		_getFakeTimers():useRealTimers()
		return jestObject
	end
	local function resetModules()
		self:resetModules()
		return jestObject
	end
	local function isolateModules(fn: () -> ())
		self:isolateModules(fn)
		return jestObject
	end
	-- ROBLOX deviation START: no built-in bind support in Luau
	local fn = function(...)
		return self._moduleMocker:fn(...)
	end
	local spyOn = function(...)
		return self._moduleMocker:spyOn(...)
	end

	-- local fn = self._moduleMocker.fn:bind(self._moduleMocker)
	-- local spyOn = self._moduleMocker.spyOn:bind(self._moduleMocker)
	-- ROBLOX deviation END

	-- ROBLOX deviation START: not implemented yet
	-- local ref = if typeof(self._moduleMocker.mocked) == "table" then self._moduleMocker.mocked.bind else nil
	-- local ref = if ref ~= nil then ref(self._moduleMocker) else nil
	-- local mocked = if ref ~= nil
	-- 	then ref
	-- 	else function()
	-- 		error(Error.new("Your test environment does not support `mocked`, please update it."))
	-- 	end
	-- local function setTimeout(timeout: number)
	-- 	if Boolean.toJSBoolean(self._environment.global.jasmine) then
	-- 		self._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout
	-- 	else
	-- 		-- @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587
	-- 		self._environment.global[tostring(testTimeoutSymbol)] = timeout
	-- 	end
	-- 	return jestObject
	-- end
	-- local function retryTimes(numTestRetries: number)
	-- 	-- @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587
	-- 	self._environment.global[tostring(retryTimesSymbol)] = numTestRetries
	-- 	return jestObject
	-- end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: variable predefined
	-- local jestObject: Jest = {
	jestObject = {
		-- ROBLOX deviation end
		advanceTimersByTime = function(msToRun: number)
			return _getFakeTimers():advanceTimersByTime(msToRun)
		end,
		advanceTimersToNextTimer = function(steps: number?)
			return _getFakeTimers():advanceTimersToNextTimer(steps)
		end,
		-- ROBLOX deviation START: additional method to allow mocking of game-engine timer behavior
		getEngineFrameTime = function()
			return _getFakeTimers():getEngineFrameTime()
		end,
		setEngineFrameTime = function(frameTimeMs: number)
			return _getFakeTimers():setEngineFrameTime(frameTimeMs)
		end,
		-- ROBLOX deviation END
		-- ROBLOX TODO START: not implemented yet
		-- autoMockOff = disableAutomock,
		-- autoMockOn = enableAutomock,
		-- ROBLOX TODO END
		clearAllMocks = clearAllMocks,
		clearAllTimers = function()
			return _getFakeTimers():clearAllTimers()
		end,
		-- ROBLOX TODO START: not implemented yet
		-- createMockFromModule = function(moduleName: ModuleScript)
		-- 	return self:_generateMock(from, moduleName)
		-- end,
		-- deepUnmock = deepUnmock,
		-- disableAutomock = disableAutomock,
		-- ROBLOX deviation END
		doMock = mock,
		dontMock = unmock,
		-- ROBLOX TODO START: not implemented yet
		-- enableAutomock = enableAutomock,
		-- ROBLOX TODO END
		fn = fn,
		-- ROBLOX TODO START: not implemented yet
		-- genMockFromModule = function(moduleName: ModuleScript)
		-- 	return self:_generateMock(from, moduleName)
		-- end,
		-- ROBLOX TODO END
		getRealSystemTime = function()
			local fakeTimers = _getFakeTimers()
			if fakeTimers == self._environment.fakeTimersModern then
				return fakeTimers:getRealSystemTime()
			else
				error(TypeError.new("getRealSystemTime is not available when not using modern timers"))
			end
		end,
		getTimerCount = function()
			return _getFakeTimers():getTimerCount()
		end,
		-- ROBLOX deviation: mocking globals
		globalEnv = self._globalMocker.envObject,
		isMockFunction = self._moduleMocker.isMockFunction,
		isolateModules = isolateModules,
		mock = mock,
		-- ROBLOX deviation START: not implemented yet
		-- mocked = mocked,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: issue roblox/js-to-lua #686 - no built-in bind support in Luau
		-- requireActual = self.requireActual:bind(self, from),
		requireActual = function(moduleName: ModuleScript | string)
			if typeof(moduleName) == "string" then
				-- Disabling this at the surface level of the API until we have
				-- deeper support in Jest.
				error("Require-by-string is not enabled for use inside Jest at this time.")
			end
			return self:requireActual(from, moduleName)
		end,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: not implemented yet
		-- requireMock = self.requireMock:bind(self, from),
		-- ROBLOX deviation END
		resetAllMocks = resetAllMocks,
		resetModules = resetModules,
		restoreAllMocks = restoreAllMocks,
		-- ROBLOX deviation START: not implemented yet
		-- retryTimes = retryTimes,
		-- runAllImmediates = function()
		-- 	local fakeTimers = _getFakeTimers()
		-- 	if fakeTimers == self._environment.fakeTimers then
		-- 		fakeTimers:runAllImmediates()
		-- 	else
		-- 		error(TypeError.new("runAllImmediates is not available when using modern timers"))
		-- 	end
		-- end,
		-- ROBLOX deviation END
		runAllTicks = function()
			return _getFakeTimers():runAllTicks()
		end,
		runAllTimers = function()
			return _getFakeTimers():runAllTimers()
		end,
		runOnlyPendingTimers = function()
			return _getFakeTimers():runOnlyPendingTimers()
		end,
		-- ROBLOX deviation START: additional property
		-- ROBLOX TODO: remove when we don't need to manually inject fake timers into tests
		jestTimers = _getFakeTimers(),
		-- ROBLOX deviation END
		-- ROBLOX deviation START: using ModuleScript instead of string moduleName & virtual mocks not supported
		setMock = function(moduleName: ModuleScript, mock: unknown)
			-- ROBLOX deviation END
			return setMockFactory(moduleName, function()
				return mock
			end)
		end,
		setSystemTime = function(now: (number | DateTime)?)
			local fakeTimers = _getFakeTimers()
			if fakeTimers == self._environment.fakeTimersModern then
				fakeTimers:setSystemTime(now)
			else
				error(TypeError.new("setSystemTime is not available when not using modern timers"))
			end
		end,
		-- ROBLOX TODO START: not implemented yet
		-- setTimeout = setTimeout,
		-- ROBLOX TODO END
		spyOn = spyOn,
		unmock = unmock,
		-- ROBLOX TODO START: not implemented yet
		-- unstable_mockModule = mockModule,
		-- ROBLOX TODO END
		useFakeTimers = useFakeTimers,
		useRealTimers = useRealTimers,
	}
	-- ROBLOX deviation START: explicitly casting jestObject
	-- return jestObject
	return jestObject :: Jest
	-- ROBLOX deviation END
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:_logFormattedReferenceError(errorMessage: string)
-- 	local testPath = if Boolean.toJSBoolean(self._testPath)
-- 		then (" From %s."):format(tostring(slash(path:relative(self._config.rootDir, self._testPath))))
-- 		else ""
-- 	local originalStack = Array.join(
-- 		Array.filter(
-- 			(ReferenceError.new(("%s%s"):format(tostring(errorMessage), tostring(testPath))).stack :: any):split("\n"), -- Remove this file from the stack (jest-message-utils will keep one line)
-- 			function(line)
-- 				return Array.indexOf(line, __filename) --[[ ROBLOX CHECK: check if 'line' is an Array ]]
-- 					== -1
-- 			end
-- 		), --[[ ROBLOX CHECK: check if 'new ReferenceError(`${errorMessage}${testPath}`).stack!.split('\n')' is an Array ]]
-- 		"\n"
-- 	)
-- 	local message, stack
-- 	do
-- 		local ref = separateMessageFromStack(originalStack)
-- 		message, stack = ref.message, ref.stack
-- 	end
-- 	console.error(
-- 		("\n%s\n"):format(tostring(message))
-- 			.. tostring(formatStackTrace(stack, self._config, { noStackTrace = false }))
-- 	)
-- end
-- function Runtime_private:wrapCodeInModuleWrapper(content: string)
-- 	return tostring(self:constructModuleWrapperStart() + content) .. "\n}});"
-- end
-- function Runtime_private:constructModuleWrapperStart()
-- 	local args = self:constructInjectedModuleParameters()
-- 	return '({"'
-- 		.. tostring(EVAL_RESULT_VARIABLE)
-- 		.. ('":function(%s){'):format(tostring(Array.join(args, ",") --[[ ROBLOX CHECK: check if 'args' is an Array ]]))
-- end
-- function Runtime_private:constructInjectedModuleParameters(): Array<string>
-- 	return Array.filter(
-- 		Array.concat({}, {
-- 			"module",
-- 			"exports",
-- 			"require",
-- 			"__dirname",
-- 			"__filename",
-- 			if Boolean.toJSBoolean(self._config.injectGlobals) then "jest" else nil,
-- 		}, Array.spread(self._config.extraGlobals)),
-- 		notEmpty
-- 	)
-- end
-- function Runtime_private:handleExecutionError(e: Error, module: Module): never
-- 	local moduleNotFoundError = Resolver:tryCastModuleNotFoundError(e)
-- 	if Boolean.toJSBoolean(moduleNotFoundError) then
-- 		if not Boolean.toJSBoolean(moduleNotFoundError.requireStack) then
-- 			moduleNotFoundError.requireStack = { Boolean.toJSBoolean(module.filename) and module.filename or module.id }
-- 			do
-- 				local cursor = module.parent
-- 				while cursor do
-- 					table.insert(
-- 						moduleNotFoundError.requireStack,
-- 						Boolean.toJSBoolean(cursor.filename) and cursor.filename or cursor.id
-- 					) --[[ ROBLOX CHECK: check if 'moduleNotFoundError.requireStack' is an Array ]]
-- 					cursor = cursor.parent
-- 				end
-- 			end
-- 			moduleNotFoundError:buildMessage(self._config.rootDir)
-- 		end
-- 		error(moduleNotFoundError)
-- 	end
-- 	error(e)
-- end
-- function Runtime_private:getGlobalsForCjs(from: Config_Path): JestGlobalsWithJest
-- 	local jest = self.jestObjectCaches:get(from)
-- 	invariant(jest, "There should always be a Jest object already")
-- 	return Object.assign({}, self:getGlobalsFromEnvironment(), { jest = jest })
-- end
-- function Runtime_private:getGlobalsForEsm(from: Config_Path, context: VMContext): Promise<VMModule>
-- 	local jest = self.jestObjectCaches:get(from)
-- 	if not Boolean.toJSBoolean(jest) then
-- 		jest = self:_createJestObjectFor(from)
-- 		self.jestObjectCaches:set(from, jest)
-- 	end
-- 	local globals: JestGlobalsWithJest = Object.assign({}, self:getGlobalsFromEnvironment(), { jest = jest })
-- 	local module = SyntheticModule.new(Object.keys(globals), function()
-- 		Array.forEach(Object.entries(globals), function(ref0)
-- 			local key, value = table.unpack(ref0, 1, 2)
-- 			-- @ts-expect-error: TS doesn't know what `this` is
-- 			self:setExport(key, value)
-- 		end) --[[ ROBLOX CHECK: check if 'Object.entries(globals)' is an Array ]]
-- 	end, { context = context, identifier = "@jest/globals" })
-- 	return evaluateSyntheticModule(module)
-- end
-- ROBLOX deviation END
function Runtime_private:getGlobalsFromEnvironment(): JestGlobals
	if self.jestGlobals then
		-- ROBLOX deviation START: using table.clone for better performance
		-- return Object.assign({}, self.jestGlobals)
		return table.clone(self.jestGlobals)
		-- ROBLOX deviation END
	end

	-- ROBLOX deviation START: additional extracted variables
	local jestSnapshot = self:requireModuleOrMock(Packages.JestSnapshot)
	local jestExpect = self:requireModuleOrMock(Packages.Expect)
	-- ROBLOX deviation END

	return {
		-- ROBLOX deviation START: skipped for now
		-- afterAll = self._environment.global.afterAll,
		-- afterEach = self._environment.global.afterEach,
		-- beforeAll = self._environment.global.beforeAll,
		-- beforeEach = self._environment.global.beforeEach,
		-- describe = self._environment.global.describe,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use extracted variable
		-- expect = self._environment.global.expect :: any,
		expect = jestExpect,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: additional property
		expectExtended = jestExpect,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: skipped for now
		-- fdescribe = self._environment.global.fdescribe,
		-- fit = self._environment.global.fit,
		-- it = self._environment.global.it,
		-- test = self._environment.global.test,
		-- xdescribe = self._environment.global.xdescribe,
		-- xit = self._environment.global.xit,
		-- xtest = self._environment.global.xtest,
		-- ROBLOX deviation END
		-- ROBLOX deviation START: additional property
		jestSnapshot = {
			toMatchSnapshot = jestSnapshot.toMatchSnapshot,
			toThrowErrorMatchingSnapshot = jestSnapshot.toThrowErrorMatchingSnapshot,
		},
		-- ROBLOX deviation END
	}
end
-- ROBLOX deviation START: skipped
-- function Runtime_private:readFile(filename: Config_Path): string
-- 	local source = self._cacheFS:get(filename)
-- 	if not Boolean.toJSBoolean(source) then
-- 		source = fs:readFileSync(filename, "utf8")
-- 		self._cacheFS:set(filename, source)
-- 	end
-- 	return source
-- end
-- ROBLOX deviation END
function Runtime_private:setGlobalsForRuntime(globals: JestGlobals): ()
	self.jestGlobals = globals
end
-- ROBLOX deviation START: skipped
-- exports.default = Runtime
-- local function invariant(
-- 	condition: unknown,
-- 	message: string?
-- ): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ asserts condition ]]
-- 	if not Boolean.toJSBoolean(condition) then
-- 		error(Error.new(message))
-- 	end
-- end
-- local function notEmpty<T>(
-- 	value: T | nil --[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]] | nil
-- ): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ value is T ]]
-- 	return value ~= nil and value ~= nil
-- end
-- local function evaluateSyntheticModule(module: SyntheticModule)
-- 	return Promise.resolve():andThen(function()
-- 		module
-- 			:link(function()
-- 				error(Error.new("This should never happen"))
-- 			end)
-- 			:expect()
-- 		module:evaluate():expect()
-- 		return module
-- 	end)
-- end
-- ROBLOX deviation END
-- ROBLOX deviation START: returning Runtime directly instead of exports.default
-- return exports
return Runtime
-- ROBLOX deviation END
]]></string>
            </Properties>
            <Item class="Folder" referent="369">
              <Properties>
                <string name="Name">__mocks__</string>
              </Properties>
              <Item class="ModuleScript" referent="370">
                <Properties>
                  <string name="Name">createRuntime</string>
                  <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/jest-runtime/src/__mocks__/createRuntime.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local Packages = script.Parent.Parent.Parent
local Promise = require(Packages.Promise)
-- ROBLOX deviation START: not needed
-- local path = require(Packages.path).default
-- local Map = LuauPolyfill.Map
-- local JestGlobals = require(Packages.Dev.JestGlobals)
-- local expect = JestGlobals.expect
-- local tmpdir = require(Packages.os).tmpdir
-- local makeProjectConfig = require(Packages["@jest"]["test-utils"]).makeProjectConfig
-- local createScriptTransformer = require(Packages["@jest"].transform).createScriptTransformer
-- local NodeEnvironment = require(Packages["jest-environment-node"]).default
-- local JestEnvironmentLuau = require(Packages.Dev.JestEnvironmentLuau).default
-- local tryRealpath = require(Packages.JestUtil).tryRealpath
-- ROBLOX deviation END
local Runtime = require(script.Parent.Parent) -- Copy from jest-config (since we don't want to depend on this package)
-- ROBLOX deviation START: not used
-- local function getCacheDirectory()
-- 	local getuid = process.getuid
-- 	local tmpdirPath = Array.join(path, tryRealpath(tmpdir()), "jest") --[[ ROBLOX CHECK: check if 'path' is an Array ]]
-- 	if
-- 		getuid == nil --[[ ROBLOX CHECK: loose equality used upstream ]]
-- 	then
-- 		return tmpdirPath
-- 	else
-- 		-- On some platforms tmpdir() is `/tmp`, causing conflicts between different
-- 		-- users and permission issues. Adding an additional subdivision by UID can
-- 		-- help.
-- 		return ("%s_%s"):format(tostring(tmpdirPath), tostring(getuid(process):toString(36)))
-- 	end
-- end
-- local function setupModuleNameMapper(config, rootDir)
-- 	if Boolean.toJSBoolean(if Boolean.toJSBoolean(config) then config.moduleNameMapper else config) then
-- 		return Array.map(Object.keys(config.moduleNameMapper), function(regex)
-- 			local item = if Boolean.toJSBoolean(config.moduleNameMapper)
-- 				then config.moduleNameMapper[tostring(regex)]
-- 				else config.moduleNameMapper
-- 			return if Boolean.toJSBoolean(item) then { regex, item:replace("<rootDir>", rootDir) } else item
-- 		end) --[[ ROBLOX CHECK: check if 'Object.keys(config.moduleNameMapper)' is an Array ]]
-- 	end
-- 	return {}
-- end
-- local function setupTransform(config, rootDir)
-- 	if Boolean.toJSBoolean(if typeof(config) == "table" then config.transform else nil) then
-- 		local transform = config.transform
-- 		return Array.map(Object.keys(transform), function(regex)
-- 			return { regex, path:resolve(rootDir, transform[tostring(regex)]) }
-- 		end) --[[ ROBLOX CHECK: check if 'Object.keys(transform)' is an Array ]]
-- 	end
-- 	return { { "^.+\\.[jt]sx?$", require_:resolve("babel-jest") } }
-- end
-- ROBLOX deviation END

-- ROBLOX deviation START: get config types
local JestTypes = require(Packages.JestTypes)
type Config_ProjectConfig = JestTypes.Config_ProjectConfig
-- ROBLOX deviation END

return function( -- ROBLOX deviation START: arguments not needed. filename only kept to preserve this createRuntime's call api
	-- self: any,
	filename: ModuleScript,
	config: Config_ProjectConfig
	-- ROBLOX deviation END
)
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: custom implementation
		-- local rootDir = path:resolve(path:dirname(filename), "test_root")
		-- local moduleNameMapper = setupModuleNameMapper(config, rootDir)
		-- local transform = setupTransform(config, rootDir)
		-- config = makeProjectConfig(Object.assign({}, {
		-- 	cacheDirectory = getCacheDirectory(),
		-- 	cwd = path:resolve(__dirname, "..", "..", "..", ".."),
		-- 	haste = {
		-- 		hasteImplModulePath = path:resolve(
		-- 			__dirname,
		-- 			"..",
		-- 			"..",
		-- 			"..",
		-- 			"jest-haste-map",
		-- 			"src",
		-- 			"__tests__",
		-- 			"haste_impl.js"
		-- 		),
		-- 	},
		-- 	moduleDirectories = { "node_modules" },
		-- 	moduleFileExtensions = { "js", "jsx", "ts", "tsx", "json", "node" },
		-- 	name = "Runtime-"
		-- 		.. tostring(
		-- 			filename:replace(
		-- 				error("not implemented"), --[[ ROBLOX TODO: Unhandled node for type: RegExpLiteral ]] --[[ /\W/ ]]
		-- 				"-"
		-- 			)
		-- 		)
		-- 		.. ".tests",
		-- 	rootDir = rootDir,
		-- }, config, { moduleNameMapper = moduleNameMapper, transform = transform }))
		-- if not Boolean.toJSBoolean(config.roots.length) then
		-- 	config.roots = { config.rootDir }
		-- end
		-- local environment = NodeEnvironment.new(config)
		-- environment.global.console = console
		-- local hasteMap = Runtime:createHasteMap(config, { maxWorkers = 1, resetCache = false }):build():expect()
		-- local cacheFS = Map.new()
		-- local scriptTransformer = createScriptTransformer(config, cacheFS):expect()
		-- local runtime = Runtime.new(
		-- 	config,
		-- 	environment,
		-- 	Runtime:createResolver(config, hasteMap.moduleMap),
		-- 	scriptTransformer,
		-- 	cacheFS,
		-- 	{
		-- 		changedFiles = nil,
		-- 		collectCoverage = false,
		-- 		collectCoverageFrom = {},
		-- 		collectCoverageOnlyFrom = nil,
		-- 		coverageProvider = "v8",
		-- 		sourcesRelatedToTestsInChangedFiles = nil,
		-- 	},
		-- 	filename
		-- )
		-- for _, path in config.setupFiles do
		-- 	local esm = runtime:unstable_shouldLoadAsEsm(path)
		-- 	if Boolean.toJSBoolean(esm) then
		-- 		runtime:unstable_importModule(path):expect()
		-- 	else
		-- 		runtime:requireModule(path)
		-- 	end
		-- end
		-- runtime.__mockRootPath = Array.join(path, config.rootDir, "root.js") --[[ ROBLOX CHECK: check if 'path' is an Array ]]
		-- runtime.__mockSubdirPath = Array.join(path, config.rootDir, "subdir2", "module_dir", "module_dir_module.js") --[[ ROBLOX CHECK: check if 'path' is an Array ]]
		local runtime = Runtime.new(config); -- ROBLOX NOTE: this is JS file upstream so no type checking is performed
		(runtime :: any).__mockRootPath = script.Parent.Parent.__tests__.test_root
		-- ROBLOX deviation END
		return runtime
	end)
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="371">
              <Properties>
                <string name="Name">_types</string>
                <string name="Source"><![CDATA[--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
-- ROBLOX NOTE: Not paired with upstream. Just using for the "Jest Object" type

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local JestFakeTimers = require(Packages.JestFakeTimers)
type FakeTimers = JestFakeTimers.FakeTimers

local moduleMockerModule = require(Packages.JestMock)
type ModuleMocker = moduleMockerModule.ModuleMocker

export type MockFactory = () -> ...unknown

export type Jest = {
	-- autoMockOn: () -> Jest,
	-- autoMockOff: () -> Jest,
	-- disableAutomock: () -> Jest,
	-- enableAutomock: () -> Jest,
	-- mock: (scriptInstance: ModuleScript, mockFactory: MockFactory, options: any) -> Jest,
	clearAllMocks: () -> Jest,
	resetAllMocks: () -> Jest,
	restoreAllMocks: () -> Jest,
	useFakeTimers: () -> Jest,
	useRealTimers: () -> Jest,
	resetModules: () -> Jest,
	isolateModules: (fn: () -> ()) -> Jest,
	fn: () -> ModuleMocker,
	-- genMockFromModule: (scriptInstance: ModuleScript) -> any,
	getRealSystemTime: () -> (),
	getTimerCount: () -> number,
	runAllTicks: () -> (),
	runAllTimers: () -> (),
	runOnlyPendingTimers: () -> (),
	-- setMock: (scriptInstance: ModuleScript, mock: unknown, options: { virtual: boolean? }?) -> Jest,
	setSystemTime: (now: (number | DateTime)?) -> (),
	setTimeout: any,
}

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="372">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-runtime/src/types.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local typesModule = require(Packages.JestTypes)
type Config_ProjectConfig = typesModule.Config_ProjectConfig

export type Context = {
	config: Config_ProjectConfig,
	-- ROBLOX deviation START: no supported
	-- hasteFS: HasteFS,
	-- moduleMap: ModuleMap,
	-- resolver: Resolver,
	-- ROBLOX deviation END
}

return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="373">
            <Properties>
              <string name="Name">JestSnapshot</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

-- ROBLOX deviation: omitting imports for file system interaction

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local instanceof = LuauPolyfill.instanceof
local AssertionError = LuauPolyfill.AssertionError

-- ROBLOX deviation START: additional dependencies
local RobloxShared = require(Packages.RobloxShared)
local cleanLoadStringStack = RobloxShared.cleanLoadStringStack
-- ROBLOX deviation END

local getType = require(Packages.JestGetType).getType

-- ROBLOX TODO: ADO-1633 fix Jest Types imports
-- local Config = require(Packages.JestTypes).Config
type ConfigPath = string

local JestMatcherUtils = require(Packages.JestMatcherUtils)
local BOLD_WEIGHT = JestMatcherUtils.BOLD_WEIGHT
local EXPECTED_COLOR = JestMatcherUtils.EXPECTED_COLOR
-- local MatcherHintOptions = JestMatcherUtils.MatcherHintOptions
local RECEIVED_COLOR = JestMatcherUtils.RECEIVED_COLOR
local matcherErrorMessage = JestMatcherUtils.matcherErrorMessage
local matcherHint = JestMatcherUtils.matcherHint
local printWithType = JestMatcherUtils.printWithType
local stringify = JestMatcherUtils.stringify

local SnapshotResolverModule = require(script.SnapshotResolver)
local EXTENSION = SnapshotResolverModule.EXTENSION
type JestSnapshotResolver = SnapshotResolverModule.SnapshotResolver
local buildSnapshotResolver = SnapshotResolverModule.buildSnapshotResolver
local isSnapshotPath = SnapshotResolverModule.isSnapshotPath

local SnapshotStateModule = require(CurrentModule.State)
local SnapshotState = SnapshotStateModule.default
type SnapshotState = SnapshotStateModule.SnapshotState

local plugins = require(CurrentModule.plugins)
local addSerializer = plugins.addSerializer
local getSerializers = plugins.getSerializers

local printSnapshot = require(CurrentModule.printSnapshot)
local PROPERTIES_ARG = printSnapshot.PROPERTIES_ARG
-- local SNAPSHOT_ARG = printSnapshot.SNAPSHOT_ARG
local bReceivedColor = printSnapshot.bReceivedColor
local matcherHintFromConfig = printSnapshot.matcherHintFromConfig
-- local noColor = printSnapshot.noColor
local printExpected = printSnapshot.printExpected
local printPropertiesAndReceived = printSnapshot.printPropertiesAndReceived
local printReceived = printSnapshot.printReceived
local printSnapshotAndReceived = printSnapshot.printSnapshotAndReceived

local types = require(CurrentModule.types)
type MatchSnapshotConfig = types.MatchSnapshotConfig

local utils = require(CurrentModule.utils)

local _toMatchSnapshot, _toThrowErrorMatchingSnapshot

local DID_NOT_THROW = "Received function did not throw"
local NOT_SNAPSHOT_MATCHERS = "Snapshot matchers cannot be used with " .. BOLD_WEIGHT("never")

-- ROBLOX deviation: we cannot have multiline regex patterns in Lua so in our usage of
-- this pattern, we will first split on newlines and then use it
-- local INDENTATION_REGEX = "^([^%S\n]*)%S"

-- Display name in report when matcher fails same as in snapshot file,
-- but with optional hint argument in bold weight.
local function printSnapshotName(concatenatedBlockNames_: string?, hint_: string?, count: number): string
	local concatenatedBlockNames = if concatenatedBlockNames_ then concatenatedBlockNames_ else ""
	local hint = if hint_ then hint_ else ""
	local hasNames = concatenatedBlockNames:len() ~= 0
	local hasHint = #hint ~= 0

	local retval = "Snapshot name: `"
	if hasNames then
		retval = retval .. utils.escapeBacktickString(concatenatedBlockNames)
	end

	if hasNames and hasHint then
		retval = retval .. ": "
	end

	if hasHint then
		retval = retval .. BOLD_WEIGHT(utils.escapeBacktickString(hint))
	end

	retval = retval .. " " .. count .. "`"

	return retval
end

-- ROBLOX TODO: ADO-1552 Add stripAddedIndentation when we support inlineSnapshot testing

-- ROBLOX deviation: omitted fileExists and cleanup

local function toMatchSnapshot(...)
	local args = { ... }
	local this: types.Context = args[1]
	local received: any = args[2]
	local propertiesOrHint: any = args[3]
	local hint: ConfigPath = args[4]

	local matcherName = "toMatchSnapshot"
	local properties

	local length = select("#", ...)
	-- ROBLOX deviation: all the length parameters are one more than upstream because
	-- the this parameter isn't counted in upstream
	if length == 3 and typeof(propertiesOrHint) == "string" then
		hint = propertiesOrHint
	elseif length >= 3 then
		if typeof(propertiesOrHint) ~= "table" or typeof(propertiesOrHint) == nil then
			local options: JestMatcherUtils.MatcherHintOptions = {
				isNot = this.isNot,
				promise = this.promise,
			}
			local printedWithType = printWithType("Expected properties", propertiesOrHint, printExpected)

			if length == 4 then
				options.secondArgument = "hint"
				options.secondArgumentColor = BOLD_WEIGHT

				if propertiesOrHint == nil then
					printedWithType = printedWithType
						.. "\n\nTo provide a hint without properties: toMatchSnapshot('hint')"
				end
			end

			error(AssertionError.new({
				message = matcherErrorMessage(
					matcherHint(matcherName, nil, PROPERTIES_ARG, options),
					"Expected " .. EXPECTED_COLOR("properties") .. " must be an object",
					printedWithType
				),
			}))
		end

		-- Future breaking change: Snapshot hint must be a string
		-- if (arguments.length === 3 && typeof hint !== 'string') {}

		properties = propertiesOrHint
	end

	return _toMatchSnapshot({
		context = this,
		hint = hint,
		isInline = false,
		matcherName = matcherName,
		properties = properties,
		received = received,
	})
end

-- ROBLOX TODO: ADO-1552 add toMatchInlineSnapshot

function _toMatchSnapshot(config: MatchSnapshotConfig): {
	pass: boolean,
	message: () -> string,
	actual: string?,
	expected: string?,
	name: string?,
}
	local context = config.context
	local hint = config.hint
	local inlineSnapshot = config.inlineSnapshot
	local isInline = config.isInline
	local matcherName = config.matcherName
	local properties = config.properties
	local received = config.received

	-- ROBLOX deviation START: we don't call dontThrow because we don't yet have the functionality in
	-- place where we add errors to global matcher state and deal with them accordingly
	-- so we instead rely on throwing the actual errors
	-- local _ = context.dontThrow and context.dontThrow()
	-- ROBLOX deviation END

	local currentTestName = context.currentTestName
	local isNot = context.isNot
	local snapshotState = context.snapshotState

	if isNot then
		error(AssertionError.new({
			message = matcherErrorMessage(matcherHintFromConfig(config, false), NOT_SNAPSHOT_MATCHERS),
		}))
	end

	if snapshotState == nil then
		-- Because the state is the problem, this is not a matcher error.
		-- Call generic stringify from jest-matcher-utils package
		-- because uninitialized snapshot state does not need snapshot serializers.
		error(AssertionError.new({
			message = matcherHintFromConfig(config, false)
				.. "\n\n"
				.. "Snapshot state must be initialized"
				.. "\n\n"
				.. printWithType("Snapshot state", snapshotState, stringify),
		}))
	end

	local fullTestName = if currentTestName and hint
		then currentTestName .. ": " .. hint :: string
		else currentTestName or "" -- future BREAKING change: || hint

	if typeof(properties) == "table" then
		-- ROBLOX deviation: Roblox Instance matchers
		-- allow property matchers against received Instance values
		if received == nil or (typeof(received) ~= "table" and getType(received) ~= "Instance") then
			error(AssertionError.new({
				message = matcherErrorMessage(
					matcherHintFromConfig(config, false),
					RECEIVED_COLOR("received")
						.. " value must be an object when the matcher has "
						.. EXPECTED_COLOR("properties"),
					printWithType("Received", received, printReceived)
				),
			}))
		end

		local propertyPass = context.equals(received, properties, {
			context.utils.iterableEquality,
			context.utils.subsetEquality,
			-- ROBLOX deviation: Roblox Instance matchers
			-- ROBLOX TODO: uncomment when implementing snapshot property matchers on Instances
			-- context.utils.instanceSubsetEquality,
		})

		if not propertyPass then
			local key = snapshotState:fail(fullTestName, received)
			local matched = key:match("(%d+)$")
			-- ROBLOX deviation START: no way for Luau to know if matched is non-nil then tonumber(matched) is guaranteed to be non-nil
			local count = if matched == nil then 1 else tonumber(matched) :: number
			-- ROBLOX deviation END

			local message = function()
				return matcherHintFromConfig(config, false)
					.. "\n\n"
					.. printSnapshotName(currentTestName, hint, count)
					.. "\n\n"
					.. printPropertiesAndReceived(properties, received, snapshotState.expand)
			end

			return {
				message = message,
				name = matcherName,
				pass = false,
			}
		else
			received = utils.deepMerge(received, properties)
		end
	end

	local result = snapshotState:match({
		error = context.error,
		inlineSnapshot = inlineSnapshot,
		isInline = isInline,
		received = received,
		testName = fullTestName,
	})
	local actual = result.actual
	local count = result.count
	local expected = result.expected
	local pass = result.pass

	if pass then
		return {
			message = function()
				return ""
			end,
			pass = true,
		}
	end

	local message
	if expected == nil then
		message = function()
			local retval = matcherHintFromConfig(config, true)
				.. "\n\n"
				.. printSnapshotName(currentTestName, hint, count)
				.. "\n\n"
				.. "New snapshot was "
				.. BOLD_WEIGHT("not written")
				.. ". The update flag "
				.. "must be explicitly passed to write a new snapshot.\n\n"
				.. "This is likely because this test is run in a continuous integration "
				.. "(CI) environment in which snapshots are not written by default.\n\n"
				.. "Received:"

			if actual:find("\n") then
				retval = retval .. "\n"
			else
				retval = retval .. " "
			end

			retval = retval .. bReceivedColor(actual)

			return retval
		end
	else
		message = function()
			return matcherHintFromConfig(config, true)
				.. "\n\n"
				.. printSnapshotName(currentTestName, hint, count)
				.. "\n\n"
				.. printSnapshotAndReceived(expected, actual, received, snapshotState.expand)
		end
	end

	-- Passing the actual and expected objects so that a custom reporter
	-- could access them, for example in order to display a custom visual diff,
	-- or create a different error message
	return {
		actual = actual,
		expected = expected,
		message = message,
		name = matcherName,
		pass = false,
	}
end

local function toThrowErrorMatchingSnapshot(
	this: types.Context,
	received: any,
	hint: string | any,
	fromPromise: boolean
)
	local matcherName = "toThrowErrorMatchingSnapshot"

	-- Future breaking change: Snapshot hint must be a string
	-- if (hint !== undefined && typeof hint !== string) {}

	return _toThrowErrorMatchingSnapshot({
		context = this,
		hint = hint,
		isInline = false,
		matcherName = matcherName,
		received = received,
	}, fromPromise)
end

function _toThrowErrorMatchingSnapshot(config: types.MatchSnapshotConfig, fromPromise: boolean?)
	local context = config.context
	local hint = config.hint
	local inlineSnapshot = config.inlineSnapshot
	local isInline = config.isInline
	local matcherName = config.matcherName
	local received = config.received

	-- ROBLOX deviation START: we don't call dontThrow because we don't yet have the functionality in
	-- place where we add errors to global matcher state and deal with them accordingly
	-- so we instead rely on throwing the actual errors
	-- local _ = context.dontThrow and context.dontThrow()
	-- ROBLOX deviation END

	local isNot = context.isNot
	local promise = context.promise

	if not fromPromise then
		if typeof(received) ~= "function" then
			local options: JestMatcherUtils.MatcherHintOptions = { isNot = isNot, promise = promise }

			error(AssertionError.new({
				message = matcherErrorMessage(
					matcherHint(matcherName, nil, "", options),
					RECEIVED_COLOR("received") .. " value must be a function",
					printWithType("Received", received, printReceived)
				),
			}))
		end
	end

	if isNot then
		error(AssertionError.new({
			message = matcherErrorMessage(matcherHintFromConfig(config, false), NOT_SNAPSHOT_MATCHERS),
		}))
	end

	local error_

	if fromPromise then
		error_ = received
	else
		local ok, result = pcall(function()
			received()
		end)
		if not ok then
			error_ = result
		end
	end

	if error_ == nil then
		-- Because the received value is a function, this is not a matcher error.
		error(AssertionError.new({ message = matcherHintFromConfig(config, false) .. "\n\n" .. DID_NOT_THROW }))
	end

	-- ROBLOX deviation: instead of being able to set received = error.message in our
	-- _toMatchSnapshot call, we have to deal with different cases since in Lua
	-- we could be dealing with our Error polyfill, a thrown object, or a thrown
	-- string
	if instanceof(error_, Error) or typeof(error_) == "table" and rawget(error_, "message") ~= nil then
		error_ = error_.message
	elseif typeof(error_) ~= "string" then
		error_ = tostring(error_)
	end

	-- ROBLOX deviation: if loadstring is used, format the loadstring stacktrace to look like a path
	error_ = cleanLoadStringStack(error_)

	return _toMatchSnapshot({
		context = context,
		hint = hint,
		inlineSnapshot = inlineSnapshot,
		isInline = isInline,
		matcherName = matcherName,
		received = error_,
	})
end

local JestSnapshot = {
	EXTENSION = EXTENSION,
	SnapshotState = SnapshotState,
	addSerializer = addSerializer,
	buildSnapshotResolver = buildSnapshotResolver,
	-- cleanup = cleanup,
	getSerializers = getSerializers,
	isSnapshotPath = isSnapshotPath,
	-- toMatchInlineSnapshot = toMatchInlineSnapshot,
	toMatchSnapshot = toMatchSnapshot,
	toThrowErrorMatchingSnapshot = toThrowErrorMatchingSnapshot,
	utils = utils,
	-- WORKSPACES FIXME: needs to be exported for consumption by workspace neighbors
	plugins = require(CurrentModule.plugins),
}

export type JestSnapshot_SnapshotResolver = JestSnapshotResolver
export type JestSnapshot_SnapshotStateType = SnapshotState

return JestSnapshot
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="374">
              <Properties>
                <string name="Name">PrettyFormat</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream
-- ROBLOX TODO: fix PrettyFormat types imports

type CompareKeys = ((a: string, b: string) -> number) | nil

type Plugin = any

export type Plugins = { [number]: Plugin }

type ThemeReceived = {
	comment: string?,
	content: string?,
	prop: string?,
	tag: string?,
	value: string?,
}

export type PrettyFormatOptions = {
	callToJSON: boolean?,
	compareKeys: CompareKeys,
	escapeRegex: boolean?,
	escapeString: boolean?,
	highlight: boolean?,
	indent: number?,
	maxDepth: number?,
	min: boolean?,
	plugins: Plugins?,
	printBasicPrototype: boolean?,
	printInstanceDefaults: boolean?,
	printFunctionName: boolean?,
	redactStackTracesInStrings: boolean?,
	theme: ThemeReceived?,
}

export type OptionsReceived = PrettyFormatOptions

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="375">
              <Properties>
                <string name="Name">SnapshotResolver</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/SnapshotResolver.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>
type Promise<T> = LuauPolyfill.Promise<T>
local Promise = require(Packages.Promise)

local exports = {}

-- ROBLOX deviation START: not needed
-- local path = require(Packages.path)
-- local chalk = require(Packages.ChalkLua)
-- local createTranspilingRequire = require(Packages["@jest"].transform).createTranspilingRequire
-- ROBLOX deviation END
local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
-- ROBLOX deviation START: not needed
-- local interopRequireDefault = require(Packages.JestUtil).interopRequireDefault
-- ROBLOX deviation END

-- ROBLOX deviation START: additinal dependencies
local RobloxShared = require(Packages.RobloxShared)
local getParent = RobloxShared.getParent
local getDataModelService = RobloxShared.getDataModelService
local CoreScriptSyncService = getDataModelService("CoreScriptSyncService")
-- ROBLOX deviation END

-- ROBLOX deviation START: predefine functions
local createSnapshotResolver
local createDefaultSnapshotResolver
--- ROBLOX deviation END
export type SnapshotResolver = {
	-- ROBLOX deviation START: not supported
	-- testPathForConsistencyCheck: string,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: custom return value. We need to be able to resolve both snapshot instance and path
	resolveSnapshotPath: (
		self: SnapshotResolver,
		testPath: ModuleScript,
		extension: string?
	) -> {
		getInstance: () -> ModuleScript?,
		getPath: () -> string,
	},
	-- ROBLOX deviation END
	-- ROBLOX deviation START: not supported
	-- resolveTestPath: (self: any, snapshotPath: Config_Path, extension: string?) -> Config_Path,
	-- ROBLOX deviation END
}
local EXTENSION = "snap"
exports.EXTENSION = EXTENSION
local DOT_EXTENSION = "." .. EXTENSION
exports.DOT_EXTENSION = DOT_EXTENSION

local function isSnapshotPath(path: string): boolean
	return String.endsWith(path, DOT_EXTENSION)
end
exports.isSnapshotPath = isSnapshotPath

local cache = Map.new()
type LocalRequire = (module: string) -> unknown

local function buildSnapshotResolver(
	config: Config_ProjectConfig,
	-- ROBLOX deviation: not supported
	_localRequire: (Promise<LocalRequire> | LocalRequire)?
	-- ROBLOX deviation END
): Promise<SnapshotResolver>
	-- ROBLOX deviation: not supported
	-- if localRequire == nil then
	-- 	localRequire = createTranspilingRequire(config)
	-- end
	-- ROBLOX deviation END
	return Promise.resolve():andThen(function()
		local key = config.rootDir
		local ref = cache:get(key)
		local resolver = if ref ~= nil
			then ref
			else createSnapshotResolver(
				-- ROBLOX deviation: not supported
				-- localRequire:expect(), config.snapshotResolver
				-- ROBLOX deviation END
			):expect()
		cache:set(key, resolver)
		return resolver
	end)
end
exports.buildSnapshotResolver = buildSnapshotResolver

function createSnapshotResolver(--[[ ROBLOX deviation: not supported ]]--[[
	localRequire: LocalRequire,
	snapshotResolverPath: (Config_Path | nil)?
]]--[[ ROBLOX deviation END ]]): Promise<SnapshotResolver>
	return Promise.resolve():andThen(function()
		-- ROBLOX deviation START: only support default snapshot resolver
		-- return if typeof(snapshotResolverPath) == "string"
		-- 	then createCustomSnapshotResolver(snapshotResolverPath, localRequire):expect()
		-- 	else createDefaultSnapshotResolver()
		return createDefaultSnapshotResolver()
		-- ROBLOX deviation END
	end)
end

function createDefaultSnapshotResolver(): SnapshotResolver
	return {
		resolveSnapshotPath = function(
			_self: SnapshotResolver,
			-- ROBLOX deviation START: using ModuleScript instead of Config_Path
			testPath: ModuleScript
			-- ROBLOX deviation END
		)
			-- ROBLOX deviation START: custom implementation
			return {
				getInstance = function()
					local testFileName = testPath.Name
					local snapshotPath: ModuleScript? = nil
					pcall(function()
						snapshotPath = (testPath.Parent :: any).__snapshots__[testFileName .. DOT_EXTENSION]
					end)
					return snapshotPath
				end,
				getPath = function()
					if not CoreScriptSyncService then
						error(
							Error(
								"Attempting to save snapshots in an environment where CoreScriptSyncService is inaccessible.\n"
									.. "You may need to pass in --load.asRobloxScript."
							)
						)
					end

					local ok, result = pcall(function()
						return CoreScriptSyncService:GetScriptFilePath(testPath)
					end)
					if not ok then
						local err = result
						if string.find(err, "lacking permission 5") then
							error(
								Error.new(
									string.format(
										"Could not get a snapshot path for test file '%s'. You may need to pass in --load.asRobloxScript",
										testPath.Name
									)
								)
							)
						else
							error(
								Error.new(
									string.format(
										"Could not get a snapshot path for test file '%s' because of the following error: %s",
										testPath.Name,
										err
									)
								)
							)
						end
					end
					local snapshotPath = result
					local parentPath = getParent(snapshotPath, 1)
					local snapshotFileName = testPath.Name .. DOT_EXTENSION .. ".lua"

					return ("%s/__snapshots__/%s"):format(parentPath, snapshotFileName)
				end,
			}
			-- ROBLOX deviation END
		end,
		-- ROBLOX deviation START: not supported
		-- resolveTestPath = function(snapshotPath: Config_Path)
		-- 	return path:resolve(path:dirname(snapshotPath), "..", path:basename(snapshotPath, DOT_EXTENSION))
		-- end,
		-- testPathForConsistencyCheck = path.posix.join("consistency_check", "__tests__", "example.test.js"),
		-- ROBLOX deviation END
	}
end

--[[
	ROBLOX deviation: skipped lines 56-132
	original code: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/SnapshotResolver.ts#L56-L132
]]

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="376">
              <Properties>
                <string name="Name">State</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/State.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

-- ROBLOX deviation: omitting fs and types file import and defining in line instead

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
type Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set

local JestTypes = require(Packages.JestTypes)
-- ROBLOX deviation: custom type
type ConfigPath = {
	getInstance: () -> ModuleScript?,
	getPath: () -> string,
}
-- ROBLOX deviation END
type ConfigSnapshotUpdateState = JestTypes.Config_SnapshotUpdateState

-- local JestMessageUtil = require(Packages.JestMessageUtil)
-- local getStackTraceLines = JestMessageUtil.getStackTraceLines
-- local getTopFrame = JestMessageUtil.getTopFrame

-- ROBLOX TODO: fix PrettyFormat types imports
-- local PrettyFormat = require(Packages.PrettyFormat)
local PrettyFormat = require(CurrentModule.PrettyFormat)
type PrettyFormatOptions = PrettyFormat.OptionsReceived

local utils = require(CurrentModule.utils)
local addExtraLineBreaks = utils.addExtraLineBreaks
local getSnapshotData = utils.getSnapshotData
local keyToTestName = utils.keyToTestName
local removeExtraLineBreaks = utils.removeExtraLineBreaks
-- ROBLOX TODO: ADO-1552 translate this function when we add inlineSnapshot functionality
-- local removeLinesBeforeExternalMatcherTrap = utils.removeLinesBeforeExternalMatcherTrap
local saveSnapshotFile = utils.saveSnapshotFile
local removeSnapshotFile = utils.removeSnapshotFile
local serialize = utils.serialize
local testNameToKey = utils.testNameToKey

-- ROBLOX TODO: ADO-1552 add inline_snapshots imports when we support this
-- functionality

local types = require(CurrentModule.types)
-- ROBLOX deviation: we do not have the BabelTraverse or Prettier types defined in the
-- types file
type SnapshotData = types.SnapshotData

export type SnapshotStateOptions = {
	updateSnapshot: ConfigSnapshotUpdateState,
	-- ROBLOX deviation: the function return is defined as any instead of null | Prettier
	-- prettierPath: ConfigPath;
	expand: boolean?,
	snapshotFormat: PrettyFormatOptions,
}

export type SnapshotMatchOptions = {
	testName: string,
	received: any?,
	key: string?,
	inlineSnapshot: string?,
	isInline: boolean,
	-- ROBLOX deviation: error type defined as any instead of Error
	error_: any,
}

type SnapshotReturnOptions = {
	actual: string,
	count: number,
	expected: string?,
	key: string,
	pass: boolean,
}

type SaveStatus = {
	deleted: boolean,
	saved: boolean,
}

export type SnapshotState = {
	markSnapshotsAsCheckedForTest: (self: SnapshotState, testName: string) -> (),
	clear: (self: SnapshotState) -> (),
	save: (self: SnapshotState) -> SaveStatus,
	getUncheckedCount: (self: SnapshotState) -> number,
	getUncheckedKeys: (self: SnapshotState) -> { string },
	removeUncheckedKeys: (self: SnapshotState) -> (),
	match: (self: SnapshotState, snapshotMatchOptions: SnapshotMatchOptions) -> SnapshotReturnOptions,
	fail: (self: SnapshotState, testName: string, _received: any, key: string) -> string,
}

type SnapshotState_statics = {
	new: (snapshotPath: ConfigPath, options: SnapshotStateOptions) -> SnapshotState,
}

type SnapshotStatePrivate = {
	_counters: { [string]: number },
	_dirty: boolean,
	_index: number,
	_updateSnapshot: ConfigSnapshotUpdateState,
	_snapshotData: SnapshotData,
	_initialData: SnapshotData,
	_snapshotPath: ConfigPath,
	-- ROBLOX TODO: ADO-1552 align this type as Array<InlineSnapshot> when we support inlineSnapshot testing
	_inlineSnapshots: { any },
	-- ROBLOX deviation: defined as any for now because LuauPolyfill.Set<string> and Set.Set<string>
	-- both didn't seem to be working
	_uncheckedKeys: any,
	-- _uncheckedKeys: LuauPolyfill.Set<string>,
	-- ROBLOX deviation: omitting field _prettierPath
	-- _prettierPath: ConfigPath;
	_snapshotFormat: PrettyFormatOptions,

	added: number,
	expand: boolean,
	matched: number,
	unmatched: number,
	updated: number,

	_addSnapshot: (
		self: SnapshotStatePrivate,
		key: string,
		receivedSerialized: string,
		options: { isInline: boolean, error: Error? }
	) -> (),

	markSnapshotsAsCheckedForTest: (self: SnapshotStatePrivate, testName: string) -> (),
	clear: (self: SnapshotStatePrivate) -> (),
	save: (self: SnapshotStatePrivate) -> SaveStatus,
	getUncheckedCount: (self: SnapshotStatePrivate) -> number,
	getUncheckedKeys: (self: SnapshotStatePrivate) -> { string },
	removeUncheckedKeys: (self: SnapshotStatePrivate) -> (),
	match: (self: SnapshotStatePrivate, snapshotMatchOptions: SnapshotMatchOptions) -> SnapshotReturnOptions,
	fail: (self: SnapshotStatePrivate, testName: string, _received: any, key: string) -> string,
}

local SnapshotState = {} :: SnapshotStatePrivate & SnapshotState_statics;
(SnapshotState :: any).__index = SnapshotState

function SnapshotState.new(snapshotPath: ConfigPath, options: SnapshotStateOptions): SnapshotState
	local returnValue = getSnapshotData(
		-- ROBLOX deviation START: get instance of a snapshot
		snapshotPath.getInstance(),
		-- ROBLOX deviation END
		options.updateSnapshot
	)
	local data = returnValue.data
	local dirty = returnValue.dirty

	local self = {
		_snapshotPath = snapshotPath,
		_initialData = data,
		_snapshotData = data,
		_dirty = dirty,
		-- ROBLOX deviation: omitting assignment for getBabelTraverse, getPrettier
		_inlineSnapshots = {},
		_uncheckedKeys = Set.new(Object.keys(data)),
		_counters = {},
		_index = 0,
		expand = options.expand or false,
		added = 0,
		matched = 0,
		unmatched = 0,
		_updateSnapshot = options.updateSnapshot,
		updated = 0,
		_snapshotFormat = options.snapshotFormat,
	}

	return (setmetatable(self, SnapshotState) :: any) :: SnapshotState
end

function SnapshotState:markSnapshotsAsCheckedForTest(testName: string): ()
	for _, uncheckedKey in self._uncheckedKeys do
		if keyToTestName(uncheckedKey) == testName then
			self._uncheckedKeys:delete(uncheckedKey)
		end
	end
end

-- ROBLOX deviation: Error type annotated as any
function SnapshotState:_addSnapshot(
	key: string,
	receivedSerialized: string,
	options: { isInline: boolean, error: any? }
): ()
	self._dirty = true
	if options.isInline then
		-- ROBLOX TODO: ADO-1552 Add when we support inlineSnapshot testing
		error(Error("Jest-Roblox: inline snapshot testing is not currently supported"))
	else
		self._snapshotData[key] = receivedSerialized
	end
end

function SnapshotState:clear(): ()
	self._snapshotData = self._initialData
	self._inlineSnapshots = {}
	self._counters = {}
	self._index = 0
	self.added = 0
	self.matched = 0
	self.unmatched = 0
	self.updated = 0
end

function SnapshotState:save(): SaveStatus
	-- ROBLOX deviation START: checking if there is more than 0 keys as `0` is considered truthy in L
	local hasExternalSnapshots = #Object.keys(self._snapshotData) > 0
	local hasInlineSnapshots = #self._inlineSnapshots > 0
	-- ROBLOX deviation END
	local isEmpty = not hasExternalSnapshots and not hasInlineSnapshots

	local status: SaveStatus = {
		deleted = false,
		saved = false,
	}

	if (self._dirty or self._uncheckedKeys.size > 0) and not isEmpty then
		if hasExternalSnapshots and (self._dirty or self._updateSnapshot == "all") then
			saveSnapshotFile(
				self._snapshotData,
				-- ROBLOX deviation START: custom logic
				self._snapshotPath.getPath()
				-- ROBLOX deviation END
			)
		end
		if hasInlineSnapshots then
			-- ROBLOX TODO: Add when we support inlineSnapshot testing
			error(Error("Jest-Roblox: inline snapshot testing is not currently supported"))
		end
		status.saved = true
	elseif
		not hasExternalSnapshots
		-- ROBLOX deviation START: check if ModuleScript for given snapshot file exists
		and self._snapshotPath.getInstance() ~= nil
		-- ROBLOX deviation END
	then
		-- ROBLOX deviation START: omitted part of code dealing with unlinking file until we have
		-- robust final solution for I/O. This may not even be needed in our translation?
		if self._updateSnapshot == "all" then
			removeSnapshotFile(self._snapshotPath.getPath())
		end
		-- ROBLOX deviation END
		status.deleted = true
	end

	return status
end

function SnapshotState:getUncheckedCount(): number
	return self._uncheckedKeys.size or 0
end

function SnapshotState:getUncheckedKeys(): { string }
	return Array.from(self._uncheckedKeys)
end

function SnapshotState:removeUncheckedKeys(): ()
	if self._updateSnapshot == "all" and self._uncheckedKeys.size > 0 then
		self._dirty = true
		for _, key in self._uncheckedKeys do
			self._snapshotData[key] = nil
		end
		self._uncheckedKeys:clear()
	end
end

function SnapshotState:match(snapshotMatchOptions: SnapshotMatchOptions): SnapshotReturnOptions
	local testName = snapshotMatchOptions.testName
	local received = snapshotMatchOptions.received
	-- ROBLOX deviation START: not supported
	-- local inlineSnapshot = snapshotMatchOptions.inlineSnapshot
	-- ROBLOX deviation END
	local isInline = snapshotMatchOptions.isInline
	local error_ = snapshotMatchOptions.error_

	self._counters[testName] = (self._counters[testName] or 0) + 1
	local count = self._counters[testName]

	local key = if snapshotMatchOptions.key then snapshotMatchOptions.key else testNameToKey(testName, count)

	-- Do not mark the snapshot as "checked" if the snapshot is inline and
	-- there's an external snapshot. This way the external snapshot can be
	-- removed with `--updateSnapshot`.
	if not (isInline and self._snapshotData[key] ~= nil) then
		self._uncheckedKeys:delete(key)
	end

	local receivedSerialized = addExtraLineBreaks(serialize(received, nil, self._snapshotFormat))
	local expected
	if isInline then
		-- ROBLOX TODO: ADO-1552 Add when we support inlineSnapshot testing
		error(Error("Jest-Roblox: inline snapshot testing is not currently supported"))
	else
		expected = self._snapshotData[key]
	end

	local pass = expected == receivedSerialized
	local hasSnapshot = expected ~= nil
	local snapshotPathExists, _ = pcall(function()
		local inst = self._snapshotPath.getInstance() :: ModuleScript
		local _ = require(inst) :: any
	end)
	local snapshotIsPersisted = isInline or snapshotPathExists

	if pass and not isInline then
		-- Executing a snapshot file as JavaScript and writing the strings back
		-- when other snapshots have changed loses the proper escaping for some
		-- characters. Since we check every snapshot in every test, use the newly
		-- generated formatted string.
		-- Note that this is only relevant when a snapshot is added and the dirty
		-- flag is set.
		self._snapshotData[key] = receivedSerialized
	end

	-- These are the conditions on when to write snapshots:
	--  * There's no snapshot file in a non-CI environment.
	--  * There is a snapshot file and we decided to update the snapshot.
	--  * There is a snapshot file, but it doesn't have this snaphsot.
	-- These are the conditions on when not to write snapshots:
	--  * The update flag is set to 'none'.
	--  * There's no snapshot file or a file without this snapshot on a CI environment.
	if
		(hasSnapshot and self._updateSnapshot == "all")
		or (
			(not hasSnapshot or not snapshotIsPersisted)
			and (self._updateSnapshot == "new" or (self._updateSnapshot :: any) == "all")
		)
	then
		if self._updateSnapshot == "all" then
			if not pass then
				if hasSnapshot then
					self.updated = self.updated + 1
				else
					self.added = self.added + 1
				end
				self:_addSnapshot(key, receivedSerialized, { error = error_, isInline = isInline })
			else
				self.matched = self.matched + 1
			end
		else
			self:_addSnapshot(key, receivedSerialized, { error = error_, isInline = isInline })
			self.added = self.added + 1
		end

		return {
			actual = "",
			count = count,
			expected = "",
			key = key,
			pass = true,
		}
	else
		if not pass then
			self.unmatched = self.unmatched + 1
			local expectedValue = if expected then removeExtraLineBreaks(expected) else nil
			return {
				actual = removeExtraLineBreaks(receivedSerialized),
				count = count,
				expected = expectedValue,
				key = key,
				pass = false,
			}
		else
			self.matched = self.matched + 1
			return {
				actual = "",
				count = count,
				expected = "",
				key = key,
				pass = true,
			}
		end
	end
end

-- ROBLOX deviation: changed string? to string so that return type could align
function SnapshotState:fail(testName: string, _received: any, key: string): string
	self._counters[testName] = (self._counters[testName] or 0) + 1
	local count = self._counters[testName]

	key = key or testNameToKey(testName, count)

	self._uncheckedKeys:delete(key)
	self.unmatched = self.unmatched + 1
	return key
end

return {
	default = SnapshotState :: SnapshotState & SnapshotState_statics,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="377">
              <Properties>
                <string name="Name">colors</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/colors.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

-- ROBLOX deviation: tuples not currently supported in Luau so we use a number array instead
export type RGB = { number }

return {
	aForeground2 = 90,
	aBackground2 = 225,

	bForeground2 = 23,
	bBackground2 = 195,

	aForeground3 = { 0x80, 0, 0x80 },
	aBackground3 = { 0xff, 0xd7, 0xff },

	bForeground3 = { 0, 0x5f, 0x5f },
	bBackground3 = { 0xd7, 0xff, 0xff },
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="378">
              <Properties>
                <string name="Name">dedentLines</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/dedentLines.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

local getIndentationLength, dedentLine, hasUnmatchedDoubleQuoteMarks, isFirstLineOfTag, dedentStartTag, dedentMarkup, dedentLines

function getIndentationLength(line: string): number
	local result = string.match(line, "^[ ]+")

	if result == nil then
		return 0
	else
		return result:len() - (result:len() % 2)
	end
end

function dedentLine(line: string): string
	return line:sub(getIndentationLength(line) + 1)
end

-- Return true if:
-- "key": "value has multiple lines\n...
-- "key has multiple lines\n...
function hasUnmatchedDoubleQuoteMarks(string_: string): boolean
	local n = 0

	local i = string.find(string_, '"')

	while i do
		if i == 1 or string.sub(string_, i - 1, i - 1) ~= "\\" then
			n = n + 1
		end

		i = string.find(string_, '"', i + 1)
	end

	return n % 2 ~= 0
end

function isFirstLineOfTag(line: string)
	return string.find(line, "^[ ]*<") ~= nil
end

-- The length of the output array is the index of the next input line.

-- Push dedented lines of start tag onto output and return true;
-- otherwise return false because:
-- * props include a multiline string (or text node, if props have markup)
-- * start tag does not close
function dedentStartTag(input: Array<string>, output: Array<string>): boolean
	local line = input[#output + 1]
	table.insert(output, dedentLine(line))

	if string.find(line, ">") then
		return true
	end

	while #output < #input do
		line = input[#output + 1]

		if hasUnmatchedDoubleQuoteMarks(line) then
			return false -- because props include a multiline string
		elseif isFirstLineOfTag(line) then
			-- Recursion only if props have markup.
			if not dedentMarkup(input, output) then
				return false
			end
		else
			table.insert(output, dedentLine(line))

			if string.find(line, ">") then
				return true
			end
		end
	end

	return false
end

-- Push dedented lines of markup onto output and return true;
-- otherwise return false because:
-- * props include a multiline string
-- * text has more than one adjacent line
-- * markup does not close
function dedentMarkup(input: Array<string>, output: Array<string>): boolean
	local line = input[#output + 1]

	if not dedentStartTag(input, output) then
		return false
	end

	if string.find(input[#output], "/>") then
		return true
	end

	local isText = false
	local stack: Array<number> = {}
	table.insert(stack, getIndentationLength(line))

	while #stack > 0 and #output < #input do
		line = input[#output + 1]

		if isFirstLineOfTag(line) then
			if string.find(line, "</") then
				table.insert(output, dedentLine(line))
				table.remove(stack)
			else
				if not dedentStartTag(input, output) then
					return false
				end

				if not string.find(input[#output], "/>") then
					table.insert(stack, getIndentationLength(line))
				end
			end
			isText = false
		else
			if isText then
				return false -- because text has more than one adjacent line
			end

			local getIndentationLengthOfTag = stack[#stack]
			table.insert(output, line:sub(getIndentationLengthOfTag + 3))
			isText = true
		end
	end

	return #stack == 0
end

-- Return lines unindented by heuristic;
-- otherwise return null because:
-- * props include a multiline string
-- * text has more than one adjacent line
-- * markup does not close
function dedentLines(input: Array<string>): Array<string> | nil
	local output: Array<string> = {}

	while #output < #input do
		local line = input[#output + 1]

		if hasUnmatchedDoubleQuoteMarks(line) then
			return nil
		elseif isFirstLineOfTag(line) then
			if not dedentMarkup(input, output) then
				return nil
			end
		else
			table.insert(output, dedentLine(line))
		end
	end

	return output
end

return dedentLines
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="379">
              <Properties>
                <string name="Name">mockSerializer</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/mockSerializer.ts
-- /**
-- * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
-- *
-- * This source code is licensed under the MIT license found in the
-- * LICENSE file in the root directory of this source tree.
-- *
-- */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
-- ROBLOX deviation: omitted external type NewPlugin
local PrettyFormat = require(Packages.PrettyFormat)
type Config = PrettyFormat.Config
type Printer = PrettyFormat.Printer
type Refs = PrettyFormat.Refs

local function serialize(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	-- Serialize a non-default name, even if config.printFunctionName is false.
	local name = val.getMockName()
	local nameString = ""
	if name == "jest.fn()" then
		nameString = ""
	else
		nameString = " " .. name
	end

	local callsString = ""
	if #val.mock.calls ~= 0 then
		local indentationNext = indentation .. config.indent
		callsString = " {"
			.. config.spacingOuter
			.. indentationNext
			.. '"calls": '
			.. printer(val.mock.calls, config, indentationNext, depth, refs)

		if config.min then
			callsString = callsString .. ", "
		else
			callsString = callsString .. ","
		end

		callsString = callsString
			.. config.spacingOuter
			.. indentationNext
			.. '"results": '
			.. printer(val.mock.results, config, indentationNext, depth, refs)

		if not config.min then
			callsString = callsString .. ","
		end

		callsString = callsString .. config.spacingOuter .. indentation .. "}"
	end

	return "[MockFunction" .. nameString .. "]" .. callsString
end

local function test(val: any): boolean
	-- ROBLOX deviation: add a table check to prevent access errors on non-tables
	return val and typeof(val) == "table" and val._isMockFunction
end

return {
	serialize = serialize,
	test = test,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="380">
              <Properties>
                <string name="Name">plugins</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/plugins.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local jestMockSerializer = require(CurrentModule.mockSerializer)

local prettyFormat = require(Packages.PrettyFormat)
type PrettyFormatPlugins = prettyFormat.Plugins
local plugins = require(Packages.PrettyFormat).plugins
-- ROBLOX deviation: omitting DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent

-- ROBLOX TODO: ADO-1182 Add more plugins here as we translate them
local PLUGINS: PrettyFormatPlugins = {
	jestMockSerializer,
	plugins.AsymmetricMatcher,
	plugins.ReactElement,
	plugins.ReactTestComponent,
	-- ROBLOX deviation: Roblox Instance matchers
	plugins.RobloxInstance,
}

-- Prepend to list so the last added is the first tested.
local function addSerializer(plugin_)
	table.insert(PLUGINS, 1, plugin_)
end

local function getSerializers()
	return PLUGINS
end

return {
	addSerializer = addSerializer,
	getSerializers = getSerializers,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="381">
              <Properties>
                <string name="Name">printSnapshot</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/printSnapshot.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local instanceof = LuauPolyfill.instanceof
local String = LuauPolyfill.String

type Array<T> = LuauPolyfill.Array<T>

local chalk = (require(Packages.ChalkLua) :: any) :: Chalk

local getObjectSubset = require(Packages.RobloxShared).expect.getObjectSubset

local JestDiff = require(Packages.JestDiff)
local DIFF_DELETE = JestDiff.DIFF_DELETE
local DIFF_EQUAL = JestDiff.DIFF_EQUAL
local DIFF_INSERT = JestDiff.DIFF_INSERT
type Diff = JestDiff.Diff
type DiffOptionsColor = JestDiff.DiffOptionsColor
local diffLinesUnified = JestDiff.diffLinesUnified
local diffLinesUnified2 = JestDiff.diffLinesUnified2
local diffStringsRaw = JestDiff.diffStringsRaw
local diffStringsUnified = JestDiff.diffStringsUnified

local JestGetType = require(Packages.JestGetType)
local getType = JestGetType.getType
local isPrimitive = JestGetType.isPrimitive

local JestMatcherUtils = require(Packages.JestMatcherUtils)
local BOLD_WEIGHT = JestMatcherUtils.BOLD_WEIGHT
local EXPECTED_COLOR = JestMatcherUtils.EXPECTED_COLOR
local INVERTED_COLOR = JestMatcherUtils.INVERTED_COLOR
type MatcherHintOptions = JestMatcherUtils.MatcherHintOptions
local RECEIVED_COLOR = JestMatcherUtils.RECEIVED_COLOR
local getLabelPrinter = JestMatcherUtils.getLabelPrinter
local matcherHint = JestMatcherUtils.matcherHint

local prettyFormat = require(Packages.PrettyFormat).format

local colors = require(CurrentModule.colors)
local aBackground2 = colors.aBackground2
local aBackground3 = colors.aBackground3
local aForeground2 = colors.aForeground2
local aForeground3 = colors.aForeground3
local bBackground2 = colors.bBackground2
local bBackground3 = colors.bBackground3
local bForeground2 = colors.bForeground2
local bForeground3 = colors.bForeground3

local dedentLines = require(CurrentModule.dedentLines)
local types = require(CurrentModule.types)
type MatchSnapshotConfig = types.MatchSnapshotConfig

local utils = require(CurrentModule.utils)
local deserializeString = utils.deserializeString
local minify = utils.minify
local serialize = utils.serialize

-- ROBLOX deviation: omitted chalk type

-- ROBLOX deviation: omitted Chalk and DiffOptionsColor types
export type Chalk = any

-- ROBLOX FIXME: these *should* return a function, but they don't. we're misaligned on types and implementation here
local function getSnapshotColorForChalkInstance(chalkInstance: Chalk): any --: DiffOptionsColor
	-- return function(_: string): string
	local level = chalkInstance.level

	if level == 3 then
		return chalkInstance.rgb(aForeground3[1], aForeground3[2], aForeground3[3])
			.. chalkInstance.bgRgb(aBackground3[1], aBackground3[2], aBackground3[3])
	end

	if level == 2 then
		return chalkInstance.ansi256(aForeground2) .. chalkInstance.bgAnsi256(aBackground2)
	end

	return chalkInstance.magenta .. chalk.bgYellowBright
	-- end
end

-- ROBLOX FIXME: these *should* return a function, but they don't. we're misaligned on types and implementation here
local function getReceivedColorForChalkInstance(chalkInstance: Chalk): any --: DiffOptionsColor
	-- return function(_: string): string
	local level = chalkInstance.level

	if level == 3 then
		return chalkInstance.rgb(bForeground3[1], bForeground3[2], bForeground3[3])
			.. chalkInstance.bgRgb(bBackground3[1], bBackground3[2], bBackground3[3])
	end

	if level == 2 then
		return chalkInstance.ansi256(bForeground2) .. chalkInstance.bgAnsi256(bBackground2)
	end

	return chalkInstance.cyan .. chalk.bgWhiteBright -- also known as teal
	-- end
end

local aSnapshotColor = getSnapshotColorForChalkInstance(chalk)
local bReceivedColor = getReceivedColorForChalkInstance(chalk)

local function noColor(string_: string)
	return string_
end

local HINT_ARG = "hint"
local SNAPSHOT_ARG = "snapshot"
local PROPERTIES_ARG = "properties"

local function matcherHintFromConfig(matchSnapshotConfig: MatchSnapshotConfig, isUpdatable: boolean): string
	local context = matchSnapshotConfig.context
	local hint = matchSnapshotConfig.hint
	local inlineSnapshot = matchSnapshotConfig.inlineSnapshot
	local matcherName = matchSnapshotConfig.matcherName
	local properties = matchSnapshotConfig.properties

	local options: MatcherHintOptions = {
		isNot = context.isNot,
		promise = context.promise,
	}
	if isUpdatable then
		options.receivedColor = bReceivedColor
	end

	local expectedArgument = ""

	if typeof(properties) == "table" then
		expectedArgument = PROPERTIES_ARG
		if isUpdatable then
			options.expectedColor = noColor
		end

		if typeof(hint) == "string" and #hint ~= 0 then
			options.secondArgument = HINT_ARG
			options.secondArgumentColor = BOLD_WEIGHT
		elseif typeof(inlineSnapshot) == "string" then
			options.secondArgument = SNAPSHOT_ARG
			if isUpdatable then
				options.secondArgumentColor = aSnapshotColor
			else
				options.secondArgumentColor = noColor
			end
		end
	else
		if typeof(hint) == "string" and #hint ~= 0 then
			expectedArgument = HINT_ARG
			options.expectedColor = BOLD_WEIGHT
		elseif typeof(inlineSnapshot) == "string" then
			expectedArgument = SNAPSHOT_ARG
			if isUpdatable then
				options.expectedColor = aSnapshotColor
			end
		end
	end

	return matcherHint(matcherName, nil, expectedArgument, options)
end

-- Given array of diffs, return string:
-- * include common substrings
-- * exclude change substrings which have opposite op
-- * include change substrings which have argument op
--   with change color only if there is a common substring
local function joinDiffs(
	-- ROBLOX deviation: changed Array<Diff> to Array<any>
	diffs: Array<any>,
	op: number,
	hasCommon: boolean
): string
	return Array.reduce(
		diffs,
		-- ROBLOX deviation: Diff changed to any
		function(reduced: string, diff: Diff): string
			local retval = reduced
			if diff[1] == DIFF_EQUAL then
				retval = reduced .. diff[2]
			else
				if diff[1] == op then
					if hasCommon then
						retval = retval .. INVERTED_COLOR(diff[2])
					else
						retval = retval .. diff[2]
					end
				end
			end
			return retval
		end,
		""
	)
end

local function isLineDiffable(received: any): boolean
	local receivedType = getType(received)

	if isPrimitive(received) then
		return typeof(received) == "string"
	end

	-- ROBLOX deviation: type changed from "date" to "DateTime"
	if receivedType == "DateTime" or receivedType == "function" or receivedType == "regexp" then
		return false
	end

	if instanceof(received, Error) then
		return false
	end

	if receivedType == "table" and typeof(received.asymmetricMatch) == "function" then
		return false
	end

	return true
end

local function printExpected(val: any): string
	return EXPECTED_COLOR(minify(val))
end

local function printReceived(val: any): string
	return RECEIVED_COLOR(minify(val))
end

local function printPropertiesAndReceived(
	properties: any,
	received: any,
	expand: boolean -- CLI options: true if `--expand` or false if `--no-expand`
): string
	local aAnnotation = "Expected properties"
	local bAnnotation = "Received value"

	if isLineDiffable(properties) and isLineDiffable(received) then
		return diffLinesUnified(
			serialize(properties):split("\n"),
			serialize(getObjectSubset(received, properties)):split("\n"),
			{
				aAnnotation = aAnnotation,
				aColor = EXPECTED_COLOR,
				bAnnotation = bAnnotation,
				bColor = RECEIVED_COLOR,
				-- ROBLOX FIXME: our types and implementation are seriously misaligned
				changeLineTrailingSpaceColor = chalk.bgYellow :: any,
				commonLineTrailingSpaceColor = chalk.bgYellow :: any,
				emptyFirstOrLastLinePlaceholder = utf8.char(8629), -- U+21B5
				expand = expand,
				includeChangeCounts = true,
			}
		)
	end

	local printLabel = getLabelPrinter(aAnnotation, bAnnotation)
	return printLabel(aAnnotation)
		.. printExpected(properties)
		.. "\n"
		.. printLabel(bAnnotation)
		.. printReceived(received)
end

local MAX_DIFF_STRING_LENGTH = 20000

local function printSnapshotAndReceived(
	a: string, -- snapshot without extra line breaks
	b: string, -- received serialized but without extra line breaks
	received: any,
	expand: boolean -- CLI options: true if `--expand` or false if `--no-expand`
): string
	local aAnnotation = "Snapshot"
	local bAnnotation = "Received"
	local aColor = aSnapshotColor
	local bColor = bReceivedColor
	local options = {
		aAnnotation = aAnnotation,
		aColor = aColor,
		bAnnotation = bAnnotation,
		bColor = bColor,
		-- ROBLOX FIXME: our types and implementation are seriously misaligned
		changeLineTrailingSpaceColor = noColor :: any,
		commonLineTrailingSpaceColor = chalk.bgYellow :: any,
		emptyFirstOrLastLinePlaceholder = utf8.char(8629), -- U+21B5
		expand = expand,
		includeChangeCounts = true,
	}

	if typeof(received) == "string" then
		if #a >= 2 and String.startsWith(a, '"') and String.endsWith(a, '"') and b == prettyFormat(received) then
			-- If snapshot looks like default serialization of a string
			-- and received is string which has default serialization.
			if not a:find("\n") and not b:find("\n") then
				-- If neither string is multiline,
				-- display as labels and quoted strings.
				local aQuoted = a
				local bQuoted = b

				if #a - 2 <= MAX_DIFF_STRING_LENGTH and #b - 2 <= MAX_DIFF_STRING_LENGTH then
					local diffs = diffStringsRaw(string.sub(a, 2, -2), string.sub(b, 2, -2), true)
					local hasCommon = Array.some(diffs, function(diff)
						return diff[1] == DIFF_EQUAL
					end)
					aQuoted = '"' .. joinDiffs(diffs, DIFF_DELETE, hasCommon) .. '"'
					bQuoted = '"' .. joinDiffs(diffs, DIFF_INSERT, hasCommon) .. '"'
				end

				local printLabel = getLabelPrinter(aAnnotation, bAnnotation)
				return printLabel(aAnnotation) .. aColor(aQuoted) .. "\n" .. printLabel(bAnnotation) .. bColor(bQuoted)
			end

			-- Else either string is multiline, so display as unquoted strings.
			a = deserializeString(a) -- hypothetical expected string
			b = received -- not serialized
		end

		-- Else expected had custom serialization or was not a string
		-- or received has custom serialization.
		if #a <= MAX_DIFF_STRING_LENGTH and #b <= MAX_DIFF_STRING_LENGTH then
			return diffStringsUnified(a, b, options)
		else
			return diffLinesUnified(a:split("\n"), b:split("\n"), options)
		end
	end

	if isLineDiffable(received) then
		local aLines2 = a:split("\n")
		local bLines2 = b:split("\n")

		-- Fall through to fix a regression for custom serializers
		-- like jest-snapshot-serializer-raw that ignore the indent option.
		local b0 = serialize(received, 0)
		if b0 ~= b then
			local aLines0 = dedentLines(aLines2)

			if aLines0 ~= nil then
				-- Compare lines without indentation.
				local bLines0 = b0:split("\n")

				return diffLinesUnified2(aLines2, bLines2, aLines0, bLines0, options)
			end
		end

		-- Fall back because:
		-- * props include a multiline string
		-- * text has more than one adjacent line
		-- * markup does not close
		return diffLinesUnified(aLines2, bLines2, options)
	end

	local printLabel = getLabelPrinter(aAnnotation, bAnnotation)
	return printLabel(aAnnotation) .. aColor(a) .. "\n" .. printLabel(bAnnotation) .. bColor(b)
end

return {
	getSnapshotColorForChalkInstance = getSnapshotColorForChalkInstance,
	getReceivedColorForChalkInstance = getReceivedColorForChalkInstance,
	aSnapshotColor = aSnapshotColor,
	bReceivedColor = bReceivedColor,
	noColor = noColor,
	HINT_ARG = HINT_ARG,
	SNAPSHOT_ARG = SNAPSHOT_ARG,
	PROPERTIES_ARG = PROPERTIES_ARG,
	matcherHintFromConfig = matcherHintFromConfig,
	printExpected = printExpected,
	printReceived = printReceived,
	printPropertiesAndReceived = printPropertiesAndReceived,
	printSnapshotAndReceived = printSnapshotAndReceived,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="382">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/types.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */
local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

-- ROBLOX TODO: upstream is `MatcherState &`, which is from `expect` package, but would result in a circular rotriever dependency
export type Context = Object

export type MatchSnapshotConfig = {
	context: Context,
	hint: string?,
	inlineSnapshot: string?,
	isInline: boolean,
	matcherName: string,
	properties: Object?,
	received: any,
}

export type SnapshotData = { [string]: string }

-- copied from `expect` - should be shared
export type ExpectationResult = {
	pass: boolean,
	message: () -> string,
}

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="383">
              <Properties>
                <string name="Name">utils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-snapshot/src/utils.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

-- ROBLOX deviation: for now we have ported a very limited subset of utils that
-- corresponds to the functions needed by the other translated files. We plan
-- on filling the rest of utils out as we continue with the jest-snapshot file.

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local RobloxShared = require(Packages.RobloxShared)
local getDataModelService = RobloxShared.getDataModelService
local FileSystemService = getDataModelService("FileSystemService")

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local String = LuauPolyfill.String

type Array<T> = LuauPolyfill.Array<T>

-- local chalk = require(Packages.ChalkLua)

-- ROBLOX TODO: ADO-1633 fix Jest Types imports
-- local Config = require(Packages.JestTypes).Config
type ConfigPath = string
type ConfigSnapshotUpdateState = string

local PrettyFormat = require(Packages.PrettyFormat)
local PrettyFormat_ = require(CurrentModule.PrettyFormat)

-- ROBLOX TODO: fix PrettyFormat types imports
type PrettyFormatOptions = PrettyFormat_.OptionsReceived
local prettyFormat = PrettyFormat.format
local getSerializers = require(CurrentModule.plugins).getSerializers

local types = require(CurrentModule.types)
type SnapshotData = types.SnapshotData

local SNAPSHOT_VERSION = "1"
-- local SNAPSHOT_VERSION_REGEXP = "^// Jest Snapshot v(.+),"
local SNAPSHOT_GUIDE_LINK = "http://roblox.github.io/jest-roblox-internal/snapshot-testing"
-- local SNAPSHOT_VERSION_WARNING = chalk.yellow(
-- 	chalk.bold('Warning') .. ": Before you upgrade snapshots, " ..
-- 	"we recommend that you revert any local changes to tests or other code, " ..
-- 	"to ensure that you do not store invalid state."
-- )

local normalizeNewLines, deepMerge

local function writeSnapshotVersion()
	return "-- Jest Roblox Snapshot v" .. SNAPSHOT_VERSION .. ", " .. SNAPSHOT_GUIDE_LINK
end

-- ROBLOX TODO: ADO-1587, add snapshot version validation
-- local function validateSnapshotVersion(snapshotContents: { [string]: string)
-- local version = snapshotContents:match(SNAPSHOT_VERSION_REGEXP)

-- if not version then
-- 	return Error(
-- 		chalk.red(
-- 			chalk.bold('Outdated snapshot') .. ": No snapshot header found. " ..
-- 			"Jest 19 introduced version snapshots to ensure all developers " ..
-- 			"on a project are using the same version of Jest. " ..
-- 			"Please update all snapshots during this upgrade of Jest.\n\n"
-- 		) .. SNAPSHOT_VERSION_WARNING
-- 	)
-- end

-- if version < SNAPSHOT_VERSION then
-- 	return Error(
-- 		chalk.red(
-- 			chalk.red.bold('Outdated snapshot') .. ": The version of the snapshot " ..
-- 			"file associated with this test is outdated. The snapshot file " ..
-- 			"version ensures that all developers on a project are using " ..
-- 			"the same version of Jest. " ..
-- 			"Please update all snapshots during this upgrade of Jest.\n\n"
-- 		) ..
-- 		"Expected: v" .. SNAPSHOT_VERSION .. "\n" ..
-- 		"Received: v" .. version .. "\n\n" ..
-- 		SNAPSHOT_VERSION_WARNING
-- 	)
-- end

-- if version > SNAPSHOT_VERSION then
-- 	return Error(
-- 		chalk.red(
-- 			chalk.red.bold('Outdated Jest version') ..": The version of this " ..
-- 			"snapshot file indicates that this project is meant to be used " ..
-- 			"with a newer version of Jest. The snapshot file version ensures " ..
-- 			"that all developers on a project are using the same version of " ..
-- 			"Jest. Please update your version of Jest and re-run the tests.\n\n"
-- 		) ..
-- 		"Expected: v${SNAPSHOT_VERSION}\n" ..
-- 		"Received: v${version}"
-- 	)
-- end

-- return nil
-- end

local function isObject(item: any): boolean
	return item and typeof(item) == "table" and not Array.isArray(item)
end

local function testNameToKey(testName: ConfigPath, count: number): string
	return testName .. " " .. count
end

local function keyToTestName(key: string): string
	if not key:match(" %d+$") then
		error(Error("Snapshot keys must end with a number."))
	end

	return key:gsub(" %d+$", "")
end

local function getSnapshotData(
	-- ROBLOX deviation START: using ModuleScript instead of Config_Path
	snapshotPath: ModuleScript?,
	-- ROBLOX deviation END
	update: ConfigSnapshotUpdateState
): { data: SnapshotData, dirty: boolean }
	local data = {}
	local dirty = false

	-- ROBLOX deviation: snapshots in Jest Roblox are ModuleScripts, so we require them to load them
	pcall(function()
		if snapshotPath then
			data = require(snapshotPath) :: any
		end
	end)
	-- ROBLOX deviation: omitted validateSnapshotVersion for now since we will have our own
	-- snapshot versioning
	-- local validationResult = validateSnapshotVersion(data)
	local isInvalid = false -- data and validationResult

	-- if update == "none" and isInvalid then
	-- 	error(validationResult)
	-- end

	if (update == "all" or update == "new") and isInvalid then
		dirty = true
	end

	return {
		data = data,
		dirty = dirty,
	}
end

-- Add extra line breaks at beginning and end of multiline snapshot
-- to make the content easier to read.
local function addExtraLineBreaks(string_: string): string
	if string_:match("\n") then
		return "\n" .. string_ .. "\n"
	else
		return string_
	end
end

-- Remove extra line breaks at beginning and end of multiline snapshot.
-- Instead of trim, which can remove additional newlines or spaces
-- at beginning or end of the content from a custom serializer.
local function removeExtraLineBreaks(string_: string): string
	if string_:len() > 2 and String.startsWith(string_, "\n") and String.endsWith(string_, "\n") then
		return string_:sub(2, -2)
	else
		return string_
	end
end

local escapeRegex = true
local printFunctionName = false

local function serialize(val: any, indent: number?, formatOverrides: PrettyFormatOptions?): string
	indent = indent or 2
	formatOverrides = formatOverrides or {}
	return normalizeNewLines(prettyFormat(
		val,
		Object.assign({
			escapeRegex = escapeRegex,
			indent = indent,
			plugins = getSerializers(),
			printFunctionName = printFunctionName,
		}, formatOverrides)
	))
end

local function minify(val: any): string
	return prettyFormat(val, {
		escapeRegex = true,
		min = true,
		plugins = getSerializers(),
		printFunctionName = printFunctionName,
	})
end

-- Remove double quote marks and unescape double quotes and backslashes.
local function deserializeString(stringified: string): string
	stringified = string.sub(stringified, 2, -2)
	stringified = string.gsub(stringified, "\\\\", "\\")
	stringified = string.gsub(stringified, '\\"', '"')
	return stringified
end

-- ROBLOX deviation: we don't escape any characters since multiline literals don't
-- consume escape sequences
local function escapeBacktickString(str: string): string
	return str
end

-- ROBLOX deviation: we change from backtick to our literal string delimiter [=[ and ]=]
local function printBacktickString(str: string): string
	return "[=[\n" .. str .. "]=]"
end

-- ROBLOX deviation: moved to RobloxShared
local ensureDirectoryExists = RobloxShared.ensureDirectoryExists

function normalizeNewLines(string_: string)
	string_ = string.gsub(string_, "\r\n", "\n")
	local result = string.gsub(string_, "\r", "\n")
	return result
end

-- ROBLOX deviation: taken from http://notebook.kulchenko.com/algorithms/alphanumeric-natural-sorting-for-humans-in-lua
-- as an approximation of naturalCompare for now
local function alphanumsort(o)
	local function padnum(d)
		return ("%03d%s"):format(string.len(d), d)
	end
	table.sort(o, function(a, b)
		return tostring(a):gsub("%d+", padnum) < tostring(b):gsub("%d+", padnum)
	end)
	return o
end

-- ROBLOX deviation: saves a valid Roblox ModuleScript
local function saveSnapshotFile(snapshotData: SnapshotData, snapshotPath: ConfigPath)
	local snapshots = {
		writeSnapshotVersion(),
		"local exports = {}",
	}

	for _, key in ipairs(alphanumsort(Object.keys(snapshotData))) do
		table.insert(
			snapshots,
			"exports[ [=["
				-- ROBLOX deviation: we don't call printBacktickString here since we inline the
				-- multiline literal
				.. escapeBacktickString(key)
				.. "]=] ] = "
				.. printBacktickString(normalizeNewLines(snapshotData[key]))
				.. "\n"
		)
		-- ROBLOX deviation: we don't append a semicolon
	end
	table.insert(snapshots, "return exports")

	-- ROBLOX deviation: error when FileSystemService doesn't exist
	if not FileSystemService then
		error(Error("Attempting to save snapshots in an environment where FileSystemService is inaccessible."))
	end
	ensureDirectoryExists(snapshotPath)
	FileSystemService:WriteFile(snapshotPath, table.concat(snapshots, "\n") .. "\n")
end

-- ROBLOX deviation: removes a snapshot file to replace fs.unlinkSync
local function removeSnapshotFile(snapshotPath: ConfigPath)
	-- ROBLOX deviation: error when FileSystemService doesn't exist
	if not FileSystemService then
		error(Error("Attempting to save snapshots in an environment where FileSystemService is inaccessible."))
	end

	if not FileSystemService:IsRegularFile(snapshotPath) then
		error(Error(snapshotPath .. " is not a path to a .snap.lua file"))
	end
	FileSystemService:Remove(snapshotPath)
end

local function deepMergeArray(target: Array<any>, source: Array<any>)
	-- ROBLOX FIXME Luau: should be inferred from reduce's initial value
	local mergedOutput = Array.from(target) :: typeof(target)

	for index, sourceElement in ipairs(source) do
		local targetElement = mergedOutput[index]

		if Array.isArray(target[index]) then
			mergedOutput[index] = deepMergeArray(target[index], sourceElement)
		elseif isObject(targetElement) then
			mergedOutput[index] = deepMerge(target[index], sourceElement)
		else
			-- Source does not exist in target or target is primitive and cannot be deep merged
			mergedOutput[index] = sourceElement
		end
	end

	return mergedOutput
end

function deepMerge(target: any, source: any): any
	if isObject(target) and isObject(source) then
		-- ROBLOX deviation START: use table.clone instead of manual copy
		local mergedOutput = table.clone(target)
		-- ROBLOX deviation END

		for key, value in pairs(source) do
			if isObject(source[key]) and not source[key]["$$typeof"] then
				if not target[key] then
					Object.assign(mergedOutput, { [key] = source[key] })
				else
					mergedOutput[key] = deepMerge(target[key], source[key])
				end
			elseif Array.isArray(source[key]) then
				mergedOutput[key] = deepMergeArray(target[key], source[key])
			else
				Object.assign(mergedOutput, { [key] = source[key] })
			end
		end

		return mergedOutput
	elseif Array.isArray(target) and Array.isArray(source) then
		return deepMergeArray(target, source)
	end

	return target
end

return {
	testNameToKey = testNameToKey,
	keyToTestName = keyToTestName,
	getSnapshotData = getSnapshotData,
	addExtraLineBreaks = addExtraLineBreaks,
	removeExtraLineBreaks = removeExtraLineBreaks,
	serialize = serialize,
	minify = minify,
	deserializeString = deserializeString,
	escapeBacktickString = escapeBacktickString,
	saveSnapshotFile = saveSnapshotFile,
	deepMerge = deepMerge,
	removeSnapshotFile = removeSnapshotFile,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="384">
            <Properties>
              <string name="Name">JestTestResult</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-test-result/src/index.ts
--[[*
* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]
local exports = {}

exports.formatTestResults = require(script.formatTestResults).default

local helpersModule = require(script.helpers)
exports.addResult = helpersModule.addResult
exports.buildFailureTestResult = helpersModule.buildFailureTestResult
exports.createEmptyTestResult = helpersModule.createEmptyTestResult
exports.makeEmptyAggregatedTestResult = helpersModule.makeEmptyAggregatedTestResult

local typesModule = require(script.types)
export type AggregatedResult = typesModule.AggregatedResult
export type AssertionLocation = typesModule.AssertionLocation
export type AssertionResult = typesModule.AssertionResult
export type FailedAssertion = typesModule.FailedAssertion
export type FormattedTestResults = typesModule.FormattedTestResults
export type Milliseconds = typesModule.Milliseconds
export type RuntimeTransformResult = typesModule.RuntimeTransformResult
export type SerializableError = typesModule.SerializableError
export type Snapshot = typesModule.Snapshot
export type SnapshotSummary = typesModule.SnapshotSummary
export type Status = typesModule.Status
export type Suite = typesModule.Suite
export type Test = typesModule.Test
export type TestContext = typesModule.Context
export type Context = typesModule.Context
export type TestEvents = typesModule.TestEvents
-- ROBLOX FIXME: find a way to keep the generic param and it's default value when re-exporting
export type TestFileEvent = typesModule.TestFileEvent
export type TestResult = typesModule.TestResult
export type TestResultsProcessor = typesModule.TestResultsProcessor
export type TestCaseResult = typesModule.TestCaseResult
export type V8CoverageResult = typesModule.V8CoverageResult

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="385">
              <Properties>
                <string name="Name">formatTestResults</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-test-result/src/formatTestResults.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object

local types = require(CurrentModule.types)
type AggregatedResult = types.AggregatedResult
type AssertionResult = types.AssertionResult
type CodeCoverageFormatter = types.CodeCoverageFormatter
type CodeCoverageReporter = types.CodeCoverageReporter
type FormattedAssertionResult = types.FormattedAssertionResult
type FormattedTestResult = types.FormattedTestResult
type FormattedTestResults = types.FormattedTestResults
type TestResult = types.TestResult

local formatTestAssertion

local function formatTestResult(
	testResult: TestResult,
	codeCoverageFormatter: CodeCoverageFormatter?,
	reporter: CodeCoverageReporter?
): FormattedTestResult
	local assertionResults = Array.map(testResult.testResults, formatTestAssertion)
	if testResult.testExecError ~= nil then
		local now = DateTime.now().UnixTimestampMillis
		return {
			assertionResults = assertionResults,
			coverage = {},
			endTime = now,
			message = if testResult.failureMessage ~= nil
				then testResult.failureMessage
				else testResult.testExecError.message,
			name = testResult.testFilePath,
			startTime = now,
			status = "failed",
			summary = "",
		}
	else
		local allTestsPassed = testResult.numFailingTests == 0
		return {
			assertionResults = assertionResults,
			coverage = if codeCoverageFormatter ~= nil
				then codeCoverageFormatter(testResult.coverage, reporter)
				else testResult.coverage,
			endTime = testResult.perfStats["end"],
			message = if testResult.failureMessage ~= nil then testResult.failureMessage else "",
			name = testResult.testFilePath,
			startTime = testResult.perfStats.start,
			status = if Boolean.toJSBoolean(allTestsPassed) then "passed" else "failed",
			summary = "",
		}
	end
end

function formatTestAssertion(assertion: AssertionResult): FormattedAssertionResult
	local result: FormattedAssertionResult = {
		ancestorTitles = assertion.ancestorTitles,
		duration = assertion.duration,
		failureMessages = nil,
		fullName = assertion.fullName,
		location = assertion.location,
		status = assertion.status,
		title = assertion.title,
	}
	if assertion.failureMessages then
		result.failureMessages = assertion.failureMessages
	end
	return result
end

local function formatTestResults(
	results: AggregatedResult,
	codeCoverageFormatter: CodeCoverageFormatter?,
	reporter: CodeCoverageReporter?
): FormattedTestResults
	local testResults = Array.map(results.testResults, function(testResult)
		return formatTestResult(testResult, codeCoverageFormatter, reporter)
	end)
	return Object.assign({}, results, { testResults = testResults })
end

return {
	default = formatTestResults,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="386">
              <Properties>
                <string name="Name">helpers</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-test-result/src/helpers.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean

local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path

local types = require(CurrentModule.types)
type AggregatedResult = types.AggregatedResult
type SerializableError = types.SerializableError
type TestResult = types.TestResult

local function makeEmptyAggregatedTestResult(): AggregatedResult
	return {
		numFailedTestSuites = 0,
		numFailedTests = 0,
		numPassedTestSuites = 0,
		numPassedTests = 0,
		numPendingTestSuites = 0,
		numPendingTests = 0,
		numRuntimeErrorTestSuites = 0,
		numTodoTests = 0,
		numTotalTestSuites = 0,
		numTotalTests = 0,
		openHandles = {},
		snapshot = {
			added = 0,
			didUpdate = false, -- is set only after the full run
			failure = false,
			filesAdded = 0, -- combines individual test results + removed files after the full run
			filesRemoved = 0,
			filesRemovedList = {},
			filesUnmatched = 0,
			filesUpdated = 0,
			matched = 0,
			total = 0,
			unchecked = 0,
			uncheckedKeysByFile = {},
			unmatched = 0,
			updated = 0,
		},
		startTime = 0,
		success = true,
		testResults = {},
		wasInterrupted = false,
	}
end

-- Add individual test result to an aggregated test result
local function buildFailureTestResult(testPath: Config_Path, err: SerializableError): TestResult
	return {
		console = nil,
		displayName = nil,
		failureMessage = nil,
		leaks = false,
		numFailingTests = 0,
		numPassingTests = 0,
		numPendingTests = 0,
		numTodoTests = 0,
		openHandles = {},
		perfStats = { ["end"] = 0, runtime = 0, slow = false, start = 0 },
		skipped = false,
		snapshot = {
			added = 0,
			fileDeleted = false,
			matched = 0,
			unchecked = 0,
			uncheckedKeys = {},
			unmatched = 0,
			updated = 0,
		},
		testExecError = err,
		testFilePath = testPath,
		testResults = {},
	}
end

local function addResult(aggregatedResults: AggregatedResult, testResult: TestResult): ()
	-- `todos` are new as of Jest 24, and not all runners return it.
	-- Set it to `0` to avoid `NaN`
	if not Boolean.toJSBoolean(testResult.numTodoTests) then
		testResult.numTodoTests = 0
	end
	table.insert(aggregatedResults.testResults, testResult)
	aggregatedResults.numTotalTests += testResult.numPassingTests + testResult.numFailingTests + testResult.numPendingTests + testResult.numTodoTests
	aggregatedResults.numFailedTests += testResult.numFailingTests
	aggregatedResults.numPassedTests += testResult.numPassingTests
	aggregatedResults.numPendingTests += testResult.numPendingTests
	aggregatedResults.numTodoTests += testResult.numTodoTests
	if Boolean.toJSBoolean(testResult.testExecError) then
		aggregatedResults.numRuntimeErrorTestSuites += 1
	end
	if Boolean.toJSBoolean(testResult.skipped) then
		aggregatedResults.numPendingTestSuites += 1
	elseif Boolean.toJSBoolean(testResult.numFailingTests > 0 or testResult.testExecError) then
		aggregatedResults.numFailedTestSuites += 1
	else
		aggregatedResults.numPassedTestSuites += 1
	end -- Snapshot data
	if Boolean.toJSBoolean(testResult.snapshot.added) then
		aggregatedResults.snapshot.filesAdded += 1
	end
	if Boolean.toJSBoolean(testResult.snapshot.fileDeleted) then
		aggregatedResults.snapshot.filesRemoved += 1
	end
	if Boolean.toJSBoolean(testResult.snapshot.unmatched) then
		aggregatedResults.snapshot.filesUnmatched += 1
	end
	if Boolean.toJSBoolean(testResult.snapshot.updated) then
		aggregatedResults.snapshot.filesUpdated += 1
	end
	aggregatedResults.snapshot.added += testResult.snapshot.added
	aggregatedResults.snapshot.matched += testResult.snapshot.matched
	aggregatedResults.snapshot.unchecked += testResult.snapshot.unchecked
	if
		Boolean.toJSBoolean(
			if Boolean.toJSBoolean(testResult.snapshot.uncheckedKeys)
				then #testResult.snapshot.uncheckedKeys > 0
				else testResult.snapshot.uncheckedKeys
		)
	then
		table.insert(
			aggregatedResults.snapshot.uncheckedKeysByFile,
			{ filePath = testResult.testFilePath, keys = testResult.snapshot.uncheckedKeys }
		)
	end
	aggregatedResults.snapshot.unmatched += testResult.snapshot.unmatched
	aggregatedResults.snapshot.updated += testResult.snapshot.updated
	aggregatedResults.snapshot.total += testResult.snapshot.added + testResult.snapshot.matched + testResult.snapshot.unmatched + testResult.snapshot.updated
end

local function createEmptyTestResult(): TestResult
	return {
		leaks = false, -- That's legacy code, just adding it as needed for typing
		numFailingTests = 0,
		numPassingTests = 0,
		numPendingTests = 0,
		numTodoTests = 0,
		openHandles = {},
		perfStats = { ["end"] = 0, runtime = 0, slow = false, start = 0 },
		skipped = false,
		snapshot = {
			added = 0,
			fileDeleted = false,
			matched = 0,
			unchecked = 0,
			uncheckedKeys = {},
			unmatched = 0,
			updated = 0,
		},
		testFilePath = "",
		testResults = {},
	}
end

return {
	makeEmptyAggregatedTestResult = makeEmptyAggregatedTestResult,
	buildFailureTestResult = buildFailureTestResult,
	addResult = addResult,
	createEmptyTestResult = createEmptyTestResult,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="387">
              <Properties>
                <string name="Name">types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-test-result/src/types.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Record<K, T> = { [K]: T }

-- ROBLOX deviation START: collect-v8-coverage package not available
-- local collect_v8_coverageModule = require(Packages["collect-v8-coverage"])
-- type V8Coverage = collect_v8_coverageModule.V8Coverage
-- local istanbul_lib_coverageModule = require(Packages["istanbul-lib-coverage"])
-- type any = istanbul_lib_coverageModule.any
-- type CoverageMapData = istanbul_lib_coverageModule.CoverageMapData
type CoverageMap = any
type CoverageMapData = any
-- ROBLOX deviation END

-- ROBLOX TODO: once jest-console package is available
-- local consoleModule = require(Packages.JestConsole)
type ConsoleBuffer = any -- [[ consoleModule.ConsoleBuffer ]]

local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path
type Config_ProjectConfig = typesModule.Config_ProjectConfig
type Config_DisplayName = typesModule.Config_DisplayName
type TestResult_SerializableError = typesModule.TestResult_SerializableError
type TestResult_Callsite = typesModule.TestResult_Callsite
type TestResult_Status = typesModule.TestResult_Status
type TestResult_AssertionResult = typesModule.TestResult_AssertionResult
type TestResult_Milliseconds = typesModule.TestResult_Milliseconds
type TransformTypes_TransformResult = typesModule.TransformTypes_TransformResult

-- ROBLOX TODO: once jest-haste-map package is available
-- local jest_haste_mapModule = require(Packages["jest-haste-map"])
type HasteFS = any -- [[ jest_haste_mapModule.FS ]]
type ModuleMap = any -- [[ jest_haste_mapModule.ModuleMap ]]

-- ROBLOX TODO: once jest-resolve package is available
-- local jest_resolveModule = require(Packages["jest-resolve"])
type Resolver = any -- [[ jest_resolveModule.default ]]

export type RuntimeTransformResult = TransformTypes_TransformResult & { wrapperLength: number }

export type V8CoverageResult = Array<{
	codeTransformResult: RuntimeTransformResult | nil,
	result: any, --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ V8Coverage[number] ]]
}>

export type SerializableError = TestResult_SerializableError

export type FailedAssertion = {
	matcherName: string?,
	message: string?,
	actual: unknown?,
	pass: boolean?,
	passed: boolean?,
	expected: unknown?,
	isNot: boolean?,
	stack: string?,
	error_: unknown?,
}

export type AssertionLocation = { fullName: string, path: string }

export type Status = TestResult_Status

export type Bytes = number

export type Milliseconds = TestResult_Milliseconds

export type AssertionResult = TestResult_AssertionResult

-- ROBLOX deviation START: Pick<AssertionResult, "ancestorTitles" | "fullName" | "location" | "status" | "title">
export type FormattedAssertionResult = {
	ancestorTitles: Array<string>,
	fullName: string,
	location: (TestResult_Callsite | nil)?,
	status: Status,
	title: string,
	-- ROBLOX deviation: Added failureMessages directly to object instead of intersection
	failureMessages: Array<string> | nil,
	-- ROBLOX deviation END
}
-- ROBLOX deviation END

export type AggregatedResultWithoutCoverage = {
	numFailedTests: number,
	numFailedTestSuites: number,
	numPassedTests: number,
	numPassedTestSuites: number,
	numPendingTests: number,
	numTodoTests: number,
	numPendingTestSuites: number,
	numRuntimeErrorTestSuites: number,
	numTotalTests: number,
	numTotalTestSuites: number,
	openHandles: Array<Error>,
	snapshot: SnapshotSummary,
	startTime: number,
	success: boolean,
	testResults: Array<TestResult>,
	wasInterrupted: boolean,
}

export type AggregatedResult = AggregatedResultWithoutCoverage & {
	coverageMap: (any | nil)?,
}

export type TestResultsProcessor = (results: AggregatedResult) -> AggregatedResult

export type Suite = { title: string, suites: Array<Suite>, tests: Array<AssertionResult> }

export type TestCaseResult = AssertionResult

export type Snapshot = {
	added: number,
	fileDeleted: boolean,
	matched: number,
	unchecked: number,
	uncheckedKeys: Array<string>,
	unmatched: number,
	updated: number,
}

export type TestResult = {
	console: ConsoleBuffer?,
	coverage: any?, -- [[ ROBLOX TODO: convert any to CoverageMapData when type is available ]]
	displayName: Config_DisplayName?,
	failureMessage: (string | nil)?,
	leaks: boolean,
	memoryUsage: Bytes?,
	numFailingTests: number,
	numPassingTests: number,
	numPendingTests: number,
	numTodoTests: number,
	openHandles: Array<Error>,
	perfStats: { ["end"]: Milliseconds, runtime: Milliseconds, slow: boolean, start: Milliseconds },
	skipped: boolean,
	snapshot: Snapshot,
	testExecError: SerializableError?,
	testFilePath: string,
	testResults: Array<AssertionResult>,
	v8Coverage: V8CoverageResult?,
}

export type FormattedTestResult = {
	message: string,
	name: string,
	summary: string,
	status: string,
	startTime: number,
	endTime: number,
	coverage: unknown,
	assertionResults: Array<FormattedAssertionResult>,
}

export type FormattedTestResults = {
	coverageMap: (CoverageMap | nil)?,
	numFailedTests: number,
	numFailedTestSuites: number,
	numPassedTests: number,
	numPassedTestSuites: number,
	numPendingTests: number,
	numPendingTestSuites: number,
	numRuntimeErrorTestSuites: number,
	numTotalTests: number,
	numTotalTestSuites: number,
	snapshot: SnapshotSummary,
	startTime: number,
	success: boolean,
	testResults: Array<FormattedTestResult>,
	wasInterrupted: boolean,
}

export type CodeCoverageReporter = unknown

export type CodeCoverageFormatter = (
	coverage: CoverageMapData | nil,
	reporter: CodeCoverageReporter
) -> Record<string, unknown> | nil

export type UncheckedSnapshot = { filePath: string, keys: Array<string> }

export type SnapshotSummary = {
	added: number,
	didUpdate: boolean,
	failure: boolean,
	filesAdded: number,
	filesRemoved: number,
	filesRemovedList: Array<string>,
	filesUnmatched: number,
	filesUpdated: number,
	matched: number,
	total: number,
	unchecked: number,
	uncheckedKeysByFile: Array<UncheckedSnapshot>,
	unmatched: number,
	updated: number,
}

export type Test = { context: Context, duration: number?, path: Config_Path, script: ModuleScript }

export type Context = {
	config: Config_ProjectConfig,
	-- ROBLOX deviation START: no supported
	-- hasteFS: HasteFS,
	-- moduleMap: ModuleMap,
	-- resolver: Resolver,
	-- ROBLOX deviation END
}

-- Typings for `sendMessageToJest` events
export type TestEvents = {
	["test-file-start"]: Array<Test>,
	["test-file-success"]: Array<Test | TestResult>,
	["test-file-failure"]: Array<Test | SerializableError>,
	["test-case-result"]: Array<string | AssertionResult>,
}

-- ROBLOX deviation START: unroll `keyof TestEvents` as this operation is not supported in Luau
type KeyOfTestEvents = "test-file-start" | "test-file-success" | "test-file-failure" | "test-case-result"

export type TestFileEvent<T = KeyOfTestEvents> = (
	eventName: T,
	args: any --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ TestEvents[T] ]]
) -> unknown
-- ROBLOX deviation END

return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="388">
            <Properties>
              <string name="Name">JestTypes</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-types/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local CircusModule = require(script.Circus)
export type Circus_DoneFn = CircusModule.DoneFn
export type Circus_BlockFn = CircusModule.BlockFn
export type Circus_BlockNameLike = CircusModule.BlockNameLike
export type Circus_TestNameLike = CircusModule.TestNameLike
export type Circus_BlockName = CircusModule.BlockName
export type Circus_BlockMode = CircusModule.BlockMode
export type Circus_TestMode = CircusModule.TestMode
export type Circus_TestName = CircusModule.TestName
export type Circus_TestFn = CircusModule.TestFn
export type Circus_HookFn = CircusModule.HookFn
export type Circus_AsyncFn = CircusModule.AsyncFn
export type Circus_SharedHookType = CircusModule.SharedHookType
export type Circus_HookType = CircusModule.HookType
export type Circus_TestContext = CircusModule.TestContext
export type Circus_Exception = CircusModule.Exception
export type Circus_FormattedError = CircusModule.FormattedError
export type Circus_Hook = CircusModule.Hook
export type Circus_EventHandler = CircusModule.EventHandler
export type Circus_Event = CircusModule.Event
export type Circus_SyncEvent = CircusModule.SyncEvent
export type Circus_AsyncEvent = CircusModule.AsyncEvent
export type Circus_MatcherResults = CircusModule.MatcherResults
export type Circus_TestStatus = CircusModule.TestStatus
export type Circus_TestResult = CircusModule.TestResult
export type Circus_RunResult = CircusModule.RunResult
export type Circus_TestResults = CircusModule.TestResults
export type Circus_GlobalErrorHandlers = CircusModule.GlobalErrorHandlers
export type Circus_State = CircusModule.State
export type Circus_DescribeBlock = CircusModule.DescribeBlock
export type Circus_TestError = CircusModule.TestError
export type Circus_TestEntry = CircusModule.TestEntry

local ConfigModule = require(script.Config)
export type Config_Path = ConfigModule.Path
export type Config_Glob = ConfigModule.Glob
export type Config_HasteConfig = ConfigModule.HasteConfig
export type Config_CoverageReporterName = ConfigModule.CoverageReporterName
export type Config_CoverageReporterWithOptions<K> = ConfigModule.CoverageReporterWithOptions<K>
export type Config_CoverageReporters = ConfigModule.CoverageReporters
export type Config_ReporterConfig = ConfigModule.ReporterConfig
export type Config_TransformerConfig = ConfigModule.TransformerConfig
export type Config_ConfigGlobals = ConfigModule.ConfigGlobals
export type Config_PrettyFormatOptions = ConfigModule.PrettyFormatOptions
export type Config_DefaultOptions = ConfigModule.DefaultOptions
export type Config_DisplayName = ConfigModule.DisplayName
export type Config_InitialOptionsWithRootDir = ConfigModule.InitialOptionsWithRootDir
export type Config_InitialProjectOptions = ConfigModule.InitialProjectOptions
export type Config_InitialOptions = ConfigModule.InitialOptions
export type Config_SnapshotUpdateState = ConfigModule.SnapshotUpdateState
export type Config_CoverageThresholdValue = ConfigModule.CoverageThresholdValue
export type Config_GlobalConfig = ConfigModule.GlobalConfig
export type Config_ProjectConfig = ConfigModule.ProjectConfig
export type Config_Argv = ConfigModule.Argv

local GlobalModule = require(script.Global)
export type Global_ValidTestReturnValues = GlobalModule.ValidTestReturnValues
export type Global_TestReturnValue = GlobalModule.TestReturnValue
export type Global_TestContext = GlobalModule.TestContext
export type Global_DoneFn = GlobalModule.DoneFn
export type Global_DoneTakingTestFn = GlobalModule.DoneTakingTestFn
export type Global_PromiseReturningTestFn = GlobalModule.PromiseReturningTestFn
export type Global_GeneratorReturningTestFn = GlobalModule.GeneratorReturningTestFn
export type Global_TestName = GlobalModule.TestName
export type Global_TestFn = GlobalModule.TestFn
export type Global_ConcurrentTestFn = GlobalModule.ConcurrentTestFn
export type Global_BlockFn = GlobalModule.BlockFn
export type Global_BlockName = GlobalModule.BlockName
export type Global_HookFn = GlobalModule.HookFn
export type Global_Col = GlobalModule.Col
export type Global_Row = GlobalModule.Row
export type Global_Table = GlobalModule.Table
export type Global_ArrayTable = GlobalModule.ArrayTable
export type Global_TemplateTable = GlobalModule.TemplateTable
export type Global_TemplateData = GlobalModule.TemplateData
export type Global_EachTable = GlobalModule.EachTable
export type Global_TestCallback = GlobalModule.TestCallback
export type Global_EachTestFn<EachCallback> = GlobalModule.EachTestFn<EachCallback>
export type Global_HookBase = GlobalModule.HookBase
export type Global_ItBase = GlobalModule.ItBase
export type Global_It = GlobalModule.It
export type Global_ItConcurrentBase = GlobalModule.ItConcurrentBase
export type Global_ItConcurrentExtended = GlobalModule.ItConcurrentExtended
export type Global_ItConcurrent = GlobalModule.ItConcurrent
export type Global_DescribeBase = GlobalModule.DescribeBase
export type Global_Describe = GlobalModule.Describe
export type Global_TestFrameworkGlobals = GlobalModule.TestFrameworkGlobals
export type Global_GlobalAdditions = GlobalModule.GlobalAdditions
export type Global_Global = GlobalModule.Global

local TestResultModule = require(script.TestResult)
export type TestResult_Milliseconds = TestResultModule.Milliseconds
export type TestResult_AssertionResult = TestResultModule.AssertionResult
export type TestResult_SerializableError = TestResultModule.SerializableError
export type TestResult_Callsite = TestResultModule.Callsite
export type TestResult_Status = TestResultModule.Status

local TransformModule = require(script.Transform)
export type TransformTypes_TransformResult = TransformModule.TransformResult

return {}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="389">
              <Properties>
                <string name="Name">Circus</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-types/src/Circus.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local rootWorkspace = script.Parent.Parent
local LuauPolyfill = require(rootWorkspace.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Promise<T> = LuauPolyfill.Promise<T>

local RegExp = require(rootWorkspace.RegExp)
type RegExp = RegExp.RegExp

-- ROBLOX FIXME: can't express void when defined outside of a function type
type void = nil

local GlobalModule = require(script.Parent.Global)

-- ROBLOX deviation START: NodeJS.Process not available
-- type Process = NodeJS.Process
type Process = Object
-- ROBLOX deviation END

export type DoneFn = GlobalModule.DoneFn
export type BlockFn = GlobalModule.BlockFn
export type BlockName = GlobalModule.BlockName
export type BlockNameLike = GlobalModule.BlockNameLike
export type TestNameLike = GlobalModule.TestNameLike
export type BlockMode = void | "skip" | "only" | "todo"
export type TestMode = BlockMode
export type TestName = GlobalModule.TestName
export type TestFn = GlobalModule.TestFn
export type HookFn = GlobalModule.HookFn
export type AsyncFn = TestFn | HookFn
export type SharedHookType = "afterAll" | "beforeAll"
export type HookType = SharedHookType | "afterEach" | "beforeEach"
export type TestContext = GlobalModule.TestContext
export type Exception = any -- Since in JS anything can be thrown as an error.
export type FormattedError = string -- String representation of error.
export type Hook = {
	asyncError: Error,
	fn: HookFn,
	type: HookType,
	parent: DescribeBlock,
	seenDone: boolean,
	timeout: number | nil,
}

-- ROBLOX deviation: combined both possible function signatures into one so that it's considered callable by Luau analyze
export type EventHandler = (self: any, event: AsyncEvent | SyncEvent, state: State) -> ...Promise<void>

export type Event = SyncEvent | AsyncEvent

type JestGlobals = GlobalModule.TestFrameworkGlobals & {
	-- we cannot type `expect` properly as it'd create circular dependencies
	expect: any,
	expectExtended: any,
}

export type SyncEvent = {
	asyncError: Error,
	mode: BlockMode,
	name: "start_describe_definition",
	blockName: BlockName,
} | {
	mode: BlockMode,
	name: "finish_describe_definition",
	blockName: BlockName,
} | {
	asyncError: Error,
	name: "add_hook",
	hookType: HookType,
	fn: HookFn,
	timeout: number | nil,
} | {
	asyncError: Error,
	name: "add_test",
	testName: TestName,
	fn: TestFn,
	mode: TestMode?,
	concurrent: boolean,
	timeout: number | nil,
	failing: boolean,
} | {
	-- Any unhandled error that happened outside of test/hooks (unless it is
	-- an `afterAll` hook)
	name: "error",
	error: Exception,
}

export type AsyncEvent = {
	-- first action to dispatch. Good time to initialize all settings
	name: "setup",
	testNamePattern: string?,
	runtimeGlobals: JestGlobals,
	parentProcess: Process,
} | {
	name: "include_test_location_in_result",
} | {
	name: "hook_start",
	hook: Hook,
} | {
	name: "hook_success",
	describeBlock: DescribeBlock?,
	test: TestEntry?,
	hook: Hook,
} | {
	name: "hook_failure",
	error: string | Exception,
	describeBlock: DescribeBlock?,
	test: TestEntry?,
	hook: Hook,
} | {
	name: "test_fn_start",
	test: TestEntry,
} | {
	name: "test_fn_success",
	test: TestEntry,
} | {
	name: "test_fn_failure",
	error: Exception,
	test: TestEntry,
} | {
	name: "test_retry",
	test: TestEntry,
} | {
	-- the `test` in this case is all hooks + it/test function, not just the
	-- function passed to `it/test`
	name: "test_start",
	test: TestEntry,
} | {
	name: "test_skip",
	test: TestEntry,
} | {
	name: "test_todo",
	test: TestEntry,
} | {
	-- test failure is defined by presence of errors in `test.errors`,
	-- `test_done` indicates that the test and all its hooks were run,
	-- and nothing else will change it's state in the future. (except third
	-- party extentions/plugins)
	name: "test_done",
	test: TestEntry,
} | {
	name: "run_describe_start",
	describeBlock: DescribeBlock,
} | {
	name: "run_describe_finish",
	describeBlock: DescribeBlock,
} | {
	name: "run_start",
} | {
	name: "run_finish",
} | {
	-- Action dispatched after everything is finished and we're about to wrap
	-- things up and return test results to the parent process (caller).
	name: "teardown",
}

export type MatcherResults = { actual: any, expected: any, name: string, pass: boolean }

export type TestStatus = "skip" | "done" | "todo"
export type TestResult = {
	duration: (number | nil)?,
	errors: Array<FormattedError>,
	errorsDetailed: Array<MatcherResults | any>,
	invocations: number,
	status: TestStatus,
	location: ({ column: number, line: number } | nil)?,
	retryReasons: Array<FormattedError>,
	testPath: Array<TestName | BlockName>,
}

export type RunResult = { unhandledErrors: Array<FormattedError>, testResults: TestResults }

export type TestResults = Array<TestResult>

export type GlobalErrorHandlers = {
	uncaughtException: Array<(exception: Exception) -> ()>,
	unhandledRejection: Array<(exception: Exception, promise: Promise<any>) -> ()>,
}

export type State = {
	currentDescribeBlock: DescribeBlock,
	currentlyRunningTest: (TestEntry | nil)?, -- including when hooks are being executed
	expand: boolean?, -- expand error messages
	hasFocusedTests: boolean, -- that are defined using test.only
	hasStarted: boolean, -- whether the rootDescribeBlock has started running
	-- Store process error handlers. During the run we inject our own
	-- handlers (so we could fail tests on unhandled errors) and later restore
	-- the original ones.
	originalGlobalErrorHandlers: GlobalErrorHandlers?,
	parentProcess: Process | nil, -- process object from the outer scope
	rootDescribeBlock: DescribeBlock,
	testNamePattern: (RegExp | nil)?,
	testTimeout: number,
	unhandledErrors: Array<Exception>,
	includeTestLocationInResult: boolean,
}

export type DescribeBlock = {
	type: "describeBlock",
	children: Array<DescribeBlock | TestEntry>,
	hooks: Array<Hook>,
	mode: BlockMode,
	name: BlockName,
	parent: DescribeBlock?,
	--[[* @deprecated Please get from `children` array instead ]]
	tests: Array<TestEntry>,
}

export type TestError = Exception | Array<Exception | nil> -- the error from the test, as well as a backup error for async

export type TestEntry = {
	type: "test",
	asyncError: Exception, -- Used if the test failure contains no usable stack trace
	errors: Array<TestError>,
	retryReasons: Array<TestError>,
	fn: TestFn,
	invocations: number,
	mode: TestMode,
	name: TestName,
	parent: DescribeBlock,
	startedAt: (number | nil)?,
	duration: (number | nil)?,
	seenDone: boolean,
	status: (TestStatus | nil)?, -- whether the test has been skipped or run already
	timeout: number?,
	failing: boolean,
}

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="390">
              <Properties>
                <string name="Name">Config</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-types/src/Config.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local rootWorkspace = script.Parent.Parent
local LuauPolyfill = require(rootWorkspace.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local RegExp = require(rootWorkspace.RegExp)
type RegExp = RegExp.RegExp

type Record<T, U> = { [T]: U }
type TemplateStringsArray = Array<string>

-- ROBLOX deviation START: Libraries/types not available
-- local chalkModule = require(rootWorkspace.chalk)
-- type ForegroundColor = chalkModule.ForegroundColor
type ForegroundColor = string

-- local istanbul_reportsModule = require(rootWorkspace["istanbul-reports"])
-- type ReportOptions = istanbul_reportsModule.ReportOptions
type ReportOptions = Object

-- local yargsModule = require(rootWorkspace.yargs)
-- type Arguments = yargsModule.Arguments
type Arguments<T> = T & Object
-- ROBLOX deviation END: Libraries/types not available

type CoverageProvider = "babel" | "v8"

export type FakeableAPI =
	"Date"
	| "hrtime"
	| "nextTick"
	| "performance"
	| "queueMicrotask"
	| "requestAnimationFrame"
	| "cancelAnimationFrame"
	| "requestIdleCallback"
	| "cancelIdleCallback"
	| "setImmediate"
	| "clearImmediate"
	| "setInterval"
	| "clearInterval"
	| "setTimeout"
	| "clearTimeout"

export type GlobalFakeTimersConfig = { --[[*
   * Whether fake timers should be enabled globally for all test files.
   *
   * @defaultValue
   * The default is `false`.
   ]]
	enableGlobally: boolean?,
}

export type FakeTimersConfig = { --[[*
   * If set to `true` all timers will be advanced automatically
   * by 20 milliseconds every 20 milliseconds. A custom time delta
   * may be provided by passing a number.
   *
   * @defaultValue
   * The default is `false`.
   ]]
	advanceTimers: (boolean | number)?,
	--[[*
   * List of names of APIs (e.g. `Date`, `nextTick()`, `setImmediate()`,
   * `setTimeout()`) that should not be faked.
   *
   * @defaultValue
   * The default is `[]`, meaning all APIs are faked.
   ]]
	doNotFake: Array<FakeableAPI>?,
	--[[*
   * Sets current system time to be used by fake timers.
   *
   * @defaultValue
   * The default is `Date.now()`.
   ]]
	now: (number | DateTime)?,
	--[[*
   * The maximum number of recursive timers that will be run when calling
   * `jest.runAllTimers()`.
   *
   * @defaultValue
   * The default is `100_000` timers.
   ]]
	timerLimit: number?,
	--[[*
   * Use the old fake timers implementation instead of one backed by
   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).
   *
   * @defaultValue
   * The default is `false`.
   ]]
	legacyFakeTimers: false?,
}

export type LegacyFakeTimersConfig = { --[[*
   * Use the old fake timers implementation instead of one backed by
   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).
   *
   * @defaultValue
   * The default is `false`.
   ]]
	legacyFakeTimers: true?,
}

-- ROBLOX deviation START: handle TSParenthesizedType, remove Exclude<T> and replace 'Date' with 'DateTime'
type FakeTimers = GlobalFakeTimersConfig & ((FakeTimersConfig & {
	now: DateTime?,
}) | LegacyFakeTimersConfig)
-- ROBLOX deviation STOP

type Timers = "real" | "fake" | "modern" | "legacy"

export type Path = string

export type Glob = string

export type HasteConfig = {
	--[[* Whether to hash files using SHA-1. ]]
	computeSha1: boolean?,
	--[[* The platform to use as the default, e.g. 'ios'. ]]
	defaultPlatform: (string | nil)?,
	--[[* Force use of Node's `fs` APIs rather than shelling out to `find` ]]
	forceNodeFilesystemAPI: boolean?,
	--[[*
  	 * Whether to follow symlinks when crawling for files.
  	 *   This options cannot be used in projects which use watchman.
  	 *   Projects with `watchman` set to true will error if this option is set to true.
  	 ]]
	enableSymlinks: boolean?,
	--[[* string to a custom implementation of Haste. ]]
	hasteImplModulePath: string?,
	--[[* All platforms to target, e.g ['ios', 'android']. ]]
	platforms: Array<string>?,
	--[[* Whether to throw on error on module collision. ]]
	throwOnModuleCollision: boolean?,
	--[[* Custom HasteMap module ]]
	hasteMapModulePath: string?,
	--[[* Whether to retain all files, allowing e.g. search for tests in `node_modules`. ]]
	retainAllFiles: boolean?,
}

export type CoverageReporterName = string --[[ ROBLOX TODO: Unhandled node for type: TSTypeOperator ]] --[[ keyof ReportOptions ]]

-- ROBLOX FIXME: add default generic type <K = CoverageReporterName>
-- ROBLOX TODO: Unhandled node for type: TSConditionalType ]] --[[ K extends CoverageReporterName ? ReportOptions[K] extends never ? never : [K, Partial<ReportOptions[K]>] : never
export type CoverageReporterWithOptions<K> =
	Array<string | Object> --[[ [K, Partial<ReportOptions[K]>] ]]
	| nil

export type CoverageReporters = Array<CoverageReporterName | CoverageReporterWithOptions<CoverageReporterName>>

-- ROBLOX deviation: using a named table for ReporterConfig since we can't type tuples
-- export type ReporterConfig = Array<string | ModuleScript | Record<string, any>>
export type ReporterConfig = { reporter: string | ModuleScript, options: { [string]: any } }

export type TransformerConfig = Array<string | Record<string, any>>

export type ConfigGlobals = {
	[string]: any,
}

-- This interface gets filled out when pretty-format is included
export type PrettyFormatOptions = {}

export type DefaultOptions = {
	automock: boolean,
	bail: number,
	-- ROBLOX deviation START: caching not supported
	-- cache: boolean,
	-- cacheDirectory: Path,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: not supported
	-- changedFilesWithAncestor: boolean,
	-- ROBLOX deviation END
	ci: boolean,
	clearMocks: boolean,
	-- ROBLOX deviation START: not supported
	-- collectCoverage: boolean,
	-- coveragePathIgnorePatterns: Array<string>,
	-- coverageReporters: Array<CoverageReporterName>,
	-- coverageProvider: CoverageProvider,
	-- detectLeaks: boolean,
	-- detectOpenHandles: boolean,
	-- errorOnDeprecated: boolean,
	-- ROBLOX deviation END
	expand: boolean,
	-- ROBLOX deviation START: not supported
	-- extensionsToTreatAsEsm: Array<Path>,
	-- forceCoverageMatch: Array<Glob>,
	-- ROBLOX deviation END
	globals: ConfigGlobals,
	-- ROBLOX deviation START: not supported
	-- haste: HasteConfig,
	-- ROBLOX deviation END
	injectGlobals: boolean,
	listTests: boolean,
	maxConcurrency: number,
	maxWorkers: number | string,
	-- ROBLOX deviation START: not supported
	-- moduleDirectories: Array<string>,
	-- moduleFileExtensions: Array<string>,
	-- moduleNameMapper: Record<string, string | Array<string>>,
	-- modulePathIgnorePatterns: Array<string>,
	-- ROBLOX deviation END
	-- ROBLOX deviation: mock data model
	mockDataModel: boolean,
	noStackTrace: boolean,
	-- ROBLOX deviation START: not supported
	-- notify: boolean,
	-- notifyMode: NotifyMode,
	-- ROBLOX deviation END
	-- ROBLOX deviation: inject alike types
	oldFunctionSpying: boolean,
	passWithNoTests: boolean,
	-- ROBLOX deviation START: not supported
	-- prettierPath: string,
	-- ROBLOX deviation END
	resetMocks: boolean,
	resetModules: boolean,
	restoreMocks: boolean,
	roots: Array<string>,
	runTestsByPath: boolean,
	runner: string,
	setupFiles: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>,
	setupFilesAfterEnv: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>,
	skipFilter: boolean,
	slowTestThreshold: number,
	snapshotSerializers: Array<string>,
	testEnvironment: string,
	testEnvironmentOptions: Record<string, any>,
	testFailureExitCode: string | number,
	testLocationInResults: boolean,
	testMatch: Array<string>,
	testPathIgnorePatterns: Array<string>,
	testRegex: Array<string>,
	-- ROBLOX deviation START: not supported
	-- testRunner: string,
	-- testSequencer: string,
	-- testURL: string,
	-- ROBLOX deviation END
	timers: Timers,
	-- ROBLOX deviation START: not supported
	-- transformIgnorePatterns: Array<Glob>,
	-- useStderr: boolean,
	-- watch: boolean,
	-- watchPathIgnorePatterns: Array<string>,
	-- watchman: boolean,
	-- ROBLOX deviation END
}

export type DisplayName = {
	name: string,
	color: string, --[[ ROBLOX TODO: Unhandled node for type: TSTypeQuery ]] --[[ typeof ForegroundColor ]]
}

-- ROBLOX deviation: inline Required<Pick<InitialOptions, 'rootDir'>>
export type InitialOptionsWithRootDir = InitialOptions & { rootDir: Path }

-- ROBLOX deviation: inline Pick<InitialOptions & {cwd?: string}, keyof ProjectConfig>
export type InitialProjectOptions = {
	automock: boolean?,
	-- ROBLOX deviation START: not supported
	-- cache: boolean?,
	-- cacheDirectory: Path?,
	-- ROBLOX deviation END
	clearMocks: boolean?,
	-- ROBLOX deviation START: not supported
	-- coveragePathIgnorePatterns: Array<string>?,
	-- dependencyExtractor: string?,
	-- detectLeaks: boolean?,
	-- detectOpenHandles: boolean?,
	-- ROBLOX deviation END
	displayName: (string | DisplayName)?,
	-- ROBLOX deviation START: not supported
	-- extensionsToTreatAsEsm: Array<Path>?,
	-- extraGlobals: Array<string>?,
	-- ROBLOX deviation END
	filter: Path?,
	-- ROBLOX deviation START: not supported
	-- forceCoverageMatch: Array<Glob>?,
	-- globalSetup: (string | nil)?,
	-- globalTeardown: (string | nil)?,
	-- haste: HasteConfig?,
	-- ROBLOX deviation END
	injectGlobals: boolean?,
	-- ROBLOX deviation START: not supported
	-- moduleDirectories: Array<string>?,
	-- moduleFileExtensions: Array<string>?,
	-- ROBLOX deviation END
	moduleLoader: Path?,
	-- ROBLOX deviation START: not supported
	-- moduleNameMapper: { [string]: string | Array<string> }?,
	-- modulePathIgnorePatterns: Array<string>?,
	-- modulePaths: Array<string>?,
	-- prettierPath: (string | nil)?,
	-- ROBLOX deviation END
	resetMocks: boolean?,
	resetModules: boolean?,
	-- ROBLOX deviation START: not supported
	-- resolver: (Path | nil)?,
	-- ROBLOX deviation END
	restoreMocks: boolean?,
	-- ROBLOX deviation START: using Instance instead of Path
	rootDir: Instance?,
	-- ROBLOX deviation END
	roots: Array<string>?,
	runner: string?,
	setupFiles: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>?,
	setupFilesAfterEnv: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>?,
	skipFilter: boolean?,
	skipNodeResolution: boolean?,
	slowTestThreshold: number?,
	-- ROBLOX deviation START: not supported
	-- snapshotResolver: Path?,
	-- ROBLOX deviation END
	snapshotSerializers: Array<Path>?,
	snapshotFormat: PrettyFormatOptions?,
	testEnvironment: string?,
	testEnvironmentOptions: Record<string, any>?,
	testLocationInResults: boolean?,
	testMatch: Array<Glob>?,
	testPathIgnorePatterns: Array<string>?,
	testRegex: (string | Array<string>)?,
	-- ROBLOX deviation START: not supported
	-- testRunner: string?,
	-- testURL: string?,
	-- ROBLOX deviation END
	timers: Timers?,
	-- ROBLOX deviation START: not supported
	-- transform: { [string]: Path | TransformerConfig }?,
	-- transformIgnorePatterns: Array<Glob>?,
	-- watchPathIgnorePatterns: Array<string>?,
	-- unmockedModulePathPatterns: Array<string>?,
	-- ROBLOX deviation END
} & {
	-- ROBLOX deviation START: not supported
	-- cwd: string?
	-- ROBLOX deviation END
}

-- ROBLOX deviation: replace Partial type making all fields optional
export type InitialOptions = {
	automock: boolean?,
	bail: (boolean | number)?,
	-- ROBLOX deviation START: not supported
	-- cache: boolean?,
	-- cacheDirectory: Path?,
	-- ROBLOX deviation END
	ci: boolean?,
	clearMocks: boolean?,
	-- ROBLOX deviation START: not supported
	-- changedFilesWithAncestor: boolean?,
	-- ROBLOX deviation END
	changedSince: string?,
	-- ROBLOX deviation START: not supported
	-- collectCoverage: boolean?,
	-- collectCoverageFrom: Array<Glob>?,
	-- collectCoverageOnlyFrom: { [string]: boolean }?,
	-- coverageDirectory: string?,
	-- coveragePathIgnorePatterns: Array<string>?,
	-- coverageProvider: CoverageProvider?,
	-- coverageReporters: CoverageReporters?,
	-- coverageThreshold: CoverageThreshold?,
	-- dependencyExtractor: string?,
	-- detectLeaks: boolean?,
	-- detectOpenHandles: boolean?,
	-- ROBLOX deviation END
	displayName: (string | DisplayName)?,
	expand: boolean?,
	-- ROBLOX deviation START: not supported
	-- extensionsToTreatAsEsm: Array<Path>?,
	-- extraGlobals: Array<string>?,
	-- ROBLOX deviation END
	filter: Path?,
	findRelatedTests: boolean?,
	-- ROBLOX deviation START: not supported
	-- forceCoverageMatch: Array<Glob>?,
	-- forceExit: boolean?,
	-- ROBLOX deviation END
	json: boolean?,
	globals: ConfigGlobals?,
	-- ROBLOX deviation START: not supported
	-- globalSetup: (string | nil)?,
	-- globalTeardown: (string | nil)?,
	-- haste: HasteConfig?,
	-- ROBLOX deviation END
	injectGlobals: boolean?,
	reporters: Array<string | ModuleScript | ReporterConfig>?,
	-- ROBLOX deviation START: not supported
	-- logHeapUsage: boolean?,
	-- lastCommit: boolean?,
	-- ROBLOX deviation END
	listTests: boolean?,
	maxConcurrency: number?,
	maxWorkers: (number | string)?,
	-- ROBLOX deviation START: not supported
	-- moduleDirectories: Array<string>?,
	-- moduleFileExtensions: Array<string>?,
	-- ROBLOX deviation END
	moduleLoader: Path?,
	-- ROBLOX deviation START: not supported
	-- moduleNameMapper: { [string]: string | Array<string> }?,
	-- modulePathIgnorePatterns: Array<string>?,
	-- modulePaths: Array<string>?,
	-- ROBLOX deviation END
	id: string?,
	-- ROBLOX deviation: mock data model
	mockDataModel: boolean?,
	noStackTrace: boolean?,
	-- ROBLOX deviation START: not supported
	-- notify: boolean?,
	-- notifyMode: string?,
	-- onlyChanged: boolean?,
	-- onlyFailures: boolean?,
	-- ROBLOX deviation END
	outputFile: Path?,
	-- ROBLOX deviation: inject alike types
	oldFunctionSpying: boolean?,
	passWithNoTests: boolean?,
	--[[*
	* @deprecated Use `transformIgnorePatterns` options instead.
	]]
	preprocessorIgnorePatterns: Array<Glob>?,
	preset: (string | nil)?,
	-- ROBLOX deviation START: not supported
	-- prettierPath: (string | nil)?,
	-- ROBLOX deviation END
	projects: Array<Glob | InitialProjectOptions>?,
	-- ROBLOX deviation START: not supported
	-- replname: (string | nil)?,
	-- ROBLOX deviation END
	resetMocks: boolean?,
	resetModules: boolean?,
	-- ROBLOX deviation START: not supported
	-- resolver: (Path | nil)?,
	-- ROBLOX deviation END
	restoreMocks: boolean?,
	-- ROBLOX deviation START: using Instance instead of Path
	rootDir: Instance?,
	-- ROBLOX deviation END
	roots: Array<Path>?,
	runner: string?,
	runTestsByPath: boolean?,
	runtime: string?,
	sandboxInjectedGlobals: Array<string>?,
	--[[*
  	 * @deprecated Use `transform` options instead.
  	 ]]
	scriptPreprocessor: string?,
	setupFiles: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>?,
	-- ROBLOX deviation START: not supported
	-- --[[*
	-- * @deprecated Use `setupFilesAfterEnv` options instead.
	-- ]]
	-- setupTestFrameworkScriptFile: Path?,
	-- ROBLOX deviation END
	setupFilesAfterEnv: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>?,
	silent: boolean?,
	skipFilter: boolean?,
	skipNodeResolution: boolean?,
	slowTestThreshold: number?,
	-- ROBLOX deviation START: not supported
	-- snapshotResolver: Path?,
	-- ROBLOX deviation END
	snapshotSerializers: Array<Path>?,
	snapshotFormat: PrettyFormatOptions?,
	-- ROBLOX deviation START: not supported
	-- errorOnDeprecated: boolean?,
	-- ROBLOX deviation END
	testEnvironment: string?,
	testEnvironmentOptions: Record<string, any>?,
	testFailureExitCode: (string | number)?,
	testLocationInResults: boolean?,
	testMatch: Array<Glob>?,
	testNamePattern: string?,
	--[[*
	 * @deprecated Use `roots` options instead.
	 ]]
	testPathDirs: Array<Path>?,
	testPathIgnorePatterns: Array<string>?,
	testRegex: (string | Array<string>)?,
	-- ROBLOX deviation START: not supported
	-- testResultsProcessor: string?,
	-- testRunner: string?,
	-- testSequencer: string?,
	-- testURL: string?,
	-- ROBLOX deviation END
	testTimeout: number?,
	timers: Timers?,
	-- ROBLOX deviation START: not supported
	-- transform: { [string]: Path | TransformerConfig }?,
	-- transformIgnorePatterns: Array<Glob>?,
	-- watchPathIgnorePatterns: Array<string>?,
	-- unmockedModulePathPatterns: Array<string>?,
	-- ROBLOX deviation END
	updateSnapshot: boolean?,
	-- ROBLOX deviation START: not supported
	-- useStderr: boolean?,
	-- ROBLOX deviation END
	verbose: boolean?,
	-- ROBLOX deviation START: not supported
	-- watch: boolean?,
	-- watchAll: boolean?,
	-- watchman: boolean?,
	-- watchPlugins: Array<string | Array<string | Record<string, any>>>?,
	-- ROBLOX deviation END
}

export type SnapshotUpdateState = "all" | "new" | "none"

type NotifyMode = "always" | "failure" | "success" | "change" | "success-change" | "failure-change"

export type CoverageThresholdValue = {
	branches: number?,
	functions: number?,
	lines: number?,
	statements: number?,
}

type CoverageThreshold = { [string]: CoverageThresholdValue, global: CoverageThresholdValue }

export type GlobalConfig = {
	bail: number,
	changedSince: string?,
	-- ROBLOX deviation START: not supported
	-- changedFilesWithAncestor: boolean,
	-- collectCoverage: boolean,
	-- collectCoverageFrom: Array<Glob>,
	-- collectCoverageOnlyFrom: { [string]: boolean }?,
	-- coverageDirectory: string,
	-- coveragePathIgnorePatterns: Array<string>?,
	-- coverageProvider: CoverageProvider,
	-- coverageReporters: CoverageReporters,
	-- coverageThreshold: CoverageThreshold?,
	-- detectLeaks: boolean,
	-- detectOpenHandles: boolean,
	-- ROBLOX deviation END
	expand: boolean,
	filter: Path?,
	-- ROBLOX deviation START: not supported
	-- findRelatedTests: boolean,
	-- forceExit: boolean,
	-- ROBLOX deviation END
	json: boolean,
	-- ROBLOX deviation START: not supported
	-- globalSetup: string?,
	-- globalTeardown: string?,
	-- lastCommit: boolean,
	-- logHeapUsage: boolean,
	-- ROBLOX deviation END
	listTests: boolean,
	maxConcurrency: number,
	maxWorkers: number,
	noStackTrace: boolean,
	nonFlagArgs: Array<string>,
	-- ROBLOX deviation START: not supported
	-- noSCM: boolean?,
	-- notify: boolean,
	-- notifyMode: NotifyMode,
	-- ROBLOX deviation END
	outputFile: Path?,
	-- ROBLOX deviation START: not supported
	-- onlyChanged: boolean,
	-- onlyFailures: boolean,
	-- ROBLOX deviation END
	passWithNoTests: boolean,
	-- ROBLOX deviation: using Instance instead of Glob
	projects: Array<Instance>,
	-- ROBLOX deviation START: not supported
	-- replname: string?,
	-- ROBLOX deviation END
	reporters: Array<string | ModuleScript | ReporterConfig>?,
	runTestsByPath: boolean,
	-- ROBLOX deviation START: using Instance instead of Path
	rootDir: Instance,
	-- ROBLOX deviation END
	silent: boolean?,
	skipFilter: boolean,
	snapshotFormat: PrettyFormatOptions,
	-- ROBLOX deviation START: not supported
	-- errorOnDeprecated: boolean,
	-- ROBLOX deviation END
	testFailureExitCode: number,
	testNamePattern: string?,
	testPathPattern: string,
	-- ROBLOX deviation START: not supported
	-- testResultsProcessor: string?,
	-- testSequencer: string,
	-- ROBLOX deviation END
	testTimeout: number?,
	updateSnapshot: SnapshotUpdateState,
	-- ROBLOX deviation START: not supported
	-- useStderr: boolean,
	-- ROBLOX deviation END
	verbose: boolean?,
	-- ROBLOX deviation START: not supported
	-- watch: boolean,
	-- watchAll: boolean,
	-- watchman: boolean,
	-- watchPlugins: (Array<{
	-- 	path: string,
	-- 	config: Record<string, any>,
	-- }> | nil)?,
	-- ROBLOX deviation END
}
export type ProjectConfig = {
	automock: boolean,
	-- ROBLOX deviation START: caching not supported
	-- cache: boolean,
	-- cacheDirectory: Path,
	-- ROBLOX deviation END
	clearMocks: boolean,
	-- ROBLOX deviation START: not supported
	-- coveragePathIgnorePatterns: Array<string>,
	-- cwd: Path,
	-- dependencyExtractor: string?,
	-- detectLeaks: boolean,
	-- detectOpenHandles: boolean,
	-- ROBLOX deviation END
	displayName: DisplayName?,
	-- ROBLOX deviation START: not supported
	-- errorOnDeprecated: boolean,
	-- extensionsToTreatAsEsm: Array<Path>,
	fakeTimers: FakeTimers,
	-- extraGlobals: Array<string>, -- ROBLOX deviation: Array<keyof typeof globalThis>;
	-- ROBLOX deviation END
	filter: Path?,
	-- ROBLOX deviation START: not supported
	-- forceCoverageMatch: Array<Glob>,
	-- globalSetup: string?,
	-- globalTeardown: string?,
	-- globals: ConfigGlobals,
	-- haste: HasteConfig,
	-- ROBLOX deviation END
	id: string,
	injectGlobals: boolean,
	-- ROBLOX deviation START: not supported
	-- moduleDirectories: Array<string>,
	-- moduleFileExtensions: Array<string>,
	-- moduleLoader: Path?,
	-- moduleNameMapper: Array<Array<string>>,
	-- modulePathIgnorePatterns: Array<string>,
	-- modulePaths: Array<string>?,
	-- prettierPath: string,
	-- ROBLOX deviation END
	-- ROBLOX deviation: mock data model
	mockDataModel: boolean,
	-- ROBLOX deviation: inject alike types
	oldFunctionSpying: boolean,
	resetMocks: boolean,
	resetModules: boolean,
	-- ROBLOX deviation START: not supported
	-- resolver: Path?,
	-- ROBLOX deviation END
	restoreMocks: boolean,
	-- ROBLOX deviation START: using Instance instead of Path
	rootDir: Instance,
	-- ROBLOX deviation END
	roots: Array<Path>,
	runner: string,
	runtime: string?,
	sandboxInjectedGlobals: Array<ProjectConfig>,
	setupFiles: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>,
	setupFilesAfterEnv: Array<
		-- ROBLOX deviation START: using ModuleScript instead of Path
		ModuleScript
		-- ROBLOX deviation END
	>,
	skipFilter: boolean,
	-- ROBLOX deviation START: not supported
	-- skipNodeResolution: boolean?,
	-- ROBLOX deviation END
	slowTestThreshold: number,
	-- ROBLOX deviation START: not supported
	-- snapshotResolver: Path?,
	-- ROBLOX deviation END
	snapshotSerializers: Array<Path>,
	snapshotFormat: PrettyFormatOptions,
	testEnvironment: string,
	testEnvironmentOptions: Record<string, any>,
	testMatch: Array<Glob>,
	testLocationInResults: boolean,
	testPathIgnorePatterns: Array<string>,
	testRegex: Array<string | RegExp>,
	-- ROBLOX deviation START: not supported
	-- testRunner: string,
	-- testURL: string,
	-- ROBLOX deviation END
	timers: Timers,
	-- ROBLOX deviation START: not supported
	-- transform: Array<Array<string | Path | Record<string, any>>>,
	-- transformIgnorePatterns: Array<Glob>,
	-- watchPathIgnorePatterns: Array<string>,
	-- unmockedModulePathPatterns: Array<string>?,
	-- ROBLOX deviation END
}
-- ROBLOX deviation: replace Partial type making all fields optional
export type Argv = Arguments<{
	all: boolean?,
	automock: boolean?,
	bail: (boolean | number)?,
	-- ROBLOX deviation START: not supported
	-- cache: boolean?,
	-- cacheDirectory: string?,
	-- changedFilesWithAncestor: boolean?,
	-- ROBLOX deviation END
	changedSince: string?,
	ci: boolean?,
	clearCache: boolean?,
	clearMocks: boolean?,
	-- ROBLOX deviation START: not supported
	-- collectCoverage: boolean?,
	-- collectCoverageFrom: string?,
	-- collectCoverageOnlyFrom: Array<string>?,
	-- ROBLOX deviation END
	color: boolean?,
	colors: boolean?,
	config: string?,
	coverage: boolean?,
	-- ROBLOX deviation START: not supported
	-- coverageDirectory: string?,
	-- coveragePathIgnorePatterns: Array<string>?,
	-- coverageReporters: Array<string>?,
	-- coverageThreshold: string?,
	-- ROBLOX deviation END
	debug: boolean?,
	env: string?,
	expand: boolean?,
	-- ROBLOX deviation START: not supported
	-- findRelatedTests: boolean?,
	-- forceExit: boolean?,
	-- ROBLOX deviation END
	globals: string?,
	-- ROBLOX deviation START: not supported
	-- globalSetup: (string | nil)?,
	-- globalTeardown: (string | nil)?,
	-- haste: string?,
	-- ROBLOX deviation END
	init: boolean?,
	injectGlobals: boolean?,
	json: boolean?,
	-- ROBLOX deviation START: not supported
	-- lastCommit: boolean?,
	-- logHeapUsage: boolean?,
	-- ROBLOX deviation END
	maxWorkers: (number | string)?,
	-- ROBLOX deviation START: not supported
	-- moduleDirectories: Array<string>?,
	-- moduleFileExtensions: Array<string>?,
	-- moduleNameMapper: string?,
	-- modulePathIgnorePatterns: Array<string>?,
	-- modulePaths: Array<string>?,
	-- ROBLOX deviation END
	noStackTrace: boolean?,
	-- ROBLOX deviation START: not supported
	-- notify: boolean?,
	-- notifyMode: string?,
	-- onlyChanged: boolean?,
	-- onlyFailures: boolean?,
	-- ROBLOX deviation END
	outputFile: string?,
	preset: (string | nil)?,
	projects: Array<string>?,
	-- ROBLOX deviation START: not supported
	-- prettierPath: (string | nil)?,
	-- ROBLOX deviation END
	reporters: Array<string | ModuleScript | ReporterConfig>?,
	resetMocks: boolean?,
	resetModules: boolean?,
	-- ROBLOX deviation START: not supported
	-- resolver: (string | nil)?,
	-- ROBLOX deviation END
	restoreMocks: boolean?,
	-- ROBLOX deviation START: using Instance instead of string
	rootDir: Instance?,
	-- ROBLOX deviation END
	roots: Array<string>?,
	runInBand: boolean?,
	selectProjects: Array<string>?,
	setupFiles: Array<
		-- ROBLOX deviation START: using ModuleScript instead of string
		ModuleScript
		-- ROBLOX deviation END
	>?,
	setupFilesAfterEnv: Array<
		-- ROBLOX deviation START: using ModuleScript instead of string
		ModuleScript
		-- ROBLOX deviation END
	>?,
	showConfig: boolean?,
	silent: boolean?,
	snapshotSerializers: Array<string>?,
	testEnvironment: string?,
	testEnvironmentOptions: string?,
	testFailureExitCode: (string | nil)?,
	testMatch: Array<string>?,
	testNamePattern: string?,
	testPathIgnorePatterns: Array<string>?,
	testPathPattern: Array<string>?,
	testRegex: string | Array<string>?,
	-- ROBLOX deviation START: not supported
	-- testResultsProcessor: string?,
	-- testRunner: string?,
	-- testSequencer: string?,
	-- testURL: string?,
	-- ROBLOX deviation END
	testTimeout: (number | nil)?,
	timers: string?,
	-- ROBLOX deviation START: not supported
	-- transform: string?,
	-- transformIgnorePatterns: Array<string>?,
	-- unmockedModulePathPatterns: (Array<string> | nil)?,
	-- ROBLOX deviation END
	updateSnapshot: boolean?,
	-- ROBLOX deviation START: not supported
	-- useStderr: boolean?,
	-- ROBLOX deviation END
	verbose: boolean?,
	version: boolean?,
	-- ROBLOX deviation START: not supported
	-- watch: boolean?,
	-- watchAll: boolean?,
	-- watchman: boolean?,
	-- watchPathIgnorePatterns: Array<string>?,
	-- ROBLOX deviation END
}>

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="391">
              <Properties>
                <string name="Name">Global</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-types/src/Global.ts
--[[*
* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]

local rootWorkspace = script.Parent.Parent
local LuauPolyfill = require(rootWorkspace.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Promise<T> = LuauPolyfill.Promise<T>

type Generator<T, TReturn, TNext> = Object
type Record<T, U> = { [T]: U }
type ReturnType<T> = any
type TemplateStringsArray = Array<string>

-- ROBLOX FIXME: can't express void when defined outside of a function type
type void = nil

-- ROBLOX deviation START: Package not available, setting type to object
-- local istanbul_lib_coverageModule = require(rootWorkspace["istanbul-lib-coverage"])
type CoverageMapData = Object
-- ROBLOX deviation END

export type ValidTestReturnValues = void | nil
type TestReturnValuePromise = Promise<any>
type TestReturnValueGenerator = Generator<void, any, void>
export type TestReturnValue = ValidTestReturnValues | TestReturnValuePromise

export type TestContext = Record<string, any>

export type DoneFn = (reason: (string | Error)?) -> ()

-- these should not be undefined
export type DoneTakingTestFn = (this: TestContext | nil, done: DoneFn) -> ValidTestReturnValues
export type PromiseReturningTestFn = (this: TestContext | nil) -> TestReturnValue
export type GeneratorReturningTestFn = (this: TestContext | nil) -> TestReturnValueGenerator

type Fn = (...any) -> ...any
export type NameLike = number | Fn
export type TestName = string
export type TestNameLike = TestName | NameLike
export type TestFn = PromiseReturningTestFn | GeneratorReturningTestFn | DoneTakingTestFn
export type ConcurrentTestFn = () -> TestReturnValuePromise
export type BlockFn = () -> ()
export type BlockName = string
export type BlockNameLike = BlockName | NameLike
export type HookFn = TestFn

export type Col = any
export type Row = Array<Col>
export type Table = Array<Row>
export type ArrayTable = Table | Row
export type TemplateTable = TemplateStringsArray
export type TemplateData = Array<any>

-- ROBLOX deviation: Template literals are represented as a string
export type EachTable = ArrayTable | TemplateTable | string

export type TestCallback = BlockFn | TestFn | ConcurrentTestFn

-- ROBLOX FIXME: add type constraint <EachCallback extends TestCallback>
export type EachTestFn<EachCallback> = (...any) -> ReturnType<EachCallback>

-- TODO: Get rid of this at some point
type Jasmine = { _DEFAULT_TIMEOUT_INTERVAL: number?, addMatchers: (matchers: Record<string, any>) -> () }

-- ROBLOX FIXME: add type constraint <EachCallback extends TestCallback>
type Each<EachCallback> =
	((table: EachTable, ...any) -> (title: string, test: EachTestFn<EachCallback>, timeout: number?) -> ())
	| (() -> () -> ())

export type HookBase = (fn: TestFn, timeout: number?) -> ()

export type ItBase = typeof(setmetatable(
	{} :: { each: Each<TestFn>, failing: (testName: TestNameLike, fn: TestFn, timeout: number?) -> () },
	{ __call = function(_, testName: TestName, fn: TestFn, timeout: number?): () end }
))

export type It = ItBase & { only: ItBase, skip: ItBase, todo: (testName: TestName) -> () }

export type ItConcurrentBase = typeof(setmetatable(
	{} :: {
		each: Each<ConcurrentTestFn>,
		failing: (testName: TestNameLike, fn: ConcurrentTestFn, timeout: number?) -> (),
	},
	{ __call = function(_, testName: string, testFn: ConcurrentTestFn, timeout: number?): () end }
))

export type ItConcurrentExtended = ItConcurrentBase & { only: ItConcurrentBase, skip: ItConcurrentBase }

-- ROBLOX FIXME START Luau: inline It to make Luau analyze happy
export type ItConcurrent =
	ItBase
	& { only: ItBase, skip: ItBase, todo: (testName: TestName) -> () }
	& { concurrent: ItConcurrentExtended }
-- export type ItConcurrent = It & { concurrent: ItConcurrentExtended }
-- ROBLOX FIXME END

export type DescribeBase = typeof(setmetatable({} :: { each: Each<BlockFn> }, {
	__call = function(_, blockName: BlockName, blockFn: BlockFn): () end,
}))

export type Describe = DescribeBase & { only: DescribeBase, skip: DescribeBase }

export type TestFrameworkGlobals = {
	it: ItConcurrent,
	test: ItConcurrent,
	fit: ItBase & { concurrent: ItConcurrentBase? },
	xit: ItBase,
	xtest: ItBase,
	describe: Describe,
	xdescribe: DescribeBase,
	fdescribe: DescribeBase,
	beforeAll: HookBase,
	beforeEach: HookBase,
	afterEach: HookBase,
	afterAll: HookBase,
}

export type GlobalAdditions = TestFrameworkGlobals & {
	__coverage__: CoverageMapData,
	jasmine: Jasmine,
	fail: () -> (),
	pending: () -> (),
	spyOn: () -> (),
	spyOnProperty: () -> (),
}

-- ROBLOX FIXME: should intersect with Omit<typeof globalThis, keyof GlobalAdditions>
export type Global = GlobalAdditions & { [string]: any }

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="392">
              <Properties>
                <string name="Name">TestResult</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-types/src/TestResult.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local rootWorkspace = script.Parent.Parent
local LuauPolyfill = require(rootWorkspace.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

export type Milliseconds = number

export type Status = "passed" | "failed" | "skipped" | "pending" | "todo" | "disabled"

export type Callsite = { column: number, line: number }

-- this is here to make it possible to avoid huge dependency trees just for types
export type AssertionResult = {
	ancestorTitles: Array<string>,
	duration: (Milliseconds | nil)?,
	failureDetails: Array<any>,
	failureMessages: Array<string>,
	fullName: string,
	invocations: number?,
	location: (Callsite | nil)?,
	numPassingAsserts: number,
	retryReasons: Array<string>?,
	status: Status,
	title: string,
}

export type SerializableError = {
	code: any?,
	message: string,
	stack: string | nil,
	type: string?,
}

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="393">
              <Properties>
                <string name="Name">Transform</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-types/src/Transform.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- this is here to make it possible to avoid huge dependency trees just for types
export type TransformResult = {
	code: string,
	originalCode: string,
	sourceMapPath: string | nil,
}
return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="394">
            <Properties>
              <string name="Name">JestUtil</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/index.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local LuauPolyfill = require(script.Parent.LuauPolyfill)
local Object = LuauPolyfill.Object

local exports = {}

exports.clearLine = require(script.clearLine).default
exports.createDirectory = require(script.createDirectory).default
local ErrorWithStackModule = require(script.ErrorWithStack)
exports.ErrorWithStack = ErrorWithStackModule.default
export type ErrorWithStack = ErrorWithStackModule.ErrorWithStack
-- ROBLOX deviation: need to execute the module explicitly
exports.installCommonGlobals = require(script.installCommonGlobals)().default
-- ROBLOX deviation not ported as it doesn't seem necessary in Lua
-- exports.interopRequireDefault = require(script.interopRequireDefault).default
exports.isInteractive = require(script.isInteractive).default
exports.isPromise = require(script.isPromise).default
exports.setGlobal = require(script.setGlobal).default
exports.deepCyclicCopy = require(script.deepCyclicCopy).default
exports.convertDescriptorToString = require(script.convertDescriptorToString).default
local specialCharsModule = require(script.specialChars)
Object.assign(exports, specialCharsModule)
exports.specialChars = specialCharsModule
-- ROBLOX deviation START: additional assignments for Lua type inferrence to work
exports.ARROW = specialCharsModule.ARROW
exports.ICONS = specialCharsModule.ICONS
exports.CLEAR = specialCharsModule.CLEAR
-- ROBLOX deviation END
-- ROBLOX deviation: not ported as it doesn't seem necessary in Lua
-- exports.replacePathSepForGlob = require(script.replacePathSepForGlob).default
exports.testPathPatternToRegExp = require(script.testPathPatternToRegExp).default
exports.globsToMatcher = require(script.globsToMatcher).default
local preRunMessageModule = require(script.preRunMessage)
exports.preRunMessage = preRunMessageModule
-- ROBLOX deviation START: additional assignments for Lua type inferrence to work
exports.print = preRunMessageModule.print
exports.remove = preRunMessageModule.remove
-- ROBLOX deviation END
exports.pluralize = require(script.pluralize).default
exports.formatTime = require(script.formatTime).default
-- ROBLOX deviation START: not ported as it doesn't seem necessary in Lua
-- exports.tryRealpath = require(script.tryRealpath).default
-- exports.requireOrImportModule = require(script.requireOrImportModule).default
-- ROBLOX deviation END
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="395">
              <Properties>
                <string name="Name">ErrorWithStack</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/ErrorWithStack.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
type Error = LuauPolyfill.Error
local exports = {}

export type ErrorWithStack = Error & {}
local ErrorWithStack = setmetatable({}, { __index = Error })
ErrorWithStack.__index = ErrorWithStack
function ErrorWithStack.new(
	message: string | nil,
	callsite: (...any) -> ...unknown,
	stackLimit: number?
): ErrorWithStack
	-- Ensure we have a large stack length so we get full details.
	local originalStackLimit = Error["stackTraceLimit"]
	if stackLimit ~= nil and stackLimit ~= 0 then
		Error["stackTraceLimit"] =
			math.max(stackLimit, Boolean.toJSBoolean(originalStackLimit) and originalStackLimit or 10)
	end

	local self = setmetatable(Error.new(message), ErrorWithStack)
	if Error.captureStackTrace then
		Error.captureStackTrace((self :: any) :: ErrorWithStack, callsite)
	end
	Error["stackTraceLimit"] = originalStackLimit
	return (self :: any) :: ErrorWithStack
end
exports.default = ErrorWithStack
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="396">
              <Properties>
                <string name="Name">clearLine</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/clearLine.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable
local exports = {}

local function clearLine(stream: Writeable): ()
	if Boolean.toJSBoolean(stream.isTTY) then
		stream:write("\x1b[999D\x1b[K")
	end
end
exports.default = clearLine

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="397">
              <Properties>
                <string name="Name">convertDescriptorToString</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/convertDescriptorToString.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local String = LuauPolyfill.String
local exports = {}

--[[ eslint-disable local/ban-types-eventually ]]

-- See: https://github.com/facebook/jest/pull/5154
--[[
	ROBLOX FIXME: add extends if supported:
	original code:
	export default function convertDescriptorToString<
	  T extends number | string | Function | undefined,
	>
]]
local function convertDescriptorToString<T>(descriptor: T): string
	local condition_ = typeof(descriptor)
	if condition_ == "function" then
		-- ROBLOX deviation START: using Lua specific implementation for retrieving function name
		-- if Boolean.toJSBoolean(descriptor.name) then
		-- 	return descriptor.name
		-- end
		local name = String.trim(debug.info(descriptor :: any, "n"))
		if name ~= nil and name ~= "" then
			return name
		end
		-- ROBLOX deviation END
	elseif condition_ == "number" or descriptor == nil then
		return ("%s"):format(tostring(descriptor))
	elseif condition_ == "string" then
		-- ROBLOX deviation START: descriptor should be inferred as string from branch
		-- return descriptor
		return (descriptor :: unknown) :: string
		-- ROBLOX deviation END
	end

	-- ROBLOX deviation START: using Lua specific implementation for retrieving function name
	local descriptorString
	if typeof(descriptor) == "function" then
		descriptorString = "[Function anonymous]"
	else
		descriptorString = tostring(descriptor)
	end
	-- ROBLOX deviation END

	error(Error.new(
		-- ROBLOX deviation START: remove "class" verbiage and from error message
		-- and substitute function tostring with variable
		("Invalid first argument, %s. It must be a named function, number, or string."):format(descriptorString)
		-- ROBLOX deviation END
	))
end
exports.default = convertDescriptorToString
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="398">
              <Properties>
                <string name="Name">createDirectory</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/createDirectory.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local exports = {}

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

-- ROBLOX deviation: using FileSystemService instead of fs
local getFileSystemService = require(CurrentModule.getFileSystemService)
local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path

local function createDirectory(path: Config_Path): ()
	local FileSystemService = getFileSystemService()

	local ok, result, hasReturned = pcall(function()
		-- ROBLOX deviation: using FileSystemService instead of fs
		FileSystemService:CreateDirectories(path)
	end)
	if not ok then
		local e = result
		-- ROBLOX deviation START: additional error handling for AccessDenied case
		if e:find("Error%(13%): Access Denied%. Path is outside of sandbox%.") then
			error(
				Error.new(
					"Provided path is invalid: you likely need to provide a different argument to --fs.readwrite.\n"
						.. "You may need to pass in `--fs.readwrite=$PWD`"
				)
			)
		end
		-- ROBLOX deviation END

		-- ROBLOX FIXME: investigate how to catch directory exists error
		if e.code ~= "EEXIST" then
			error(e)
		end
	end
	if hasReturned then
		return result
	end
end
exports.default = createDirectory
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="399">
              <Properties>
                <string name="Name">createProcessObject</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/createProcessObject.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

--[[
	ROBLOX deviation:
	skipped whole file as it seems unnecessary in Lua environment
]]

return {
	default = function()
		return {}
	end,
}

-- -- ROBLOX FIXME START: added types and objects that do not exist in Luau
-- type NodeJS_ProcessEnv = any
-- type NodeJS_Process = any

-- local process = {
-- 	env = {},
-- }
-- -- ROBLOX FIXME END

-- local CurrentModule = script.Parent
-- local Packages = CurrentModule.Parent
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Array = LuauPolyfill.Array
-- local Boolean = LuauPolyfill.Boolean
-- local Object = LuauPolyfill.Object
-- local Set = LuauPolyfill.Set
-- local Symbol = LuauPolyfill.Symbol
-- type Record<K, V> = { [K]: V }
-- local exports = {}

-- local deepCyclicCopy = require(script.Parent.deepCyclicCopy).default

-- local BLACKLIST = Set.new({ "env", "mainModule", "_events" })
-- -- ROBLOX FIXME: make proper platform check
-- -- local isWin32 = process.platform == "win32"
-- local isWin32 = false -- UserInputService:GetPlatform() == 0
-- local proto: Record<string, unknown> = Object.getPrototypeOf(process.env)

-- -- The "process.env" object has a bunch of particularities: first, it does not
-- -- directly extend from Object; second, it converts any assigned value to a
-- -- string; and third, it is case-insensitive in Windows. We use a proxy here to
-- -- mimic it (see https://nodejs.org/api/process.html#process_process_env).

-- local function createProcessEnv(): NodeJS_ProcessEnv
-- 	local real = Object.create(proto)
-- 	local lookup: typeof(process.env) = {}

-- 	local function deletePropertyWin32(_target: unknown, key: unknown)
-- 		error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: ForInStatement ]] --[[ for (const name in real) {
--       if (real.hasOwnProperty(name)) {
--         if (typeof key === 'string') {
--           if (name.toLowerCase() === key.toLowerCase()) {
--             delete real[name];
--             delete lookup[name.toLowerCase()];
--           }
--         } else {
--           if (key === name) {
--             delete real[name];
--             delete lookup[name];
--           }
--         }
--       }
--     } ]]

-- 		return true
-- 	end

-- 	local function deleteProperty(_target: unknown, key: any)
-- 		real[tostring(key)] = nil
-- 		lookup[tostring(key)] = nil
-- 		return true
-- 	end

-- 	local function getProperty(_target: unknown, key: any)
-- 		return real[tostring(key)]
-- 	end

-- 	local function getPropertyWin32(_target: unknown, key: any)
-- 		if typeof(key) == "string" then
-- 			return lookup[tostring((function()
-- 				if Array.indexOf(Object.keys(proto), tostring(key)) ~= -1 then
-- 					return key
-- 				else
-- 					return key:lower()
-- 				end
-- 			end)())]
-- 		else
-- 			return real[tostring(key)]
-- 		end
-- 	end

-- 	-- ROBLOX CHECK: what was the intent of the proxy
-- 	local proxy = setmetatable({
-- 		deleteProperty = (function()
-- 			if Boolean.toJSBoolean(isWin32) then
-- 				return deletePropertyWin32
-- 			else
-- 				return deleteProperty
-- 			end
-- 		end)(),
-- 		get = (function()
-- 			if Boolean.toJSBoolean(isWin32) then
-- 				return getPropertyWin32
-- 			else
-- 				return getProperty
-- 			end
-- 		end)(),
-- 		set = function(self, _target, key, value)
-- 			local strValue = "" .. tostring(value)
-- 			if typeof(key) == "string" then
-- 				lookup[tostring(key:lower())] = strValue
-- 			end
-- 			real[tostring(key)] = strValue
-- 			return true
-- 		end,
-- 	}, real)
-- 	-- local proxy = Proxy.new(real, {
-- 	-- 	deleteProperty = (function()
-- 	-- 		if Boolean.toJSBoolean(isWin32) then
-- 	-- 			return deletePropertyWin32
-- 	-- 		else
-- 	-- 			return deleteProperty
-- 	-- 		end
-- 	-- 	end)(),
-- 	-- 	get = (function()
-- 	-- 		if Boolean.toJSBoolean(isWin32) then
-- 	-- 			return getPropertyWin32
-- 	-- 		else
-- 	-- 			return getProperty
-- 	-- 		end
-- 	-- 	end)(),
-- 	-- 	set = function(self, _target, key, value)
-- 	-- 		local strValue = "" .. tostring(value)
-- 	-- 		if typeof(key) == "string" then
-- 	-- 			lookup[tostring(key:lower())] = strValue
-- 	-- 		end
-- 	-- 		real[tostring(key)] = strValue
-- 	-- 		return true
-- 	-- 	end,
-- 	-- })
-- 	return Object.assign(proxy, process.env)
-- end
-- exports.default = function(): NodeJS_Process
-- 	local process = require("process")
-- 	local newProcess = deepCyclicCopy(process, { blacklist = BLACKLIST, keepPrototype = true })
-- 	local ok, result, hasReturned = pcall(function()
-- 		-- This fails on Node 12, but it's already set to 'process'
-- 		newProcess[tostring(Symbol.toStringTag)] = "process"
-- 	end)
-- 	if not ok then
-- 		local e = result
-- 		-- Make sure it's actually set instead of potentially ignoring errors
-- 		if newProcess[tostring(Symbol.toStringTag)] ~= "process" then
-- 			e.message = "Unable to set toStringTag on process. Please open up an issue at https://github.com/facebook/jest\n\n"
-- 				.. tostring(e.message)
-- 			error(e)
-- 		end
-- 	end
-- 	if hasReturned then
-- 		return result
-- 	end
-- 	-- Sequentially execute all constructors over the object.
-- 	local proto = process
-- 	error("not implemented") --[[ ROBLOX TODO: Unhandled node for type: WhileStatement ]] --[[ while (proto = Object.getPrototypeOf(proto)) {
--     if (typeof proto.constructor === 'function') {
--       proto.constructor.call(newProcess);
--     }
--   } ]]
-- 	newProcess.env = createProcessEnv()
-- 	newProcess.send = function()
-- 		return true
-- 	end
-- 	Object.defineProperty(newProcess, "domain", {
-- 		get = function(self)
-- 			return process.domain
-- 		end,
-- 	})
-- 	return newProcess
-- end
-- return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="400">
              <Properties>
                <string name="Name">deepCyclicCopy</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/deepCyclicCopy.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set
local WeakMap = LuauPolyfill.WeakMap
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type Set<T> = LuauPolyfill.Set<T>
type WeakMap<T, U> = LuauPolyfill.WeakMap<T, U>
local exports = {}

-- ROBLOX deviation START: predefine variables
local deepCyclicCopy
local deepCyclicCopyObject
local deepCyclicCopyArray
-- ROBLOX deviation END
local EMPTY = Set.new() :: Set<string>
export type DeepCyclicCopyOptions = { blacklist: Set<string>?, keepPrototype: boolean? }

function deepCyclicCopy<T>(value: T, options_: DeepCyclicCopyOptions?, cycles_: WeakMap<any, any>?): T
	local options = options_ or { blacklist = EMPTY, keepPrototype = false }
	local cycles: WeakMap<any, any> = if cycles_ then cycles_ else WeakMap.new()

	if typeof(value) ~= "table" then
		return value
	elseif cycles:has(value) then
		return cycles:get(value)
	elseif Array.isArray(value) then
		return deepCyclicCopyArray(value, options, cycles) :: any
	else
		return deepCyclicCopyObject(value, options, cycles)
	end
end
exports.default = deepCyclicCopy

function deepCyclicCopyObject<T>(object: T & Object, options: DeepCyclicCopyOptions, cycles: WeakMap<any, any>): T
	-- ROBLOX deviation START: prototypes are not supported
	local newObject = {}
	if options.keepPrototype then
		warn("Prototype copying is not supported")
	end
	-- ROBLOX deviation END

	-- ROBLOX deviation START: no property descriptors in Lua
	local descriptors = Array.reduce(Object.keys(object), function(acc, key)
		acc[key] = {
			value = (object :: any)[key],
		}
		return acc
	end, {})
	-- ROBLOX deviation END

	cycles:set(object, newObject)

	Array.forEach(Object.keys(descriptors), function(key)
		if options.blacklist ~= nil and options.blacklist:has(key) then
			descriptors[key] = nil
			return
		end

		local descriptor: Object = descriptors[key]
		if typeof(descriptor.value) ~= "nil" then
			descriptor.value =
				deepCyclicCopy(descriptor.value, { blacklist = EMPTY, keepPrototype = options.keepPrototype }, cycles)
		end
		descriptor.configurable = true
	end)

	-- ROBLOX deviation START: no property descriptors in Lua
	return Object.assign(
		newObject,
		Array.reduce(Object.keys(descriptors), function(acc, key)
			acc[key] = descriptors[key].value
			return acc
		end, {})
	)
	-- ROBLOX deviation END
end

function deepCyclicCopyArray<T>(array: Array<T>, options: DeepCyclicCopyOptions, cycles: WeakMap<any, any>): T
	-- ROBLOX deviation START: prototypes are not supported
	local newArray = {}
	if options.keepPrototype then
		warn("Prototype copying is not supported")
	end
	-- ROBLOX deviation END
	local length = #array

	cycles:set(array, newArray)

	for i = 1, length do
		newArray[i] = deepCyclicCopy(array[i], { blacklist = EMPTY, keepPrototype = options.keepPrototype }, cycles)
	end

	-- ROBLOX FIXME Luau: need to cast to `any` as Lua can't infer types properly
	return newArray :: any
end
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="401">
              <Properties>
                <string name="Name">formatTime</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/formatTime.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

-- ROBLOX deviation START: Polyfill Math.trunc
local function mathTrunc(value: number): number
	return if value > 0 then math.floor(value) else math.ceil(value)
end
-- ROBLOX deviation END
-- ROBLOX deviation START: Polyfill String.padStart
local function stringPadStart(str: string, targetLength_: number, padString_: string?)
	local targetLength = math.max(#str, targetLength_)

	local padString = padString_ or " "
	return (padString:rep(targetLength) .. str):sub(-targetLength)
end
-- ROBLOX deviation END

local function formatTime(time: number, prefixPower_: number?, padLeftLength_: number?): string
	local prefixPower = prefixPower_ or -3
	local padLeftLength = padLeftLength_ or 0
	local prefixes = { "n", "μ", "m", "" }
	local prefixIndex = math.max(0, math.min(mathTrunc(prefixPower / 3) + #prefixes - 1, #prefixes - 1)) + 1
	return ("%s %ss"):format(stringPadStart(tostring(time), padLeftLength), prefixes[prefixIndex])
end
exports.default = formatTime
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="402">
              <Properties>
                <string name="Name">getFileSystemService</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local RobloxShared = require(Packages.RobloxShared)
local getDataModelService = RobloxShared.getDataModelService

local function getFileSystemService()
	local success, result = pcall(function()
		return _G.__MOCK_FILE_SYSTEM__ or getDataModelService("FileSystemService")
	end)

	if not success then
		error(Error.new("Attempting to save snapshots in an environment where FileSystemService is inaccessible."))
	end

	return result
end

return getFileSystemService
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="403">
              <Properties>
                <string name="Name">globsToMatcher</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/globsToMatcher.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Map = LuauPolyfill.Map
type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>

local exports = {}

local picomatch = require(Packages.Picomatch)
local typesModule = require(Packages.JestTypes)
type Config_Path = typesModule.Config_Path
type Config_Glob = typesModule.Config_Glob
-- local replacePathSepForGlob = require(script.Parent.replacePathSepForGlob).default

-- ROBLOX deviation START using Callable table to allow for properties on a function alternative
type CallableMatcher = typeof(setmetatable({
	state = {} :: any,
}, {
	__call = function(self: any, str: Config_Path): boolean
		return false
	end,
}))

type MatcherFn = (str: Config_Path) -> boolean
type Matcher = CallableMatcher
-- ROBLOX deviation END

local globsToMatchersMap = Map.new() :: Map<string, { isMatch: Matcher, negated: boolean }>

local picomatchOptions = { dot = true }

--[[*
 * Converts a list of globs into a function that matches a path against the
 * globs.
 *
 * Every time picomatch is called, it will parse the glob strings and turn
 * them into regexp instances. Instead of calling picomatch repeatedly with
 * the same globs, we can use this function which will build the picomatch
 * matchers ahead of time and then have an optimized path for determining
 * whether an individual path matches.
 *
 * This function is intended to match the behavior of `micromatch()`.
 *
 * @example
 * const isMatch = globsToMatcher(['*.js', '!*.test.js']);
 * isMatch('pizza.js'); // true
 * isMatch('pizza.test.js'); // false
 ]]
local function globsToMatcher(globs: Array<Config_Glob>): MatcherFn
	if #globs == 0 then
		-- Since there were no globs given, we can simply have a fast path here and
		-- return with a very simple function.
		return function()
			return false
		end
	end

	local matchers = Array.map(globs, function(glob)
		if not globsToMatchersMap:has(glob) then
			local isMatch = picomatch(glob, picomatchOptions, true) :: Matcher

			local matcher = {
				isMatch = isMatch,
				-- Matchers that are negated have different behavior than matchers that
				-- are not negated, so we need to store this information ahead of time.
				negated = isMatch.state.negated or Boolean.toJSBoolean(isMatch.state.negatedExtglob),
			}

			globsToMatchersMap:set(glob, matcher)
		end

		return globsToMatchersMap:get(glob) :: { isMatch: Matcher, negated: boolean }
	end)

	return function(path)
		-- ROBLOX FIXME START: implement replacePathSepForGlob
		local replacedPath = path
		-- local replacedPath = replacePathSepForGlob(path)
		-- ROBLOX FIXME END
		local kept = nil
		local negatives = 0

		for i = 1, #matchers do
			local isMatch, negated
			local ref = matchers[i]
			isMatch, negated = ref.isMatch, ref.negated

			if negated then
				negatives += 1
			end

			local matched = isMatch(replacedPath)

			if not matched and negated then
				-- The path was not matched, and the matcher is a negated matcher, so we
				-- want to omit the path. This means that the negative matcher is
				-- filtering the path out.
				kept = false
			elseif matched and not negated then
				-- The path was matched, and the matcher is not a negated matcher, so we
				-- want to keep the path.
				kept = true
			end
		end

		-- If all of the globs were negative globs, then we want to include the path
		-- as long as it was not explicitly not kept. Otherwise only include
		-- the path if it was kept. This allows sets of globs that are all negated
		-- to allow some paths to be matched, while sets of globs that are mixed
		-- negated and non-negated to cause the negated matchers to only omit paths
		-- and not keep them.
		return if negatives == #matchers then kept ~= false else Boolean.toJSBoolean(kept)
	end
end
exports.default = globsToMatcher

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="404">
              <Properties>
                <string name="Name">installCommonGlobals</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/installCommonGlobals.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- ROBLOX deviation: returning a function to be able to re-execute the module in tests
return function()
	local CurrentModule = script.Parent
	local Packages = CurrentModule.Parent
	local LuauPolyfill = require(Packages.LuauPolyfill)
	local Array = LuauPolyfill.Array
	local Object = LuauPolyfill.Object
	local String = LuauPolyfill.String
	local Symbol = LuauPolyfill.Symbol

	local Promise = require(Packages.Promise)

	local exports = {}

	-- ROBLOX deviation: fs not necessary
	-- local fs = require(Packages["graceful-fs"])
	local typesModule = require(Packages.JestTypes)
	type Config_ConfigGlobals = typesModule.Config_ConfigGlobals
	local createProcessObject = require(script.Parent.createProcessObject).default
	local deepCyclicCopy = require(script.Parent.deepCyclicCopy).default

	local DTRACE = Array.filter(Object.keys(_G), function(key)
		return typeof(key) == "string" and String.startsWith(key, "DTRACE")
	end)

	exports.default = function(
		globalObject: typeof(_G),
		globals: Config_ConfigGlobals
	): typeof(_G) & Config_ConfigGlobals
		-- ROBLOX deviation: added self to be able to bind DTRACE functions
		local self = globalObject
		globalObject.process = createProcessObject()
		-- Keep a reference to some globals that Jest needs
		Object.assign(globalObject, {
			-- ROBLOX deviation START: not making props readonly
			-- ROBLOX FIXME: have to cast element to `any` to avoid type narrowing issue
			[Symbol.for_("jest-native-promise")] = Promise :: any,
			[Symbol.for_("jest-native-now")] = DateTime.now,
			-- ROBLOX deviation END
			-- ROBLOX deviation START: skipped fs related globals
			-- [Symbol.for_("jest-native-read-file")] = {
			-- 	enumerable = false,
			-- 	value = fs.readFileSync:bind(fs),
			-- 	writable = false,
			-- },
			-- [Symbol.for_("jest-native-write-file")] = {
			-- 	enumerable = false,
			-- 	value = fs.writeFileSync:bind(fs),
			-- 	writable = false,
			-- },
			-- [Symbol.for_("jest-native-exists-file")] = {
			-- 	enumerable = false,
			-- 	value = fs.existsSync:bind(fs),
			-- 	writable = false,
			-- },
			-- ROBLOX deviation END
			-- ROBLOX deviation START: not making props readonly
			["jest-symbol-do-not-touch"] = Symbol,
			-- ROBLOX deviation END
		})

		-- Forward some APIs.
		Array.forEach(DTRACE, function(dtrace)
			-- @ts-expect-error: no index
			globalObject[dtrace] = function(_self, ...: any)
				local args = { ... }
				-- @ts-expect-error: no index
				return _G[dtrace](self, table.unpack(args))
			end
		end)
		return Object.assign(globalObject, deepCyclicCopy(globals))
	end
	return exports
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="405">
              <Properties>
                <string name="Name">interopRequireDefault</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/interopRequireDefault.ts
-- ROBLOX deviation not ported as it doesn't seem necessary in Lua
return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="406">
              <Properties>
                <string name="Name">isInteractive</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/isInteractive.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
--[[
	ROBLOX deviation: no equivalent in Lua. Always returning false
	original code:
	import {isCI} from 'ci-info';

	export default !!process.stdout.isTTY && process.env.TERM !== 'dumb' && !isCI;
]]
return {
	default = false,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="407">
              <Properties>
                <string name="Name">isPromise</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/isPromise.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local Promise = require(Packages.Promise)

local exports = {}

local function isPromise(
	candidate: unknown
): boolean --[[ ROBLOX FIXME: change to TSTypePredicate equivalent if supported ]] --[[ candidate is Promise<unknown> ]]
	-- ROBLOX deviation: using Promise library implementation to check if a variable is a Promise
	return Promise.is(candidate)
end
exports.default = isPromise
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="408">
              <Properties>
                <string name="Name">pluralize</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/pluralize.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local function pluralize(word: string, count: number): string
	return ("%s %s%s"):format(tostring(count), word, if count == 1 then "" else "s")
end
exports.default = pluralize
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="409">
              <Properties>
                <string name="Name">preRunMessage</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/preRunMessage.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local exports = {}

local chalk = require(Packages.ChalkLua)
local clearLine = require(script.Parent.clearLine).default
local isInteractive = require(script.Parent.isInteractive).default

local RobloxShared = require(Packages.RobloxShared)
type Writeable = RobloxShared.Writeable

local function print(stream: Writeable): ()
	if isInteractive then
		stream:write(chalk.bold.dim("Determining test suites to run..."))
	end
end
exports.print = print

local function remove(stream: Writeable): ()
	if isInteractive then
		clearLine(stream)
	end
end
exports.remove = remove

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="410">
              <Properties>
                <string name="Name">replacePathSepForGlob</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/replacePathSepForGlob.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

--[=[
	ROBLOX deviation: not ported as it doesn't seem necessary in Lua

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_Glob = typesModule.Config_Glob
type Config_Path = typesModule.Config_Path

local function replacePathSepForGlob(path: Config_Path): Config_Glob
	return path:replace(
		error("not implemented"), --[[ ROBLOX TODO: Unhandled node for type: RegExpLiteral ]] --[[ /\\(?![{}()+?.^$])/g ]]
		"/"
	)
end
exports.default = replacePathSepForGlob
return exports
]=]

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="411">
              <Properties>
                <string name="Name">requireOrImportModule</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/requireOrImportModule.ts
-- ROBLOX deviation not ported as it doesn't seem necessary in Lua
return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="412">
              <Properties>
                <string name="Name">setGlobal</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/setGlobal.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

exports.default = function(globalToMutate: typeof(_G), key: string, value: unknown): ()
	-- @ts-expect-error: no index
	globalToMutate[key] = value
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="413">
              <Properties>
                <string name="Name">specialChars</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/specialChars.ts

--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

-- local UserInputService = game:GetService("UserInputService")

-- ROBLOX FIXME: make proper platform check
-- local isWindows = process.platform == "win32"
local isWindows = false -- UserInputService:GetPlatform() == 0
local ARROW = " \u{203A} "
exports.ARROW = ARROW
local ICONS = {
	failed = if isWindows then "\u{00D7}" else "\u{2715}",
	pending = "\u{25CB}",
	success = if isWindows then "\u{221A}" else "\u{2713}",
	todo = "\u{270E}",
}
exports.ICONS = ICONS
local CLEAR = if isWindows then "\x1B[2J\x1B[0f" else "\x1B[2J\x1B[3J\x1B[H"
exports.CLEAR = CLEAR
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="414">
              <Properties>
                <string name="Name">testPathPatternToRegExp</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/testPathPatternToRegExp.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp

local exports = {}

local typesModule = require(Packages.JestTypes)
type Config_GlobalConfig = typesModule.Config_GlobalConfig

-- Because we serialize/deserialize globalConfig when we spawn workers,
-- we can't pass regular expression. Using this shared function on both sides
-- will ensure that we produce consistent regexp for testPathPattern.
exports.default = function(testPathPattern: typeof((({} :: any) :: Config_GlobalConfig).testPathPattern)): RegExp
	return RegExp(testPathPattern, "i")
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="415">
              <Properties>
                <string name="Name">tryRealpath</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/tree/v28.0.0/packages/jest-util/src/tryRealpath.ts
-- ROBLOX deviation: not ported as it doesn't seem necessary in Lua
return {}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="416">
            <Properties>
              <string name="Name">JestValidate</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-validate/src/index.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}

local utilsModule = require(script.utils)
exports.ValidationError = utilsModule.ValidationError
export type ValidationError = utilsModule.ValidationError
-- ROBLOX deviation START: not ported yet
-- exports.createDidYouMeanMessage = utilsModule.createDidYouMeanMessage
-- exports.format = utilsModule.format
-- exports.logValidationWarning = utilsModule.logValidationWarning
-- local typesModule = require(script.types)
-- exports.DeprecatedOptions = typesModule.DeprecatedOptions
-- exports.validate = require(script.validate).default
-- exports.validateCLIOptions = require(script.validateCLIOptions).default
-- exports.multipleValidOptions = require(script.condition).multipleValidOptions
-- ROBLOX deviation END
return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="417">
              <Properties>
                <string name="Name">utils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/jest-validate/src/utils.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: not needed dependencies
-- local Array = LuauPolyfill.Array
-- ROBLOX deviation END
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
-- ROBLOX deviation START: not needed dependencies
-- local String = LuauPolyfill.String
-- local console = LuauPolyfill.console
-- type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX deviation END
type Error = LuauPolyfill.Error

local exports = {}

local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation START: not ported yet
-- local leven = require(Packages.leven).default
-- local prettyFormat = require(Packages.PrettyFormat).format
-- local BULLET: string = chalk.bold("\u{25cf}")
-- local DEPRECATION = ("%s Deprecation Warning"):format(BULLET)
-- exports.DEPRECATION = DEPRECATION
-- local ERROR = ("%s Validation Error"):format(BULLET)
-- exports.ERROR = ERROR
-- local WARNING = ("%s Validation Warning"):format(BULLET)
-- exports.WARNING = WARNING

-- local function format(value: unknown): string
-- 	return if typeof(value) == "function" then tostring(value) else prettyFormat(value, { min = true })
-- end
-- exports.format = format

-- local function formatPrettyObject(value: unknown): string
-- 	return if typeof(value) == "function"
-- 		then tostring(value)
-- 		else
-- 			Array.join(String.split(JSON.stringify(value, nil, 2),"\n"), "\n    ")
-- end
-- exports.formatPrettyObject = formatPrettyObject
-- ROBLOX deviation END

export type ValidationError = Error & { name: string, message: string }
local ValidationError = setmetatable({}, { __index = Error })
ValidationError.__index = ValidationError

function ValidationError.new(name: string, message: string, comment: (string | nil)?): ValidationError
	-- TODO: figure out why this isn't being considered an instanceof Error
	-- local self = setmetatable(Error.new(), ValidationError)
	local self = Error.new()
	comment = if comment ~= nil and Boolean.toJSBoolean(comment) then "\n\n" .. comment else "\n"
	self.name = ""
	self.message = chalk.red(chalk.bold(name) .. ":\n\n" .. message .. (comment :: string))
	-- ROBLOX deviation START: no captureStackTrace available
	-- Error:captureStackTrace(self, function() end)
	-- ROBLOX deviation END
	return (self :: any) :: ValidationError
end
exports.ValidationError = ValidationError

-- ROBLOX deviation START: not ported yet
-- local function logValidationWarning(name: string, message: string, comment: (string | nil)?): ()
-- 	comment = if Boolean.toJSBoolean(comment) then "\n\n" .. comment else "\n"
-- 	console.warn(chalk.yellow(chalk.bold(name) .. ":\n\n" .. message .. comment))
-- end
-- exports.logValidationWarning = logValidationWarning

-- local function createDidYouMeanMessage(unrecognized: string, allowedOptions: Array<string>): string
-- 	local suggestion = Array.find(allowedOptions, function(option)
-- 		local steps: number = leven(option, unrecognized)
-- 		return steps < 3
-- 	end)
-- 	return if Boolean.toJSBoolean(suggestion) then ("Did you mean %s?"):format(chalk.bold(format(suggestion))) else ""
-- end
-- exports.createDidYouMeanMessage = createDidYouMeanMessage
-- ROBLOX deviation END

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="418">
            <Properties>
              <string name="Name">LuauPolyfill</string>
              <string name="Source"><![CDATA[--!strict
local Packages = script.Parent

local Boolean = require(Packages.Boolean)
local Collections = require(Packages.Collections)
local Console = require(Packages.Console)
local Math = require(Packages.Math)
local Number = require(Packages.Number)
local String = require(Packages.String)
local Symbol = require(Packages.Symbol)
local Timers = require(Packages.Timers)
local types = require(Packages.ES7Types)

local AssertionError = require(script.AssertionError)
local Error = require(script.Error)
local PromiseModule = require(script.Promise)
local extends = require(script.extends)
local instanceof = require(Packages.InstanceOf)

export type Array<T> = types.Array<T>
export type AssertionError = AssertionError.AssertionError
export type Error = Error.Error
export type Map<T, V> = types.Map<T, V>
export type Object = types.Object

export type PromiseLike<T> = PromiseModule.PromiseLike<T>
export type Promise<T> = PromiseModule.Promise<T>

export type Set<T> = types.Set<T>
export type Symbol = Symbol.Symbol
export type Timeout = Timers.Timeout
export type Interval = Timers.Interval
export type WeakMap<T, V> = Collections.WeakMap<T, V>

return {
	Array = Collections.Array,
	AssertionError = AssertionError,
	Boolean = Boolean,
	console = Console,
	Error = Error,
	extends = extends,
	instanceof = instanceof,
	Math = Math,
	Number = Number,
	Object = Collections.Object,
	Map = Collections.Map,
	coerceToMap = Collections.coerceToMap,
	coerceToTable = Collections.coerceToTable,
	Set = Collections.Set,
	WeakMap = Collections.WeakMap,
	String = String,
	Symbol = Symbol,
	setTimeout = Timers.setTimeout,
	clearTimeout = Timers.clearTimeout,
	setInterval = Timers.setInterval,
	clearInterval = Timers.clearInterval,
	util = {
		inspect = Collections.inspect,
	},
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="419">
              <Properties>
                <string name="Name">AssertionError</string>
                <string name="Source"><![CDATA[local AssertionErrorModule = require(script["AssertionError.global"])

export type AssertionError = AssertionErrorModule.AssertionError

return AssertionErrorModule.AssertionError
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="420">
                <Properties>
                  <string name="Name">AssertionError.global</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/nodejs/node/blob/v18.1.0/lib/internal/assert/assertion_error.js
--[[
	Copyright Node.js contributors. All rights reserved.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	IN THE SOFTWARE.
]]

local LuauPolyfill = script.Parent.Parent
local Packages = LuauPolyfill.Parent

local Collections = require(Packages.Collections)
local Array = Collections.Array
local Object = Collections.Object
local Boolean = require(Packages.Boolean)
local String = require(Packages.String)
local types = require(Packages.ES7Types)
local inspect = Collections.inspect

local Error = require(LuauPolyfill.Error)
local instanceof = require(Packages.InstanceOf)

type Error = Error.Error
type Array<T> = types.Array<T>
type Object = types.Object
type Function = types.Function

-- ROBLOX deviation START: mock process to not change AssertionError internals
local process = {
	stderr = {
		isTTY = false,
		columns = 0,
		hasColors = function(...)
			return true
		end,
	},
}
-- ROBLOX deviation END
-- ROBLOX TODO START: implement ErrorCaptureStackTrace correctly
function ErrorCaptureStackTrace(err, ...)
	Error.captureStackTrace(err, ...)
end
-- ROBLOX TODO END
-- ROBLOX TODO START: use real remove colors
local function removeColors(str)
	return str
end
-- local removeColors = require_("internal/util").removeColors
-- ROBLOX TODO END
-- local validateObject = require_("internal/validators").validateObject
-- ROBLOX deviation START: isErrorStackTraceLimitWritable is not necessary ATM
-- local isErrorStackTraceLimitWritable = require_("internal/errors").isErrorStackTraceLimitWritable
-- ROBLOX deviation END
local blue = ""
local green = ""
local red = ""
local white = ""
local kReadableOperator = {
	deepStrictEqual = "Expected values to be strictly deep-equal:",
	strictEqual = "Expected values to be strictly equal:",
	strictEqualObject = 'Expected "actual" to be reference-equal to "expected":',
	deepEqual = "Expected values to be loosely deep-equal:",
	notDeepStrictEqual = 'Expected "actual" not to be strictly deep-equal to:',
	notStrictEqual = 'Expected "actual" to be strictly unequal to:',
	notStrictEqualObject = 'Expected "actual" not to be reference-equal to "expected":',
	notDeepEqual = 'Expected "actual" not to be loosely deep-equal to:',
	notIdentical = "Values have same structure but are not reference-equal:",
	notDeepEqualUnequal = "Expected values not to be loosely deep-equal:",
}
-- Comparing short primitives should just show === / !== instead of using the
-- diff.
local kMaxShortLength = 12
local function copyError(source: Object)
	local keys = Object.keys(source)
	-- ROBLOX TODO:
	local target = {} -- ObjectCreate(ObjectGetPrototypeOf(source))
	for _, key in keys do
		target[key] = source[key]
	end
	target.message = source.message
	return target
end

local function inspectValue(val)
	-- The util.inspect default values could be changed. This makes sure the
	-- error messages contain the necessary information nevertheless.
	return inspect(val, {
		compact = false,
		customInspect = false,
		depth = 1000,
		maxArrayLength = math.huge, -- Assert compares only enumerable properties (with a few exceptions).
		showHidden = false, -- Assert does not detect proxies currently.
		showProxy = false,
		sorted = true, -- Inspect getters as we also check them when comparing entries.
		getters = true,
	})
end

local function createErrDiff(actual, expected, operator)
	local other = ""
	local res = ""
	local end_ = ""
	local skipped = false
	local actualInspected = inspectValue(actual)
	local actualLines = String.split(actualInspected, "\n")
	local expectedLines = String.split(inspectValue(expected), "\n")

	local i = 0
	local indicator = ""

	-- In case both values are objects or functions explicitly mark them as not
	-- reference equal for the `strictEqual` operator.
	if
		operator == "strictEqual"
		and (
			typeof(actual) == "table" and actual ~= nil and typeof(expected) == "table" and expected ~= nil
			or typeof(actual) == "function" and typeof(expected) == "function"
		)
	then
		operator = "strictEqualObject"
	end

	-- If "actual" and "expected" fit on a single line and they are not strictly
	-- equal, check further special handling.
	if #actualLines == 1 and #expectedLines == 1 and actualLines[1] ~= expectedLines[1] then
		-- Check for the visible length using the `removeColors()` function, if
		-- appropriate.
		-- ROBLOX TODO START
		local c = false
		-- local c = inspect.defaultOptions.colors
		-- ROBLOX TODO END
		local actualRaw = if c then removeColors(actualLines[1]) else actualLines[1]
		local expectedRaw = if Boolean.toJSBoolean(c) then removeColors(expectedLines[1]) else expectedLines[1]
		local inputLength = string.len(actualRaw) + string.len(expectedRaw)
		-- If the character length of "actual" and "expected" together is less than
		-- kMaxShortLength and if neither is an object and at least one of them is
		-- not `zero`, use the strict equal comparison to visualize the output.
		if inputLength <= kMaxShortLength then
			if
				(typeof(actual) ~= "table" or actual == nil)
				and (typeof(expected) ~= "table" or expected == nil)
				and (actual ~= 0 or expected ~= 0)
			then
				-- -0 === +0
				return ("%s\n\n"):format(kReadableOperator[operator])
					.. ("%s !== %s\n"):format(actualLines[1], expectedLines[1])
			end
		elseif operator ~= "strictEqualObject" then
			-- If the stderr is a tty and the input length is lower than the current
			-- columns per line, add a mismatch indicator below the output. If it is
			-- not a tty, use a default value of 80 characters.
			local maxLength = if process.stderr.isTTY then process.stderr.columns else 80
			if inputLength < maxLength then
				while string.sub(actualRaw, i + 1, i + 1) == string.sub(expectedRaw, i + 1, i + 1) do
					i += 1
				end
				-- Ignore the first characters.
				if i > 2 then
					-- Add position indicator for the first mismatch in case it is a
					-- single line and the input length is less than the column length.
					indicator = ("\n  %s^"):format(string.rep(" ", i))
					i = 0
				end
			end
		end
	end

	-- Remove all ending lines that match (this optimizes the output for
	-- readability by reducing the number of total changed lines).
	local a = actualLines[#actualLines]
	local b = expectedLines[#expectedLines]
	while a == b do
		local i_ = i
		i += 1
		if i_ < 3 then
			end_ = ("\n  %s%s"):format(a, end_)
		else
			other = a
		end
		table.remove(actualLines)
		table.remove(expectedLines)
		if #actualLines == 0 or #expectedLines == 0 then
			break
		end
		a = actualLines[#actualLines]
		b = expectedLines[#expectedLines]
	end

	local maxLines = math.max(#actualLines, #expectedLines)
	-- Strict equal with identical objects that are not identical by reference.
	-- E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
	if maxLines == 0 then
		-- We have to get the result again. The lines were all removed before.
		local actualLines_ = String.split(actualInspected, "\n")

		-- Only remove lines in case it makes sense to collapse those.
		-- TODO: Accept env to always show the full error.
		if #actualLines_ > 50 then
			actualLines_[47] = ("%s...%s"):format(blue, white)
			while #actualLines_ > 47 do
				table.remove(actualLines_)
			end
		end

		return ("%s\n\n"):format(kReadableOperator.notIdentical) .. ("%s\n"):format(Array.join(actualLines_, "\n"))
	end

	-- There were at least five identical lines at the end. Mark a couple of
	-- skipped.
	if i >= 5 then
		end_ = ("\n%s...%s%s"):format(blue, white, end_)
		skipped = true
	end
	if other ~= "" then
		end_ = ("\n  %s%s"):format(other, end_)
		other = ""
	end

	local printedLines = 0
	local identical = 0
	local msg = kReadableOperator[operator] .. ("\n%s+ actual%s %s- expected%s"):format(green, white, red, white)
	local skippedMsg = (" %s...%s Lines skipped"):format(blue, white)

	local lines = actualLines
	local plusMinus = ("%s+%s"):format(green, white)
	local maxLength = #expectedLines
	if #actualLines < maxLines then
		lines = expectedLines
		plusMinus = ("%s-%s"):format(red, white)
		maxLength = #actualLines
	end

	for ii = 1, maxLines do
		i = ii
		if maxLength < ii then
			-- If more than two former lines are identical, print them. Collapse them
			-- in case more than five lines were identical.
			if identical > 2 then
				if identical > 3 then
					if identical > 4 then
						if identical == 5 then
							res ..= ("\n  %s"):format(lines[(ii - 3)])
							printedLines += 1
						else
							res ..= ("\n%s...%s"):format(blue, white)
							skipped = true
						end
					end
					res ..= ("\n  %s"):format(lines[(ii - 2)])
					printedLines += 1
				end
				res ..= ("\n  %s"):format(lines[(ii - 1)])
				printedLines += 1
			end
			-- No identical lines before.
			identical = 0
			-- Add the expected line to the cache.
			if lines == actualLines then
				res ..= ("\n%s %s"):format(plusMinus, lines[ii])
			else
				other ..= ("\n%s %s"):format(plusMinus, lines[ii])
			end
			printedLines += 1
			-- Only extra actual lines exist
			-- Lines diverge
		else
			local expectedLine = expectedLines[ii]
			local actualLine = actualLines[ii]
			-- If the lines diverge, specifically check for lines that only diverge by
			-- a trailing comma. In that case it is actually identical and we should
			-- mark it as such.
			local divergingLines = actualLine ~= expectedLine
				and (
					not Boolean.toJSBoolean(String.endsWith(actualLine, ","))
					or String.slice(actualLine, 0, -1) ~= expectedLine
				)
			-- If the expected line has a trailing comma but is otherwise identical,
			-- add a comma at the end of the actual line. Otherwise the output could
			-- look weird as in:
			--
			--   [
			--     1         // No comma at the end!
			-- +   2
			--   ]
			--
			if
				divergingLines
				and String.endsWith(expectedLine, ",")
				and String.slice(expectedLine, 0, -1) == actualLine
			then
				divergingLines = false
				actualLine ..= ","
			end
			if divergingLines then
				-- If more than two former lines are identical, print them. Collapse
				-- them in case more than five lines were identical.
				if identical > 2 then
					if identical > 3 then
						if identical > 4 then
							if identical == 5 then
								res ..= ("\n  %s"):format(actualLines[ii - 3])
								printedLines += 1
							else
								res ..= ("\n%s...%s"):format(blue, white)
								skipped = true
							end
						end
						res ..= ("\n  %s"):format(actualLines[ii - 2])
						printedLines += 1
					end
					res ..= ("\n  %s"):format(actualLines[ii - 1])
					printedLines += 1
				end
				-- No identical lines before.
				identical = 0
				-- Add the actual line to the result and cache the expected diverging
				-- line so consecutive diverging lines show up as +++--- and not +-+-+-.
				res ..= ("\n%s+%s %s"):format(green, white, actualLine)
				other ..= ("\n%s-%s %s"):format(red, white, expectedLine)
				printedLines += 2
				-- Lines are identical
			else
				-- Add all cached information to the result before adding other things
				-- and reset the cache.
				res ..= other
				other = ""
				identical += 1
				-- The very first identical line since the last diverging line is be
				-- added to the result.
				if identical <= 2 then
					res ..= ("\n  %s"):format(actualLine)
					printedLines += 1
				end
			end
		end
		-- Inspected object to big (Show ~50 rows max)
		if printedLines > 50 and ii < maxLines - 2 then
			return ("%s%s\n%s\n%s...%s%s\n"):format(msg, skippedMsg, res, blue, white, other)
				.. ("%s...%s"):format(blue, white)
		end
	end

	return ("%s%s\n%s%s%s%s"):format(msg, if skipped then skippedMsg else "", res, other, end_, indicator)
end
-- ROBLOX deviation START: skipped as it is only needed in [inspect.custom] method
-- local function addEllipsis(string_)
-- 	local lines = String.split(string_, "\n", 11)
-- 	if #lines.length > 10 then
-- 		lines = Array.slice(lines, 0, 10)
-- 		return ("%s\n..."):format(Array.join(lines, "\n"))
-- 	elseif string.len(string_) > 512 then
-- 		return ("%s..."):format(String.slice(string_, 512))
-- 	end
-- 	return string_
-- end
-- ROBLOX deviation END

export type AssertionError = Error & {
	actual: any,
	expected: any,
	operator: string?,
	generatedMessage: boolean,
	code: "ERR_ASSERTION",
	toString: (self: AssertionError) -> any,
	-- ROBLOX deviation: skipped [inpect.custom] method
	-- [inspect.custom]: (self: AssertionError, recurseTimes: any, ctx: any) -> any,
}

type AssertionErrorStatics = {
	new: (options: AssertionErrorOptions) -> AssertionError,
	__index: AssertionError,
	__tostring: (self: AssertionError) -> string,
}

local AssertionError: AssertionError & AssertionErrorStatics = (
	setmetatable({}, { __index = Error }) :: any
) :: AssertionError & AssertionErrorStatics
AssertionError.__index = AssertionError
AssertionError.__tostring = function(self: AssertionError)
	return self:toString()
end

type AssertionErrorOptions = {
	message: string?,
	actual: any?,
	expected: any?,
	-- ROBLOX note: this is optional in definitely-typed, but we always use it in Lua and it's only nil when details is non-nil
	operator: string?,
	stackStartFn: Function?,
}

function AssertionError.new(options: AssertionErrorOptions): AssertionError
	local self: AssertionError
	-- validateObject(options, "options")
	-- stylua: ignore
	local message, operator, stackStartFn =
		options.message,
		options.operator,
		options.stackStartFn
	local actual, expected = options.actual, options.expected
	-- ROBLOX deviation START: Error.stackTraceLimit not available in Luau port
	-- local limit = Error.stackTraceLimit
	-- if isErrorStackTraceLimitWritable() then
	-- 	Error.stackTraceLimit = 0
	-- end
	-- ROBLOX deviation END
	if message ~= nil then
		self = (setmetatable(Error.new(tostring(message)), AssertionError) :: any) :: AssertionError
	else
		if process.stderr.isTTY then
			-- Reset on each call to make sure we handle dynamically set environment
			-- variables correct.
			if process.stderr:hasColors() then
				blue = "\u{001b}[34m"
				green = "\u{001b}[32m"
				white = "\u{001b}[39m"
				red = "\u{001b}[31m"
			else
				blue = ""
				green = ""
				white = ""
				red = ""
			end
		end
		-- Prevent the error stack from being visible by duplicating the error
		-- in a very close way to the original in case both sides are actually
		-- instances of Error.
		if
			typeof(actual) == "table"
			and actual ~= nil
			and typeof(expected) == "table"
			and expected ~= nil
			and Array.indexOf(Object.keys(actual), "stack") ~= -1
			and instanceof(actual, Error)
			and Array.indexOf(Object.keys(expected), "stack") ~= -1
			and instanceof(expected, Error)
		then
			actual = copyError(actual)
			expected = copyError(expected)
		end
		if operator == "deepStrictEqual" or operator == "strictEqual" then
			self = (
				setmetatable(Error.new(createErrDiff(actual, expected, operator)), AssertionError) :: any
			) :: AssertionError
		elseif operator == "notDeepStrictEqual" or operator == "notStrictEqual" then
			-- In case the objects are equal but the operator requires unequal, show
			-- the first object and say A equals B
			local base = kReadableOperator[operator]
			local res = String.split(inspectValue(actual), "\n")

			-- In case "actual" is an object or a function, it should not be
			-- reference equal.
			if
				operator == "notStrictEqual"
				and (typeof(actual) == "table" and actual ~= nil or typeof(actual) == "function")
			then
				base = kReadableOperator.notStrictEqualObject
			end

			-- Only remove lines in case it makes sense to collapse those.
			-- TODO: Accept env to always show the full error.
			if #res > 50 then
				res[47] = ("%s...%s"):format(blue, white)
				while #res > 47 do
					table.remove(res)
				end
			end

			-- Only print a single input.
			if #res == 1 then
				self = (
					setmetatable(
						Error.new(("%s%s%s"):format(base, if string.len(res[1]) > 5 then "\n\n" else " ", res[1])),
						AssertionError
					) :: any
				) :: AssertionError
			else
				self = (
					setmetatable(Error.new(("%s\n\n%s\n"):format(base, Array.join(res, "\n"))), AssertionError) :: any
				) :: AssertionError
			end
		else
			local res = inspectValue(actual)
			local other = inspectValue(expected)
			local knownOperator = kReadableOperator[tostring(operator)]
			if operator == "notDeepEqual" and res == other then
				res = ("%s\n\n%s"):format(knownOperator, res)
				if string.len(res) > 1024 then
					res = ("%s..."):format(String.slice(res, 0, 1021))
				end
				self = (setmetatable(Error.new(res), AssertionError) :: any) :: AssertionError
			else
				if string.len(res) > 512 then
					res = ("%s..."):format(String.slice(res, 0, 509))
				end
				if string.len(other) > 512 then
					other = ("%s..."):format(String.slice(other, 0, 509))
				end
				if operator == "deepEqual" then
					res = ("%s\n\n%s\n\nshould loosely deep-equal\n\n"):format(knownOperator, res)
				else
					local newOp = kReadableOperator[("%sUnequal"):format(tostring(operator))]
					if Boolean.toJSBoolean(newOp) then
						res = ("%s\n\n%s\n\nshould not loosely deep-equal\n\n"):format(newOp, res)
					else
						other = (" %s %s"):format(tostring(operator), other)
					end
				end
				self = (setmetatable(Error.new(("%s%s"):format(res, other)), AssertionError) :: any) :: AssertionError
			end
		end
	end
	-- ROBLOX deviation START: Error.stackTraceLimit not available in Luau port
	-- if Boolean.toJSBoolean(isErrorStackTraceLimitWritable()) then
	-- 	Error.stackTraceLimit = limit
	-- end
	-- ROBLOX deviation END
	self.generatedMessage = not Boolean.toJSBoolean(message)
	--[[
		ROBLOX deviation: not using ObjectDefineProperty:
		original code:
		ObjectDefineProperty(self, "name", {
			value = "AssertionError [ERR_ASSERTION]",
			enumerable = false,
			writable = true,
			configurable = true,
		})
	]]
	self.name = "AssertionError [ERR_ASSERTION]"
	self.code = "ERR_ASSERTION"
	-- ROBLOX deviation START: details field not in public API docs, nodejs test suite, or in definitely-typed
	-- if details ~= nil then
	-- 	self.actual = nil
	-- 	self.expected = nil
	-- 	self.operator = ""
	-- 	for i = 1, #details do
	-- 		self["message " .. tostring(i)] = details[i].message
	-- 		self["actual " .. tostring(i)] = details[i].actual
	-- 		self["expected " .. tostring(i)] = details[i].expected
	-- 		self["operator " .. tostring(i)] = details[i].operator
	-- 		self["stack trace " .. tostring(i)] = details[i].stack
	-- 	end
	-- else
	self.actual = actual
	self.expected = expected
	self.operator = operator
	-- end
	-- ROBLOX deviation END
	ErrorCaptureStackTrace(self, stackStartFn or AssertionError.new)
	-- Create error message including the error code in the name.
	--[[
		ROBLOX deviation: Lua doesn't support 'LuaMemberExpression' as a standalone type
		original code:
		this.stack
	]]
	-- Reset the name.
	self.name = "AssertionError"
	return (self :: any) :: AssertionError
end

function AssertionError:toString()
	return ("%s [%s]: %s"):format(self.name, self.code, self.message)
end

AssertionError.name = "AssertionError"

return { AssertionError = AssertionError }
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="421">
              <Properties>
                <string name="Name">Error</string>
                <string name="Source"><![CDATA[local Error = require(script["Error.global"])
export type Error = Error.Error
return Error
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="422">
                <Properties>
                  <string name="Name">Error.global</string>
                  <string name="Source"><![CDATA[local LuauPolyfill = script.Parent.Parent
local Packages = LuauPolyfill.Parent

local types = require(Packages.ES7Types)

type Function = types.Function

export type Error = { name: string, message: string, stack: string? }
type Error_private = Error & { __stack: string? }

local Error = {}

local DEFAULT_NAME = "Error"
Error.__index = Error
Error.__tostring = function(self)
	-- Luau FIXME: I can't cast to Error or Object here: Type 'Object' could not be converted into '{ @metatable *unknown*, {|  |} }'
	return getmetatable(Error :: any).__tostring(self)
end

-- ROBLOX NOTE: extracted __createError function so that both Error.new() and Error() can capture the stack trace at the same depth
local function __createError(message: string?): Error
	local self = (setmetatable({
		name = DEFAULT_NAME,
		message = message or "",
	}, Error) :: any) :: Error
	Error.__captureStackTrace(self, 4)
	return self
end

function Error.new(message: string?): Error
	return __createError(message)
end

function Error.captureStackTrace(err: Error, options: Function?)
	Error.__captureStackTrace(err, 3, options)
end

function Error.__captureStackTrace(err_: Error, level: number, options: Function?)
	local err = err_ :: Error_private
	if typeof(options) == "function" then
		local stack = debug.traceback(nil, level)
		local functionName: string = debug.info(options, "n")
		local sourceFilePath: string = debug.info(options, "s")

		local espacedSourceFilePath = string.gsub(sourceFilePath, "([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
		local stacktraceLinePattern = espacedSourceFilePath .. ":%d* function " .. functionName
		local beg = string.find(stack, stacktraceLinePattern)
		local end_ = nil
		if beg ~= nil then
			beg, end_ = string.find(stack, "\n", beg + 1)
		end
		if end_ ~= nil then
			stack = string.sub(stack, end_ + 1)
		end
		err.__stack = stack
	else
		err.__stack = debug.traceback(nil, level)
	end
	Error.__recalculateStacktrace(err)
end

function Error.__recalculateStacktrace(err_: Error)
	local err = err_ :: Error_private
	local message = err.message
	local name = err.name or DEFAULT_NAME

	local errName = name .. (if message ~= nil and message ~= "" then (": " .. message) else "")
	local stack = if err.__stack then err.__stack else ""

	err.stack = errName .. "\n" .. stack
end

return setmetatable(Error, {
	__call = function(_, ...)
		return __createError(...)
	end,
	__tostring = function(self)
		if self.name ~= nil then
			if self.message and self.message ~= "" then
				return string.format("%s: %s", tostring(self.name), tostring(self.message))
			end
			return tostring(self.name)
		end
		return tostring(DEFAULT_NAME)
	end,
})
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="423">
              <Properties>
                <string name="Name">Promise</string>
                <string name="Source"><![CDATA[-- this maps onto community promise libraries which won't support Luau, so we inline
export type PromiseLike<T> = {
	andThen: (
		self: PromiseLike<T>,
		resolve: ((T) -> ...(nil | T | PromiseLike<T>))?,
		reject: ((any) -> ...(nil | T | PromiseLike<T>))?
	) -> PromiseLike<T>,
}

type PromiseStatus = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type Promise<T> = {
	andThen: (
		self: Promise<T>,
		resolve: ((T) -> ...(nil | T | PromiseLike<T>))?,
		reject: ((any) -> ...(nil | T | PromiseLike<T>))?
	) -> Promise<T>,

	catch: (Promise<T>, ((any) -> ...(nil | T | PromiseLike<nil>))) -> Promise<T>,

	onCancel: (Promise<T>, () -> ()?) -> boolean,

	expect: (Promise<T>) -> ...T,

	-- FIXME Luau: need union type packs to parse  (...T) | () | PromiseLike<T> here
	await: (Promise<T>) -> (boolean, ...(T | any)),

	getStatus: (self: Promise<T>) -> PromiseStatus,
	-- FIXME Luau: need union type packs to parse  (...T) | () | PromiseLike<T> here
	awaitStatus: (self: Promise<T>) -> (PromiseStatus, ...(T | any)),
}

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="424">
              <Properties>
                <string name="Name">encodeURIComponent</string>
                <string name="Source"><![CDATA[-- reference documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
local HttpService = game:GetService("HttpService")

local root = script.Parent
local Packages = root.Parent

local String = require(Packages.String)
local charCodeAt = String.charCodeAt
local Error = require(script.Parent.Error)

local function encodeURIComponent(value: string): string
	local valueLength = utf8.len(value)
	if valueLength == 0 or valueLength == nil then
		return ""
	end
	-- we don't exhaustively test the whole string for invalid characters like ECMA-262 15.1.3 says
	local check = charCodeAt(value, 1)
	if valueLength == 1 then
		if check == 0xD800 then
			error(Error.new("URI malformed"))
		end
		if check == 0xDFFF then
			error(Error.new("URI malformed"))
		end
	end
	if check >= 0xDC00 and check < 0xDFFF then
		error(Error.new("URI malformed"))
	end
	local encoded = HttpService:UrlEncode(value)
	-- reverting encoded chars which are not encoded by JS
	local result = encoded
		:gsub("%%2D", "-")
		:gsub("%%5F", "_")
		:gsub("%%2E", ".")
		:gsub("%%21", "!")
		:gsub("%%7E", "~")
		:gsub("%%2A", "*")
		:gsub("%%27", "'")
		:gsub("%%28", "(")
		:gsub("%%29", ")")
	return result
end

return encodeURIComponent
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="425">
              <Properties>
                <string name="Name">extends</string>
                <string name="Source"><![CDATA[--!nonstrict
--[[
	deviation: Our constructors currently have no notion of 'super' so any
	such behavior in upstream JS must be implemented manually by setting fields

	A constructor passed to this class would typically look along the lines of:
	function(self, arg, otherArg)
		self.arg = arg
		self.otherArg = otherArg
	end

	But even something like function() end can be passed in as the constructor
	if no fields need to be set. In upstream JS, the equivalent would be
	returning an empty object from the constructor.
]]
return function(parent, childName, constructor)
	local Child = {}
	Child.__index = Child
	Child.__tostring = function(self)
		return getmetatable(parent).__tostring(self)
	end

	local mt = {}

	Child.new = function(...)
		local self = {}
		constructor(self, ...)
		return setmetatable(self, Child)
	end

	if typeof(getmetatable(parent)) == "table" and getmetatable(parent).__call then
		mt.__call = function(_, ...)
			return Child.new(...)
		end
	end

	mt.__index = parent
	mt.__tostring = function(self)
		-- Printing class name
		if self == Child then
			return tostring(childName)
		end
		return getmetatable(parent).__tostring(self)
	end

	setmetatable(Child, mt)

	return Child
end
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="426">
            <Properties>
              <string name="Name">RegExp</string>
              <string name="Source"><![CDATA[local RegExp = require(script["Regexp.global"])

export type RegExp = RegExp.RegExp

return RegExp
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="427">
              <Properties>
                <string name="Name">RegEx</string>
                <string name="Source"><![CDATA[--!nolint
--!nocheck
--[[
	PCRE2-based RegEx implemention for Luau
	Version 1.0.0a2 (2020)
	Expat Licence
	Copyright © 2020, 2023 - Blockzez (devforum.roblox.com/u/Blockzez and github.com/Blockzez)
	All rights reserved.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]
--[[ Settings ]]--
-- You can change them here
local options = {
	-- The maximum cache size for regex so the patterns are cached so it doesn't recompile the pattern
	-- The only accepted value are number values >= 0, strings that can be automatically coered to numbers that are >= 0, false and nil
	-- Do note that empty regex patterns (comment-only patterns included) are never cached regardless
	-- The default is 256
	cacheSize = 256,

	-- A boolean that determines whether this use unicode data
	-- If this value evalulates to false, you can remove _unicodechar_category, _scripts and _xuc safely and it'll now error if:
	-- - You try to compile a RegEx with unicode flag
	-- - You try to use the \p pattern
	-- The default is true
	unicodeData = false,
};

--
local u_categories = options.unicodeData and require(script:WaitForChild("_unicodechar_category"));
local chr_scripts = options.unicodeData and require(script:WaitForChild("_scripts"));
local xuc_chr = options.unicodeData and require(script:WaitForChild("_xuc"));
local proxy = setmetatable({ }, { __mode = 'k' });
local re, re_m, match_m = { }, { }, { };
local lockmsg;

--[[ Functions ]]--
local function to_str_arr(self, init)
	if init then
		self = string.sub(self, utf8.offset(self, init));
	end;
	local len = utf8.len(self);
	if len <= 1999 then
		return { n = len, s = self, utf8.codepoint(self, 1, #self) };
	end;
	local clen = math.ceil(len / 1999);
	local ret = table.create(len);
	local p = 1;
	for i = 1, clen do
		local c = table.pack(utf8.codepoint(self, utf8.offset(self, i * 1999 - 1998), utf8.offset(self, i * 1999 - (i == clen and 1998 - ((len - 1) % 1999 + 1) or - 1)) - 1));
		table.move(c, 1, c.n, p, ret);
		p += c.n;
	end;
	ret.s, ret.n = self, len;
	return ret;
end;

local function from_str_arr(self)
	local len = self.n or #self;
	if len <= 7997 then
		return utf8.char(table.unpack(self));
	end;
	local clen = math.ceil(len / 7997);
	local r = table.create(clen);
	for i = 1, clen do
		r[i] = utf8.char(table.unpack(self, i * 7997 - 7996, i * 7997 - (i == clen and 7997 - ((len - 1) % 7997 + 1) or 0)));
	end;
	return table.concat(r);
end;

local function utf8_sub(self, i, j)
	j = utf8.offset(self, j);
	return string.sub(self, utf8.offset(self, i), j and j - 1);
end;

--
local flag_map = {
	a = 'anchored', i = 'caseless', m = 'multiline', s = 'dotall', u = 'unicode', U = 'ungreedy', x ='extended',
};

local posix_class_names = {
	alnum = true, alpha = true, ascii = true, blank = true, cntrl = true, digit = true, graph = true, lower = true, print = true, punct = true, space = true, upper = true, word = true, xdigit = true,
};

local escape_chars = {
	-- grouped
	-- digit, spaces and words
	[0x44] = { "class", "digit", true }, [0x53] = { "class", "space", true }, [0x57] = { "class", "word", true },
	[0x64] = { "class", "digit", false }, [0x73] = { "class", "space", false }, [0x77] = { "class", "word", false },
	-- horizontal/vertical whitespace and newline
	[0x48] = { "class", "blank", true }, [0x56] = { "class", "vertical_tab", true },
	[0x68] = { "class", "blank", false }, [0x76] = { "class", "vertical_tab", false },
	[0x4E] = { 0x4E }, [0x52] = { 0x52 },

	-- not grouped
	[0x42] = 0x08,
	[0x6E] = 0x0A, [0x72] = 0x0D, [0x74] = 0x09,
};

local b_escape_chars = {
	-- word boundary and not word boundary
	[0x62] = { 0x62, { "class", "word", false } }, [0x42] = { 0x42, { "class", "word", false } },

	-- keep match out
	[0x4B] = { 0x4B },

	-- start & end of string
	[0x47] = { 0x47 }, [0x4A] = { 0x4A }, [0x5A] = { 0x5A }, [0x7A] = { 0x7A },
};

local valid_categories = {
	C = true, Cc = true, Cf = true, Cn = true, Co = true, Cs = true,
	L = true, Ll = true, Lm = true, Lo = true, Lt = true, Lu = true,
	M = true, Mc = true, Me = true, Mn = true,
	N = true, Nd = true, Nl = true, No = true,
	P = true, Pc = true, Pd = true, Pe = true, Pf = true, Pi = true, Po = true, Ps = true,
	S = true, Sc = true, Sk = true, Sm = true, So = true,
	Z = true, Zl = true, Zp = true, Zs = true,

	Xan = true, Xps = true, Xsp = true, Xuc = true, Xwd = true,
};

local class_ascii_punct = {
	[0x21] = true, [0x22] = true, [0x23] = true, [0x24] = true, [0x25] = true, [0x26] = true, [0x27] = true, [0x28] = true, [0x29] = true, [0x2A] = true, [0x2B] = true, [0x2C] = true, [0x2D] = true, [0x2E] = true, [0x2F] = true,
	[0x3A] = true, [0x3B] = true, [0x3C] = true, [0x3D] = true, [0x3E] = true, [0x3F] = true, [0x40] = true, [0x5B] = true, [0x5C] = true, [0x5D] = true, [0x5E] = true, [0x5F] = true, [0x60] = true, [0x7B] = true, [0x7C] = true,
	[0x7D] = true, [0x7E] = true,
};

local end_str = { 0x24 };
local dot = { 0x2E };
local beginning_str = { 0x5E };
local alternation = { 0x7C };

local function check_re(re_type, name, func)
	if re_type == "Match" then
		return function(...)
			local arg_n = select('#', ...);
			if arg_n < 1 then
				error("missing argument #1 (Match expected)", 2);
			end;
			local arg0, arg1 = ...;
			if not (proxy[arg0] and proxy[arg0].name == "Match") then
				error(string.format("invalid argument #1 to %q (Match expected, got %s)", name, typeof(arg0)), 2);
			else
				arg0 = proxy[arg0];
			end;
			if name == "group" or name == "span" then
				if arg1 == nil then
					arg1 = 0;
				end;
			end;
			return func(arg0, arg1);
		end;
	end;
	return function(...)
		local arg_n = select('#', ...);
		if arg_n < 1 then
			error("missing argument #1 (RegEx expected)", 2);
		elseif arg_n < 2 then
			error("missing argument #2 (string expected)", 2);
		end;
		local arg0, arg1, arg2, arg3, arg4, arg5 = ...;
		if not (proxy[arg0] and proxy[arg0].name == "RegEx") then
			if type(arg0) ~= "string" and type(arg0) ~= "number" then
				error(string.format("invalid argument #1 to %q (RegEx expected, got %s)", name, typeof(arg0)), 2);
			end;
			arg0 = re.fromstring(arg0);
		elseif name == "sub" then
			if type(arg2) == "number" then
				arg2 ..= '';
			elseif type(arg2) ~= "string" then
				error(string.format("invalid argument #3 to 'sub' (string expected, got %s)", typeof(arg2)), 2);
			end;
		elseif type(arg1) == "number" then
			arg1 ..= '';
		elseif type(arg1) ~= "string" then
			error(string.format("invalid argument #2 to %q (string expected, got %s)", name, typeof(arg1)), 2);
		end;
		if name ~= "sub" and name ~= "split" then
			local init_type = typeof(arg2);
			if init_type ~= 'nil' then
				arg2 = tonumber(arg2);
				if not arg2 then
					error(string.format("invalid argument #3 to %q (number expected, got %s)", name, init_type), 2);
				elseif arg2 < 0 then
					arg2 = #arg1 + math.floor(arg2 + 0.5) + 1;
				else
					arg2 = math.max(math.floor(arg2 + 0.5), 1);
				end;
			end;
		end;
		arg0 = proxy[arg0];
		if name == "match" or name == "matchiter" then
			arg3 = ...;
		elseif name == "sub" then
			arg5 = ...;
		end;
		return func(arg0, arg1, arg2, arg3, arg4, arg5);
	end;
end;

--[[ Matches ]]--
local function match_tostr(self)
	local spans = proxy[self].spans;
	local s_start, s_end = spans[0][1], spans[0][2];
	if s_end <= s_start then
		return string.format("Match (%d..%d, empty)", s_start, s_end - 1);
	end;
	return string.format("Match (%d..%d): %s", s_start, s_end - 1, utf8_sub(spans.input, s_start, s_end));
end;

local function new_match(span_arr, group_id, re, str)
	span_arr.source, span_arr.input = re, str;
	local object = newproxy(true);
	local object_mt = getmetatable(object);
	object_mt.__metatable = lockmsg;
	object_mt.__index = setmetatable(span_arr, match_m);
	object_mt.__tostring = match_tostr;

	proxy[object] = { name = "Match", spans = span_arr, group_id = group_id };
	return object;
end;

match_m.group = check_re('Match', 'group', function(self, group_id)
	local span = self.spans[type(group_id) == "number" and group_id or self.group_id[group_id]];
	if not span then
		return nil;
	end;
	return utf8_sub(self.spans.input, span[1], span[2]);
end);

match_m.span = check_re('Match', 'span', function(self, group_id)
	local span = self.spans[type(group_id) == "number" and group_id or self.group_id[group_id]];
	if not span then
		return nil;
	end;
	return span[1], span[2] - 1;
end);

match_m.groups = check_re('Match', 'groups', function(self)
	local spans = self.spans;
	if spans.n > 0 then
		local ret = table.create(spans.n);
		for i = 0, spans.n do
			local v = spans[i];
			if v then
				ret[i] = utf8_sub(spans.input, v[1], v[2]);
			end;
		end;
		return table.unpack(ret, 1, spans.n);
	end;
	return utf8_sub(spans.input, spans[0][1], spans[0][2]);
end);

match_m.groupdict = check_re('Match', 'groupdict', function(self)
	local spans = self.spans;
	local ret = { };
	for k, v in pairs(self.group_id) do
		v = spans[v];
		if v then
			ret[k] = utf8_sub(spans.input, v[1], v[2]);
		end;
	end;
	return ret;
end);

match_m.grouparr = check_re('Match', 'groupdict', function(self)
	local spans = self.spans;
	local ret = table.create(spans.n);
	for i = 0, spans.n do
		local v = spans[i];
		if v then
			ret[i] = utf8_sub(spans.input, v[1], v[2]);
		end;
	end;
	ret.n = spans.n;
	return ret;
end);

--
local line_verbs = {
	CR = 0, LF = 1, CRLF = 2, ANYRLF = 3, ANY = 4, NUL = 5,
};
local function is_newline(str_arr, i, verb_flags)
	local line_verb_n = verb_flags.newline;
	local chr = str_arr[i];
	if line_verb_n == 0 then
		-- carriage return
		return chr == 0x0D;
	elseif line_verb_n == 2 then
		-- carriage return followed by line feed
		return chr == 0x0A and str_arr[i - 1] == 0x20;
	elseif line_verb_n == 3 then
		-- any of the above
		return chr == 0x0A or chr == 0x0D;
	elseif line_verb_n == 4 then
		-- any of Unicode newlines
		return chr == 0x0A or chr == 0x0B or chr == 0x0C or chr == 0x0D or chr == 0x85 or chr == 0x2028 or chr == 0x2029;
	elseif line_verb_n == 5 then
		-- null
		return chr == 0;
	end;
	-- linefeed
	return chr == 0x0A;
end;


local function tkn_char_match(tkn_part, str_arr, i, flags, verb_flags)
	local chr = str_arr[i];
	if not chr then
		return false;
	elseif flags.ignoreCase and chr >= 0x61 and chr <= 0x7A then
		chr -= 0x20;
	end;
	if type(tkn_part) == "number" then
		return tkn_part == chr;
	elseif tkn_part[1] == "charset" then
		for _, v in ipairs(tkn_part[3]) do
			if tkn_char_match(v, str_arr, i, flags, verb_flags) then
				return not tkn_part[2];
			end;
		end;
		return tkn_part[2];
	elseif tkn_part[1] == "range" then
		return chr >= tkn_part[2] and chr <= tkn_part[3] or flags.ignoreCase and chr >= 0x41 and chr <= 0x5A and (chr + 0x20) >= tkn_part[2] and (chr + 0x20) <= tkn_part[3];
	elseif tkn_part[1] == "class" then
		local char_class = tkn_part[2];
		local negate = tkn_part[3];
		local match = false;
		-- if and elseifs :(
		-- Might make these into tables in the future
		if char_class == "xdigit" then
			match = chr >= 0x30 and chr <= 0x39 or chr >= 0x41 and chr <= 0x46 or chr >= 0x61 and chr <= 0x66;
		elseif char_class == "ascii" then
			match = chr <= 0x7F;
		-- cannot be accessed through POSIX classes
		elseif char_class == "vertical_tab" then
			match = chr >= 0x0A and chr <= 0x0D or chr == 0x2028 or chr == 0x2029;
		--
		elseif flags.unicode then
			local current_category = u_categories[chr] or 'Cn';
			local first_category = current_category:sub(1, 1);
			if char_class == "alnum" then
				match = first_category == 'L' or current_category == 'Nl' or current_category == 'Nd';
			elseif char_class == "alpha" then
				match = first_category == 'L' or current_category == 'Nl';
			elseif char_class == "blank" then
				match = current_category == 'Zs' or chr == 0x09;
			elseif char_class == "cntrl" then
				match = current_category == 'Cc';
			elseif char_class == "digit" then
				match = current_category == 'Nd';
			elseif char_class == "graph" then
				match = first_category ~= 'P' and first_category ~= 'C';
			elseif char_class == "lower" then
				match = current_category == 'Ll';
			elseif char_class == "print" then
				match = first_category ~= 'C';
			elseif char_class == "punct" then
				match = first_category == 'P';
			elseif char_class == "space" then
				match = first_category == 'Z' or chr >= 0x09 and chr <= 0x0D;
			elseif char_class == "upper" then
				match = current_category == 'Lu';
			elseif char_class == "word" then
				match = first_category == 'L' or current_category == 'Nl' or current_category == 'Nd' or current_category == 'Pc';
			end;
		elseif char_class == "alnum" then
			match = chr >= 0x30 and chr <= 0x39 or chr >= 0x41 and chr <= 0x5A or chr >= 0x61 and chr <= 0x7A;
		elseif char_class == "alpha" then
			match = chr >= 0x41 and chr <= 0x5A or chr >= 0x61 and chr <= 0x7A;
		elseif char_class == "blank" then
			match = chr == 0x09 or chr == 0x20;
		elseif char_class == "cntrl" then
			match = chr <= 0x1F or chr == 0x7F;
		elseif char_class == "digit" then
			match = chr >= 0x30 and chr <= 0x39;
		elseif char_class == "graph" then
			match = chr >= 0x21 and chr <= 0x7E;
		elseif char_class == "lower" then
			match = chr >= 0x61 and chr <= 0x7A;
		elseif char_class == "print" then
			match = chr >= 0x20 and chr <= 0x7E;
		elseif char_class == "punct" then
			match = class_ascii_punct[chr];
		elseif char_class == "space" then
			match = chr >= 0x09 and chr <= 0x0D or chr == 0x20;
		elseif char_class == "upper" then
			match = chr >= 0x41 and chr <= 0x5A;
		elseif char_class == "word" then
			match = chr >= 0x30 and chr <= 0x39 or chr >= 0x41 and chr <= 0x5A or chr >= 0x61 and chr <= 0x7A or chr == 0x5F;
		end;
		if negate then
			return not match;
		end;
		return match;
	elseif tkn_part[1] == "category" then
		local chr_category = u_categories[chr] or 'Cn';
		local category_v = tkn_part[3];
		local category_len = #category_v;
		if category_len == 3 then
			local match = false;
			if category_v == "Xan" or category_v == "Xwd" then
				match = chr_category:find("^[LN]") or category_v == "Xwd" and chr == 0x5F;
			elseif category_v == "Xps" or category_v == "Xsp" then
				match = chr_category:sub(1, 1) == 'Z' or chr >= 0x09 and chr <= 0x0D;
			elseif category_v == "Xuc" then
				match = tkn_char_match(xuc_chr, str_arr, i, flags, verb_flags);
			end;
			if tkn_part[2] then
				return not match;
			end
			return match;
		elseif chr_category:sub(1, category_len) == category_v then
			return not tkn_part[2];
		end;
		return tkn_part[2];
	elseif tkn_part[1] == 0x2E then
		return flags.dotAll or not is_newline(str_arr, i, verb_flags);
	elseif tkn_part[1] == 0x4E then
		return not is_newline(str_arr, i, verb_flags);
	elseif tkn_part[1] == 0x52 then
		if verb_flags.newline_seq == 0 then
			-- CR, LF or CRLF
			return chr == 0x0A or chr == 0x0D;
		end;
		-- any unicode newline
		return chr == 0x0A or chr == 0x0B or chr == 0x0C or chr == 0x0D or chr == 0x85 or chr == 0x2028 or chr == 0x2029;
	end;
	return false;
end;

local function find_alternation(token, i, count)
	while true do
		local v = token[i];
		local is_table = type(v) == "table";
		if v == alternation then
			return i, count;
		elseif is_table and v[1] == 0x28 then
			if count then
				count += v.count;
			end;
			i = v[3];
		elseif is_table and v[1] == "quantifier" and type(v[5]) == "table" and v[5][1] == 0x28 then
			if count then
				count += v[5].count;
			end;
			i = v[5][3];
		elseif not v or is_table and v[1] == 0x29 then
			return nil, count;
		elseif count then
			if is_table and v[1] == "quantifier" then
				count += v[3];
			else
				count += 1;
			end;
		end;
		i += 1;
	end;
end;

local function re_rawfind(token, str_arr, init, flags, verb_flags, as_bool)
	local tkn_i, str_i, start_i = 0, init, init;
	local states = { };
	while tkn_i do
		if tkn_i == 0 then
			tkn_i += 1;
			local next_alt = find_alternation(token, tkn_i);
			if next_alt then
				table.insert(states, 1, { "alternation", next_alt, str_i });
			end;
			continue;
		end;
		local ctkn = token[tkn_i];
		local tkn_type = type(ctkn) == "table" and ctkn[1];
		if not ctkn then
			break;
		elseif ctkn == "ACCEPT" then
			local not_lookaround = true;
			local close_i = tkn_i;
			repeat
				close_i += 1;
				local is_table = type(token[close_i]) == "table";
				local close_i_tkn = token[close_i];
				if is_table and (close_i_tkn[1] == 0x28 or close_i_tkn[1] == "quantifier" and type(close_i_tkn[5]) == "table" and close_i_tkn[5][1] == 0x28) then
					close_i = close_i_tkn[1] == "quantifier" and close_i_tkn[5][3] or close_i_tkn[3];
				elseif is_table and close_i_tkn[1] == 0x29 and (close_i_tkn[4] == 0x21 or close_i_tkn[4] == 0x3D) then
					not_lookaround = false;
					tkn_i = close_i;
					break;
				end;
			until not close_i_tkn;
			if not_lookaround then
				break;
			end;
		elseif ctkn == "PRUNE" or ctkn == "SKIP" then
			table.insert(states, 1, { ctkn, str_i });
			tkn_i += 1;
		elseif tkn_type == 0x28 then
			table.insert(states, 1, { "group", tkn_i, str_i, nil, ctkn[2], ctkn[3], ctkn[4] });
			tkn_i += 1;
			local next_alt, count = find_alternation(token, tkn_i, (ctkn[4] == 0x21 or ctkn[4] == 0x3D) and ctkn[5] and 0);
			if next_alt then
				table.insert(states, 1, { "alternation", next_alt, str_i });
			end;
			if count then
				str_i -= count;
			end;
		elseif tkn_type == 0x29 and ctkn[4] ~= 0x21 then
			if ctkn[4] == 0x21 or ctkn[4] == 0x3D then
				while true do
					local selected_match_start;
					local selected_state = table.remove(states, 1);
					if selected_state[1] == "group" and selected_state[2] == ctkn[3] then
						if (ctkn[4] == 0x21 or ctkn[4] == 0x3D) and not ctkn[5] then
							str_i = selected_state[3];
						end;
						if selected_match_start then
							table.insert(states, 1, selected_match_start);
						end;
						break;
					elseif selected_state[1] == "matchStart" and not selected_match_start and ctkn[4] == 0x3D then
						selected_match_start = selected_state;
					end;
				end;
			elseif ctkn[4] == 0x3E then
				repeat
					local selected_state = table.remove(states, 1);
				until not selected_state or selected_state[1] == "group" and selected_state[2] == ctkn[3];
			else
				for i, v in ipairs(states) do
					if v[1] == "group" and v[2] == ctkn[3] then
						if v.jmp then
							-- recursive match
							tkn_i = v.jmp;
						end;
						v[4] = str_i;
						if v[7] == "quantifier" and v[10] + 1 < v[9] then
							if token[ctkn[3]][4] ~= "lazy" or v[10] + 1 < v[8] then
								tkn_i = ctkn[3];
							end;
							local ctkn1 = token[ctkn[3]];
							local new_group = { "group", v[2], str_i, nil, ctkn1[5][2], ctkn1[5][3], "quantifier", ctkn1[2], ctkn1[3], v[10] + 1, v[11], ctkn1[4] };
							table.insert(states, 1, new_group);
							if v[11] then
								table.insert(states, 1, { "alternation", v[11], str_i });
							end;
						end;
						break;
					end;
				end;
			end;
			tkn_i += 1;
		elseif tkn_type == 0x4B then
			table.insert(states, 1, { "matchStart", str_i });
			tkn_i += 1;
		elseif tkn_type == 0x7C then
			local close_i = tkn_i;
			repeat
				close_i += 1;
				local is_table = type(token[close_i]) == "table";
				local close_i_tkn = token[close_i];
				if is_table and (close_i_tkn[1] == 0x28 or close_i_tkn[1] == "quantifier" and type(close_i_tkn[5]) == "table" and close_i_tkn[5][1] == 0x28) then
					close_i = close_i_tkn[1] == "quantifier" and close_i_tkn[5][3] or close_i_tkn[3];
				end;
			until is_table and close_i_tkn[1] == 0x29 or not close_i_tkn;
			if token[close_i] then
				for _, v in ipairs(states) do
					if v[1] == "group" and v[6] == close_i then
						tkn_i = v[6];
						break;
					end;
				end;
			else
				tkn_i = close_i;
			end;
		elseif tkn_type == "recurmatch" then
			table.insert(states, 1, { "group", ctkn[3], str_i, nil, nil, token[ctkn[3]][3], nil, jmp = tkn_i });
			tkn_i = ctkn[3] + 1;
			local next_alt, count = find_alternation(token, tkn_i);
			if next_alt then
				table.insert(states, 1, { "alternation", next_alt, str_i });
			end;
		else
			local match;
			if ctkn == "FAIL" then
				match = false;
			elseif tkn_type == 0x29 then
				repeat
					local selected_state = table.remove(states, 1);
				until selected_state[1] == "group" and selected_state[2] == ctkn[3];
			elseif tkn_type == "quantifier" then
				if type(ctkn[5]) == "table" and ctkn[5][1] == 0x28 then
					local next_alt = find_alternation(token, tkn_i + 1);
					if next_alt then
						table.insert(states, 1, { "alternation", next_alt, str_i });
					end;
					table.insert(states, next_alt and 2 or 1, { "group", tkn_i, str_i, nil, ctkn[5][2], ctkn[5][3], "quantifier", ctkn[2], ctkn[3], 0, next_alt, ctkn[4] });
					if ctkn[4] == "lazy" and ctkn[2] == 0 then
						tkn_i = ctkn[5][3];
					end;
					match = true;
				else
					local start_i, end_i;
					local pattern_count = 1;
					local is_backref = type(ctkn[5]) == "table" and ctkn[5][1] == "backref";
					if is_backref then
						pattern_count = 0;
						local group_n = ctkn[5][2];
						for _, v in ipairs(states) do
							if v[1] == "group" and v[5] == group_n then
								start_i, end_i = v[3], v[4];
								pattern_count = end_i - start_i;
								break;
							end;
						end;
					end;
					local min_max_i = str_i + ctkn[2] * pattern_count;
					local mcount = 0;
					while mcount < ctkn[3] do
						if is_backref then
							if start_i and end_i then
								local org_i = str_i;
								if utf8_sub(str_arr.s, start_i, end_i) ~= utf8_sub(str_arr.s, org_i, str_i + pattern_count) then
									break;
								end;
							else
								break;
							end;
						elseif not tkn_char_match(ctkn[5], str_arr, str_i, flags, verb_flags) then
							break;
						end;
						str_i += pattern_count;
						mcount += 1;
					end;
					match = mcount >= ctkn[2];
					if match and ctkn[4] ~= "possessive" then
						if ctkn[4] == "lazy" then
							min_max_i, str_i = str_i, min_max_i;
						end;
						table.insert(states, 1, { "quantifier", tkn_i, str_i, math.min(min_max_i, str_arr.n + 1), (ctkn[4] == "lazy" and 1 or -1) * pattern_count });
					end;
				end;
			elseif tkn_type == "backref" then
				local start_i, end_i;
				local group_n = ctkn[2];
				for _, v in ipairs(states) do
					if v[1] == "group" and v[5] == group_n then
						start_i, end_i = v[3], v[4];
						break;
					end;
				end;
				if start_i and end_i then
					local org_i = str_i;
					str_i += end_i - start_i;
					match = utf8_sub(str_arr.s, start_i, end_i) == utf8_sub(str_arr.s, org_i, str_i);
				end;
			else
				local chr = str_arr[str_i];
				if tkn_type == 0x24 or tkn_type == 0x5A or tkn_type == 0x7A then
					match = str_i == str_arr.n + 1 or tkn_type == 0x24 and flags.multiline and is_newline(str_arr, str_i + 1, verb_flags) or tkn_type == 0x5A and str_i == str_arr.n and is_newline(str_arr, str_i, verb_flags);
				elseif tkn_type == 0x5E or tkn_type == 0x41 or tkn_type == 0x47 then
					match = str_i == 1 or tkn_type == 0x5E and flags.multiline and is_newline(str_arr, str_i - 1, verb_flags) or tkn_type == 0x47 and str_i == init;
				elseif tkn_type == 0x42 or tkn_type == 0x62 then
					local start_m = str_i == 1 or flags.multiline and is_newline(str_arr, str_i - 1, verb_flags);
					local end_m = str_i == str_arr.n + 1 or flags.multiline and is_newline(str_arr, str_i, verb_flags);
					local w_m = tkn_char_match(ctkn[2], str_arr[str_i - 1], flags) and 0 or tkn_char_match(ctkn[2], chr, flags) and 1;
					if w_m == 0 then
						match = end_m or not tkn_char_match(ctkn[2], chr, flags);
					elseif w_m then
						match = start_m or not tkn_char_match(ctkn[2], str_arr[str_i - 1], flags);
					end;
					if tkn_type == 0x42 then
						match = not match;
					end;
				else
					match = tkn_char_match(ctkn, str_arr, str_i, flags, verb_flags);
					str_i += 1;
				end;
			end;
			if not match then
				while true do
					local prev_type, prev_state = states[1] and states[1][1], states[1];
					if not prev_type or prev_type == "PRUNE" or prev_type == "SKIP" then
						if prev_type then
							table.clear(states);
						end;
						if start_i > str_arr.n then
							if as_bool then
								return false;
							end;
							return nil;
						end;
						start_i = prev_type == "SKIP" and prev_state[2] or start_i + 1;
						tkn_i, str_i = 0, start_i;
						break;
					elseif prev_type == "alternation" then
						tkn_i, str_i = prev_state[2], prev_state[3];
						local next_alt, count = find_alternation(token, tkn_i + 1);
						if next_alt then
							prev_state[2] = next_alt;
						else
							table.remove(states, 1);
						end;
						if count then
							str_i -= count;
						end;
						break;
					elseif prev_type == "group" then
						if prev_state[7] == "quantifier" then
							if prev_state[12] == "greedy" and prev_state[10] >= prev_state[8]
								or prev_state[12] == "lazy" and prev_state[10] < prev_state[9] and not prev_state[13] then
								tkn_i, str_i = prev_state[12] == "greedy" and prev_state[6] or prev_state[2], prev_state[3];
								if prev_state[12] == "greedy" then
									table.remove(states, 1);
									break;
								elseif prev_state[10] >= prev_state[8] then
									prev_state[13] = true;
									break;
								end;
							end;
						elseif prev_state[7] == 0x21 then
							table.remove(states, 1);
							tkn_i, str_i = prev_state[6], prev_state[3];
							break;
						end;
					elseif prev_type == "quantifier" then
						if math.sign(prev_state[4] - prev_state[3]) == math.sign(prev_state[5]) then
							prev_state[3] += prev_state[5];
							tkn_i, str_i = prev_state[2], prev_state[3];
							break;
						end;
					end;
					-- keep match out state and recursive state, can be safely removed
					-- prevents infinite loop
					table.remove(states, 1);
				end;
			end;
			tkn_i += 1;
		end;
	end;
	if as_bool then
		return true;
	end;
	local match_start_ran = false;
	local span = table.create(token.group_n);
	span[0], span.n = { start_i, str_i }, token.group_n;
	for _, v in ipairs(states) do
		if v[1] == "matchStart" and not match_start_ran then
			span[0][1], match_start_ran = v[2], true;
		elseif v[1] == "group" and v[5] and not span[v[5]] then
			span[v[5]] = { v[3], v[4] };
		end;
	end;
	return span;
end;

--[[ Methods ]]--
re_m.test = check_re('RegEx', 'test', function(self, str, init)
	return re_rawfind(self.token, to_str_arr(str, init), 1, self.flags, self.verb_flags, true);
end);

re_m.match = check_re('RegEx', 'match', function(self, str, init, source)
	local span = re_rawfind(self.token, to_str_arr(str, init), 1, self.flags, self.verb_flags, false);
	if not span then
		return nil;
	end;
	return new_match(span, self.group_id, source, str);
end);

re_m.matchall = check_re('RegEx', 'matchall', function(self, str, init, source)
	str = to_str_arr(str, init);
	local i = 1;
	return function()
		local span = i <= str.n + 1 and re_rawfind(self.token, str, i, self.flags, self.verb_flags, false);
		if not span then
			return nil;
		end;
		i = span[0][2] + (span[0][1] >= span[0][2] and 1 or 0);
		return new_match(span, self.group_id, source, str.s);
	end;
end);

local function insert_tokenized_sub(repl_r, str, span, tkn)
	for _, v in ipairs(tkn) do
		if type(v) == "table" then
			if v[1] == "condition" then
				if span[v[2]] then
					if v[3] then
						insert_tokenized_sub(repl_r, str, span, v[3]);
					else
						table.move(str, span[v[2]][1], span[v[2]][2] - 1, #repl_r + 1, repl_r);
					end;
				elseif v[4] then
					insert_tokenized_sub(repl_r, str, span, v[4]);
				end;
			else
				table.move(v, 1, #v, #repl_r + 1, repl_r);
			end;
		elseif span[v] then
			table.move(str, span[v][1], span[v][2] - 1, #repl_r + 1, repl_r);
		end;
	end;
	repl_r.n = #repl_r;
	return repl_r;
end;

re_m.sub = check_re('RegEx', 'sub', function(self, repl, str, n, repl_flag_str, source)
	if repl_flag_str ~= nil and type(repl_flag_str) ~= "number" and type(repl_flag_str) ~= "string" then
		error(string.format("invalid argument #5 to 'sub' (string expected, got %s)", typeof(repl_flag_str)), 3);
	end
	local repl_flags = {
		l = false, o = false, u = false,
	};
	for f in string.gmatch(repl_flag_str or '', utf8.charpattern) do
		if repl_flags[f] ~= false then
			error("invalid regular expression substitution flag " .. f, 3);
		end;
		repl_flags[f] = true;
	end;
	local repl_type = type(repl);
	if repl_type == "number" then
		repl ..= '';
	elseif repl_type ~= "string" and repl_type ~= "function" and (not repl_flags.o or repl_type ~= "table") then
		error(string.format("invalid argument #2 to 'sub' (string/function%s expected, got %s)", repl_flags.o and "/table" or '', typeof(repl)), 3);
	end;
	if tonumber(n) then
		n = tonumber(n);
		if n <= -1 or n ~= n then
			n = math.huge;
		end;
	elseif n ~= nil then
		error(string.format("invalid argument #4 to 'sub' (number expected, got %s)", typeof(n)), 3);
	else
		n = math.huge;
	end;
	if n < 1 then
		return str, 0;
	end;
	local min_repl_n = 0;
	if repl_type == "string" then
		repl = to_str_arr(repl);
		if not repl_flags.l then
			local i1 = 0;
			local repl_r = table.create(3);
			local group_n = self.token.group_n;
			local conditional_c = { };
			while i1 < repl.n do
				local i2 = i1;
				repeat
					i2 += 1;
				until not repl[i2] or repl[i2] == 0x24 or repl[i2] == 0x5C or (repl[i2] == 0x3A or repl[i2] == 0x7D) and conditional_c[1];
				min_repl_n += i2 - i1 - 1;
				if i2 - i1 > 1 then
					table.insert(repl_r, table.move(repl, i1 + 1, i2 - 1, 1, table.create(i2 - i1 - 1)));
				end;
				if repl[i2] == 0x3A then
					local current_conditional_c = conditional_c[1];
					if current_conditional_c[2] then
						error("malformed substitution pattern", 3);
					end;
					current_conditional_c[2] = table.move(repl_r, current_conditional_c[3], #repl_r, 1, table.create(#repl_r + 1 - current_conditional_c[3]));
					for i3 = #repl_r, current_conditional_c[3], -1 do
						repl_r[i3] = nil;
					end;
				elseif repl[i2] == 0x7D then
					local current_conditional_c = table.remove(conditional_c, 1);
					local second_c = table.move(repl_r, current_conditional_c[3], #repl_r, 1, table.create(#repl_r + 1 - current_conditional_c[3]));
					for i3 = #repl_r, current_conditional_c[3], -1 do
						repl_r[i3] = nil;
					end;
					table.insert(repl_r, { "condition", current_conditional_c[1], current_conditional_c[2] ~= true and (current_conditional_c[2] or second_c), current_conditional_c[2] and second_c });
				elseif repl[i2] then
					i2 += 1;
					local subst_c = repl[i2];
					if not subst_c then
						if repl[i2 - 1] == 0x5C then
							error("replacement string must not end with a trailing backslash", 3);
						end;
						local prev_repl_f = repl_r[#repl_r];
						if type(prev_repl_f) == "table" then
							table.insert(prev_repl_f, repl[i2 - 1]);
						else
							table.insert(repl_r, { repl[i2 - 1] });
						end;
					elseif subst_c == 0x5C and repl[i2 - 1] == 0x24 then
						local prev_repl_f = repl_r[#repl_r];
						if type(prev_repl_f) == "table" then
							table.insert(prev_repl_f, 0x24);
						else
							table.insert(repl_r, { 0x24 });
						end;
						i2 -= 1;
						min_repl_n += 1;
					elseif subst_c == 0x30 then
						table.insert(repl_r, 0);
					elseif subst_c > 0x30 and subst_c <= 0x39 then
						local start_i2 = i2;
						local group_i = subst_c - 0x30;
						while repl[i2 + 1] and repl[i2 + 1] >= 0x30 and repl[i2 + 1] <= 0x39 do
							group_i ..= repl[i2 + 1] - 0x30;
							i2 += 1;
						end;
						group_i = tonumber(group_i);
						if not repl_flags.u and group_i > group_n then
							error("reference to non-existent subpattern", 3);
						end;
						table.insert(repl_r, group_i);
					elseif subst_c == 0x7B and repl[i2 - 1] == 0x24 then
						i2 += 1;
						local start_i2 = i2;
						while repl[i2] and
							(repl[i2] >= 0x30 and repl[i2] <= 0x39
								or repl[i2] >= 0x41 and repl[i2] <= 0x5A
								or repl[i2] >= 0x61 and repl[i2] <= 0x7A
								or repl[i2] == 0x5F) do
							i2 += 1;
						end;
						if (repl[i2] == 0x7D or repl[i2] == 0x3A and (repl[i2 + 1] == 0x2B or repl[i2 + 1] == 0x2D)) and i2 ~= start_i2 then
							local group_k = utf8_sub(repl.s, start_i2, i2);
							if repl[start_i2] >= 0x30 and repl[start_i2] <= 0x39 then
								group_k = tonumber(group_k);
								if not repl_flags.u and group_k > group_n then
									error("reference to non-existent subpattern", 3);
								end;
							else
								group_k = self.group_id[group_k];
								if not repl_flags.u and (not group_k or group_k > group_n) then
									error("reference to non-existent subpattern", 3);
								end;
							end;
							if repl[i2] == 0x3A then
								i2 += 1;
								table.insert(conditional_c, { group_k, repl[i2] == 0x2D, #repl_r + 1 });
							else
								table.insert(repl_r, group_k);
							end;
						else
							error("malformed substitution pattern", 3);
						end;
					else
						local c_escape_char;
						if repl[i2 - 1] == 0x24 then
							if subst_c ~= 0x24 then
								local prev_repl_f = repl_r[#repl_r];
								if type(prev_repl_f) == "table" then
									table.insert(prev_repl_f, 0x24);
								else
									table.insert(repl_r, { 0x24 });
								end;
							end;
						else
							c_escape_char = escape_chars[repl[i2]];
							if type(c_escape_char) ~= "number" then
								c_escape_char = nil;
							end;
						end;
						local prev_repl_f = repl_r[#repl_r];
						if type(prev_repl_f) == "table" then
							table.insert(prev_repl_f, c_escape_char or repl[i2]);
						else
							table.insert(repl_r, { c_escape_char or repl[i2] });
						end;
						min_repl_n += 1;
					end;
				end;
				i1 = i2;
			end;
			if conditional_c[1] then
				error("malformed substitution pattern", 3);
			end;
			if not repl_r[2] and type(repl_r[1]) == "table" and repl_r[1][1] ~= "condition" then
				repl, repl.n = repl_r[1], #repl_r[1];
			else
				repl, repl_type = repl_r, "subst_string";
			end;
		end;
	end;
	str = to_str_arr(str);
	local incr, i0, count = 0, 1, 0;
	while i0 <= str.n + incr + 1 do
		local span = re_rawfind(self.token, str, i0, self.flags, self.verb_flags, false);
		if not span then
			break;
		end;
		local repl_r;
		if repl_type == "string" then
			repl_r = repl;
		elseif repl_type == "subst_string" then
			repl_r = insert_tokenized_sub(table.create(min_repl_n), str, span, repl);
		else
			local re_match;
			local repl_c;
			if repl_type == "table" then
				re_match = utf8_sub(str.s, span[0][1], span[0][2]);
				repl_c = repl[re_match];
			else
				re_match = new_match(span, self.group_id, source, str.s);
				repl_c = repl(re_match);
			end;
			if repl_c == re_match or repl_flags.o and not repl_c then
				local repl_n = span[0][2] - span[0][1];
				repl_r = table.move(str, span[0][1], span[0][2] - 1, 1, table.create(repl_n));
				repl_r.n = repl_n;
			elseif type(repl_c) == "string" then
				repl_r = to_str_arr(repl_c);
			elseif type(repl_c) == "number" then
				repl_r = to_str_arr(repl_c .. '');
			elseif repl_flags.o then
				error(string.format("invalid replacement value (a %s)", type(repl_c)), 3);
			else
				repl_r = { n = 0 };
			end;
		end;
		local match_len = span[0][2] - span[0][1];
		local repl_len = math.min(repl_r.n, match_len);
		for i1 = 0, repl_len - 1 do
			str[span[0][1] + i1] = repl_r[i1 + 1];
		end;
		local i1 = span[0][1] + repl_len;
		i0 = span[0][2];
		if match_len > repl_r.n then
			for i2 = 1, match_len - repl_r.n do
				table.remove(str, i1);
				incr -= 1;
				i0 -= 1;
			end;
		elseif repl_r.n > match_len then
			for i2 = 1, repl_r.n - match_len do
				table.insert(str, i1 + i2 - 1, repl_r[repl_len + i2]);
				incr += 1;
				i0 += 1;
			end;
		end;
		if match_len <= 0 then
			i0 += 1;
		end;
		count += 1;
		if n < count + 1 then
			break;
		end;
	end;
	return from_str_arr(str), count;
end);

re_m.split = check_re('RegEx', 'split', function(self, str, n)
	if tonumber(n) then
		n = tonumber(n);
		if n <= -1 or n ~= n then
			n = math.huge;
		end;
	elseif n ~= nil then
		error(string.format("invalid argument #3 to 'split' (number expected, got %s)", typeof(n)), 3);
	else
		n = math.huge;
	end;
	str = to_str_arr(str);
	local i, count = 1, 0;
	local ret = { };
	local prev_empty = 0;
	while i <= str.n + 1 do
		count += 1;
		local span = n >= count and re_rawfind(self.token, str, i, self.flags, self.verb_flags, false);
		if not span then
			break;
		end;
		table.insert(ret, utf8_sub(str.s, i - prev_empty, span[0][1]));
		prev_empty = span[0][1] >= span[0][2] and 1 or 0;
		i = span[0][2] + prev_empty;
	end;
	table.insert(ret, string.sub(str.s, utf8.offset(str.s, i - prev_empty)));
	return ret;
end);

--
local function re_index(self, index)
	return re_m[index] or proxy[self].flags[index];
end;

local function re_tostr(self)
	return proxy[self].pattern_repr .. proxy[self].flag_repr;
end;
--

local other_valid_group_char = {
	-- non-capturing group
	[0x3A] = true,
	-- lookarounds
	[0x21] = true, [0x3D] = true,
	-- atomic
	[0x3E] = true,
	-- branch reset
	[0x7C] = true,
};

local function tokenize_ptn(codes, flags)
	if flags.unicode and not options.unicodeData then
		return "options.unicodeData cannot be turned off while having unicode flag";
	end;
	local i, len = 1, codes.n;
	local group_n = 0;
	local outln, group_id, verb_flags = { }, { }, {
		newline = 1, newline_seq = 1, not_empty = 0,
	};
	while i <= len do
		local c = codes[i];
		if c == 0x28 then
			-- Match
			local ret;
			if codes[i + 1] == 0x2A then
				i += 2;
				local start_i = i;
				while codes[i]
					and (codes[i] >= 0x30 and codes[i] <= 0x39
					or codes[i] >= 0x41 and codes[i] <= 0x5A
					or codes[i] >= 0x61 and codes[i] <= 0x7A
					or codes[i] == 0x5F or codes[i] == 0x3A) do
					i += 1;
				end;
				if codes[i] ~= 0x29 and codes[i - 1] ~= 0x3A then
					-- fallback as normal and ( can't be repeated
					return "quantifier doesn't follow a repeatable pattern";
				end;
				local selected_verb = utf8_sub(codes.s, start_i, i);
				if selected_verb == "positive_lookahead:" or selected_verb == "negative_lookhead:"
					or selected_verb == "positive_lookbehind:" or selected_verb == "negative_lookbehind:"
					or selected_verb:find("^[pn]l[ab]:$") then
					ret = { 0x28, nil, nil, selected_verb:find('^n') and 0x21 or 0x3D, selected_verb:find('b', 3, true) and 1 };
				elseif selected_verb == "atomic:" then
					ret = { 0x28, nil, nil, 0x3E, nil };
				elseif selected_verb == "ACCEPT" or selected_verb == "FAIL" or selected_verb == 'F' or selected_verb == "PRUNE" or selected_verb == "SKIP" then
					ret = selected_verb == 'F' and "FAIL" or selected_verb;
				else
					if line_verbs[selected_verb] then
						verb_flags.newline = selected_verb;
					elseif selected_verb == "BSR_ANYCRLF" or selected_verb == "BSR_UNICODE" then
						verb_flags.newline_seq = selected_verb == "BSR_UNICODE" and 1 or 0;
					elseif selected_verb == "NOTEMPTY" or selected_verb == "NOTEMPTY_ATSTART" then
						verb_flags.not_empty = selected_verb == "NOTEMPTY" and 1 or 2;
					else
						return "unknown or malformed verb";
					end;
					if outln[1] then
						return "this verb must be placed at the beginning of the regex";
					end;
				end;
			elseif codes[i + 1] == 0x3F then
				-- ? syntax
				i += 2;
				if codes[i] == 0x23 then
					-- comments
					i = table.find(codes, 0x29, i);
					if not i then
						return "unterminated parenthetical";
					end;
					i += 1;
					continue;
				elseif not codes[i] then
					return "unterminated parenthetical";
				end;
				ret = { 0x28, nil, nil, codes[i], nil };
				if codes[i] == 0x30 and codes[i + 1] == 0x29 then
					-- recursive match entire pattern
					ret[1], ret[2], ret[3], ret[5] = "recurmatch", 0, 0, nil;
				elseif codes[i] > 0x30 and codes[i] <= 0x39 then
					-- recursive match
					local org_i = i;
					i += 1;
					while codes[i] >= 0x30 and codes[i] <= 0x30 do
						i += 1;
					end;
					if codes[i] ~= 0x29 then
						return "invalid group structure";
					end;
					ret[1], ret[2], ret[4] = "recurmatch", tonumber(utf8_sub(codes.s, org_i, i)), nil;
				elseif codes[i] == 0x3C and codes[i + 1] == 0x21 or codes[i + 1] == 0x3D then
					-- lookbehinds
					i += 1;
					ret[4], ret[5] = codes[i], 1;
				elseif codes[i] == 0x7C then
					-- branch reset
					ret[5] = group_n;
				elseif codes[i] == 0x50 or codes[i] == 0x3C or codes[i] == 0x27 then
					if codes[i] == 0x50 then
						i += 1;
					end;
					if codes[i] == 0x3D then
						-- backref
						local start_i = i + 1;
						while codes[i] and
							(codes[i] >= 0x30 and codes[i] <= 0x39
								or codes[i] >= 0x41 and codes[i] <= 0x5A
								or codes[i] >= 0x61 and codes[i] <= 0x7A
								or codes[i] == 0x5F) do
							i += 1;
						end;
						if not codes[i] then
							return "unterminated parenthetical";
						elseif codes[i] ~= 0x29 or i == start_i then
							return "invalid group structure";
						end;
						ret = { "backref", utf8_sub(codes.s, start_i, i) };
					elseif codes[i] == 0x3C or codes[i - 1] ~= 0x50 and codes[i] == 0x27 then
						-- named capture
						local delimiter = codes[i] == 0x27 and 0x27 or 0x3E;
						local start_i = i + 1;
						i += 1;
						if codes[i] == 0x29 then
							return "missing character in subpattern";
						elseif codes[i] >= 0x30 and codes[i] <= 0x39 then
							return "subpattern name must not begin with a digit";
						elseif not (codes[i] >= 0x41 and codes[i] <= 0x5A or codes[i] >= 0x61 and codes[i] <= 0x7A or codes[i] == 0x5F) then
							return "invalid character in subpattern";
						end;
						i += 1;
						while codes[i] and
							(codes[i] >= 0x30 and codes[i] <= 0x39
								or codes[i] >= 0x41 and codes[i] <= 0x5A
								or codes[i] >= 0x61 and codes[i] <= 0x7A
								or codes[i] == 0x5F) do
							i += 1;
						end;
						if not codes[i] then
							return "unterminated parenthetical";
						elseif codes[i] ~= delimiter then
							return "invalid character in subpattern";
						end;
						local name = utf8_sub(codes.s, start_i, i);
						group_n += 1;
						if (group_id[name] or group_n) ~= group_n then
							return "subpattern name already exists";
						end;
						for name1, group_n1 in pairs(group_id) do
							if name ~= name1 and group_n == group_n1 then
								return "different names for subpatterns of the same number aren't permitted";
							end;
						end;
						group_id[name] = group_n;
						ret[2], ret[4] = group_n, nil;
					else
						return "invalid group structure";
					end;
				elseif not other_valid_group_char[codes[i]] then
					return "invalid group structure";
				end;
			else
				group_n += 1;
				ret = { 0x28, group_n, nil, nil };
			end;
			if ret then
				table.insert(outln, ret);
			end;
		elseif c == 0x29 then
			-- Close parenthesis
			local i1 = #outln + 1;
			local lookbehind_c = -1;
			local current_lookbehind_c = 0;
			local max_c, group_c = 0, 0;
			repeat
				i1 -= 1;
				local v, is_table = outln[i1], type(outln[i1]) == "table";
				if is_table and v[1] == 0x28 then
					group_c += 1;
					if current_lookbehind_c and v.count then
						current_lookbehind_c += v.count;
					end;
					if not v[3] then
						if v[4] == 0x7C then
							group_n = v[5] + math.max(max_c, group_c);
						end;
						if current_lookbehind_c ~= lookbehind_c and lookbehind_c ~= -1 then
							lookbehind_c = nil;
						else
							lookbehind_c = current_lookbehind_c;
						end;
						break;
					end;
				elseif v == alternation then
					if current_lookbehind_c ~= lookbehind_c and lookbehind_c ~= -1 then
						lookbehind_c, current_lookbehind_c = nil, nil;
					else
						lookbehind_c, current_lookbehind_c = current_lookbehind_c, 0;
					end;
					max_c, group_c = math.max(max_c, group_c), 0;
				elseif current_lookbehind_c then
					if is_table and v[1] == "quantifier" then
						if v[2] == v[3] then
							current_lookbehind_c += v[2];
						else
							current_lookbehind_c = nil;
						end;
					else
						current_lookbehind_c += 1;
					end;
				end;
			until i1 < 1;
			if i1 < 1 then
				return "unmatched ) in regular expression";
			end;
			local v = outln[i1];
			local outln_len_p_1 = #outln + 1;
			local ret = { 0x29, v[2], i1, v[4], v[5], count = lookbehind_c };
			if (v[4] == 0x21 or v[4] == 0x3D) and v[5] and not lookbehind_c then
				return "lookbehind assertion is not fixed width";
			end;
			v[3] = outln_len_p_1;
			table.insert(outln, ret);
		elseif c == 0x2E then
			table.insert(outln, dot);
		elseif c == 0x5B then
			-- Character set
			local negate, char_class = false, nil;
			i += 1;
			local start_i = i;
			if codes[i] == 0x5E then
				negate = true;
				i += 1;
			elseif codes[i] == 0x2E or codes[i] == 0x3A or codes[i] == 0x3D then
				-- POSIX character classes
				char_class = codes[i];
			end;
			local ret;
			if codes[i] == 0x5B or codes[i] == 0x5C then
				ret = { };
			else
				ret = { codes[i] };
				i += 1;
			end;
			while codes[i] ~= 0x5D do
				if not codes[i] then
					return "unterminated character class";
				elseif codes[i] == 0x2D and ret[1] and type(ret[1]) == "number" then
					if codes[i + 1] == 0x5D then
						table.insert(ret, 1, 0x2D);
					else
						i += 1;
						local ret_c = codes[i];
						if ret_c == 0x5B then
							if codes[i + 1] == 0x2E or codes[i + 1] == 0x3A or codes[i + 1] == 0x3D then
								-- Check for POSIX character class, name does not matter
								local i1 = i + 2;
								repeat
									i1 = table.find(codes, 0x5D, i1);
								until not i1 or codes[i1 - 1] ~= 0x5C;
								if not i1 then
									return "unterminated character class";
								elseif codes[i1 - 1] == codes[i + 1] and i1 - 1 ~= i + 1 then
									return "invalid range in character class";
								end;
							end;
							if ret[1] > 0x5B then
								return "invalid range in character class";
							end;
						elseif ret_c == 0x5C then
							i += 1;
							if codes[i] == 0x78 then
								local radix0, radix1;
								i += 1;
								if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x39 or codes[i] >= 0x41 and codes[i] <= 0x46 or codes[i] >= 0x61 and codes[i] <= 0x66 then
									radix0 = codes[i] - ((codes[i] >= 0x41 and codes[i] <= 0x5A) and 0x37 or (codes[i] >= 0x61 and codes[i] <= 0x7A) and 0x57 or 0x30);
									i += 1;
									if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x39 or codes[i] >= 0x41 and codes[i] <= 0x46 or codes[i] >= 0x61 and codes[i] <= 0x66 then
										radix1 = codes[i] - ((codes[i] >= 0x41 and codes[i] <= 0x5A) and 0x37 or (codes[i] >= 0x61 and codes[i] <= 0x7A) and 0x57 or 0x30);
									else
										i -= 1;
									end;
								else
									i -= 1;
								end;
								ret_c = radix0 and (radix1 and 16 * radix0 + radix1 or radix0) or 0;
							elseif codes[i] >= 0x30 and codes[i] <= 0x37 then
								local radix0, radix1, radix2 = codes[i] - 0x30, nil, nil;
								i += 1;
								if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 then
									radix1 = codes[i] - 0x30;
									i += 1;
									if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 then
										radix2 = codes[i] - 0x30;
									else
										i -= 1;
									end;
								else
									i -= 1;
								end;
								ret_c = radix1 and (radix2 and 64 * radix0 + 8 * radix1 + radix2 or 8 * radix0 + radix1) or radix0;
							else
								ret_c = escape_chars[codes[i]] or codes[i];
								if type(ret_c) ~= "number" then
									return "invalid range in character class";
								end;
							end;
						elseif ret[1] > ret_c then
							return "invalid range in character class";
						end;
						ret[1] = { "range", ret[1], ret_c };
					end;
				elseif codes[i] == 0x5B then
					if codes[i + 1] == 0x2E or codes[i + 1] == 0x3A or codes[i + 1] == 0x3D then
						local i1 = i + 2;
						repeat
							i1 = table.find(codes, 0x5D, i1);
						until not i1 or codes[i1 - 1] ~= 0x5C;
						if not i1 then
							return "unterminated character class";
						elseif codes[i1 - 1] ~= codes[i + 1] or i1 - 1 == i + 1 then
							table.insert(ret, 1, 0x5B);
						elseif codes[i1 - 1] == 0x2E or codes[i1 - 1] == 0x3D then
							return "POSIX collating elements aren't supported";
						elseif codes[i1 - 1] == 0x3A then
							-- I have no plans to support escape codes (\) in character class names
							local negate = codes[i + 3] == 0x5E;
							local class_name = utf8_sub(codes.s, i + (negate and 3 or 2), i1 - 1);
							--  If not valid then throw an error
							if not posix_class_names[class_name] then
								return "unknown POSIX class name";
							end;
							table.insert(ret, 1, { "class", class_name, negate });
							i = i1;
						end;
					else
						table.insert(ret, 1, 0x5B);
					end;
				elseif codes[i] == 0x5C then
					i += 1;
					if codes[i] == 0x78 then
						local radix0, radix1;
						i += 1;
						if codes[i] == 0x7B then
							i += 1;
							local org_i = i;
							while codes[i] and
								(codes[i] >= 0x30 and codes[i] <= 0x39
									or codes[i] >= 0x41 and codes[i] <= 0x46
									or codes[i] >= 0x61 and codes[i] <= 0x66) do
								i += 1;
							end;
							if codes[i] ~= 0x7D or i == org_i then
								return "malformed hexadecimal character";
							elseif i - org_i > 4 then
								return "character offset too large";
							end;
							table.insert(ret, 1, tonumber(utf8_sub(codes.s, org_i, i), 16));
						else
							if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x39 or codes[i] >= 0x41 and codes[i] <= 0x46 or codes[i] >= 0x61 and codes[i] <= 0x66 then
								radix0 = codes[i] - ((codes[i] >= 0x41 and codes[i] <= 0x5A) and 0x37 or (codes[i] >= 0x61 and codes[i] <= 0x7A) and 0x57 or 0x30);
								i += 1;
								if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x39 or codes[i] >= 0x41 and codes[i] <= 0x46 or codes[i] >= 0x61 and codes[i] <= 0x66 then
									radix1 = codes[i] - ((codes[i] >= 0x41 and codes[i] <= 0x5A) and 0x37 or (codes[i] >= 0x61 and codes[i] <= 0x7A) and 0x57 or 0x30);
								else
									i -= 1;
								end;
							else
								i -= 1;
							end;
							table.insert(ret, 1, radix0 and (radix1 and 16 * radix0 + radix1 or radix0) or 0);
						end;
					elseif codes[i] >= 0x30 and codes[i] <= 0x37 then
						local radix0, radix1, radix2 = codes[i] - 0x30, nil, nil;
						i += 1;
						if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 then
							radix1 = codes[i] - 0x30;
							i += 1;
							if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 then
								radix2 = codes[i] - 0x30;
							else
								i -= 1;
							end;
						else
							i -= 1;
						end;
						table.insert(ret, 1, radix1 and (radix2 and 64 * radix0 + 8 * radix1 + radix2 or 8 * radix0 + radix1) or radix0);
					elseif codes[i] == 0x45 then
						-- intentionally left blank, \E that's not preceded \Q is ignored
					elseif codes[i] == 0x51 then
						local start_i = i + 1;
						repeat
							i = table.find(codes, 0x5C, i + 1);
						until not i or codes[i + 1] == 0x45;
						table.move(codes, start_i, i and i - 1 or #codes, #outln + 1, outln);
						if not i then
							break;
						end;
						i += 1;
					elseif codes[i] == 0x4E then
						if codes[i + 1] == 0x7B and codes[i + 2] == 0x55 and codes[i + 3] == 0x2B and flags.unicode then
							i += 4;
							local start_i = i;
							while codes[i] and
								(codes[i] >= 0x30 and codes[i] <= 0x39
									or codes[i] >= 0x41 and codes[i] <= 0x46
									or codes[i] >= 0x61 and codes[i] <= 0x66) do
								i += 1;
							end;
							if codes[i] ~= 0x7D or i == start_i then
								return "malformed Unicode code point";
							end;
							local code_point = tonumber(utf8_sub(codes.s, start_i, i));
							table.insert(ret, 1, code_point);
						else
							return "invalid escape sequence";
						end;
					elseif codes[i] == 0x50 or codes[i] == 0x70 then
						if not options.unicodeData then
							return "options.unicodeData cannot be turned off when using \\p";
						end;
						i += 1;
						if codes[i] ~= 0x7B then
							local c_name = utf8.char(codes[i] or 0);
							if not valid_categories[c_name] then
								return "unknown or malformed script name";
							end;
							table.insert(ret, 1, { "category", false, c_name });
						else
							local negate = codes[i] == 0x50;
							i += 1;
							if codes[i] == 0x5E then
								i += 1;
								negate = not negate;
							end;
							local start_i = i;
							while codes[i] and
								(codes[i] >= 0x30 and codes[i] <= 0x39
									or codes[i] >= 0x41 and codes[i] <= 0x5A
									or codes[i] >= 0x61 and codes[i] <= 0x7A
									or codes[i] == 0x5F) do
								i += 1;
							end;
							if codes[i] ~= 0x7D then
								return "unknown or malformed script name";
							end;
							local c_name = utf8_sub(codes.s, start_i, i);
							local script_set = chr_scripts[c_name];
							if script_set then
								table.insert(ret, 1, { "charset", negate, script_set });
							elseif not valid_categories[c_name] then
								return "unknown or malformed script name";
							else
								table.insert(ret, 1, { "category", negate, c_name });
							end;
						end;
					elseif codes[i] == 0x6F then
						i += 1;
						if codes[i] ~= 0x7B then
							return "malformed octal code";
						end;
						i += 1;
						local org_i = i;
						while codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 do
							i += 1;
						end;
						if codes[i] ~= 0x7D or i == org_i then
							return "malformed octal code";
						end;
						local ret_chr = tonumber(utf8_sub(codes.s, org_i, i), 8);
						if ret_chr > 0xFFFF then
							return "character offset too large";
						end;
						table.insert(ret, 1, ret_chr);
					else
						local esc_char = escape_chars[codes[i]];
						table.insert(ret, 1, type(esc_char) == "string" and { "class", esc_char, false } or esc_char or codes[i]);
					end;
				elseif flags.ignoreCase and codes[i] >= 0x61 and codes[i] <= 0x7A then
					table.insert(ret, 1, codes[i] - 0x20);
				else
					table.insert(ret, 1, codes[i]);
				end;
				i += 1;
			end;
			if codes[i - 1] == char_class and i - 1 ~= start_i then
				return char_class == 0x3A and "POSIX named classes are only support within a character set" or "POSIX collating elements aren't supported";
			end;
			if not ret[2] and not negate then
				table.insert(outln, ret[1]);
			else
				table.insert(outln, { "charset", negate, ret });
			end;
		elseif c == 0x5C then
			-- Escape char
			i += 1;
			local escape_c = codes[i];
			if not escape_c then
				return "pattern may not end with a trailing backslash";
			elseif escape_c >= 0x30 and escape_c <= 0x39 then
				local org_i = i;
				while codes[i + 1] and codes[i + 1] >= 0x30 and codes[i + 1] <= 0x39 do
					i += 1;
				end;
				local escape_d = tonumber(utf8_sub(codes.s, org_i, i + 1));
				if escape_d > group_n and i ~= org_i then
					i = org_i;
					local radix0, radix1, radix2;
					if codes[i] <= 0x37 then
						radix0 = codes[i] - 0x30;
						i += 1;
						if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 then
							radix1 = codes[i] - 0x30;
							i += 1;
							if codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 then
								radix2 = codes[i] - 0x30;
							else
								i -= 1;
							end;
						else
							i -= 1;
						end;
					end;
					table.insert(outln, radix0 and (radix1 and (radix2 and 64 * radix0 + 8 * radix1 + radix2 or 8 * radix0 + radix1) or radix0) or codes[org_i]);
				else
					table.insert(outln, { "backref", escape_d });
				end;
			elseif escape_c == 0x45 then
				-- intentionally left blank, \E that's not preceded \Q is ignored
			elseif escape_c == 0x51 then
				local start_i = i + 1;
				repeat
					i = table.find(codes, 0x5C, i + 1);
				until not i or codes[i + 1] == 0x45;
				table.move(codes, start_i, i and i - 1 or #codes, #outln + 1, outln);
				if not i then
					break;
				end;
				i += 1;
			elseif escape_c == 0x4E then
				if codes[i + 1] == 0x7B and codes[i + 2] == 0x55 and codes[i + 3] == 0x2B and flags.unicode then
					i += 4;
					local start_i = i;
					while codes[i] and
						(codes[i] >= 0x30 and codes[i] <= 0x39
							or codes[i] >= 0x41 and codes[i] <= 0x46
							or codes[i] >= 0x61 and codes[i] <= 0x66) do
						i += 1;
					end;
					if codes[i] ~= 0x7D or i == start_i then
						return "malformed Unicode code point";
					end;
					local code_point = tonumber(utf8_sub(codes.s, start_i, i));
					table.insert(outln, code_point);
				else
					table.insert(outln, escape_chars[0x4E]);
				end;
			elseif escape_c == 0x50 or escape_c == 0x70 then
				if not options.unicodeData then
					return "options.unicodeData cannot be turned off when using \\p";
				end;
				i += 1;
				if codes[i] ~= 0x7B then
					local c_name = utf8.char(codes[i] or 0);
					if not valid_categories[c_name] then
						return "unknown or malformed script name";
					end;
					table.insert(outln, { "category", false, c_name });
				else
					local negate = escape_c == 0x50;
					i += 1;
					if codes[i] == 0x5E then
						i += 1;
						negate = not negate;
					end;
					local start_i = i;
					while codes[i] and
						(codes[i] >= 0x30 and codes[i] <= 0x39
							or codes[i] >= 0x41 and codes[i] <= 0x5A
							or codes[i] >= 0x61 and codes[i] <= 0x7A
							or codes[i] == 0x5F) do
						i += 1;
					end;
					if codes[i] ~= 0x7D then
						return "unknown or malformed script name";
					end;
					local c_name = utf8_sub(codes.s, start_i, i);
					local script_set = chr_scripts[c_name];
					if script_set then
						table.insert(outln, { "charset", negate, script_set });
					elseif not valid_categories[c_name] then
						return "unknown or malformed script name";
					else
						table.insert(outln, { "category", negate, c_name });
					end;
				end;
			elseif escape_c == 0x67 and (codes[i + 1] == 0x7B or codes[i + 1] >= 0x30 and codes[i + 1] <= 0x39) then
				local is_grouped = false;
				i += 1;
				if codes[i] == 0x7B then
					i += 1;
					is_grouped = true;
				elseif codes[i] < 0x30 or codes[i] > 0x39 then
					return "malformed reference code";
				end;
				local org_i = i;
				while codes[i] and
					(codes[i] >= 0x30 and codes[i] <= 0x39
						or codes[i] >= 0x41 and codes[i] <= 0x46
						or codes[i] >= 0x61 and codes[i] <= 0x66) do
					i += 1;
				end;
				if is_grouped and codes[i] ~= 0x7D then
					return "malformed reference code";
				end;
				local ref_name = tonumber(utf8_sub(codes.s, org_i, i + (is_grouped and 0 or 1)));
				table.insert(outln, { "backref", ref_name });
				if not is_grouped then
					i -= 1;
				end;
			elseif escape_c == 0x6F then
				i += 1;
				if codes[i + 1] ~= 0x7B then
					return "malformed octal code";
				end
				i += 1;
				local org_i = i;
				while codes[i] and codes[i] >= 0x30 and codes[i] <= 0x37 do
					i += 1;
				end;
				if codes[i] ~= 0x7D or i == org_i then
					return "malformed octal code";
				end;
				local ret_chr = tonumber(utf8_sub(codes.s, org_i, i), 8);
				if ret_chr > 0xFFFF then
					return "character offset too large";
				end;
				table.insert(outln, ret_chr);
			elseif escape_c == 0x78 then
				local radix0, radix1;
				i += 1;
				if codes[i] == 0x7B then
					i += 1;
					local org_i = i;
					while codes[i] and
						(codes[i] >= 0x30 and codes[i] <= 0x39
							or codes[i] >= 0x41 and codes[i] <= 0x46
							or codes[i] >= 0x61 and codes[i] <= 0x66) do
						i += 1;
					end;
					if codes[i] ~= 0x7D or i == org_i then
						return "malformed hexadecimal code";
					elseif i - org_i > 4 then
						return "character offset too large";
					end;
					table.insert(outln, tonumber(utf8_sub(codes.s, org_i, i), 16));
				else
					if codes[i] and (codes[i] >= 0x30 and codes[i] <= 0x39 or codes[i] >= 0x41 and codes[i] <= 0x46 or codes[i] >= 0x61 and codes[i] <= 0x66) then
						radix0 = codes[i] - ((codes[i] >= 0x41 and codes[i] <= 0x5A) and 0x37 or (codes[i] >= 0x61 and codes[i] <= 0x7A) and 0x57 or 0x30);
						i += 1;
						if codes[i] and (codes[i] >= 0x30 and codes[i] <= 0x39 or codes[i] >= 0x41 and codes[i] <= 0x46 or codes[i] >= 0x61 and codes[i] <= 0x66) then
							radix1 = codes[i] - ((codes[i] >= 0x41 and codes[i] <= 0x5A) and 0x37 or (codes[i] >= 0x61 and codes[i] <= 0x7A) and 0x57 or 0x30);
						else
							i -= 1;
						end;
					else
						i -= 1;
					end;
					table.insert(outln, radix0 and (radix1 and 16 * radix0 + radix1 or radix0) or 0);
				end;
			else
				local esc_char = b_escape_chars[escape_c] or escape_chars[escape_c];
				table.insert(outln, esc_char or escape_c);
			end;
		elseif c == 0x2A or c == 0x2B or c == 0x3F or c == 0x7B then
			-- Quantifier
			local start_q, end_q;
			if c == 0x7B then
				local org_i = i + 1;
				local start_i;
				while codes[i + 1] and (codes[i + 1] >= 0x30 and codes[i + 1] <= 0x39 or codes[i + 1] == 0x2C and not start_i and i + 1 ~= org_i) do
					i += 1;
					if codes[i] == 0x2C then
						start_i = i;
					end;
				end;
				if codes[i + 1] == 0x7D then
					i += 1;
					if not start_i then
						start_q = tonumber(utf8_sub(codes.s, org_i, i));
						end_q = start_q;
					else
						start_q, end_q = tonumber(utf8_sub(codes.s, org_i, start_i)), start_i + 1 == i and math.huge or tonumber(utf8_sub(codes.s, start_i + 1, i));
						if end_q < start_q then
							return "numbers out of order in {} quantifier";
						end;
					end;
				else
					table.move(codes, org_i - 1, i, #outln + 1, outln);
				end;
			else
				start_q, end_q = c == 0x2B and 1 or 0, c == 0x3F and 1 or math.huge;
			end;
			if start_q then
				local quantifier_type = flags.ungreedy and "lazy" or "greedy";
				if codes[i + 1] == 0x2B or codes[i + 1] == 0x3F then
					i += 1;
					quantifier_type = codes[i] == 0x2B and "possessive" or flags.ungreedy and "greedy" or "lazy";
				end;
				local outln_len = #outln;
				local last_outln_value = outln[outln_len];
				if not last_outln_value or type(last_outln_value) == "table" and (last_outln_value[1] == "quantifier" or last_outln_value[1] == 0x28 or b_escape_chars[last_outln_value[1]])
					or last_outln_value == alternation or type(last_outln_value) == "string" then
					return "quantifier doesn't follow a repeatable pattern";
				end;
				if end_q == 0 then
					table.remove(outln);
				elseif start_q ~= 1 or end_q ~= 1 then
					if type(last_outln_value) == "table" and last_outln_value[1] == 0x29 then
						outln_len = last_outln_value[3];
					end;
					outln[outln_len] = { "quantifier", start_q, end_q, quantifier_type, outln[outln_len] };
				end;
			end;
		elseif c == 0x7C then
			-- Alternation
			table.insert(outln, alternation);
			local i1 = #outln;
			repeat
				i1 -= 1;
				local v1, is_table = outln[i1], type(outln[i1]) == "table";
				if is_table and v1[1] == 0x29 then
					i1 = outln[i1][3];
				elseif is_table and v1[1] == 0x28 then
					if v1[4] == 0x7C then
						group_n = v1[5];
					end;
					break;
				end;
			until not v1;
		elseif c == 0x24 or c == 0x5E then
			table.insert(outln, c == 0x5E and beginning_str or end_str);
		elseif flags.ignoreCase and c >= 0x61 and c <= 0x7A then
			table.insert(outln, c - 0x20);
		elseif flags.extended and (c >= 0x09 and c <= 0x0D or c == 0x20 or c == 0x23) then
			if c == 0x23 then
				repeat
					i += 1;
				until not codes[i] or codes[i] == 0x0A or codes[i] == 0x0D;
			end;
		else
			table.insert(outln, c);
		end;
		i += 1;
	end;
	local max_group_n = 0;
	for i, v in ipairs(outln) do
		if type(v) == "table" and (v[1] == 0x28 or v[1] == "quantifier" and type(v[5]) == "table" and v[5][1] == 0x28) then
			if v[1] == "quantifier" then
				v = v[5];
			end;
			if not v[3] then
				return "unterminated parenthetical";
			elseif v[2] then
				max_group_n = math.max(max_group_n, v[2]);
			end;
		elseif type(v) == "table" and (v[1] == "backref" or v[1] == "recurmatch") then
			if not group_id[v[2]] and (type(v[2]) ~= "number" or v[2] > group_n) then
				return "reference to a non-existent or invalid subpattern";
			elseif v[1] == "recurmatch" and v[2] ~= 0 then
				for i1, v1 in ipairs(outln) do
					if type(v1) == "table" and v1[1] == 0x28 and v1[2] == v[2] then
						v[3] = i1;
						break;
					end;
				end;
			elseif type(v[2]) == "string" then
				v[2] = group_id[v[2]];
			end;
		end;
	end;
	outln.group_n = max_group_n;
	return outln, group_id, verb_flags;
end;

if not tonumber(options.cacheSize) then
	error(string.format("expected number for options.cacheSize, got %s", typeof(options.cacheSize)), 2);
end;
local cacheSize = math.floor(options.cacheSize or 0) ~= 0 and tonumber(options.cacheSize);
local cache_pattern, cache_pattern_names;
if not cacheSize then
elseif cacheSize < 0 or cacheSize ~= cacheSize then
	error("cache size cannot be a negative number or a NaN", 2);
elseif cacheSize == math.huge then
	cache_pattern, cache_pattern_names = { nil }, { nil };
elseif cacheSize >= 2 ^ 32 then
	error("cache size too large", 2);
else
	cache_pattern, cache_pattern_names = table.create(options.cacheSize), table.create(options.cacheSize);
end;
if cacheSize then
	function re.pruge()
		table.clear(cache_pattern_names);
		table.clear(cache_pattern);
	end;
end;

local function new_re(str_arr, flags, flag_repr, pattern_repr)
	local tokenized_ptn, group_id, verb_flags;
	local cache_format = cacheSize and string.format("%s|%s", str_arr.s, flag_repr);
	local cached_token = cacheSize and cache_pattern[table.find(cache_pattern_names, cache_format)];
	if cached_token then
		tokenized_ptn, group_id, verb_flags = table.unpack(cached_token, 1, 3);
	else
		tokenized_ptn, group_id, verb_flags = tokenize_ptn(str_arr, flags);
		if type(tokenized_ptn) == "string" then
			error(tokenized_ptn, 2);
		end;
		if cacheSize and tokenized_ptn[1] then
			table.insert(cache_pattern_names, 1, cache_format);
			table.insert(cache_pattern, 1, { tokenized_ptn, group_id, verb_flags });
			if cacheSize ~= math.huge then
				table.remove(cache_pattern_names, cacheSize + 1);
				table.remove(cache_pattern, cacheSize + 1);
			end;
		end;
	end;

	local object = newproxy(true);
	proxy[object] = { name = "RegEx", flags = flags, flag_repr = flag_repr, pattern_repr = pattern_repr, token = tokenized_ptn, group_id = group_id, verb_flags = verb_flags };
	local object_mt = getmetatable(object);
	object_mt.__index = setmetatable(flags, re_m);
	object_mt.__tostring = re_tostr;
	object_mt.__metatable = lockmsg;

	return object;
end;

local function escape_fslash(pre)
	return (#pre % 2 == 0 and '\\' or '') .. pre .. '.';
end;

local function sort_flag_chr(a, b)
	return a:lower() < b:lower();
end;

function re.new(...)
	if select('#', ...) == 0 then
		error("missing argument #1 (string expected)", 2);
	end;
	local ptn, flags_str = ...;
	if type(ptn) == "number" then
		ptn ..= '';
	elseif type(ptn) ~= "string" then
		error(string.format("invalid argument #1 (string expected, got %s)", typeof(ptn)), 2);
	end;
	if type(flags_str) ~= "string" and type(flags_str) ~= "number" and flags_str ~= nil then
		error(string.format("invalid argument #2 (string expected, got %s)", typeof(flags_str)), 2);
	end;

	local flags = {
		anchored = false, caseless = false, multiline = false, dotall = false, unicode = false, ungreedy = false, extended = false,
	};
	local flag_repr = { };
	for f in string.gmatch(flags_str or '', utf8.charpattern) do
		if flags[flag_map[f]] ~= false then
			error("invalid regular expression flag " .. f, 3);
		end;
		flags[flag_map[f]] = true;
		table.insert(flag_repr, f);
	end;
	table.sort(flag_repr, sort_flag_chr);
	flag_repr = table.concat(flag_repr);
	return new_re(to_str_arr(ptn), flags, flag_repr, string.format("/%s/", ptn:gsub("(\\*)/", escape_fslash)));
end;

function re.fromstring(...)
	if select('#', ...) == 0 then
		error("missing argument #1 (string expected)", 2);
	end;
	local ptn = ...;
	if type(ptn) == "number" then
		ptn ..= '';
	elseif type(ptn) ~= "string" then
		error(string.format("invalid argument #1 (string expected, got %s)", typeof(ptn), 2));
	end;
	local str_arr = to_str_arr(ptn);
	local delimiter = str_arr[1];
	if not delimiter then
		error("empty regex", 2);
	elseif delimiter == 0x5C or (delimiter >= 0x30 and delimiter <= 0x39) or (delimiter >= 0x41 and delimiter <= 0x5A) or (delimiter >= 0x61 and delimiter <= 0x7A) then
		error("delimiter must not be alphanumeric or a backslash", 2);
	end;

	local i0 = 1;
	repeat
		i0 = table.find(str_arr, delimiter, i0 + 1);
		if not i0 then
			error(string.format("no ending delimiter ('%s') found", utf8.char(delimiter)), 2);
		end;
		local escape_count = 1;
		while str_arr[i0 - escape_count] == 0x5C do
			escape_count += 1;
		end;
	until escape_count % 2 == 1;

	local flags = {
		anchored = false, caseless = false, multiline = false, dotall = false, unicode = false, ungreedy = false, extended = false,
	};
	local flag_repr = { };
	while str_arr.n > i0 do
		local f = utf8.char(table.remove(str_arr));
		str_arr.n -= 1;
		if flags[flag_map[f]] ~= false then
			error("invalid regular expression flag " .. f, 3);
		end;
		flags[flag_map[f]] = true;
		table.insert(flag_repr, f);
	end;
	table.sort(flag_repr, sort_flag_chr);
	flag_repr = table.concat(flag_repr);
	table.remove(str_arr, 1);
	table.remove(str_arr);
	str_arr.n -= 2;
	str_arr.s = string.sub(str_arr.s, 2, 1 + str_arr.n);
	return new_re(str_arr, flags, flag_repr, string.sub(ptn, 1, 2 + str_arr.n));
end;

local re_escape_line_chrs = {
	['\0'] = '\\x00', ['\n'] = '\\n', ['\t'] = '\\t', ['\r'] = '\\r', ['\f'] = '\\f',
};

function re.escape(...)
	if select('#', ...) == 0 then
		error("missing argument #1 (string expected)", 2);
	end;
	local str, extended, delimiter = ...;
	if type(str) == "number" then
		str ..= '';
	elseif type(str) ~= "string" then
		error(string.format("invalid argument #1 to 'escape' (string expected, got %s)", typeof(str)), 2);
	end;
	if delimiter == nil then
		delimiter = '';
	elseif type(delimiter) == "number" then
		delimiter ..= '';
	elseif type(delimiter) ~= "string" then
		error(string.format("invalid argument #3 to 'escape' (string expected, got %s)", typeof(delimiter)), 2);
	end;
	if utf8.len(delimiter) > 1 or delimiter:match("^[%a\\]$") then
		error("delimiter have not be alphanumeric", 2);
	end;
	return (string.gsub(str, "[\0\f\n\r\t]", re_escape_line_chrs):gsub(string.format("[\\%s#()%%%%*+.?[%%]^{|%s]", extended and '%s' or '', (delimiter:find'^[%%%]]$' and '%' or '') .. delimiter), "\\%1"));
end;

function re.type(...)
	if select('#', ...) == 0 then
		error("missing argument #1", 2);
	end;
	return proxy[...] and proxy[...].name;
end;

for k, f in pairs(re_m) do
	re[k] = f;
end;

re_m = { __index = re_m };

lockmsg = re.fromstring([[/The\s*metatable\s*is\s*(?:locked|inaccessible)(?#Nice try :])/i]]);
getmetatable(lockmsg).__metatable = lockmsg;

local function readonly_table()
	error("Attempt to modify a readonly table", 2);
end;

match_m = {
	__index = match_m,
	__metatable = lockmsg,
	__newindex = readonly_table,
};

re.Match = setmetatable({ }, match_m);

return setmetatable({ }, {
	__index = re,
	__metatable = lockmsg,
	__newindex = readonly_table,
});
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="428">
              <Properties>
                <string name="Name">Regexp.global</string>
                <string name="Source"><![CDATA[local RegEx = require(script.Parent.RegEx)
type Array<T> = { [number]: T }

type RegExpExecArray = Array<string> & { index: number?, input: string?, n: number }

export type RegExp = {
    exec: (self: RegExp, input: string) -> RegExpExecArray | nil,
    test: (self: RegExp, input: string) -> boolean,
}

local RegExp = {}
local RegExpMetatable = {
    __index = RegExp,
    __tostring = function(self)
        return tostring(self._innerRegEx)
    end,
}

function RegExp:exec(str: string): RegExpExecArray | nil
    local match = self._innerRegEx:match(str)
    if not match then
        return nil
    end

    local index = match:span()
    local groups = match:grouparr()

    local matches = { groups[0] }
    for i = 1, groups.n do
        matches[i + 1] = groups[i]
    end
    matches.n = groups.n + 1
    matches.index = index
    matches.input = str
    return matches
end

function RegExp:test(str: string): boolean
    return self:exec(str) ~= nil
end

local function new(_self, pattern: RegExp | string, flags: string?)
    flags = flags or ""
    local innerRegEx = RegEx.new(pattern, flags)
    local object = {
        source = pattern,
        ignoreCase = (flags :: string):find("i") ~= nil,
        global = (flags :: string):find("g") ~= nil,
        multiline = (flags :: string):find("m") ~= nil,
        _innerRegEx = innerRegEx,
    }

    return setmetatable(object, RegExpMetatable)
end

-- FIXME: Capture this as a local variable before returning, else a luau bug
-- prevents __call from being understood: https://jira.rbx.com/browse/CLI-40294
local interface = setmetatable(RegExp, {
    __call = new,
})

return interface
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="429">
            <Properties>
              <string name="Name">Math</string>
              <string name="Source"><![CDATA[--!strict
return {
	clz32 = require(script.clz32),
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="430">
              <Properties>
                <string name="Name">clz32</string>
                <string name="Source"><![CDATA[return bit32.countlz
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="431">
            <Properties>
              <string name="Name">Number</string>
              <string name="Source"><![CDATA[--!strict
return {
	isFinite = require(script.isFinite),
	isInteger = require(script.isInteger),
	isNaN = require(script.isNaN),
	isSafeInteger = require(script.isSafeInteger),
	MAX_SAFE_INTEGER = require(script.MAX_SAFE_INTEGER),
	MIN_SAFE_INTEGER = require(script.MIN_SAFE_INTEGER),
	NaN = 0 / 0,
	toExponential = require(script.toExponential),
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="432">
              <Properties>
                <string name="Name">MAX_SAFE_INTEGER</string>
                <string name="Source"><![CDATA[--!strict
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
return 9007199254740991
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="433">
              <Properties>
                <string name="Name">MIN_SAFE_INTEGER</string>
                <string name="Source"><![CDATA[--!strict
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER
return -9007199254740991
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="434">
              <Properties>
                <string name="Name">isFinite</string>
                <string name="Source"><![CDATA[--!strict
return function(value)
	return typeof(value) == "number" and value == value and value ~= math.huge and value ~= -math.huge
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="435">
              <Properties>
                <string name="Name">isInteger</string>
                <string name="Source"><![CDATA[--!strict
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
return function(value)
	return type(value) == "number" and value ~= math.huge and value == math.floor(value)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="436">
              <Properties>
                <string name="Name">isNaN</string>
                <string name="Source"><![CDATA[--!strict
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
return function(value)
	return type(value) == "number" and value ~= value
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="437">
              <Properties>
                <string name="Name">isSafeInteger</string>
                <string name="Source"><![CDATA[--!strict
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger
local isInteger = require(script.Parent.isInteger)
local MAX_SAFE_INTEGER = require(script.Parent.MAX_SAFE_INTEGER)

return function(value)
	return isInteger(value) and math.abs(value) <= MAX_SAFE_INTEGER
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="438">
              <Properties>
                <string name="Name">toExponential</string>
                <string name="Source"><![CDATA[--!strict
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential
return function(value: string | number, fractionDigits: number?): string | nil
	local num = value
	if typeof(value) == "string" then
		-- ROBLOX FIXME: add parseInt to encapsulate this logic and use it here
		local NaN = 0 / 0
		num = tonumber(value) or NaN -- works because 0 is truthy in Lua
	end
	-- returns nil for invalid input instead of nan to be more lua-native
	if typeof(num) ~= "number" then
		return "nan"
	end

	if fractionDigits ~= nil then
		if typeof(fractionDigits) ~= "number" then
			error("TypeError: fractionDigits must be a number between 0 and 100")
		end
		if fractionDigits < 0 or fractionDigits > 100 then
			error("RangeError: fractionDigits must be between 0 and 100")
		end
	end

	local formatString
	if fractionDigits == nil then
		formatString = "%e"
	else
		formatString = "%." .. tostring(fractionDigits) .. "e"
	end

	local retval = string.format(formatString, num):gsub("%+0", "+"):gsub("%-0", "-"):gsub("0*e", "e")

	return retval
end
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="439">
            <Properties>
              <string name="Name">Path</string>
              <string name="Source"><![CDATA[local CurrentModule = script

local pathModule = require(CurrentModule.path)
local Path = pathModule.Path
export type Path = pathModule.Path

function makePathImpl()
	local path = Path.new()
	path:initialize("/", "/")
	return path
end

return {
	path = makePathImpl(),
	Path = Path,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="440">
              <Properties>
                <string name="Name">path</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/luvit/luvit/blob/master/deps/path/base.lua
--[[
Copyright 2014 The Luvit Authors. All Rights Reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
]]

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

local process = {
	env = {},
	cwd = function()
		return ""
	end,
}

export type Path = {
	initialize: (self: Path, root: string, sep: string) -> (),
	getRoot: (self: Path, filePath: string?) -> string,
	getSep: (self: Path) -> string,
	pathsEqual: (self: Path, a: string, b: string) -> boolean,
	_splitPath: (self: Path, filename: string) -> (string, string, string),
	_normalizeArray: (self: Path, parts: Array<string>, isrelative: boolean) -> (),
	_splitBySeparators: (self: Path, filepath: string) -> Array<string>,
	normalize: (self: Path, filepath: string) -> string,
	_filterparts: (self: Path, parts: Array<string>) -> Array<string>,
	_rawjoin: (self: Path, parts: Array<string>) -> string,
	_filteredjoin: (self: Path, ...string) -> (string, Array<string>),
	join: (self: Path, ...string) -> string,
	resolve: (self: Path, ...string) -> string | nil,
	_commonParts: (self: Path, ...string) -> Array<string>,
	relative: (self: Path, from: string, to: string) -> string,
	dirname: (self: Path, filepath: string) -> string,
	basename: (self: Path, filepath: string, expected_ext: string?) -> string,
	extname: (self: Path, filepath: string) -> string?,
	isDriveRelative: (self: Path, filePath: string?) -> boolean,
	isAbsolute: (self: Path, filepath: string) -> boolean,
	normalizeSeparators: (self: Path, filepath: string) -> string,
	sep: string,
	root: string,
}

type Path_statics = {
	new: () -> Path,
}

local Path = {} :: Path_statics & Path;
(Path :: any).__index = Path

function Path.new(): Path
	local self = setmetatable({}, Path)
	return (self :: any) :: Path
end

function Path:initialize(root: string, sep: string)
	self.root = root
	self.sep = sep
end

function Path:getRoot(_filePath)
	return self.root
end

function Path:getSep()
	return self.sep
end

function Path:pathsEqual(a: string, b: string)
	return a == b
end

-- Split a filename into [root, dir, basename]
function Path:_splitPath(filename: string)
	filename = self:normalizeSeparators(filename)
	local root = ""
	if self:isAbsolute(filename) or self:isDriveRelative(filename) then
		root = self:getRoot(filename)
		filename = filename:sub(root:len() + 1)
	end
	local trailing_slashes = filename:match("[" .. self.sep .. "]*$")
	if trailing_slashes then
		filename = filename:sub(1, -trailing_slashes:len() - 1)
	end
	local basename = filename:match("[^" .. self.sep .. "]+$") or ""
	local dir = basename and filename:sub(1, -basename:len() - 1) or filename
	return root, dir, basename
end

-- Modifies an array of path parts in place by interpreting "." and ".." segments
function Path:_normalizeArray(parts: Array<string>, isrelative: boolean)
	local skip = 0
	for i = #parts, 1, -1 do
		local part = parts[i]
		if part == "." then
			table.remove(parts, i)
		elseif part == ".." then
			table.remove(parts, i)
			skip = skip + 1
		elseif skip > 0 then
			table.remove(parts, i)
			skip = skip - 1
		end
	end
	if isrelative then
		while skip > 0 do
			table.insert(parts, 1, "..")
			skip = skip - 1
		end
	end
end

function Path:_splitBySeparators(filepath: string)
	local parts = {}
	for part in filepath:gmatch("[^" .. self.sep .. "]+") do
		parts[#parts + 1] = part
	end
	return parts
end

function Path:normalize(filepath: string)
	filepath = self:normalizeSeparators(filepath)
	local is_absolute = self:isAbsolute(filepath)
	local root = is_absolute and self:getRoot(filepath) or nil
	local trailing_slash = filepath:sub(#filepath) == self.sep

	if root then
		filepath = filepath:sub(root:len() + 1)
	end

	local parts = self:_splitBySeparators(filepath)
	self:_normalizeArray(parts, not is_absolute)
	filepath = table.concat(parts, self.sep)

	if #filepath == 0 then
		if is_absolute then
			return root :: string
		end
		return "."
	end
	if trailing_slash then
		filepath = filepath .. self.sep
	end
	if is_absolute then
		filepath = (root :: string) .. filepath
	end
	return filepath
end

function Path:_filterparts(parts: Array<string>)
	local filteredparts = {}
	-- filter out empty parts
	for i, part in ipairs(parts) do
		if part and part ~= "" then
			table.insert(filteredparts, part)
		end
	end
	for i, part in ipairs(filteredparts) do
		-- Strip leading slashes on all but first item
		if i > 1 then
			while part:sub(1, 1) == self.sep do
				part = part:sub(2)
			end
		end
		-- Strip trailing slashes on all but last item
		if i < #filteredparts then
			while part:sub(#part) == self.sep do
				part = part:sub(1, #part - 1)
			end
		end
		filteredparts[i] = part
	end
	return filteredparts
end

function Path:_rawjoin(parts: Array<string>)
	return table.concat(parts, self.sep)
end

function Path:_filteredjoin(...: string)
	local parts: Array<string> = { ... }
	for i, part in ipairs(parts) do
		parts[i] = self:normalizeSeparators(part)
	end
	local filteredparts = self:_filterparts(parts)
	local joined = self:_rawjoin(filteredparts)
	return joined, filteredparts
end

function Path:join(...: string)
	local joined = self:_filteredjoin(...)
	return self:normalize(joined)
end

-- Works backwards, joining the arguments until it resolves to an absolute path.
-- If an absolute path is not resolved, then the current working directory is
-- prepended
function Path:resolve(...: string)
	local paths: Array<string> = { ... }
	local resolvedpath = ""
	local resolveddrive: string? = nil
	local isabsolute = false
	for i = #paths, 1, -1 do
		local path = paths[i]
		if path and path ~= "" then
			local root: string = (resolveddrive and self:getRoot(path)) :: string
			if self:isDriveRelative(path) then
				root = root or self:getRoot(path)
				resolveddrive = resolveddrive or root
				path = path:sub(root:len() + 1)
			end
			if not root or (resolveddrive :: string):sub(1, 2) == root:sub(1, 2) then
				resolvedpath = self:join(self:normalize(path), resolvedpath)
				if self:isAbsolute(resolvedpath) then
					isabsolute = true
					break
				end
			end
		end
	end
	if not isabsolute then
		if resolveddrive then
			local drivecwd = process.env["=" .. resolveddrive]
			if drivecwd and self:pathsEqual(drivecwd:sub(1, 2), resolveddrive) then
				resolvedpath = self:join(drivecwd, resolvedpath)
			else
				resolvedpath = self:join(resolveddrive, resolvedpath)
			end
		else
			resolvedpath = self:join(process.cwd(), resolvedpath)
		end
	end

	local trailing_slashes = resolvedpath:match("[" .. self.sep .. "]*$")
	if trailing_slashes then
		resolvedpath = resolvedpath:sub(1, -trailing_slashes:len() - 1)
	end

	return resolvedpath
end

-- Returns the common parts of the given paths or {} if no
-- common parts were found.
function Path:_commonParts(...: string)
	local common_parts: Array<string> = {}
	local paths: Array<string> = { ... }
	local split_paths = {}
	for _, path in ipairs(paths) do
		table.insert(split_paths, self:_splitBySeparators(path))
	end
	for part_i = 1, #split_paths[1] do
		local test_part = split_paths[1][part_i]
		for path_i = 2, #split_paths do
			local part = split_paths[path_i][part_i]
			if not self:pathsEqual(test_part, part) then
				return common_parts
			end
		end
		table.insert(common_parts, test_part)
	end
	return common_parts
end

-- Returns the relative path from 'from' to 'to'
-- If no relative path can be solved, then 'to' is returned
function Path:relative(from: string, to: string)
	local from_root, from_dir, from_basename = self:_splitPath(from)
	local to_root, to_dir, to_basename = self:_splitPath(to)

	if not self:pathsEqual(from_root, to_root) then
		return to
	end

	local from_path, to_path = from_dir .. from_basename, to_dir .. to_basename
	local common_parts = self:_commonParts(from_path, to_path)
	local from_parts = self:_splitBySeparators(from_path)
	local to_parts = self:_splitBySeparators(to_path)

	local relative_parts = {}
	if #common_parts > 0 then
		for i = #common_parts, #from_parts - 1 do
			table.insert(relative_parts, "..")
		end
	end
	for i = #common_parts + 1, #to_parts do
		table.insert(relative_parts, to_parts[i])
	end

	return self:_rawjoin(relative_parts)
end

function Path:dirname(filepath: string)
	filepath = self:normalizeSeparators(filepath)
	if filepath:sub(filepath:len()) == self.sep then
		filepath = filepath:sub(1, -2)
	end

	local root, dir = self:_splitPath(filepath)

	if #dir > 0 then
		dir = dir:sub(1, #dir - 1)
		return root .. dir
	end
	if #root > 0 then
		return root
	end
	return "."
end

function Path:basename(filepath: string, expected_ext: string?)
	local _, _, base = self:_splitPath(filepath)
	if expected_ext then
		local ext_pos = base:find(expected_ext:gsub(".", ".") .. "$")
		if ext_pos then
			base = base:sub(1, ext_pos - 1)
		end
	end
	return base
end

function Path:extname(filepath: string)
	local basename = self:basename(filepath)
	if basename == ".." then
		return ""
	else
		return basename:match(".(%.[^.]*)$") or ""
	end
end

function Path:isDriveRelative()
	return false
end

function Path:isAbsolute(filepath: string)
	return filepath:sub(1, self.root:len()) == self.root
end

function Path:normalizeSeparators(filepath: string)
	return filepath
end

return {
	Path = Path,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="441">
            <Properties>
              <string name="Name">Picomatch</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/micromatch/picomatch/blob/2.3.1/index.js

return require(script.picomatch)
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="442">
              <Properties>
                <string name="Name">constants</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/lib/constants.js

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local RegExp = require(Packages.RegExp)

-- ROBLOX deviation: skipping path
-- local path = require("path")
local WIN_SLASH = "\\\\/"
local WIN_NO_SLASH = ("[^%s]"):format(WIN_SLASH)
--[[*
 * Posix glob regex
 ]]
local DOT_LITERAL = "\\."
local PLUS_LITERAL = "\\+"
local QMARK_LITERAL = "\\?"
local SLASH_LITERAL = "\\/"
local ONE_CHAR = "(?=.)"
local QMARK = "[^/]"
local END_ANCHOR = ("(?:%s|$)"):format(SLASH_LITERAL)
local START_ANCHOR = ("(?:^|%s)"):format(SLASH_LITERAL)
local DOTS_SLASH = ("%s{1,2}%s"):format(DOT_LITERAL, END_ANCHOR)
local NO_DOT = ("(?!%s)"):format(DOT_LITERAL)
local NO_DOTS = ("(?!%s%s)"):format(START_ANCHOR, DOTS_SLASH)
local NO_DOT_SLASH = ("(?!%s{0,1}%s)"):format(DOT_LITERAL, END_ANCHOR)
local NO_DOTS_SLASH = ("(?!%s)"):format(DOTS_SLASH)
local QMARK_NO_DOT = ("[^.%s]"):format(SLASH_LITERAL)
local STAR = ("%s*?"):format(QMARK)
local POSIX_CHARS = {
	DOT_LITERAL = DOT_LITERAL,
	PLUS_LITERAL = PLUS_LITERAL,
	QMARK_LITERAL = QMARK_LITERAL,
	SLASH_LITERAL = SLASH_LITERAL,
	ONE_CHAR = ONE_CHAR,
	QMARK = QMARK,
	END_ANCHOR = END_ANCHOR,
	DOTS_SLASH = DOTS_SLASH,
	NO_DOT = NO_DOT,
	NO_DOTS = NO_DOTS,
	NO_DOT_SLASH = NO_DOT_SLASH,
	NO_DOTS_SLASH = NO_DOTS_SLASH,
	QMARK_NO_DOT = QMARK_NO_DOT,
	STAR = STAR,
	START_ANCHOR = START_ANCHOR,
}
--[[*
 * Windows glob regex
 ]]
local WINDOWS_CHARS = Object.assign({}, POSIX_CHARS, {
	SLASH_LITERAL = ("[%s]"):format(WIN_SLASH),
	QMARK = WIN_NO_SLASH,
	STAR = ("%s*?"):format(WIN_NO_SLASH),
	DOTS_SLASH = ("%s{1,2}(?:[%s]|$)"):format(DOT_LITERAL, WIN_SLASH),
	NO_DOT = ("(?!%s)"):format(DOT_LITERAL),
	NO_DOTS = ("(?!(?:^|[%s])%s{1,2}(?:[%s]|$))"):format(WIN_SLASH, DOT_LITERAL, WIN_SLASH),
	NO_DOT_SLASH = ("(?!%s{0,1}(?:[%s]|$))"):format(DOT_LITERAL, WIN_SLASH),
	NO_DOTS_SLASH = ("(?!%s{1,2}(?:[%s]|$))"):format(DOT_LITERAL, WIN_SLASH),
	QMARK_NO_DOT = ("[^.%s]"):format(WIN_SLASH),
	START_ANCHOR = ("(?:^|[%s])"):format(WIN_SLASH),
	END_ANCHOR = ("(?:[%s]|$)"):format(WIN_SLASH),
})
--[[*
 * POSIX Bracket Regex
 ]]
local POSIX_REGEX_SOURCE = {
	alnum = "a-zA-Z0-9",
	alpha = "a-zA-Z",
	ascii = "\\x00-\\x7F",
	blank = " \\t",
	cntrl = "\\x00-\\x1F\\x7F",
	digit = "0-9",
	graph = "\\x21-\\x7E",
	lower = "a-z",
	print = "\\x20-\\x7E ",
	punct = "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
	space = " \\t\\r\\n\\v\\f",
	upper = "A-Z",
	word = "A-Za-z0-9_",
	xdigit = "A-Fa-f0-9",
}

return {
	MAX_LENGTH = 1024 * 64,
	POSIX_REGEX_SOURCE = POSIX_REGEX_SOURCE,

	-- regular expressions
	-- ROBLOX TODO: no "g" flag supported yet
	-- REGEX_BACKSLASH = RegExp("\\\\(?![*+?^${}(|)[\\]])", "g"),
	REGEX_NON_SPECIAL_CHARS = "^[^@![%].,$*+?^{}()|\\/]+",
	REGEX_SPECIAL_CHARS = "[-*+?.^${}(|)[%]]",
	-- ROBLOX TODO START: no "g" flag supported yet
	REGEX_SPECIAL_CHARS_BACKREF = RegExp("(\\\\?)((\\W)(\\3*))"),
	-- ROBLOX TODO: no "g" flag supported yet
	REGEX_SPECIAL_CHARS_GLOBAL = RegExp("([-*+?.^${}(|)[\\]])"),
	-- REGEX_REMOVE_BACKSLASH = RegExp("(?:\\[.*?[^\\\\]\\]|\\\\(?=.))", "g"),
	-- ROBLOX TODO END

	-- Replace globs with equivalent patterns to reduce parsing time.
	REPLACEMENTS = {
		["***"] = "*",
		["**/**"] = "**",
		["**/**/**"] = "**",
	},

	-- Digits
	CHAR_0 = 48, --[[ 0 ]]
	CHAR_9 = 57, --[[ 9 ]]

	-- Alphabet chars.
	CHAR_UPPERCASE_A = 65, --[[ A ]]
	CHAR_LOWERCASE_A = 97, --[[ a ]]
	CHAR_UPPERCASE_Z = 90, --[[ Z ]]
	CHAR_LOWERCASE_Z = 122, --[[ z ]]
	CHAR_LEFT_PARENTHESES = 40, --[[ ( ]]
	CHAR_RIGHT_PARENTHESES = 41, --[[ ) ]]
	CHAR_ASTERISK = 42, --[[ * ]]

	-- Non-alphabetic chars.
	CHAR_AMPERSAND = 38, --[[ & ]]
	CHAR_AT = 64, --[[ @ ]]
	CHAR_BACKWARD_SLASH = 92, --[[ \ ]]
	CHAR_CARRIAGE_RETURN = 13, --[[ \r ]]
	CHAR_CIRCUMFLEX_ACCENT = 94, --[[ ^ ]]
	CHAR_COLON = 58, --[[ : ]]
	CHAR_COMMA = 44, --[[ , ]]
	CHAR_DOT = 46, --[[ . ]]
	CHAR_DOUBLE_QUOTE = 34, --[[ " ]]
	CHAR_EQUAL = 61, --[[ = ]]
	CHAR_EXCLAMATION_MARK = 33, --[[ ! ]]
	CHAR_FORM_FEED = 12, --[[ \f ]]
	CHAR_FORWARD_SLASH = 47, --[[ / ]]
	CHAR_GRAVE_ACCENT = 96, --[[ ` ]]
	CHAR_HASH = 35, --[[ # ]]
	CHAR_HYPHEN_MINUS = 45, --[[ - ]]
	CHAR_LEFT_ANGLE_BRACKET = 60, --[[ < ]]
	CHAR_LEFT_CURLY_BRACE = 123, --[[ { ]]
	CHAR_LEFT_SQUARE_BRACKET = 91, --[[ [ ]]
	CHAR_LINE_FEED = 10, --[[ \n ]]
	CHAR_NO_BREAK_SPACE = 160, --[[ \u00A0 ]]
	CHAR_PERCENT = 37, --[[ % ]]
	CHAR_PLUS = 43, --[[ + ]]
	CHAR_QUESTION_MARK = 63, --[[ ? ]]
	CHAR_RIGHT_ANGLE_BRACKET = 62, --[[ > ]]
	CHAR_RIGHT_CURLY_BRACE = 125, --[[ } ]]
	CHAR_RIGHT_SQUARE_BRACKET = 93, --[[ ] ]]
	CHAR_SEMICOLON = 59, --[[ ; ]]
	CHAR_SINGLE_QUOTE = 39, --[[ ' ]]
	CHAR_SPACE = 32, --[[   ]]
	CHAR_TAB = 9, --[[ \t ]]
	CHAR_UNDERSCORE = 95, --[[ _ ]]
	CHAR_VERTICAL_LINE = 124, --[[ | ]]
	CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279, --[[ \uFEFF ]]

	-- ROBLOX FIXME
	SEP = "/", -- path.sep,

	--[[*
	 * Create EXTGLOB_CHARS
	]]

	extglobChars = function(chars)
		return {
			["!"] = { type = "negate", open = "(?:(?!(?:", close = ("))%s)"):format(chars.STAR) },
			["?"] = { type = "qmark", open = "(?:", close = ")?" },
			["+"] = { type = "plus", open = "(?:", close = ")+" },
			["*"] = { type = "star", open = "(?:", close = ")*" },
			["@"] = { type = "at", open = "(?:", close = ")" },
		}
	end,

	--[[*
	 * Create GLOB_CHARS
	]]

	globChars = function(win32)
		return if win32 == true then WINDOWS_CHARS else POSIX_CHARS
	end,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="443">
              <Properties>
                <string name="Name">parse</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/lib/parse.js

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local String = LuauPolyfill.String
local String_replace = require(CurrentModule.stringUtils).stringReplace
type Token = Object
type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>

local RegExp = require(Packages.RegExp)
local constants = require(CurrentModule.constants)
local utils = require(CurrentModule.utils)

--[[*
 * Constants
 ]]

local MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS =
	constants.MAX_LENGTH,
	constants.POSIX_REGEX_SOURCE,
	constants.REGEX_NON_SPECIAL_CHARS,
	constants.REGEX_SPECIAL_CHARS_BACKREF,
	constants.REPLACEMENTS

--[[*
 * Helpers
 ]]

local function expandRange(args: Array<any>, options)
	if typeof(options.expandRange) == "function" then
		return options.expandRange(table.unpack(args), options)
	end

	Array.sort(args)
	local value = ("[%s]"):format(Array.join(args, "-"))

	local ok = pcall(function()
		--[[ eslint-disable-next-line no-new ]]
		RegExp(value)
	end)
	if not ok then
		return Array.join(
			Array.map(args, function(v)
				return utils.escapeRegex(v)
			end),
			".."
		)
	end

	return value
end

--[[*
 * Create the message for a syntax error
 ]]

local function syntaxError(type, char)
	return ('Missing %s: "%s" - use "\\%s" to match literal characters'):format(type, char, char)
end

--[[*
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 ]]

-- ROBLOX deviation START: defining parse as callable table
local parse_
local parse = setmetatable({}, {
	__call = function(_self: any, input: string, options: Object?)
		return parse_(input, options)
	end,
})

function parse_(input, options) -- ROBLOX deviation END
	if typeof(input) ~= "string" then
		error(Error.new("TypeError: Expected a string"))
	end

	input = REPLACEMENTS[input] or input

	local opts = Object.assign({}, options)
	local max = if typeof(opts.maxLength) == "number" then math.min(MAX_LENGTH, opts.maxLength) else MAX_LENGTH

	local len = #input
	if len > max then
		error(
			Error.new(
				("SyntaxError: Input length: %s, exceeds maximum allowed length: %s"):format(
					tostring(len),
					tostring(max)
				)
			)
		)
	end

	local bos = { type = "bos", value = "", output = opts.prepend or "" }
	local tokens = { bos }

	local capture = if Boolean.toJSBoolean(opts.capture) then "" else "?:"
	local win32 = utils.isWindows(options)

	-- create constants based on platform, for windows or posix
	local PLATFORM_CHARS = constants.globChars(win32)
	local EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS)

	local DOT_LITERAL, PLUS_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK, QMARK_NO_DOT, STAR, START_ANCHOR =
		PLATFORM_CHARS.DOT_LITERAL,
		PLATFORM_CHARS.PLUS_LITERAL,
		PLATFORM_CHARS.SLASH_LITERAL,
		PLATFORM_CHARS.ONE_CHAR,
		PLATFORM_CHARS.DOTS_SLASH,
		PLATFORM_CHARS.NO_DOT,
		PLATFORM_CHARS.NO_DOT_SLASH,
		PLATFORM_CHARS.NO_DOTS_SLASH,
		PLATFORM_CHARS.QMARK,
		PLATFORM_CHARS.QMARK_NO_DOT,
		PLATFORM_CHARS.STAR,
		PLATFORM_CHARS.START_ANCHOR

	local function globstar(opts)
		return ("(%s(?:(?!%s%s).)*?)"):format(
			capture,
			START_ANCHOR,
			if Boolean.toJSBoolean(opts.dot) then DOTS_SLASH else DOT_LITERAL
		)
	end

	local nodot = if Boolean.toJSBoolean(opts.dot) then "" else NO_DOT
	local qmarkNoDot = if Boolean.toJSBoolean(opts.dot) then QMARK else QMARK_NO_DOT
	local star = if opts.bash == true then globstar(opts) else STAR

	if Boolean.toJSBoolean(opts.capture) then
		star = ("(%s)"):format(star)
	end

	-- minimatch options support
	if typeof(opts.noext) == "boolean" then
		opts.noextglob = opts.noext
	end

	local state = {
		input = input,
		index = 0,
		start = 1,
		dot = opts.dot == true,
		consumed = "",
		output = "",
		prefix = "",
		backtrack = false,
		negated = false,
		brackets = 0,
		braces = 0,
		parens = 0,
		quotes = 0,
		globstar = false,
		tokens = tokens,
	}

	input = utils.removePrefix(input, state)
	len = #input

	local extglobs: Array<Token> = {}
	local braces: Array<Token> = {}
	local stack: Array<string> = {}
	local prev: Token = bos
	local value

	--[[*
	 * Tokenizing helpers
	 ]]

	local function eos()
		return state.index == len
	end
	state.peek = function(n_: number?)
		local n = if n_ ~= nil then n_ else 1
		return string.sub(input, state.index + n, state.index + n)
	end
	local peek = state.peek
	state.advance = function()
		state.index += 1
		return string.sub(input, state.index, state.index) or ""
	end
	local advance = state.advance
	local function remaining()
		return string.sub(input, state.index + 1)
	end
	local function consume(value_: string?, num_: number?)
		local value = value_ or ""
		local num = num_ or 0
		state.consumed ..= value
		state.index += num
	end

	local function append(token: Token)
		state.output ..= if token.output ~= nil then token.output else token.value
		consume(token.value)
	end

	local function negate()
		local count = 1

		while peek() == "!" and (peek(2) ~= "(" or peek(3) == "?") do
			advance()
			state.start += 1
			count += 1
		end

		if count % 2 == 0 then
			return false
		end

		state.negated = true
		state.start += 1
		return true
	end

	local function increment(type)
		state[type] += 1
		table.insert(stack, type)
	end

	local function decrement(type)
		state[type] -= 1
		table.remove(stack)
	end

	--[[*
	 * Push tokens onto the tokens array. This helper speeds up
	 * tokenizing by 1) helping us avoid backtracking as much as possible,
	 * and 2) helping us avoid creating extra tokens when consecutive
	 * characters are plain text. This improves performance and simplifies
	 * lookbehinds.
	 ]]

	local function push(tok: Token)
		if prev.type == "globstar" then
			local isBrace = state.braces > 0 and (tok.type == "comma" or tok.type == "brace")
			local isExtglob = tok.extglob == true
				or if #extglobs ~= 0 then tok.type == "pipe" or tok.type == "paren" else #extglobs

			if tok.type ~= "slash" and tok.type ~= "paren" and not isBrace and not isExtglob then
				state.output = String.slice(state.output, 0, -#prev.output)
				prev.type = "star"
				prev.value = "*"
				prev.output = star
				state.output ..= prev.output
			end
		end

		if #extglobs ~= 0 and tok.type ~= "paren" then
			extglobs[#extglobs].inner ..= tok.value
		end

		if Boolean.toJSBoolean(tok.value) or Boolean.toJSBoolean(tok.output) then
			append(tok)
		end
		if prev ~= nil and prev.type == "text" and tok.type == "text" then
			prev.value ..= tok.value
			prev.output = (prev.output or "") .. tok.value
			return
		end

		tok.prev = prev
		table.insert(tokens, tok)
		prev = tok
	end

	local function extglobOpen(type, value)
		local token = Object.assign({}, EXTGLOB_CHARS[value], { conditions = 1, inner = "" })

		token.prev = prev
		token.parens = state.parens
		token.output = state.output
		local output = (if Boolean.toJSBoolean(opts.capture) then "(" else "") .. token.open

		increment("parens")
		push({
			type = type,
			value = value,
			output = if Boolean.toJSBoolean(state.output) then "" else ONE_CHAR,
		})
		push({ type = "paren", extglob = true, value = advance(), output = output })
		table.insert(extglobs, token)
	end

	local function extglobClose(token: Token)
		local output = token.close .. (if Boolean.toJSBoolean(opts.capture) then ")" else "")
		local rest

		if token.type == "negate" then
			local extglobStar = star

			if token.inner ~= nil and #token.inner > 1 and token.inner:find("/", 1, true) ~= nil then
				extglobStar = globstar(opts)
			end

			if extglobStar ~= star or eos() or RegExp("^\\)+$"):test(remaining()) then
				token.close = (")$))%s"):format(extglobStar)
				output = token.close
			end

			if
				token.inner:find("*", 1, true) ~= nil
				and (function()
					rest = remaining()
					return rest
				end)()
				and RegExp("^\\.[^\\\\/.]+$"):test(rest)
			then
				-- Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
				-- In this case, we need to parse the string and use it in the output of the original pattern.
				-- Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
				--
				-- Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
				local expression = parse(rest, Object.assign({}, options, { fastpaths = false })).output

				token.close = (")%s)%s)"):format(expression, extglobStar)
				output = token.close
			end

			if token.prev.type == "bos" then
				state.negatedExtglob = true
			end
		end

		push({ type = "paren", extglob = true, value = value, output = output })
		decrement("parens")
	end

	--[[*
	 * Fast paths
	 ]]

	if opts.fastpaths ~= false and not RegExp('(^[*!]|[/()[\\]{}"])'):test(input) then
		local backslashes = false

		-- ROBLOX deviation: using custom string.replace implementation
		local output = String_replace(input, REGEX_SPECIAL_CHARS_BACKREF, function(m, esc, chars, first, rest, index)
			if first == "\\" then
				backslashes = true
				return m
			end

			if first == "?" then
				if Boolean.toJSBoolean(esc) then
					return esc .. first .. if rest ~= nil then string.rep(QMARK, #rest) else ""
				end
				if index == 0 then
					return qmarkNoDot .. if rest ~= nil then string.rep(QMARK, #rest) else ""
				end
				return string.rep(QMARK, #chars)
			end

			if first == "." then
				return string.rep(DOT_LITERAL, #chars)
			end

			if first == "*" then
				if Boolean.toJSBoolean(esc) then
					return esc .. first .. if rest ~= nil then star else ""
				end
				return star
			end
			return if Boolean.toJSBoolean(esc) then m else ("\\%s"):format(m)
		end)

		if backslashes == true then
			if opts.unescape == true then
				-- ROBLOX FIXME START: change :replace to working solution
				error("not implemented")
				-- output = output:replace(RegExp("\\", "g")(""))
				-- ROBLOX FIXME END
			else
				-- ROBLOX FIXME START: change :replace to working solution
				error("not implemented")
				-- output = output:replace(RegExp("\\+", "g"), function(m)
				-- 	return if #m % 2 == 0 then "\\\\" else (if Boolean.toJSBoolean(m) then "\\" else "")
				-- end)
				-- ROBLOX FIXME END
			end
		end

		if output == input and opts.contains == true then
			state.output = input
			return state
		end

		state.output = utils.wrapOutput(output, state, options)
		return state
	end

	--[[*
	 * Tokenize input until we reach end-of-string
	 ]]

	while not eos() do
		value = advance()

		if value == "\u{0000}" then
			continue
		end

		--[[*
		 * Escaped characters
		 ]]

		if value == "\\" then
			local next = peek()

			if next == "/" and opts.bash ~= true then
				continue
			end

			if next == "." or next == ";" then
				continue
			end

			if not Boolean.toJSBoolean(next) then
				-- ROBLOX FIXME Luau: it seems that Luau narrows the type to be singleton type of "\\" and doesn't allow to append anything to it
				value ..= "\\" :: any
				push({ type = "text", value = value })
				continue
			end

			-- collapse slashes to reduce potential for exploits
			local match = (RegExp("^\\\\+")):exec(remaining())
			local slashes = 0

			if match ~= nil and #match[1] > 2 then
				slashes = #match[1]
				state.index += slashes
				if slashes % 2 ~= 0 then
					-- ROBLOX FIXME Luau: it seems that Luau narrows the type to be singleton type of "\\" and doesn't allow to append anything to it
					value ..= "\\" :: any
				end
			end

			if opts.unescape == true then
				value = advance()
			else
				-- ROBLOX FIXME Luau: it seems that Luau narrows the type to be singleton type of "\\" and doesn't allow to append anything to it
				value ..= advance() :: any
			end

			if state.brackets == 0 then
				push({ type = "text", value = value })
				continue
			end
		end

		--[[*
		 * If we're inside a regex character class, continue
		 * until we reach the closing bracket.
		 ]]

		if state.brackets > 0 and (value ~= "]" or prev.value == "[" or prev.value == "[^") then
			if opts.posix ~= false and value == ":" then
				local inner = String.slice(prev.value, 1)
				if inner:find("[", 1, true) ~= nil then
					prev.posix = true

					if inner:find(":", 1, true) ~= nil then
						local idx = String.lastIndexOf(prev.value, "[")
						local pre = String.slice(prev.value, 1, idx)
						local rest = String.slice(prev.value, idx + 2)
						local posix = POSIX_REGEX_SOURCE[rest]
						if posix then
							prev.value = pre .. posix
							state.backtrack = true
							advance()

							if
								not Boolean.toJSBoolean(bos.output)
								and Array.indexOf(tokens, prev) == 2 --[[ ROBLOX deviation: added 1 to account for 1-based indexing]]
							then
								bos.output = ONE_CHAR
							end
							continue
						end
					end
				end
			end

			if value == "[" and peek() ~= ":" or value == "-" and peek() == "]" then
				value = ("\\%s"):format(value)
			end

			if value == "]" and (prev.value == "[" or prev.value == "[^") then
				value = ("\\%s"):format(value)
			end

			if opts.posix == true and value == "!" and prev.value == "[" then
				value = "^"
			end

			-- ROBLOX FIXME Luau: it seems that Luau narrows the type to be singleton type of "\\" and doesn't allow to append anything to it
			prev.value ..= value :: any
			append({ value = value })
			continue
		end

		--[[*
		 * If we're inside a quoted string, continue
		 * until we reach the closing double quote.
		 ]]

		if state.quotes == 1 and value ~= '"' then
			value = utils.escapeRegex(value)
			prev.value ..= value
			append({ value = value })
			continue
		end

		--[[*
		 * Double quotes
		 ]]

		if value == '"' then
			state.quotes = state.quotes == 1 and 0 or 1
			if opts.keepQuotes == true then
				push({ type = "text", value = value })
			end
			continue
		end

		--[[*
		 * Parentheses
		 ]]

		if value == "(" then
			increment("parens")
			push({ type = "paren", value = value })
			continue
		end

		if value == ")" then
			if state.parens == 0 and opts.strictBrackets == true then
				error(Error.new("SyntaxError: " .. syntaxError("opening", "(")))
			end

			local extglob = extglobs[#extglobs]
			if extglob ~= nil and state.parens == extglob.parens + 1 then
				extglobClose(table.remove(extglobs) :: Token)
				continue
			end

			push({
				type = "paren",
				value = value,
				output = if Boolean.toJSBoolean(state.parens) then ")" else "\\)",
			})
			decrement("parens")
			continue
		end

		--[[*
		 * Square brackets
		 ]]

		if value == "[" then
			if opts.nobracket == true or remaining():find("]", 1, true) == nil then
				if opts.nobracket ~= true and opts.strictBrackets == true then
					error(Error.new("SyntaxError: " .. syntaxError("closing", "]")))
				end

				value = ("\\%s"):format(value)
			else
				increment("brackets")
			end

			push({ type = "bracket", value = value })
			continue
		end

		if value == "]" then
			if opts.nobracket == true or (prev ~= nil and prev.type == "bracket" and #prev.value == 1) then
				push({ type = "text", value = value, output = ("\\%s"):format(value) })
				continue
			end
			if state.brackets == 0 then
				if opts.strictBrackets == true then
					error(Error.new("SyntaxError: " .. syntaxError("opening", "[")))
				end

				push({ type = "text", value = value, output = ("\\%s"):format(value) })
				continue
			end

			decrement("brackets")

			local prevValue = String.slice(prev.value, 2)
			if prev.posix ~= true and prevValue:sub(1, 1) == "^" and prevValue:find("/", 1, true) == nil then
				value = ("/%s"):format(value)
			end

			prev.value ..= value
			append({ value = value })

			-- when literal brackets are explicitly disabled
			-- assume we should match with a regex character class
			if opts.literalBrackets == false or utils.hasRegexChars(prevValue) then
				continue
			end

			local escaped = utils.escapeRegex(prev.value)
			state.output = String.slice(state.output, 1, -#prev.value)

			-- when literal brackets are explicitly enabled
			-- assume we should escape the brackets to match literal characters
			if opts.literalBrackets == true then
				state.output ..= escaped
				prev.value = escaped
				continue
			end

			-- when the user specifies nothing, try to match both
			prev.value = ("(%s%s|%s)"):format(capture, escaped, prev.value)
			state.output ..= prev.value
			continue
		end

		--[[*
		 * Braces
		 ]]

		if value == "{" and opts.nobrace ~= true then
			increment("braces")

			local open = {
				type = "brace",
				value = value,
				output = "(",
				outputIndex = #state.output,
				tokensIndex = #state.tokens,
			}

			table.insert(braces, open)
			push(open)
			continue
		end

		if value == "}" then
			local brace = braces[#braces]

			if opts.nobrace == true or not Boolean.toJSBoolean(brace) then
				push({ type = "text", value = value, output = value })
				continue
			end

			local output = ")"

			if brace.dots == true then
				local arr = Array.slice(tokens)
				local range = {}

				for i = #arr, 1, -1 do
					table.remove(tokens)
					if arr[i].type == "brace" then
						break
					end
					if arr[i].type ~= "dots" then
						table.insert(range, 1, arr[i].value)
					end
				end

				output = expandRange(range, opts)
				state.backtrack = true
			end

			if brace.comma ~= true and brace.dots ~= true then
				local out = String.slice(state.output, 1, brace.outputIndex)
				local toks = Array.slice(state.tokens, brace.tokensIndex)
				brace.output = "\\{"
				brace.value = brace.output
				output = "\\}"
				value = output
				state.output = out
				for _, t in ipairs(toks) do
					state.output ..= if Boolean.toJSBoolean(t.output) then t.output else t.value
				end
			end

			push({ type = "brace", value = value, output = output })
			decrement("braces")
			table.remove(braces)
			continue
		end

		--[[*
		 * Pipes
		 ]]

		if value == "|" then
			if #extglobs > 0 then
				extglobs[#extglobs].conditions += 1
			end
			push({ type = "text", value = value })
			continue
		end

		--[[*
		 * Commas
		 ]]

		if value == "," then
			local output = value

			local brace = braces[#braces]
			if Boolean.toJSBoolean(brace) and stack[#stack] == "braces" then
				brace.comma = true
				output = "|"
			end

			push({ type = "comma", value = value, output = output })
			continue
		end

		--[[*
		 * Slashes
		 ]]

		if value == "/" then
			-- if the beginning of the glob is "./", advance the start
			-- to the current index, and don't add the "./" characters
			-- to the state. This greatly simplifies lookbehinds when
			-- checking for BOS characters like "!" and "." (not "./")
			if prev.type == "dot" and state.index == state.start + 1 then
				state.start = state.index + 1
				state.consumed = ""
				state.output = ""
				table.remove(tokens)
				prev = bos -- reset "prev" to the first token
				continue
			end

			push({ type = "slash", value = value, output = SLASH_LITERAL })
			continue
		end

		--[[*
		 * Dots
		 ]]

		if value == "." then
			if state.braces > 0 and prev.type == "dot" then
				if prev.value == "." then
					prev.output = DOT_LITERAL
				end
				local brace = braces[#braces]
				prev.type = "dots"
				prev.output ..= value
				prev.value ..= value
				brace.dots = true
				continue
			end

			if state.braces + state.parens == 0 and prev.type ~= "bos" and prev.type ~= "slash" then
				push({ type = "text", value = value, output = DOT_LITERAL })
				continue
			end

			push({ type = "dot", value = value, output = DOT_LITERAL })
			continue
		end

		--[[*
		 * Question marks
		 ]]

		if value == "?" then
			local isGroup = Boolean.toJSBoolean(prev) and prev.value == "("
			if not isGroup and Boolean.toJSBoolean(opts.noextglob) ~= true and peek() == "(" and peek(2) ~= "?" then
				extglobOpen("qmark", value)
				continue
			end

			if Boolean.toJSBoolean(prev) and prev.type == "paren" then
				local next = peek()
				local output = value

				if next == "<" and not utils.supportsLookbehinds() then
					error(Error.new("Node.js v10 or higher is required for regex lookbehinds"))
				end

				if
					(prev.value == "(" and not RegExp("[!=<:]"):test(next))
					or (next == "<" and not RegExp("<([!=]|\\w+>)"):test(remaining()))
				then
					output = ("\\%s"):format(value)
				end

				push({ type = "text", value = value, output = output })
				continue
			end

			if opts.dot ~= true and (prev.type == "slash" or prev.type == "bos") then
				push({ type = "qmark", value = value, output = QMARK_NO_DOT })
				continue
			end

			push({ type = "qmark", value = value, output = QMARK })
			continue
		end

		--[[*
		 * Exclamation
		 ]]

		if value == "!" then
			if Boolean.toJSBoolean(opts.noextglob) ~= true and peek() == "(" then
				if peek(2) ~= "?" or not RegExp("[!=<:]"):test(peek(3)) then
					extglobOpen("negate", value)
					continue
				end
			end

			if opts.nonegate ~= true and state.index == 1 then
				negate()
				continue
			end
		end

		--[[*
		 * Plus
		 ]]

		if value == "+" then
			if Boolean.toJSBoolean(opts.noextglob) ~= true and peek() == "(" and peek(2) ~= "?" then
				extglobOpen("plus", value)
				continue
			end

			if prev ~= nil and prev.value == "(" or opts.regex == false then
				push({ type = "plus", value = value, output = PLUS_LITERAL })
				continue
			end

			if
				(prev ~= nil and (prev.type == "bracket" or prev.type == "paren" or prev.type == "brace"))
				or state.parens > 0
			then
				push({ type = "plus", value = value })
				continue
			end

			push({ type = "plus", value = PLUS_LITERAL })
			continue
		end

		--[[*
		 * Plain text
		 ]]

		if value == "@" then
			if Boolean.toJSBoolean(opts.noextglob) ~= true and peek() == "(" and peek(2) ~= "?" then
				push({ type = "at", extglob = true, value = value, output = "" })
				continue
			end

			push({ type = "text", value = value })
			continue
		end

		--[[*
		 * Plain text
		 ]]

		if value ~= "*" then
			if value == "$" or value == "^" then
				value = ("\\%s"):format(value)
			end

			local match = string.match(remaining(), REGEX_NON_SPECIAL_CHARS)
			if match ~= nil then
				value ..= match
				state.index += #match
			end

			push({ type = "text", value = value })
			continue
		end

		--[[*
		 * Stars
		 ]]

		if prev ~= nil and (prev.type == "globstar" or prev.star == true) then
			prev.type = "star"
			prev.star = true
			prev.value ..= value
			prev.output = star
			state.backtrack = true
			state.globstar = true
			consume(value)
			continue
		end

		local rest = remaining()
		if Boolean.toJSBoolean(opts.noextglob) ~= true and RegExp("^\\([^?]"):test(rest) then
			extglobOpen("star", value)
			continue
		end

		if prev.type == "star" then
			if opts.noglobstar == true then
				consume(value)
				continue
			end

			local prior = prev.prev
			local before = prior.prev
			local isStart = prior.type == "slash" or prior.type == "bos"
			local afterStar = if Boolean.toJSBoolean(before)
				then before.type == "star" or before.type == "globstar"
				else before

			if opts.bash == true and (not isStart or (rest:sub(1, 1) ~= nil and rest:sub(1, 1) ~= "/")) then
				push({ type = "star", value = value, output = "" })
				continue
			end

			local isBrace = state.braces > 0 and (prior.type == "comma" or prior.type == "brace")
			local isExtglob = #extglobs > 0 and (prior.type == "pipe" or prior.type == "paren")
			if not isStart and prior.type ~= "paren" and not isBrace and not isExtglob then
				push({ type = "star", value = value, output = "" })
				continue
			end

			-- strip consecutive `/**/`
			while String.slice(rest, 1, 4) == "/**" do
				local after = input:sub(state.index + 4, state.index + 4)
				if Boolean.toJSBoolean(after) and after ~= "/" then
					break
				end
				rest = String.slice(rest, 4)
				consume("/**", 3)
			end

			if prior.type == "bos" and eos() then
				prev.type = "globstar"
				prev.value ..= value
				prev.output = globstar(opts)
				state.output = prev.output
				state.globstar = true
				consume(value)
				continue
			end

			if prior.type == "slash" and prior.prev.type ~= "bos" and not Boolean.toJSBoolean(afterStar) and eos() then
				state.output = String.slice(state.output, 1, -#(prior.output .. prev.output))
				prior.output = ("(?:%s"):format(prior.output)

				prev.type = "globstar"
				prev.output = globstar(opts) .. (if opts.strictSlashes then ")" else "|$)")
				prev.value ..= value
				state.globstar = true
				state.output ..= prior.output .. prev.output
				consume(value)
				continue
			end

			if prior.type == "slash" and prior.prev.type ~= "bos" and rest:sub(1, 1) == "/" then
				local end_ = if rest:sub(2, 2) ~= nil then "|$" else ""

				state.output = String.slice(state.output, 1, -#(prior.output .. prev.output))
				prior.output = ("(?:%s"):format(prior.output)

				prev.type = "globstar"
				prev.output = ("%s%s|%s%s)"):format(globstar(opts), SLASH_LITERAL, SLASH_LITERAL, end_)
				prev.value ..= value

				state.output ..= prior.output .. prev.output
				state.globstar = true

				consume(value .. advance())

				push({ type = "slash", value = "/", output = "" })
				continue
			end

			if prior.type == "bos" and rest:sub(1, 1) == "/" then
				prev.type = "globstar"
				prev.value ..= value
				prev.output = ("(?:^|%s|%s%s)"):format(SLASH_LITERAL, globstar(opts), SLASH_LITERAL)
				state.output = prev.output
				state.globstar = true
				consume(value .. advance())
				push({ type = "slash", value = "/", output = "" })
				continue
			end

			-- remove single star from output
			state.output = String.slice(state.output, 1, -#prev.output)

			-- reset previous token to globstar
			prev.type = "globstar"
			prev.output = globstar(opts)
			prev.value ..= value

			-- reset output with globstar
			state.output ..= prev.output
			state.globstar = true
			consume(value)
			continue
		end

		local token = { type = "star", value = value, output = star }

		if opts.bash == true then
			token.output = ".*?"
			if prev.type == "bos" or prev.type == "slash" then
				token.output = nodot .. token.output
			end
			push(token)
			continue
		end

		if prev ~= nil and (prev.type == "bracket" or prev.type == "paren") and opts.regex == true then
			token.output = value
			push(token)
			continue
		end

		if state.index == state.start or prev.type == "slash" or prev.type == "dot" then
			if prev.type == "dot" then
				state.output ..= NO_DOT_SLASH
				prev.output ..= NO_DOT_SLASH
			elseif opts.dot == true then
				state.output ..= NO_DOTS_SLASH
				prev.output ..= NO_DOTS_SLASH
			else
				state.output ..= nodot
				prev.output ..= nodot
			end

			if peek() ~= "*" then
				state.output ..= ONE_CHAR
				prev.output ..= ONE_CHAR
			end
		end

		push(token)
	end

	while state.brackets > 0 do
		if opts.strictBrackets == true then
			error(Error.new("SyntaxError: " .. syntaxError("closing", "]")))
		end
		state.output = utils.escapeLast(state.output, "[")
		decrement("brackets")
	end

	while state.parens > 0 do
		if opts.strictBrackets == true then
			error(Error.new("SyntaxError: " .. syntaxError("closing", ")")))
		end
		state.output = utils.escapeLast(state.output, "(")
		decrement("parens")
	end

	while state.braces > 0 do
		if opts.strictBrackets == true then
			error(Error.new("SyntaxError: " .. syntaxError("closing", "}")))
		end
		state.output = utils.escapeLast(state.output, "{")
		decrement("braces")
	end

	if opts.strictSlashes ~= true and (prev.type == "star" or prev.type == "bracket") then
		push({ type = "maybe_slash", value = "", output = ("%s?"):format(SLASH_LITERAL) })
	end

	-- rebuild the output if we had to backtrack at any point
	if state.backtrack == true then
		state.output = ""

		for _, token: Token in ipairs(state.tokens) do
			state.output ..= if token.output ~= nil then token.output else token.value

			if token.suffix then
				state.output ..= token.suffix
			end
		end
	end
	return state
end

--[[*
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 ]]

parse.fastpaths = function(input: string, options: Object?)
	local opts = Object.assign({}, options)
	local max = if typeof(opts.maxLength) == "number" then math.min(MAX_LENGTH, opts.maxLength) else MAX_LENGTH
	local len = #input
	if len > max then
		error(
			Error.new(
				("SyntaxError: Input length: %s, exceeds maximum allowed length: %s"):format(
					tostring(len),
					tostring(max)
				)
			)
		)
	end

	input = Boolean.toJSBoolean(REPLACEMENTS[input]) and REPLACEMENTS[input] or input
	local win32 = utils.isWindows(options)

	-- create constants based on platform, for windows or posix

	local ref = constants.globChars(win32)
	local DOT_LITERAL, SLASH_LITERAL, ONE_CHAR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOTS_SLASH, STAR, START_ANCHOR =
		ref.DOT_LITERAL,
		ref.SLASH_LITERAL,
		ref.ONE_CHAR,
		ref.DOTS_SLASH,
		ref.NO_DOT,
		ref.NO_DOTS,
		ref.NO_DOTS_SLASH,
		ref.STAR,
		ref.START_ANCHOR

	local nodot = if Boolean.toJSBoolean(opts.dot) then NO_DOTS else NO_DOT
	local slashDot = if Boolean.toJSBoolean(opts.dot) then NO_DOTS_SLASH else NO_DOT
	local capture = if Boolean.toJSBoolean(opts.capture) then "" else "?:"
	local state = { negated = false, prefix = "" }
	local star = if opts.bash == true then ".*?" else STAR

	if Boolean.toJSBoolean(opts.capture) then
		star = ("(%s)"):format(star)
	end

	local function globstar(opts)
		if opts.noglobstar == true then
			return star
		end
		return ("(%s(?:(?!%s%s).)*?)"):format(
			capture,
			START_ANCHOR,
			if Boolean.toJSBoolean(opts.dot) then DOTS_SLASH else DOT_LITERAL
		)
	end

	local function create(str): string?
		if str == "*" then
			return ("%s%s%s"):format(nodot, ONE_CHAR, star)
		elseif str == ".*" then
			return ("%s%s%s"):format(DOT_LITERAL, ONE_CHAR, star)
		elseif str == "*.*" then
			return ("%s%s%s%s%s"):format(nodot, star, DOT_LITERAL, ONE_CHAR, star)
		elseif str == "*/*" then
			return ("%s%s%s%s%s%s"):format(nodot, star, SLASH_LITERAL, ONE_CHAR, slashDot, star)
		elseif str == "**" then
			return nodot .. globstar(opts)
		elseif str == "**/*" then
			return ("(?:%s%s%s)?%s%s%s"):format(nodot, globstar(opts), SLASH_LITERAL, slashDot, ONE_CHAR, star)
		elseif str == "**/*.*" then
			return ("(?:%s%s%s)?%s%s%s%s%s"):format(
				nodot,
				globstar(opts),
				SLASH_LITERAL,
				slashDot,
				star,
				DOT_LITERAL,
				ONE_CHAR,
				star
			)
		elseif str == "**/.*" then
			return ("(?:%s%s%s)?%s%s%s"):format(nodot, globstar(opts), SLASH_LITERAL, DOT_LITERAL, ONE_CHAR, star)
		else
			local match = RegExp("^(.*?)\\.(\\w+)$"):exec(str)
			if not Boolean.toJSBoolean(match) then
				return nil
			end

			local source = create(match[2])
			if not Boolean.toJSBoolean(source) then
				return nil
			end

			return source .. DOT_LITERAL .. match[3]
		end
	end

	local output = utils.removePrefix(input, state)
	local source = create(output)

	if source ~= nil and Boolean.toJSBoolean(source) and opts.strictSlashes ~= true then
		source ..= ("%s?"):format(SLASH_LITERAL)
	end

	return source
end

return parse
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="444">
              <Properties>
                <string name="Name">picomatch</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/lib/picomatch.js

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp

-- ROBLOX deviation: skipping path
-- local path = require("path")
local scan = require(CurrentModule.scan)
local parse = require(CurrentModule.parse)
local utils = require(CurrentModule.utils)
local constants = require(CurrentModule.constants)
local function isObject(val)
	return typeof(val) == "table" and not Array.isArray(val)
end

--[[*
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 ]]

-- ROBLOX deviation START: defining picomatch as callable table
local picomatch_
local picomatch = setmetatable({}, {
	__call = function(_self: any, glob: any, options: Object?, returnState: boolean?)
		return picomatch_(glob, options, returnState)
	end,
})

function picomatch_(
	glob: any,
	options: Object?,
	returnState_: boolean?
): typeof(setmetatable({ state = {} :: any }, {
	__call = function(_self: any, str: string, returnObject: boolean?): any
		return nil :: any
	end,
})) -- ROBLOX deviation END
	local returnState = returnState_ or false

	if Array.isArray(glob) then
		local fns = Array.map(glob, function(input)
			return picomatch(input, options, returnState)
		end)
		-- ROBLOX deviation START: defining arrayMatcher as callable table
		local arrayMatcher_
		local arrayMatcher = setmetatable({}, {
			__call = function(_self: any, str: string)
				return arrayMatcher_(str)
			end,
		})

		function arrayMatcher_(str: string) -- ROBLOX deviation: END
			for _, isMatch in ipairs(fns) do
				local state = isMatch(str)
				if state then
					return state
				end
			end
			return false
		end
		return arrayMatcher
	end

	local isState = isObject(glob) and Boolean.toJSBoolean(glob.tokens) and Boolean.toJSBoolean(glob.input)

	if glob == "" or typeof(glob) ~= "string" and not isState then
		error(Error.new("TypeError: Expected pattern to be a non-empty string"))
	end

	local opts = options or {} :: Object
	local posix = utils.isWindows(options)
	-- ROBLOX Luau FIXME: needs normalization to avoid Type 'RegExp' could not be converted into 'RegExp & {| state: any? |}'
	local regex: RegExp & { state: any? } = if isState
		then picomatch.compileRe(glob, options) :: any
		else picomatch.makeRe(glob, options, false, true)

	local state = regex.state
	regex.state = nil

	local isIgnored: (str: string) -> boolean
	function isIgnored(_)
		return false
	end
	if Boolean.toJSBoolean(opts.ignore) then
		local ignoreOpts = Object.assign(
			{},
			options,
			{ ignore = Object.None, onMatch = Object.None, onResult = Object.None }
		)
		-- ROBLOX FIXME Luau: Callable table can't be assigned to a function
		isIgnored = picomatch(opts.ignore, ignoreOpts, returnState) :: any
	end

	-- ROBLOX deviation START: defining matcher as callable table
	local matcher_
	local matcher = setmetatable({}, {
		__call = function(_self: any, input: string, returnObject: boolean?)
			return matcher_(input, returnObject)
		end,
	})

	function matcher_(input: string, returnObject_: boolean?) -- ROBLOX deviation END
		local returnObject = returnObject_ or false

		local ref = picomatch.test(input, regex, options, { glob = glob, posix = posix })
		local isMatch, match, output = ref.isMatch, ref.match, ref.output
		local result = {
			glob = glob,
			state = state,
			regex = regex,
			posix = posix,
			input = input,
			output = output,
			match = match,
			isMatch = isMatch,
		}

		if typeof(opts.onResult) == "function" then
			opts.onResult(result)
		end

		if isMatch == false then
			result.isMatch = false
			return if returnObject then result else false
		end

		if isIgnored(input) then
			if typeof(opts.onIgnore) == "function" then
				opts.onIgnore(result)
			end
			result.isMatch = false
			return if returnObject then result else false
		end

		if typeof(opts.onMatch) == "function" then
			opts.onMatch(result)
		end
		return if returnObject then result else true
	end

	if Boolean.toJSBoolean(returnState) then
		matcher.state = state
	end
	return matcher
end

--[[*
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 ]]

function picomatch.test(input: string, regex: RegExp, options: Object?, ref_: Object?)
	local ref: Object = ref_ or {}
	local glob, posix = ref.glob, ref.posix

	if typeof(input) ~= "string" then
		error(Error.new("TypeError: Expected input to be a string"))
	end

	if input == "" then
		return { isMatch = false, output = "" }
	end

	local opts: Object = options or {}
	local format = if Boolean.toJSBoolean(opts.format)
		then opts.format
		else if Boolean.toJSBoolean(posix) then utils.toPosixSlashes else nil
	local match = input == glob
	local output = if match and Boolean.toJSBoolean(format) then format(input) else input

	if match == false then
		output = if Boolean.toJSBoolean(format) then format(input) else input
		match = output == glob
	end

	if match == false or opts.capture == true then
		if opts.matchBase == true or opts.basename == true then
			match = picomatch.matchBase(input, regex, options, posix)
		else
			-- ROBLOX FIXME: Luau narrows the type to boolean and doesn't allow for result of RegExp:exec to be assigned
			match = regex:exec(output) :: any
		end
	end

	return { isMatch = Boolean.toJSBoolean(match), match = match, output = output }
end

--[[*
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 ]]

-- ROBLOX TODO START: implement when possible
function picomatch.matchBase(input, glob, options, posix_: boolean?): boolean
	error("matchBase not implemented")
	-- local _posix = posix_ or utils.isWindows(options)

	-- local regex = if instanceof(glob, RegExp) then glob else picomatch.makeRe(glob, options)
	-- -- ROBLOX FIXME: return regex:test(path:basename(input))
	-- return regex:test(input)
end
-- ROBLOX TODO END

--[[*
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 ]]

function picomatch.isMatch(str: string, patterns, options: Object?)
	return picomatch(patterns, options)(str)
end

--[[*
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 ]]

function picomatch.parse(pattern, options: Object?)
	if Array.isArray(pattern) then
		return Array.map(pattern, function(p)
			return picomatch.parse(p, options)
		end)
	end
	return parse(pattern, Object.assign({}, options, { fastpaths = false }))
end

--[[*
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 ]]

function picomatch.scan(input, options: Object?)
	return scan(input, options)
end

--[[*
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 ]]

picomatch.compileRe = function(state: Object, options: Object?, returnOutput_: boolean?, returnState_: boolean?): RegExp
	local returnOutput = returnOutput_ or false
	local returnState = returnState_ or false

	if returnOutput == true then
		return state.output
	end

	local opts: Object = options or {}
	local prepend = if Boolean.toJSBoolean(opts.contains) then "" else "^"
	local append = if Boolean.toJSBoolean(opts.contains) then "" else "$"

	local source = ("%s(?:%s)%s"):format(prepend, tostring(state.output), append)
	if typeof(state) == "table" and state.negated == true then
		source = ("^(?!%s).*$"):format(source)
	end

	local regex = picomatch.toRegex(source, options)
	if returnState == true then
		regex.state = state
	end

	return regex
end

--[[*
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 ]]

function picomatch.makeRe(input: string, options_: Object?, returnOutput_: boolean?, returnState_: boolean?): RegExp
	local options: Object = options_ or {}
	local returnOutput = returnOutput_ or false
	local returnState = returnState_ or false

	if not Boolean.toJSBoolean(input) or typeof(input) ~= "string" then
		error(Error.new("TypeError: Expected a non-empty string"))
	end

	local parsed = { negated = false, fastpaths = true }

	if options.fastpaths ~= false and (string.sub(input, 1, 1) == "." or string.sub(input, 1, 1) == "*") then
		parsed.output = parse.fastpaths(input, options)
	end

	if not Boolean.toJSBoolean(parsed.output) then
		parsed = parse(input, options)
	end

	return picomatch.compileRe(parsed, options, returnOutput, returnState)
end

--[[*
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 ]]

function picomatch.toRegex(source: string, options: Object?)
	local ok, result = pcall(function()
		local opts: Object = options or {}
		return RegExp(
			source,
			Boolean.toJSBoolean(opts.flags) and opts.flags or if Boolean.toJSBoolean(opts.nocase) then "i" else ""
		)
	end)
	if not ok then
		local err = result
		if options ~= nil and options.debug == true then
			error(err)
		end
		return RegExp("$^")
	end
	return result
end

--[[*
 * Picomatch constants.
 * @return {Object}
 ]]

picomatch.constants = constants

--[[*
 * Expose "picomatch"
 ]]

return picomatch
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="445">
              <Properties>
                <string name="Name">scan</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/lib/scan.js

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local String = LuauPolyfill.String
type Object = LuauPolyfill.Object
type Token = any

local utils = require(CurrentModule.utils)
local Constants = require(CurrentModule.constants)
local CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET =
	Constants.CHAR_ASTERISK, --[[ * ]]
	Constants.CHAR_AT, --[[ @ ]]
	Constants.CHAR_BACKWARD_SLASH, --[[ \ ]]
	Constants.CHAR_COMMA, --[[ , ]]
	Constants.CHAR_DOT, --[[ . ]]
	Constants.CHAR_EXCLAMATION_MARK, --[[ ! ]]
	Constants.CHAR_FORWARD_SLASH, --[[ / ]]
	Constants.CHAR_LEFT_CURLY_BRACE, --[[ { ]]
	Constants.CHAR_LEFT_PARENTHESES, --[[ ( ]]
	Constants.CHAR_LEFT_SQUARE_BRACKET, --[[ [ ]]
	Constants.CHAR_PLUS, --[[ + ]]
	Constants.CHAR_QUESTION_MARK, --[[ ? ]]
	Constants.CHAR_RIGHT_CURLY_BRACE, --[[ } ]]
	Constants.CHAR_RIGHT_PARENTHESES, --[[ ) ]]
	Constants.CHAR_RIGHT_SQUARE_BRACKET --[[ ] ]]

local function isPathSeparator(code)
	return code == CHAR_FORWARD_SLASH or code == CHAR_BACKWARD_SLASH
end

local function depth(token)
	if token.isPrefix ~= true then
		token.depth = if Boolean.toJSBoolean(token.isGlobstar) then math.huge else 1
	end
end

--[[*
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 ]]

local function scan(input: string, options: Object?)
	local opts: Object = options or {}

	local length = #input + 1
	local scanToEnd = opts.parts == true or opts.scanToEnd == true
	local slashes = {}
	local tokens = {}
	local parts = {}

	local str = input
	local index = 0
	local start = 1
	local lastIndex = 1
	local isBrace = false
	local isBracket = false
	local isGlob = false
	local isExtglob = false
	local isGlobstar = false
	local braceEscaped = false
	local backslashes = false
	local negated = false
	local negatedExtglob = false
	local finished = false
	local braces = 0
	local prev
	local code
	-- ROBLOX FIXME: specify type explicitely to avoid type narrowing
	local token: Token = { value = "", depth = 0, isGlob = false }

	local function eos()
		return index >= length
	end
	local function peek()
		return String.charCodeAt(str, index + 1)
	end
	local function advance()
		prev = code
		index += 1
		return String.charCodeAt(str, index)
	end
	while index < length do
		code = advance()
		local next

		if code == CHAR_BACKWARD_SLASH then
			token.backslashes = true
			backslashes = token.backslashes
			code = advance()

			if code == CHAR_LEFT_CURLY_BRACE then
				braceEscaped = true
			end
			continue
		end

		if braceEscaped == true or code == CHAR_LEFT_CURLY_BRACE then
			braces += 1
			while eos() ~= true and Boolean.toJSBoolean((function()
				code = advance()
				return code
			end)()) do
				if code == CHAR_BACKWARD_SLASH then
					token.backslashes = true
					backslashes = token.backslashes
					advance()
					continue
				end

				if code == CHAR_LEFT_CURLY_BRACE then
					braces += 1
					continue
				end

				if
					braceEscaped ~= true
					and code == CHAR_DOT
					and (function()
						code = advance()
						return code
					end)() == CHAR_DOT
				then
					token.isBrace = true
					isBrace = token.isBrace
					token.isGlob = true
					isGlob = token.isGlob
					finished = true

					if scanToEnd == true then
						continue
					end

					break
				end

				if braceEscaped ~= true and code == CHAR_COMMA then
					token.isBrace = true
					isBrace = token.isBrace
					token.isGlob = true
					isGlob = token.isGlob
					finished = true

					if scanToEnd == true then
						continue
					end

					break
				end

				if code == CHAR_RIGHT_CURLY_BRACE then
					braces -= 1

					if braces == 0 then
						braceEscaped = false
						token.isBrace = true
						isBrace = token.isBrace
						finished = true
						break
					end
				end
			end

			if scanToEnd == true then
				continue
			end

			break
		end

		if code == CHAR_FORWARD_SLASH then
			table.insert(slashes, index)
			table.insert(tokens, token)
			token = { value = "", depth = 0, isGlob = false }

			if finished == true then
				continue
			end
			if prev == CHAR_DOT and index == start + 1 then
				start += 2
				continue
			end

			lastIndex = index + 1
			continue
		end

		if opts.noext ~= true then
			local isExtglobChar = code == CHAR_PLUS
				or code == CHAR_AT
				or code == CHAR_ASTERISK
				or code == CHAR_QUESTION_MARK
				or code == CHAR_EXCLAMATION_MARK

			if isExtglobChar == true and peek() == CHAR_LEFT_PARENTHESES then
				token.isGlob = true
				isGlob = token.isGlob
				token.isExtglob = true
				isExtglob = token.isExtglob
				finished = true
				if code == CHAR_EXCLAMATION_MARK and index == start then
					negatedExtglob = true
				end

				if scanToEnd == true then
					while
						eos() ~= true
						and Boolean.toJSBoolean((function()
							code = advance()
							return code
						end)())
					do
						if code == CHAR_BACKWARD_SLASH then
							token.backslashes = true
							backslashes = token.backslashes
							code = advance()
							continue
						end

						if code == CHAR_RIGHT_PARENTHESES then
							token.isGlob = true
							isGlob = token.isGlob
							finished = true
							break
						end
					end
					continue
				end
				break
			end
		end

		if code == CHAR_ASTERISK then
			if prev == CHAR_ASTERISK then
				token.isGlobstar = true
				isGlobstar = token.isGlobstar
			end
			token.isGlob = true
			isGlob = token.isGlob
			finished = true

			if scanToEnd == true then
				continue
			end
			break
		end

		if code == CHAR_QUESTION_MARK then
			token.isGlob = true
			isGlob = token.isGlob
			finished = true

			if scanToEnd == true then
				continue
			end
			break
		end

		if code == CHAR_LEFT_SQUARE_BRACKET then
			while eos() ~= true and Boolean.toJSBoolean((function()
				next = advance()
				return next
			end)()) do
				if next == CHAR_BACKWARD_SLASH then
					token.backslashes = true
					backslashes = token.backslashes
					advance()
					continue
				end

				if next == CHAR_RIGHT_SQUARE_BRACKET then
					token.isBracket = true
					isBracket = token.isBracket
					token.isGlob = true
					isGlob = token.isGlob
					finished = true
					break
				end
			end

			if scanToEnd == true then
				continue
			end

			break
		end

		if opts.nonegate ~= true and code == CHAR_EXCLAMATION_MARK and index == start then
			token.negated = true
			negated = token.negated
			start += 1
			continue
		end

		if opts.noparen ~= true and code == CHAR_LEFT_PARENTHESES then
			token.isGlob = true
			isGlob = token.isGlob

			if scanToEnd == true then
				while
					eos() ~= true
					and Boolean.toJSBoolean((function()
						code = advance()
						return code
					end)())
				do
					if code == CHAR_LEFT_PARENTHESES then
						token.backslashes = true
						backslashes = token.backslashes
						code = advance()
						continue
					end

					if code == CHAR_RIGHT_PARENTHESES then
						finished = true
						break
					end
				end
				continue
			end
			break
		end

		if isGlob == true then
			finished = true

			if scanToEnd == true then
				continue
			end

			break
		end
	end

	if opts.noext == true then
		isExtglob = false
		isGlob = false
	end

	local base = str
	local prefix = ""
	local glob = ""

	if start > 1 then
		prefix = String.slice(str, 1, start)
		str = String.slice(str, start)
		lastIndex -= start
	end

	if Boolean.toJSBoolean(base) and isGlob == true and lastIndex > 1 then
		base = String.slice(str, 1, lastIndex)
		glob = String.slice(str, lastIndex)
	elseif isGlob == true then
		base = ""
		glob = str
	else
		base = str
	end

	if Boolean.toJSBoolean(base) and base ~= "" and base ~= "/" and base ~= str then
		if isPathSeparator(String.charCodeAt(base, #base)) then
			base = String.slice(base, 1, -1)
		end
	end

	if opts.unescape == true then
		if Boolean.toJSBoolean(glob) then
			glob = utils.removeBackslashes(glob)
		end

		if Boolean.toJSBoolean(base) and backslashes == true then
			base = utils.removeBackslashes(base)
		end
	end

	local state = {
		prefix = prefix,
		input = input,
		start = start,
		base = base,
		glob = glob,
		isBrace = isBrace,
		isBracket = isBracket,
		isGlob = isGlob,
		isExtglob = isExtglob,
		isGlobstar = isGlobstar,
		negated = negated,
		negatedExtglob = negatedExtglob,
	}

	if opts.tokens == true then
		state.maxDepth = 0
		if not isPathSeparator(code) then
			table.insert(tokens, token)
		end
		state.tokens = tokens
	end

	if opts.parts == true or opts.tokens == true then
		local prevIndex

		for idx = 1, #slashes do
			local n = if Boolean.toJSBoolean(prevIndex) then prevIndex + 1 else start
			local i = slashes[idx]
			local value = String.slice(input, n, i)
			if Boolean.toJSBoolean(opts.tokens) then
				if idx == 1 and start ~= 1 then
					tokens[idx].isPrefix = true
					tokens[idx].value = prefix
				else
					tokens[idx].value = value
				end
				depth(tokens[idx])
				state.maxDepth += tokens[idx].depth
			end
			if idx ~= 1 or value ~= "" then
				table.insert(parts, value)
			end
			prevIndex = i
		end

		if Boolean.toJSBoolean(prevIndex) and prevIndex + 1 < #input then
			local value = String.slice(input, prevIndex + 1)
			table.insert(parts, value)

			if Boolean.toJSBoolean(opts.tokens) then
				tokens[#tokens].value = value
				depth(tokens[#tokens])
				state.maxDepth += tokens[#tokens].depth
			end
		end

		state.slashes = slashes
		state.parts = parts
	end

	return state
end

return scan
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="446">
              <Properties>
                <string name="Name">stringUtils</string>
                <string name="Source"><![CDATA[-- ROBLOX NOTE: no upstream

-- ROBLOX TODO: implement in LuauPolyfill

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

local RegExp = require(Packages.RegExp)
type RegExp = RegExp.RegExp

local function stringReplace(str: string, regExp: RegExp, replFn: (...any) -> string)
	local v = str
	local match = regExp:exec(v)
	local offset = 0
	local replaceArr = {}
	while match ~= nil and match.index ~= nil do
		-- ROBLOX FIXME Luau: analyze complains about match type being `Array<string> & {| index: number?, input: string?, n: number |}` instead of table
		local m = (match :: Array<string>)[1]
		local args: Array<string | number> = Array.slice(match, 1, match.n + 1)
		-- ROBLOX FIXME Luau: analyze doesn't recognize match.index as a number
		local index = (match.index :: any) + offset

		table.insert(args, index)

		local replace = replFn(table.unpack(args))

		table.insert(replaceArr, {
			from = index,
			length = #m,
			value = replace,
		})

		-- ROBLOX FIXME Luau: analyze doesn't recognize match.index as a number
		offset += #m + (match.index :: any) - 1
		v = str:sub(offset + 1)
		match = regExp:exec(v)
	end
	local result = str:sub(1)
	for _, rep in ipairs(Array.reverse(replaceArr)) do
		local from, length, value = rep.from, rep.length, rep.value
		local prefix = result:sub(1, from - 1)
		local suffix = result:sub(from + length)

		result = prefix .. value .. suffix
	end

	return result
end

return {
	stringReplace = stringReplace,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="447">
              <Properties>
                <string name="Name">utils</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/micromatch/picomatch/tree/2.3.1/lib/utils.js

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local String = LuauPolyfill.String
type Object = LuauPolyfill.Object

local exports = {}

-- ROBLOX deviation: skipping path
-- local path = require("path")
-- ROBLOX FIXME: make proper platform check
-- local win32 = process.platform == "win32"
local win32 = false
local Constants = require(CurrentModule.constants)
-- ROBLOX TODO START: implement missing RegExp when 'g' flag available (or reimplement without RegExp)
local REGEX_SPECIAL_CHARS = Constants.REGEX_SPECIAL_CHARS
-- local REGEX_BACKSLASH, REGEX_REMOVE_BACKSLASH, REGEX_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_GLOBAL =
-- 	Constants.REGEX_BACKSLASH,
-- 	Constants.REGEX_REMOVE_BACKSLASH,
-- 	Constants.REGEX_SPECIAL_CHARS,
local REGEX_SPECIAL_CHARS_GLOBAL = Constants.REGEX_SPECIAL_CHARS_GLOBAL
-- ROBLOX TODO END

function exports.isObject(val)
	return val ~= nil and typeof(val) == "table" and not Array.isArray(val)
end
function exports.hasRegexChars(str)
	return string.match(str, REGEX_SPECIAL_CHARS) ~= nil
end
function exports.isRegexChar(str: string)
	return #str == 1 and exports.hasRegexChars(str)
end
-- ROBLOX deviation START: additional dependencies
local String_replace = require(CurrentModule.stringUtils).stringReplace
-- ROBLOX deviation END

function exports.escapeRegex(str): string
	-- ROBLOX deviation: using custom String_replace function
	return String_replace(str, REGEX_SPECIAL_CHARS_GLOBAL, function(m)
		return "\\" .. m
	end)
	-- return str:replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1")
	-- ROBLOX deviation END
end
function exports.toPosixSlashes(str): string
	error("toPosixSlashes not implemented")
	-- return str:replace(REGEX_BACKSLASH, "/")
end

function exports.removeBackslashes(str): string
	error("removeBackslashes not implemented")
	-- return str:replace(REGEX_REMOVE_BACKSLASH, function(match)
	-- 	return match == "\\" and "" or match
	-- end)
end
-- ROBLOX TODO END

function exports.supportsLookbehinds()
	-- ROBLOX CHECK: do we suppoert lookbehind in Lua?
	-- ROBLOX deviation: no equivalent check in Lua. Returning always false
	return false
end

function exports.isWindows(options: Object?): boolean
	if typeof(options) == "table" and typeof(options.windows) == "boolean" then
		return options.windows
	end
	--[[
		ROBLOX deviation: not using path.sep as it's not available
		original code:
		return win32 === true || path.sep === '\\';
	]]
	return win32 == true
end

function exports.escapeLast(input: string, char: string, lastIdx: number?)
	local idx = String.lastIndexOf(input, char, lastIdx)
	if idx == -1 then
		return input
	end
	if input:sub(idx - 1, idx - 1) == "\\" then
		return exports.escapeLast(input, char, idx - 1)
	end
	return ("%s%s"):format(String.slice(input, 1, idx), String.slice(input, idx))
end

function exports.removePrefix(input: string, state_: Object?)
	local state: Object = state_ or {}

	local output = input
	if String.startsWith(output, "./") then
		output = String.slice(output, 3)
		state.prefix = "./"
	end
	return output
end
function exports.wrapOutput(input, state_: Object?, options_: Object?)
	local state: Object = state_ or {}
	local options: Object = options_ or {}

	local prepend = if Boolean.toJSBoolean(options.contains) then "" else "^"
	local append = if Boolean.toJSBoolean(options.contains) then "" else "$"

	local output = ("%s(?:%s)%s"):format(prepend, input, append)
	if state.negated == true then
		output = ("(?:^(?!%s).*$)"):format(output)
	end
	return output
end

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="448">
            <Properties>
              <string name="Name">PrettyFormat</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

-- ROBLOX deviation: ansi-styles not ported

local CurrentModule = script
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local extends = LuauPolyfill.extends
local isNaN = LuauPolyfill.Number.isNaN

local Collections = require(CurrentModule.Collections)
local printTableEntries = Collections.printTableEntries
local printMapEntries = Collections.printMapEntries
local printListItems = Collections.printListItems

local AsymmetricMatcher = require(CurrentModule.plugins.AsymmetricMatcher)
local ConvertAnsi = require(CurrentModule.plugins.ConvertAnsi)
local RobloxInstance = require(CurrentModule.plugins.RobloxInstance)
local ReactElement = require(CurrentModule.plugins.ReactElement)
local ReactTestComponent = require(CurrentModule.plugins.ReactTestComponent)
local RedactStackTraces = require(CurrentModule.plugins.RedactStackTraces)

local JestGetType = require(Packages.JestGetType)
local getType = JestGetType.getType
local isRobloxBuiltin = JestGetType.isRobloxBuiltin

local Types = require(CurrentModule.Types)
export type Colors = Types.Colors
export type CompareKeys = Types.CompareKeys
export type Config = Types.Config
export type Options = Types.Options
export type OptionsReceived = Types.OptionsReceived
export type OldPlugin = Types.OldPlugin
export type NewPlugin = Types.NewPlugin
export type Plugin = Types.Plugin
export type Plugins = Types.Plugins
export type PrettyFormatOptions = Types.PrettyFormatOptions
export type Printer = Types.Printer
export type Refs = Types.Refs
export type Theme = Types.Theme

local PrettyFormatPluginError = extends(Error, "PrettyFormatPluginError", function(self, message)
	self.name = "PrettyFormatPluginError"
	self.message = message
end)

-- ROBLOX deviation: isToStringedArrayType omitted because lua has no typed arrays

local printer, createIndent

local function printNumber(val: number): string
	-- explicitly check for nan because string representation is platform dependent
	if isNaN(val) then
		return "nan"
	end
	return tostring(val)
end

-- ROBLOX deviation: printBigInt omitted

local function printFunction(val: any, printFunctionName: boolean): string
	if not printFunctionName then
		return "[Function]"
	end
	local functionName = debug.info(val, "n")
	if functionName == nil or functionName == "" then
		functionName = "anonymous"
	end
	return "[Function " .. functionName .. "]"
end

local function printSymbol(val: any): string
	return tostring(val)
end

local function printError(val)
	return "[" .. tostring(val) .. "]"
end

-- /**
--  * The first port of call for printing an object, handles most of the
--  * data-types in JS.
--  */
local function printBasicValue(
	val: any,
	printFunctionName: boolean,
	escapeRegex: boolean,
	escapeString: boolean
): string | nil
	local typeOf = getType(val)

	-- ROBLOX deviation: we check for boolean type since we can't do strict equality comparison
	-- ROBLOX deviation: undefined is treated as nil in lua
	if typeOf == "boolean" or typeOf == "nil" then
		return tostring(val)
	end

	if typeOf == "number" then
		return printNumber(val)
	end

	-- ROBLOX deviation: printBigInt omitted because lua has no bingint type
	if typeOf == "string" then
		if escapeString then
			val = val:gsub("\\", "\\\\")
			val = val:gsub('"', '\\"')
			return '"' .. val .. '"'
		end
		return '"' .. val .. '"'
	end
	if typeOf == "function" then
		return printFunction(val, printFunctionName)
	end
	if typeOf == "symbol" then
		return printSymbol(val)
	end

	-- ROBLOX deviation: modified to use Roblox DateTime
	if typeOf == "DateTime" then
		-- Roblox DateTime:ToIsoDate doesn't include milliseconds
		return string.sub(val:ToIsoDate(), 1, -2)
			.. "."
			.. string.format("%03d", val:ToUniversalTime().Millisecond)
			.. "Z"
	end

	if typeOf == "error" then
		return printError(val)
	end

	if typeOf == "regexp" then
		val = tostring(val)
		if escapeRegex then
			-- https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
			val = val:gsub("[\\%^%$%*%+%?%.%(%)|%[%]{}]", "\\%1")
			return val
		end
		return val
	end

	-- ROBLOX deviation: output classname for Instance types
	if typeOf == "Instance" then
		return val.ClassName
	end

	-- ROBLOX deviation: output DataType for builtin types
	if isRobloxBuiltin(val) then
		return string.format("%s(%s)", typeOf, tostring(val))
	end

	-- ROBLOX deviation: catchall for arbitrary userdata
	if typeOf == "userdata" then
		return tostring(val)
	end

	-- ROBLOX deviation: omitted all the JS types

	return nil
end

-- ROBLOX deviation: function to check whether a table is an array
-- https://stackoverflow.com/questions/7526223/how-do-i-know-if-a-table-is-an-array/52697380#52697380
local function is_array(t)
	if type(t) ~= "table" then
		return false
	end

	-- objects always return empty size
	if #t > 0 then
		return true
	end

	-- only object can have empty length with elements inside
	for k, v in pairs(t) do
		return false
	end

	-- if no elements it can be array and not at same time
	return true
end

-- /**
--  * Handles more complex objects ( such as objects with circular references.
--  * maps and sets etc )
--  */
local function printComplexValue(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	hasCalledToJSON: boolean?
): string
	if table.find(refs, val) ~= nil then
		return "[Circular]"
	end
	refs = { unpack(refs) }
	table.insert(refs, val)

	depth = depth + 1
	local hitMaxDepth = depth > config.maxDepth
	local min = config.min

	if
		config.callToJSON
		and not hitMaxDepth
		and val.toJSON
		and typeof(val.toJSON) == "function"
		and not hasCalledToJSON
	then
		return printer(val.toJSON(), config, indentation, depth, refs, true)
	end

	-- ROBLOX deviation start: rewrote this part since lua only has tables
	if hitMaxDepth then
		if getType(val) == "set" then
			return "[Set]"
		else
			return "[Table]"
		end
	end
	local retval = ""
	if not min then
		retval = if config.printBasicPrototype then "Table" .. " " else ""
	end

	if is_array(val) then
		return retval .. "{" .. printListItems(val, config, indentation, depth, refs, printer) .. "}"
	end

	if getType(val) == "set" then
		if hitMaxDepth then
			return "[Set]"
		else
			return "Set {" .. printListItems(val._array, config, indentation, depth, refs, printer) .. "}"
		end
	end

	if getType(val) == "map" then
		if hitMaxDepth then
			return "[Map]"
		else
			return "Map {" .. printMapEntries(val._map, config, indentation, depth, refs, printer) .. "}"
		end
	end

	return retval .. "{" .. printTableEntries(val, config, indentation, depth, refs, printer) .. "}"
	-- ROBLOX deviation end
end

local function isNewPlugin(plugin_: Plugin): boolean
	return (plugin_ :: NewPlugin).serialize ~= nil
end

function printPlugin(plugin_: Plugin, val: any, config: Config, indentation: string, depth: number, refs: Refs): string
	local printed

	local ok, err = pcall(function()
		if isNewPlugin(plugin_) then
			printed = (plugin_ :: NewPlugin).serialize(val, config, indentation, depth, refs, printer)
		else
			printed = (plugin_ :: OldPlugin).print(val, function(valChild)
				return printer(valChild, config, indentation, depth, refs)
			end, function(str)
				local indentationNext = indentation .. config.indent
				return indentationNext .. str:gsub("\n", "\n" .. indentationNext)
			end, {
				edgeSpacing = config.spacingOuter,
				min = config.min,
				spacing = config.spacingInner,
			}, config.colors)
		end
	end)
	if not ok then
		-- ROBLOX deviation START: float the error up if a PrettyFormatPluginError is already thrown to avoid nesting
		if typeof(err) == "table" and err.name == "PrettyFormatPluginError" then
			error(err)
		end
		-- ROBLOX deviation END
		error(PrettyFormatPluginError(err))
	end

	if typeof(printed) ~= "string" then
		error(
			Error(
				string.format(
					'pretty-format: Plugin must return type "string" but instead returned "%s".',
					typeof(printed)
				)
			)
		)
	end
	return printed
end

-- ROBLOX FIXME Luau: should infer this function a Plugin | nil, with no warnings
local function findPlugin(plugins: Plugins, val: any): Plugin | nil
	for _, p in ipairs(plugins) do
		local ok, ret = pcall(p.test, val)
		if not ok then
			error(PrettyFormatPluginError(ret))
		elseif ret then
			return p
		end
	end

	return nil
end

function printer(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	hasCalledToJSON: boolean?
): string
	local plugin_ = findPlugin(config.plugins, val)
	if plugin_ ~= nil then
		return printPlugin(plugin_, val, config, indentation, depth, refs)
	end

	local basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString)
	if basicResult ~= nil then
		return basicResult
	end

	return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON)
end

-- ROBLOX deviation: color formatting omitted

local DEFAULT_OPTIONS = {
	callToJSON = true,
	-- ROBLOX deviation: using Object.None instead of nil because assigning nil is no different from not assigning value at all
	compareKeys = Object.None,
	escapeRegex = false,
	escapeString = true,
	highlight = false,
	indent = 2,
	maxDepth = math.huge,
	maxWidth = math.huge,
	min = false,
	plugins = {},
	printBasicPrototype = true,
	-- ROBLOX deviation: option to omit default Roblox Instance values
	printInstanceDefaults = true,
	printFunctionName = true,
	-- ROBLOX deviation: stable stacktrace snapshots
	redactStackTracesInStrings = false,
	-- ROBLOX deviation: color formatting omitted
	theme = nil,
}

local function validateOptions(options: OptionsReceived)
	for k, _ in pairs(options) do
		if DEFAULT_OPTIONS[k] == nil then
			error(Error(string.format('pretty-format: Unknown option "%s".', tostring(k))))
		end
	end

	if options.min and options.indent ~= nil and options.indent ~= 0 then
		error(Error('pretty-format: Options "min" and "indent" cannot be used together.'))
	end

	-- ROBLOX deviation: color formatting omitted
end

-- ROBLOX deviation: color formatting omitted

-- ROBLOX deviation: replaced most get methods to reduce code repetition
local function getOption(options: OptionsReceived?, opt): any
	if options and options[opt] ~= nil then
		return options[opt]
	end
	return DEFAULT_OPTIONS[opt]
end

local function getIndent(options: OptionsReceived?)
	if options and options.min then
		return ""
	end
	local number = DEFAULT_OPTIONS.indent
	if options and options.indent ~= nil then
		number = options.indent
	end
	return createIndent(number)
end

local function getSpacingInner(options: OptionsReceived?)
	if options and options.min then
		return " "
	end
	return "\n"
end

local function getSpacingOuter(options: OptionsReceived?)
	if options and options.min then
		return ""
	end
	return "\n"
end

-- ROBLOX deviation: rewrote to replace ternary operators and reduce code repetition
local function getConfig(options: OptionsReceived?): Config
	return {
		callToJSON = getOption(options, "callToJSON"),
		-- ROBLOX deviation: color formatting omitted
		colors = nil,
		compareKeys = if options ~= nil and typeof(options.compareKeys) == "function"
			then options.compareKeys
			else DEFAULT_OPTIONS.compareKeys,
		escapeRegex = getOption(options, "escapeRegex"),
		escapeString = getOption(options, "escapeString"),
		indent = getIndent(options),
		maxDepth = getOption(options, "maxDepth"),
		maxWidth = getOption(options, "maxWidth"),
		min = getOption(options, "min"),
		plugins = getOption(options, "plugins"),
		printBasicPrototype = if options ~= nil and options.printBasicPrototype ~= nil
			then options.printBasicPrototype
			else true,
		-- ROBLOX deviation: option to omit default Roblox Instance values
		printInstanceDefaults = getOption(options, "printInstanceDefaults"),
		-- ROBLOX deviation: stable stack traces in snapshots
		redactStackTracesInStrings = getOption(options, "redactStackTracesInStrings"),
		printFunctionName = getOption(options, "printFunctionName"),
		spacingInner = getSpacingInner(options),
		spacingOuter = getSpacingOuter(options),
	}
end

function createIndent(indent: number): string
	-- ROBLOX deviation: used string repeat instead of a table join, also don't need the +1
	return string.rep(" ", indent)
end

-- /**
--  * Returns a presentation string of your `val` object
--  * @param val any potential JavaScript object
--  * @param options Custom settings
--  */
local function format(val: any, options: OptionsReceived?): string
	if options then
		validateOptions(options)
		if options.plugins then
			local plugin_ = findPlugin(options.plugins :: Plugins, val)
			if plugin_ ~= nil then
				return printPlugin(plugin_, val, getConfig(options), "", 0, {})
			end
		end
	end

	local basicResult = printBasicValue(
		val,
		getOption(options, "printFunctionName"),
		getOption(options, "escapeRegex"),
		getOption(options, "escapeString")
	)
	if basicResult ~= nil then
		return basicResult
	end

	-- ROBLOX deviation: luau doesn't handle optional arguments, explicitly pass nil
	return printComplexValue(val, getConfig(options), "", 0, {}, nil)
end

local plugins = {
	AsymmetricMatcher = AsymmetricMatcher,
	ConvertAnsi = ConvertAnsi,
	ReactElement = ReactElement,
	ReactTestComponent = ReactTestComponent,
	-- ROBLOX deviation: Roblox Instance matchers
	RobloxInstance = RobloxInstance,
	-- ROBLOX deviation: stable stacktrace snapshots
	RedactStackTraces = RedactStackTraces,
}

-- ROBLOX deviation start: protect against bad reads
setmetatable(plugins, {
	__index = function(self, key)
		error(Error.new("Can't find pretty-format plugin: " .. key))
	end,
})
-- ROBLOX deviation end

return {
	format = format,
	default = format,

	plugins = plugins,
	DEFAULT_OPTIONS = DEFAULT_OPTIONS,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="449">
              <Properties>
                <string name="Name">Collections</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/collections.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Array = LuauPolyfill.Array
local Types = require(CurrentModule.Types)
type CompareKeys = Types.CompareKeys
type Config = Types.Config
type Refs = Types.Refs
type Printer = Types.Printer

-- ROBLOX deviation: deviates from upstream substantially since Lua only has tables
-- we only have two functions
-- `printTableEntries` for formatting key, value pairs and
-- `printListItems` for formatting arrays

-- ROBLOX deviation: printIteratorEntries is renamed to printTableEntries
-- /**
--  * Return entries of a table
--  * with spacing, indentation, and comma
--  * without surrounding punctuation (for example, braces)
--  */
local function printTableEntries(
	t: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer,
	separator_: string?
): string
	local separator = if separator_ then separator_ else ": "
	local result = ""

	-- ROBLOX TODO: remove this inline if-expression and function once Array.sort() fix merges
	local keys = Array.sort(
		Object.keys(t),
		if config.compareKeys ~= nil and config.compareKeys ~= Object.None
			then config.compareKeys
			else function(a, b)
				return if type(a) .. tostring(a) < type(b) .. tostring(b)
					then -1
					else if type(a) .. tostring(a) == type(b) .. tostring(b) then 0 else 1
			end
	)

	if #keys > 0 then
		result ..= config.spacingOuter

		local indentationNext = indentation .. config.indent

		for i = 1, #keys do
			local k = keys[i]
			local v = t[k]

			result ..= indentationNext

			local name = printer(k, config, indentationNext, depth, refs)
			local value = printer(v, config, indentationNext, depth, refs)

			result ..= name .. separator .. value

			if i < #keys then
				result ..= (",%s"):format(tostring(config.spacingInner))
			elseif not config.min then
				result ..= ","
			end
		end

		result ..= config.spacingOuter .. indentation
	end

	return result
end

-- ROBLOX deviation START: function is not present upstream
--[[*
 * Return entries of a map
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, braces)
 *]]
local function printMapEntries(
	t: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer,
	separator_: string?
): string
	local separator = if separator_ then separator_ else " => "
	local result = ""

	local keys = Array.sort(
		Object.keys(t),
		if config.compareKeys ~= nil and config.compareKeys ~= Object.None
			then config.compareKeys
			else function(a, b)
				return if type(a) .. tostring(a) < type(b) .. tostring(b)
					then -1
					else if type(a) .. tostring(a) == type(b) .. tostring(b) then 0 else 1
			end
	)

	if #keys > 0 then
		result ..= config.spacingOuter

		local indentationNext = indentation .. config.indent

		for i = 1, #keys do
			local k = keys[i]
			local v = t[k]

			result ..= indentationNext

			if i == config.maxWidth + 1 then
				result ..= "\u{2026}"
				break
			end

			local name = printer(k, config, indentationNext, depth, refs)
			local value = printer(v, config, indentationNext, depth, refs)

			result ..= name .. separator .. value

			if i < #keys then
				result ..= (",%s"):format(tostring(config.spacingInner))
			elseif not config.min then
				result ..= ","
			end
		end

		result ..= config.spacingOuter .. indentation
	end

	return result
end
-- ROBLOX deviation END

--[[*
 * Return items (for example, of an array)
 * with spacing, indentation, and comma
 * without surrounding punctuation (for example, brackets)
 *]]
local function printListItems(
	list: { [number]: any },
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	local result = ""

	if #list > 0 then
		result = result .. config.spacingOuter

		local indentationNext = indentation .. config.indent

		for i = 1, #list do
			result ..= indentationNext

			-- ROBLOX deviation START: off by one due to lua 1-indexing
			-- if i == config.maxWidth then
			if i == config.maxWidth + 1 then
				-- ROBLOX deviation END
				result ..= "\u{2026}"
				break
			end

			if list[i] ~= nil then
				result ..= printer(list[i], config, indentationNext, depth, refs)
			end

			-- ROBLOX deviation: < #list instead of #list - 1 because of 1-indexing
			if i < #list then
				result ..= (",%s"):format(tostring(config.spacingInner))
			elseif not config.min then
				result ..= ","
			end
		end

		result = result .. config.spacingOuter .. indentation
	end

	return result
end

return {
	printTableEntries = printTableEntries,
	printMapEntries = printMapEntries,
	printListItems = printListItems,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="450">
              <Properties>
                <string name="Name">Types</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/types.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

export type Colors = {
	comment: { close: string, open: string },
	content: { close: string, open: string },
	prop: { close: string, open: string },
	tag: { close: string, open: string },
	value: { close: string, open: string },
}
type Indent = (string) -> string
export type Refs = { [number]: any }
type Print = (any) -> string

export type Theme = {
	comment: string,
	content: string,
	prop: string,
	tag: string,
	value: string,
}

type ThemeReceived = {
	comment: string?,
	content: string?,
	prop: string?,
	tag: string?,
	value: string?,
}

export type CompareKeys = ((a: string, b: string) -> number) | nil

export type Options = {
	callToJSON: boolean,
	compareKeys: CompareKeys,
	escapeRegex: boolean,
	escapeString: boolean,
	highlight: boolean,
	indent: number,
	maxDepth: number,
	min: boolean,
	plugins: Plugins,
	printBasicPrototype: boolean,
	printInstanceDefaults: boolean,
	printFunctionName: boolean,
	-- ROBLOX deviation: stable stacktrace snapshots
	redactStackTracesInStrings: boolean?,
	theme: Theme,
}

export type PrettyFormatOptions = {
	callToJSON: boolean?,
	compareKeys: CompareKeys,
	escapeRegex: boolean?,
	escapeString: boolean?,
	highlight: boolean?,
	indent: number?,
	maxDepth: number?,
	min: boolean?,
	plugins: Plugins?,
	printBasicPrototype: boolean?,
	printInstanceDefaults: boolean?,
	printFunctionName: boolean?,
	-- ROBLOX deviation: stable stacktrace snapshots
	redactStackTracesInStrings: boolean?,
	theme: ThemeReceived?,
}

export type OptionsReceived = PrettyFormatOptions

export type Config = {
	callToJSON: boolean,
	compareKeys: CompareKeys,
	-- ROBLOX deviation: we don't support colors?
	colors: Colors?,
	escapeRegex: boolean,
	escapeString: boolean,
	indent: string,
	maxDepth: number,
	maxWidth: number,
	min: boolean,
	plugins: Plugins,
	printBasicPrototype: boolean,
	printInstanceDefaults: boolean,
	printFunctionName: boolean,
	-- ROBLOX deviation: stable stacktrace snapshots
	redactStackTracesInStrings: boolean,
	spacingInner: string,
	spacingOuter: string,
}

export type Printer = (any, Config, string, number, Refs, boolean?) -> string

type Test = (any) -> boolean

export type NewPlugin = {
	serialize: (any, Config, string, number, Refs, Printer) -> string,
	test: Test,
}

type PluginOptions = {
	edgeSpacing: string,
	min: boolean,
	spacing: string,
}

export type OldPlugin = {
	-- ROBLOX deviation: we don't support colors?
	print: (any, Print, Indent, PluginOptions, Colors?) -> string,
	test: Test,
}

export type Plugin = NewPlugin | OldPlugin

export type Plugins = { [number]: Plugin }

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="451">
              <Properties>
                <string name="Name">plugins</string>
              </Properties>
              <Item class="ModuleScript" referent="452">
                <Properties>
                  <string name="Name">AsymmetricMatcher</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/plugins/AsymmetricMatcher.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol

local Collections = require(CurrentModule.Collections)
local printListItems = Collections.printListItems
local printObjectProperties = Collections.printTableEntries

local Types = require(CurrentModule.Types)
type Config = Types.Config
type Refs = Types.Refs
type Printer = Types.Printer

local asymmetricMatcher = Symbol.for_("jest.asymmetricMatcher")
local SPACE = " "

-- ROBLOX deviation: stringContaining shouldn't accept string patterns so we unescape special characters
local function unescape(s: string): string
	return s:gsub("%%([%$%%%^%*%(%)%.%[%]%+%-%?])", "%1")
end

local function serialize(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	local stringedValue = val:toString()

	if stringedValue == "ArrayContaining" or stringedValue == "ArrayNotContaining" then
		depth = depth + 1
		if depth > config.maxDepth then
			return "[" .. stringedValue .. "]"
		end
		return stringedValue
			.. SPACE
			.. "{"
			.. printListItems(val.sample, config, indentation, depth, refs, printer)
			.. "}"
	end

	if stringedValue == "ObjectContaining" or stringedValue == "ObjectNotContaining" then
		depth = depth + 1
		if depth > config.maxDepth then
			return "[" .. stringedValue .. "]"
		end
		return stringedValue
			.. SPACE
			.. "{"
			.. printObjectProperties(val.sample, config, indentation, depth, refs, printer)
			.. "}"
	end

	if stringedValue == "StringMatching" or stringedValue == "StringNotMatching" then
		return stringedValue .. SPACE .. printer(val.sample, config, indentation, depth, refs)
	end

	if stringedValue == "StringContaining" or stringedValue == "StringNotContaining" then
		return stringedValue .. SPACE .. printer(unescape(val.sample), config, indentation, depth, refs)
	end

	if typeof(val.toAsymmetricMatcher) ~= "function" then
		-- ROBLOX deviation START: do not print constructor name as we don't have it
		-- error(
		-- 	Error.new(
		-- 		("Asymmetric matcher %s does not implement toAsymmetricMatcher()"):format(
		-- 			tostring(val.constructor.name)
		-- 		)
		-- 	)
		-- )
		error("Asymmetric matcher does not implement toAsymmetricMatcher()")
		-- ROBLOX deviation END
	end

	return val:toAsymmetricMatcher()
end

local function test(val: any): boolean
	return typeof(val) == "table" and val ~= nil and val["$$typeof"] == asymmetricMatcher
end

return {
	serialize = serialize,
	test = test,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="453">
                <Properties>
                  <string name="Name">ConvertAnsi</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/plugins/ConvertAnsi.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local Types = require(CurrentModule.Types)
type Config = Types.Config
type Refs = Types.Refs
type Printer = Types.Printer

local chalk = require(Packages.ChalkLua)

-- ROBLOX deviation: this regex attempts to match both ansi16 and ansi256 regexes
local ansiRegex = string.char(27) .. "%[%d+;?5?;?%d*m"

local ansiLookupTable = {
	[chalk.red.close] = "</>",
	[chalk.green.close] = "</>",
	[chalk.cyan.close] = "</>",
	[chalk.gray.close] = "</>",
	[chalk.white.close] = "</>",
	[chalk.yellow.close] = "</>",
	[chalk.bgRed.close] = "</>",
	[chalk.bgGreen.close] = "</>",
	[chalk.bgYellow.close] = "</>",
	[chalk.inverse.close] = "</>",
	[chalk.dim.close] = "</>",
	[chalk.bold.close] = "</>",
	[chalk.reset.open] = "</>",
	[chalk.reset.close] = "</>",
	[chalk.red.open] = "<red>",
	[chalk.green.open] = "<green>",
	[chalk.cyan.open] = "<cyan>",
	[chalk.gray.open] = "<gray>",
	[chalk.white.open] = "<white>",
	[chalk.yellow.open] = "<yellow>",
	[chalk.bgRed.open] = "<bgRed>",
	[chalk.bgGreen.open] = "<bgGreen>",
	[chalk.bgYellow.open] = "<bgYellow>",
	[chalk.inverse.open] = "<inverse>",
	[chalk.dim.open] = "<dim>",
	[chalk.bold.open] = "<bold>",
}

local function toHumanReadableAnsi(text: string)
	return text:gsub(ansiRegex, function(match)
		if ansiLookupTable[match] then
			return ansiLookupTable[match]
		else
			return ""
		end
	end)
end

local function test(val: any)
	return typeof(val) == "string" and Boolean.toJSBoolean(val:match(ansiRegex))
end

local function serialize(val: string, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer)
	return printer(toHumanReadableAnsi(val), config, indentation, depth, refs)
end

return {
	test = test,
	serialize = serialize,
	-- ROBLOX deviation: exporting ansiRegex since we don't have a separate module for it
	ansiRegex = ansiRegex,
	-- ROBLOX deviation: exporting toHumanReadableAnsi
	toHumanReadableAnsi = toHumanReadableAnsi,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="454">
                <Properties>
                  <string name="Name">ReactElement</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/plugins/ReactElement.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
local exports = {}
local ReactIs = require(Packages.ReactIs)
local typesModule = require(script.Parent.Parent.Types)
type Config = typesModule.Config
type NewPlugin = typesModule.NewPlugin
type Printer = typesModule.Printer
type Refs = typesModule.Refs
local markupModule = require(script.Parent.lib.markup)
local printChildren = markupModule.printChildren
local printElement = markupModule.printElement
local printElementAsLeaf = markupModule.printElementAsLeaf
local printProps = markupModule.printProps

-- Given element.props.children, or subtree during recursive traversal,
-- return flattened array of children.
local function getChildren(arg: unknown, children_: Array<unknown>?)
	local children = children_ or {}
	if Array.isArray(arg) then
		Array.forEach(arg :: Array<unknown>, function(item)
			getChildren(item, children)
		end)
	elseif arg ~= nil and arg ~= false then
		table.insert(children, arg)
	end
	return children
end

local function getType(element: any)
	local type_ = element.type
	if typeof(type_) == "string" then
		return type_
	end
	-- ROBLOX deviation START: functions can't have properties in Lua
	if typeof(type_) == "function" then
		local typeName = debug.info(type_, "n")
		return if Boolean.toJSBoolean(typeName) then typeName else "Unknown"
	end
	if typeof(type_) == "table" then
		local metatable = getmetatable(type_)
		if metatable ~= nil and typeof(metatable.__call) == "function" then
			return if Boolean.toJSBoolean(type_.displayName)
				then type_.displayName
				elseif Boolean.toJSBoolean(type_.name) then type_.name
				else "Unknown"
		end
	end
	-- ROBLOX deviation END

	if ReactIs.isFragment(element) then
		return "React.Fragment"
	end
	if ReactIs.isSuspense(element) then
		return "React.Suspense"
	end
	if typeof(type_) == "table" and type_ ~= nil then
		if ReactIs.isContextProvider(element) then
			return "Context.Provider"
		end
		if ReactIs.isContextConsumer(element) then
			return "Context.Consumer"
		end

		if ReactIs.isForwardRef(element) then
			if Boolean.toJSBoolean(type_.displayName) then
				return type_.displayName
			end

			-- ROBLOX deviation START: check if type_.render is callable table
			local functionName = if typeof(type_.render) == "function"
					and Boolean.toJSBoolean(debug.info(type_.render, "n"))
				then debug.info(type_.render, "n")
				else if typeof(type_.render) == "table"
					then if Boolean.toJSBoolean(type_.render.displayName)
						then type_.render.displayName
						elseif Boolean.toJSBoolean(type_.render.name) then type_.render.name
						else ""
					else ""
			-- ROBLOX deviation END

			return if functionName ~= "" then "ForwardRef(" .. functionName .. ")" else "ForwardRef"
		end

		if ReactIs.isMemo(element) then
			local functionName = if Boolean.toJSBoolean(type_.displayName)
				then type_.displayName
				elseif
					typeof(type_.type) == "table" -- ROBLOX deviation: can't index functions in Lua
					and Boolean.toJSBoolean(type_.type.displayName)
				then type_.type.displayName
				elseif
					typeof(type_.type) == "function" and Boolean.toJSBoolean(debug.info(type_.type, "n"))
				then debug.info(type_.type, "n")
				else ""

			return if functionName ~= "" then "Memo(" .. functionName .. ")" else "Memo"
		end
	end
	return "UNDEFINED"
end

local function getPropKeys(element: any)
	local props = element.props

	return Array.sort(Array.filter(Object.keys(props), function(key)
		return key ~= "children" and props[key] ~= nil
	end))
end

--[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]]
--[[ export const serialize: NewPlugin['serialize'] ]]
local function serialize(
	element: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	depth += 1
	return if depth > config.maxDepth
		then printElementAsLeaf(getType(element), config)
		else printElement(
			getType(element),
			printProps(getPropKeys(element), element.props, config, indentation .. config.indent, depth, refs, printer),
			printChildren(
				getChildren(element.props.children),
				config,
				indentation .. config.indent,
				depth,
				refs,
				printer
			),
			config,
			indentation
		)
end

exports.serialize = serialize
--[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]]
--[[ export const test: NewPlugin['test'] ]]
local function test(val: unknown): boolean
	return val ~= nil and ReactIs.isElement(val)
end
exports.test = test

local plugin: NewPlugin = { serialize = serialize, test = test }

exports.default = plugin
return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="455">
                <Properties>
                  <string name="Name">ReactTestComponent</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/plugins/ReactTestComponent.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent.Parent
local Packages = CurrentModule.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local Symbol = LuauPolyfill.Symbol
type Array<T> = LuauPolyfill.Array<T>
type Symbol = LuauPolyfill.Symbol
type Record<K, T> = { [K]: T }

local exports = {}

local typesModule = require(script.Parent.Parent.Types)
type Config = typesModule.Config
type NewPlugin = typesModule.NewPlugin
type Printer = typesModule.Printer
type Refs = typesModule.Refs
local markupModule = require(script.Parent.lib.markup)
local printChildren = markupModule.printChildren
local printElement = markupModule.printElement
local printElementAsLeaf = markupModule.printElementAsLeaf
local printProps = markupModule.printProps

export type ReactTestObject = {
	-- ROBLOX deviation: using number to match roact-alignment
	["$$typeof"]: number,
	type: string,
	props: Record<string, unknown>?,
	children: (nil | Array<ReactTestChild>)?,
}

-- Child can be `number` in Stack renderer but not in Fiber renderer.
type ReactTestChild = ReactTestObject | string | number

-- ROBLOX deviation: Symbol is always available in polyfills
local testSymbol = Symbol.for_("react.test.json")

local function getPropKeys(object: ReactTestObject)
	local props = object.props

	return if props ~= nil
		then Array.sort(Array.filter(Object.keys(props), function(key)
			return props[key] ~= nil
		end))
		else {}
end

-- local serialize: Function --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ NewPlugin['serialize'] ]]
local function serialize(
	object: ReactTestObject,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
)
	depth += 1
	return if depth > config.maxDepth
		then printElementAsLeaf(object.type, config)
		else printElement(
			object.type,
			if object.props ~= nil
				then printProps(
					getPropKeys(object),
					object.props,
					config,
					indentation .. config.indent,
					depth,
					refs,
					printer
				)
				else "",
			if object.children ~= nil
				then printChildren(object.children, config, indentation .. config.indent, depth, refs, printer)
				else "",
			config,
			indentation
		)
end
exports.serialize = serialize

-- local test: any --[[ ROBLOX TODO: Unhandled node for type: TSIndexedAccessType ]] --[[ NewPlugin['test'] ]]
local function test(val)
	return typeof(val) == "table" and val["$$typeof"] == testSymbol
end
exports.test = test

local plugin: NewPlugin = { serialize = serialize, test = test }

exports.default = plugin

return exports
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="456">
                <Properties>
                  <string name="Name">RedactStackTraces</string>
                  <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream

local CurrentModule = script.Parent.Parent
local Packages = CurrentModule.Parent

local JestGetType = require(Packages.JestGetType)
local getType = JestGetType.getType

local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Array = LuauPolyfill.Array
local instanceof = LuauPolyfill.instanceof

local redactStackTrace = require(Packages.RobloxShared).redactStackTrace

local Types = require(CurrentModule.Types)
type Config = Types.Config
type Refs = Types.Refs
type Printer = Types.Printer

local RedactStackTraces = {}

function RedactStackTraces.serialize(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	depth = depth + 1
	local ty = getType(val)
	if ty == "string" then
		local interiorConfig = table.clone(config)
		interiorConfig.plugins = table.clone(interiorConfig.plugins)
		table.remove(interiorConfig.plugins, table.find(interiorConfig.plugins, RedactStackTraces))
		local pretty = printer(val, interiorConfig, indentation, depth, refs)
		if config.redactStackTracesInStrings then
			pretty = redactStackTrace(pretty) :: string
		end
		return pretty
	elseif ty == "error" then
		local interiorConfig = table.clone(config)
		interiorConfig.plugins = table.clone(interiorConfig.plugins)
		table.remove(interiorConfig.plugins, table.find(interiorConfig.plugins, RedactStackTraces))
		local pretty = printer(val, interiorConfig, indentation, depth, refs)
		return redactStackTrace(pretty) :: string
	else
		error("not supported")
	end
end

function RedactStackTraces.test(val: any): boolean
	local ty = getType(val)
	return ty == "error" or ty == "string"
end

return RedactStackTraces
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="457">
                <Properties>
                  <string name="Name">RobloxInstance</string>
                  <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream
-- this plugin serializes Roblox Instance objects
-- https://developer.roblox.com/en-us/api-reference/class/Instance

local CurrentModule = script.Parent.Parent
local Packages = CurrentModule.Parent

local JestGetType = require(Packages.JestGetType)
local getType = JestGetType.getType

local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Array = LuauPolyfill.Array
local instanceof = LuauPolyfill.instanceof

local RobloxInstance = require(Packages.RobloxShared).RobloxInstance
local InstanceSubset = RobloxInstance.InstanceSubset

local printTableEntries = require(CurrentModule.Collections).printTableEntries

local Types = require(CurrentModule.Types)
type Config = Types.Config
type Refs = Types.Refs
type Printer = Types.Printer

local function printInstance(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	local result = ""

	local printChildrenList = val:GetChildren()
	table.sort(printChildrenList, function(a, b)
		return a.Name < b.Name
	end)

	local propertiesMap = RobloxInstance.listProps(val)
	local printPropsList = Object.keys(propertiesMap)
	if not config.printInstanceDefaults then
		local defaultsMap = RobloxInstance.listDefaultProps(val.ClassName)
		printPropsList = Array.filter(printPropsList, function(name)
			return propertiesMap[name] ~= defaultsMap[name]
		end)
	end
	table.sort(printPropsList)

	local willPrintProps = #printPropsList > 0
	local willPrintChildren = #printChildrenList > 0

	if willPrintProps or willPrintChildren then
		result = result .. config.spacingOuter

		local indentationNext = indentation .. config.indent

		-- print properties of Instance
		for propOrder, propName in ipairs(printPropsList) do
			local propValue = propertiesMap[propName]
			if propValue == Object.None then
				propValue = nil
			end

			-- collapses output for Instance values to avoid loops
			local valueDepth = if getType(propValue) == "Instance" then math.huge else depth
			local printName = printer(propName, config, indentationNext, depth, refs)
			local printValue = printer(propValue, config, indentationNext, valueDepth, refs)

			result = string.format("%s%s%s: %s", result, indentationNext, printName, printValue)

			if propOrder ~= #printPropsList or willPrintChildren then
				result = result .. "," .. config.spacingInner
			elseif not config.min then
				result = result .. ","
			end
		end

		-- recursively print children of Instance
		for childOrder, child in ipairs(printChildrenList) do
			local printName = printer(child.Name, config, indentationNext, depth, refs)
			local printValue = printer(child, config, indentationNext, depth, refs)

			result = string.format("%s%s%s: %s", result, indentationNext, printName, printValue)

			if childOrder ~= #printChildrenList then
				result = result .. "," .. config.spacingInner
			elseif not config.min then
				result = result .. ","
			end
		end

		result = result .. config.spacingOuter .. indentation
	end

	return result
end

local function serialize(
	val: any,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	depth = depth + 1

	if depth >= config.maxDepth then
		return string.format('"%s" [%s]', val.Name, val.ClassName)
	end

	if instanceof(val, InstanceSubset) then
		return val.ClassName .. " {" .. printTableEntries(val.subset, config, indentation, depth, refs, printer) .. "}"
	end

	return val.ClassName .. " {" .. printInstance(val, config, indentation, depth, refs, printer) .. "}"
end

local function test(val: any): boolean
	return getType(val) == "Instance" or instanceof(val, InstanceSubset)
end

return {
	serialize = serialize,
	test = test,
}
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="458">
                <Properties>
                  <string name="Name">lib</string>
                </Properties>
                <Item class="ModuleScript" referent="459">
                  <Properties>
                    <string name="Name">escapeHTML</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/plugins/lib/escapeHTML.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local exports = {}
local function escapeHTML(str: string): string
	return str:gsub("<", "&lt;"):gsub(">", "&gt;")
end
exports.default = escapeHTML
return exports
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="460">
                  <Properties>
                    <string name="Name">markup</string>
                    <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/pretty-format/src/plugins/lib/markup.ts
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local CurrentModule = script.Parent.Parent.Parent
local Packages = CurrentModule.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
type Array<T> = LuauPolyfill.Array<T>
type Record<K, T> = { [K]: T }

local exports = {}

-- ROBLOX deviation START: predefine functions
local printProps
local printChildren
local printText
local printComment
local printElement
local printElementAsLeaf
-- ROBLOX deviation END

local typesModule = require(script.Parent.Parent.Parent.Types)
type Config = typesModule.Config
type Printer = typesModule.Printer
type Refs = typesModule.Refs
local escapeHTML = require(script.Parent.escapeHTML).default

-- ROBLOX deviation START: adding default colors since we don't currently support colors
type Colors = typesModule.Colors
local DEFAULT_COLORS: Colors = {
	comment = { close = "", open = "" },
	content = { close = "", open = "" },
	prop = { close = "", open = "" },
	tag = { close = "", open = "" },
	value = { close = "", open = "" },
}
-- ROBLOX deviation END

-- Return empty string if keys is empty.
function printProps(
	keys: Array<string>,
	props: Record<string, unknown>,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	local indentationNext = indentation .. config.indent

	-- ROBLOX deviation: adding default value as we don't support colors
	local colors = config.colors or DEFAULT_COLORS
	return Array.join(
		Array.map(keys, function(key: string)
			local value = props[key]
			local printed = printer(value, config, indentationNext, depth, refs)

			if typeof(value) ~= "string" then
				if string.find(printed, "\n") ~= nil then
					printed = config.spacingOuter .. indentationNext .. printed .. config.spacingOuter .. indentation
				end
				printed = "{" .. printed .. "}"
			end

			-- ROBLOX deviation: keys can be of type table. eg. when using ReactRoblox.Change
			local key_ = if typeof(key) == "table"
				then (if key.name then key.name else printer(key, config, indentationNext, depth, refs))
				else key

			return config.spacingInner
				.. indentation
				.. colors.prop.open
				.. colors.prop.open
				.. key_
				.. colors.prop.close
				.. "="
				.. colors.value.open
				.. printed
				.. colors.value.close
				.. colors.value.close
		end),
		""
	)
end
exports.printProps = printProps

-- Return empty string if children is empty.
function printChildren(
	children: Array<unknown>,
	config: Config,
	indentation: string,
	depth: number,
	refs: Refs,
	printer: Printer
): string
	return Array.join(
		Array.map(children, function(child)
			return config.spacingOuter
				.. indentation
				.. if typeof(child) == "string"
					then printText(child, config)
					else printer(child, config, indentation, depth, refs)
		end),
		""
	)
end
exports.printChildren = printChildren

function printText(text: string, config: Config): string
	-- ROBLOX deviation START: adding default value as we don't support colors
	local colors = config.colors or DEFAULT_COLORS
	local contentColor = colors.content
	-- ROBLOX deviation END
	return contentColor.open .. escapeHTML(text) .. contentColor.close
end
exports.printText = printText

function printComment(comment: string, config: Config): string
	-- ROBLOX deviation START: adding default value as we don't support colors
	local colors = config.colors or DEFAULT_COLORS
	local commentColor = colors.comment
	-- ROBLOX deviation END
	return commentColor.open .. "<!--" .. escapeHTML(comment) .. "-->" .. commentColor.close
end
exports.printComment = printComment

-- Separate the functions to format props, children, and element,
-- so a plugin could override a particular function, if needed.
-- Too bad, so sad: the traditional (but unnecessary) space
-- in a self-closing tagColor requires a second test of printedProps.
function printElement(
	type_: string,
	printedProps: string,
	printedChildren: string,
	config: Config,
	indentation: string
): string
	-- ROBLOX deviation START: adding default value as we don't support colors
	local colors = config.colors or DEFAULT_COLORS
	local tagColor = colors.tag
	-- ROBLOX deviation END
	return tagColor.open
		.. "<"
		.. type_
		.. (if Boolean.toJSBoolean(printedProps)
			then tagColor.close .. printedProps .. config.spacingOuter .. indentation .. tagColor.open
			else printedProps)
		.. (if Boolean.toJSBoolean(printedChildren)
			then ">"
				.. tagColor.close
				.. printedChildren
				.. config.spacingOuter
				.. indentation
				.. tagColor.open
				.. "</"
				.. type_
			else (if Boolean.toJSBoolean(printedProps) and not Boolean.toJSBoolean(config.min) then "" else " ") .. "/")
		.. ">"
		.. tagColor.close
end
exports.printElement = printElement

function printElementAsLeaf(type_: string, config: Config): string
	-- ROBLOX deviation START: adding default value as we don't support colors
	local colors = config.colors or DEFAULT_COLORS
	local tagColor = colors.tag
	-- ROBLOX deviation END
	return tagColor.open .. "<" .. type_ .. tagColor.close .. " …" .. tagColor.open .. " />" .. tagColor.close
end
exports.printElementAsLeaf = printElementAsLeaf

return exports
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="461">
            <Properties>
              <string name="Name">ReactIs</string>
              <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-is/src/ReactIs.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
local Packages = script.Parent
-- ROBLOX deviation START: not used
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
-- ROBLOX deviation START: use patched console from shared
-- local console = LuauPolyfill.console
local console = require(Packages.Shared).console
-- ROBLOX deviation END
local exports = {}
-- ROBLOX deviation START: fix import
-- local sharedReactSymbolsModule = require(Packages.shared.ReactSymbols)
local sharedReactSymbolsModule = require(Packages.Shared).ReactSymbols
-- ROBLOX deviation END
local REACT_CONTEXT_TYPE = sharedReactSymbolsModule.REACT_CONTEXT_TYPE
local REACT_ELEMENT_TYPE = sharedReactSymbolsModule.REACT_ELEMENT_TYPE
local REACT_FORWARD_REF_TYPE = sharedReactSymbolsModule.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = sharedReactSymbolsModule.REACT_FRAGMENT_TYPE
local REACT_LAZY_TYPE = sharedReactSymbolsModule.REACT_LAZY_TYPE
local REACT_MEMO_TYPE = sharedReactSymbolsModule.REACT_MEMO_TYPE
local REACT_PORTAL_TYPE = sharedReactSymbolsModule.REACT_PORTAL_TYPE
local REACT_PROFILER_TYPE = sharedReactSymbolsModule.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = sharedReactSymbolsModule.REACT_PROVIDER_TYPE
local REACT_STRICT_MODE_TYPE = sharedReactSymbolsModule.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = sharedReactSymbolsModule.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = sharedReactSymbolsModule.REACT_SUSPENSE_LIST_TYPE
-- ROBLOX deviation START: fix import
-- local isValidElementType = require(Packages.shared.isValidElementType).default
local isValidElementType = require(Packages.Shared).isValidElementType
-- ROBLOX deviation END
-- ROBLOX deviation START: additional imports
local REACT_BINDING_TYPE = sharedReactSymbolsModule.REACT_BINDING_TYPE
-- ROBLOX deviation END
local function typeOf(object: any)
	if typeof(object) == "table" and object ~= nil then
		local __typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]] =
			object["$$typeof"]
		-- ROBLOX deviation START: simplified switch statement conversion, adds Binding type check
		-- repeat --[[ ROBLOX comment: switch statement conversion ]]
		-- 	local entered_, break_ = false, false
		-- 	local condition_ = __typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]]
		-- 	for _, v in ipairs({ REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE }) do
		-- 		if condition_ == v then
		-- 			if v == REACT_ELEMENT_TYPE then
		-- 				entered_ = true
		-- 				local type_ = object.type
		-- 				local condition_ = type_
		-- 				if
		-- 					condition_ == REACT_FRAGMENT_TYPE
		-- 					or condition_ == REACT_PROFILER_TYPE
		-- 					or condition_ == REACT_STRICT_MODE_TYPE
		-- 					or condition_ == REACT_SUSPENSE_TYPE
		-- 					or condition_ == REACT_SUSPENSE_LIST_TYPE
		-- 				then
		-- 					return type_
		-- 				else
		-- 					local __typeofType --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeofType ]] = if Boolean.toJSBoolean(
		-- 							type_
		-- 						)
		-- 						then type_["$$typeof"]
		-- 						else type_
		-- 					local condition_ = __typeofType --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeofType ]]
		-- 					if
		-- 						condition_ == REACT_CONTEXT_TYPE
		-- 						or condition_ == REACT_FORWARD_REF_TYPE
		-- 						or condition_ == REACT_LAZY_TYPE
		-- 						or condition_ == REACT_MEMO_TYPE
		-- 						or condition_ == REACT_PROVIDER_TYPE
		-- 					then
		-- 						return __typeofType --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeofType ]]
		-- 					else
		-- 						return __typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]]
		-- 					end
		-- 				end
		-- 			end
		-- 			if v == REACT_PORTAL_TYPE or entered_ then
		-- 				entered_ = true
		-- 				return __typeof --[[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof ]]
		-- 			end
		-- 		end
		-- 	end
		-- until true
		if __typeof == REACT_ELEMENT_TYPE then
			local __type = object.type

			if
				__type == REACT_FRAGMENT_TYPE
				or __type == REACT_PROFILER_TYPE
				or __type == REACT_STRICT_MODE_TYPE
				or __type == REACT_SUSPENSE_TYPE
				or __type == REACT_SUSPENSE_LIST_TYPE
			then
				return __type
			else
				-- ROBLOX note: We need to check that __type is a table before we
				-- index into it, or Luau will throw errors
				local __typeofType = __type
					and typeof(__type) == "table"
					and __type["$$typeof"]

				if
					__typeofType == REACT_CONTEXT_TYPE
					or __typeofType == REACT_FORWARD_REF_TYPE
					or __typeofType == REACT_LAZY_TYPE
					or __typeofType == REACT_MEMO_TYPE
					or __typeofType == REACT_PROVIDER_TYPE
				then
					return __typeofType
				else
					return __typeof
				end
			end
		elseif
			__typeof == REACT_PORTAL_TYPE
			-- ROBLOX note: Bindings are a feature migrated from Roact
			or __typeof == REACT_BINDING_TYPE
		then
			return __typeof
		end
		-- ROBLOX deviation END
	end
	return nil
end
exports.typeOf = typeOf
local ContextConsumer = REACT_CONTEXT_TYPE
exports.ContextConsumer = ContextConsumer
local ContextProvider = REACT_PROVIDER_TYPE
exports.ContextProvider = ContextProvider
local Element = REACT_ELEMENT_TYPE
exports.Element = Element
local ForwardRef = REACT_FORWARD_REF_TYPE
exports.ForwardRef = ForwardRef
local Fragment = REACT_FRAGMENT_TYPE
exports.Fragment = Fragment
local Lazy = REACT_LAZY_TYPE
exports.Lazy = Lazy
local Memo = REACT_MEMO_TYPE
exports.Memo = Memo
local Portal = REACT_PORTAL_TYPE
exports.Portal = Portal
local Profiler = REACT_PROFILER_TYPE
exports.Profiler = Profiler
local StrictMode = REACT_STRICT_MODE_TYPE
exports.StrictMode = StrictMode
local Suspense = REACT_SUSPENSE_TYPE
exports.Suspense = Suspense
-- ROBLOX deviation START: export Roblox Only type
exports.Binding = sharedReactSymbolsModule.REACT_BINDING_TYPE
-- ROBLOX deviation END
exports.isValidElementType = isValidElementType
local hasWarnedAboutDeprecatedIsAsyncMode = false
local hasWarnedAboutDeprecatedIsConcurrentMode = false -- AsyncMode should be deprecated
local function isAsyncMode(object: any)
	-- ROBLOX deviation START: remove toJSBoolean, use _G.__DEV__
	-- if Boolean.toJSBoolean(__DEV__) then
	-- 	if not Boolean.toJSBoolean(hasWarnedAboutDeprecatedIsAsyncMode) then
	if _G.__DEV__ then
		if not hasWarnedAboutDeprecatedIsAsyncMode then
			-- ROBLOX deviation END
			hasWarnedAboutDeprecatedIsAsyncMode = true -- Using console['warn'] to evade Babel and ESLint
			console["warn"](
				"The ReactIs.isAsyncMode() alias has been deprecated, "
					.. "and will be removed in React 18+."
			)
		end
	end
	return false
end
exports.isAsyncMode = isAsyncMode
local function isConcurrentMode(object: any)
	-- ROBLOX deviation START: remove toJSBoolean, use _G.__DEV__
	-- if Boolean.toJSBoolean(__DEV__) then
	-- 	if not Boolean.toJSBoolean(hasWarnedAboutDeprecatedIsConcurrentMode) then
	if _G.__DEV__ then
		if not hasWarnedAboutDeprecatedIsConcurrentMode then
			-- ROBLOX deviation END
			hasWarnedAboutDeprecatedIsConcurrentMode = true -- Using console['warn'] to evade Babel and ESLint
			console["warn"](
				"The ReactIs.isConcurrentMode() alias has been deprecated, "
					.. "and will be removed in React 18+."
			)
		end
	end
	return false
end
exports.isConcurrentMode = isConcurrentMode
local function isContextConsumer(object: any)
	return typeOf(object) == REACT_CONTEXT_TYPE
end
exports.isContextConsumer = isContextConsumer
local function isContextProvider(object: any)
	return typeOf(object) == REACT_PROVIDER_TYPE
end
exports.isContextProvider = isContextProvider
local function isElement(object: any)
	return typeof(object) == "table"
		and object ~= nil
		and object["$$typeof"] == REACT_ELEMENT_TYPE
end
exports.isElement = isElement
local function isForwardRef(object: any)
	return typeOf(object) == REACT_FORWARD_REF_TYPE
end
exports.isForwardRef = isForwardRef
local function isFragment(object: any)
	return typeOf(object) == REACT_FRAGMENT_TYPE
end
exports.isFragment = isFragment
local function isLazy(object: any)
	return typeOf(object) == REACT_LAZY_TYPE
end
exports.isLazy = isLazy
local function isMemo(object: any)
	return typeOf(object) == REACT_MEMO_TYPE
end
exports.isMemo = isMemo
local function isPortal(object: any)
	return typeOf(object) == REACT_PORTAL_TYPE
end
exports.isPortal = isPortal
local function isProfiler(object: any)
	return typeOf(object) == REACT_PROFILER_TYPE
end
exports.isProfiler = isProfiler
local function isStrictMode(object: any)
	return typeOf(object) == REACT_STRICT_MODE_TYPE
end
exports.isStrictMode = isStrictMode
local function isSuspense(object: any)
	return typeOf(object) == REACT_SUSPENSE_TYPE
end
exports.isSuspense = isSuspense
-- ROBLOX deviation START: Bindings are a feature migrated from Roact
exports.isBinding = function(object: any)
	return typeOf(object) == REACT_BINDING_TYPE
end
-- ROBLOX deviation END
return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="462">
            <Properties>
              <string name="Name">Promise</string>
              <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(...)
	local promises = { ... }

	-- check if we've been given a list of promises, not just a variable number of promises
	if type(promises[1]) == "table" and not Promise.is(promises[1]) then
		-- we've been given a table of promises already
		promises = promises[1]
	end

	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Chains onto an existing Promise, except execution begins after the next `Heartbeat` event, and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThenAsync` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThenAsync` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThenAsync(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThenAsync"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThenAsync"))


	return self:_andThen(
		debug.traceback(nil, 2),
		function(...)
			local length, values = pack(...)
			return Promise.defer(function(resolve)
				resolve(unpack(values, 1, length))
			end)
		end,
		function(...)
			local length, values = pack(...)
			return Promise.defer(function(_, reject)
				reject(unpack(values, 1, length))
			end)
		end
	):andThen(successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or isCallable(finallyHandler),
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self:finally(function()
			task.spawn(thread)
		end)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="463">
            <Properties>
              <string name="Name">RobloxShared</string>
              <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local CurrentModule = script

local nodeUtilsModule = require(CurrentModule.nodeUtils)
export type NodeJS_WriteStream = nodeUtilsModule.NodeJS_WriteStream
local exports = {
	cleanLoadStringStack = require(CurrentModule.cleanLoadStringStack),
	dedent = require(CurrentModule.dedent).dedent,
	escapePatternCharacters = require(CurrentModule.escapePatternCharacters).escapePatternCharacters,
	ensureDirectoryExists = require(CurrentModule.ensureDirectoryExists),
	getDataModelService = require(CurrentModule.getDataModelService),
	getParent = require(CurrentModule.getParent),
	expect = require(CurrentModule.expect),
	getRelativePath = require(CurrentModule.getRelativePath),
	RobloxInstance = require(CurrentModule.RobloxInstance),
	nodeUtils = nodeUtilsModule,
	normalizePromiseError = require(CurrentModule.normalizePromiseError),
	pruneDeps = require(CurrentModule.pruneDeps),
	redactStackTrace = require(CurrentModule.redactStackTrace),
	stripAnsi = require(CurrentModule.stripAnsi),
}

local WriteableModule = require(CurrentModule.Writeable)
exports.Writeable = WriteableModule.Writeable
export type Writeable = WriteableModule.Writeable

return exports
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="464">
              <Properties>
                <string name="Name">RobloxApiDump</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- version-5d89b8817a4e4de3
return {
	Instance = { Properties = { "Archivable", "ClassName", "Name", "Parent" } },
	Accoutrement = {
		Properties = { "AttachmentForward", "AttachmentPoint", "AttachmentPos", "AttachmentRight", "AttachmentUp" },
		Superclass = "Instance",
	},
	Accessory = { Properties = { "AccessoryType" }, Superclass = "Accoutrement" },
	Hat = { Properties = {}, Superclass = "Accoutrement" },
	AdvancedDragger = { Properties = {}, Superclass = "Instance" },
	Animation = { Properties = { "AnimationId" }, Superclass = "Instance" },
	AnimationClip = { Properties = { "Loop", "Priority" }, Superclass = "Instance" },
	CurveAnimation = { Properties = {}, Superclass = "AnimationClip" },
	KeyframeSequence = { Properties = {}, Superclass = "AnimationClip" },
	AnimationController = { Properties = {}, Superclass = "Instance" },
	AnimationRigData = { Properties = {}, Superclass = "Instance" },
	AnimationTrack = {
		Properties = {
			"Animation",
			"IsPlaying",
			"Length",
			"Looped",
			"Priority",
			"Speed",
			"TimePosition",
			"WeightCurrent",
			"WeightTarget",
		},
		Superclass = "Instance",
	},
	Animator = { Properties = {}, Superclass = "Instance" },
	Atmosphere = { Properties = { "Color", "Decay", "Density", "Glare", "Haze", "Offset" }, Superclass = "Instance" },
	Attachment = {
		Properties = {
			"Axis",
			"CFrame",
			"Orientation",
			"Position",
			"SecondaryAxis",
			"Visible",
			"WorldAxis",
			"WorldCFrame",
			"WorldOrientation",
			"WorldPosition",
			"WorldSecondaryAxis",
		},
		Superclass = "Instance",
	},
	Bone = { Properties = { "Transform", "TransformedCFrame", "TransformedWorldCFrame" }, Superclass = "Attachment" },
	Backpack = { Properties = {}, Superclass = "Instance" },
	BackpackItem = { Properties = { "TextureId" }, Superclass = "Instance" },
	HopperBin = { Properties = { "Active", "BinType" }, Superclass = "BackpackItem" },
	Tool = {
		Properties = {
			"CanBeDropped",
			"Enabled",
			"Grip",
			"GripForward",
			"GripPos",
			"GripRight",
			"GripUp",
			"ManualActivationOnly",
			"RequiresHandle",
			"ToolTip",
		},
		Superclass = "BackpackItem",
	},
	Flag = { Properties = { "TeamColor" }, Superclass = "Tool" },
	BasePlayerGui = { Properties = {}, Superclass = "Instance" },
	PlayerGui = {
		Properties = { "CurrentScreenOrientation", "ScreenOrientation", "SelectionImageObject" },
		Superclass = "BasePlayerGui",
	},
	BaseWrap = {
		Properties = { "CageMeshId", "CageOrigin", "CageOriginWorld", "ImportOrigin", "ImportOriginWorld" },
		Superclass = "Instance",
	},
	WrapLayer = {
		Properties = {
			"BindOffset",
			"Enabled",
			"Order",
			"Puffiness",
			"ReferenceMeshId",
			"ReferenceOrigin",
			"ReferenceOriginWorld",
			"ShrinkFactor",
		},
		Superclass = "BaseWrap",
	},
	WrapTarget = { Properties = { "Stiffness" }, Superclass = "BaseWrap" },
	Beam = {
		Properties = {
			"Attachment0",
			"Attachment1",
			"Brightness",
			"Color",
			"CurveSize0",
			"CurveSize1",
			"Enabled",
			"FaceCamera",
			"LightEmission",
			"LightInfluence",
			"Segments",
			"Texture",
			"TextureLength",
			"TextureMode",
			"TextureSpeed",
			"Transparency",
			"Width0",
			"Width1",
			"ZOffset",
		},
		Superclass = "Instance",
	},
	BindableEvent = { Properties = {}, Superclass = "Instance" },
	BindableFunction = { Properties = {}, Superclass = "Instance" },
	BodyMover = { Properties = {}, Superclass = "Instance" },
	BodyAngularVelocity = { Properties = { "AngularVelocity", "MaxTorque", "P" }, Superclass = "BodyMover" },
	BodyForce = { Properties = { "Force" }, Superclass = "BodyMover" },
	BodyGyro = { Properties = { "CFrame", "D", "MaxTorque", "P" }, Superclass = "BodyMover" },
	BodyPosition = { Properties = { "D", "MaxForce", "P", "Position" }, Superclass = "BodyMover" },
	BodyThrust = { Properties = { "Force", "Location" }, Superclass = "BodyMover" },
	BodyVelocity = { Properties = { "MaxForce", "P", "Velocity" }, Superclass = "BodyMover" },
	RocketPropulsion = {
		Properties = {
			"CartoonFactor",
			"MaxSpeed",
			"MaxThrust",
			"MaxTorque",
			"Target",
			"TargetOffset",
			"TargetRadius",
			"ThrustD",
			"ThrustP",
			"TurnD",
			"TurnP",
		},
		Superclass = "BodyMover",
	},
	Breakpoint = { Properties = {}, Superclass = "Instance" },
	Camera = {
		Properties = {
			"CFrame",
			"CameraSubject",
			"CameraType",
			"DiagonalFieldOfView",
			"FieldOfView",
			"FieldOfViewMode",
			"Focus",
			"HeadLocked",
			"HeadScale",
			"MaxAxisFieldOfView",
			"NearPlaneZ",
			"ViewportSize",
		},
		Superclass = "Instance",
	},
	CharacterAppearance = { Properties = {}, Superclass = "Instance" },
	BodyColors = {
		Properties = {
			"HeadColor",
			"HeadColor3",
			"LeftArmColor",
			"LeftArmColor3",
			"LeftLegColor",
			"LeftLegColor3",
			"RightArmColor",
			"RightArmColor3",
			"RightLegColor",
			"RightLegColor3",
			"TorsoColor",
			"TorsoColor3",
		},
		Superclass = "CharacterAppearance",
	},
	CharacterMesh = {
		Properties = { "BaseTextureId", "BodyPart", "MeshId", "OverlayTextureId" },
		Superclass = "CharacterAppearance",
	},
	Clothing = { Properties = { "Color3" }, Superclass = "CharacterAppearance" },
	Pants = { Properties = { "PantsTemplate" }, Superclass = "Clothing" },
	Shirt = { Properties = { "ShirtTemplate" }, Superclass = "Clothing" },
	ShirtGraphic = { Properties = { "Color3", "Graphic" }, Superclass = "CharacterAppearance" },
	Skin = { Properties = { "SkinColor" }, Superclass = "CharacterAppearance" },
	ClickDetector = { Properties = { "CursorIcon", "MaxActivationDistance" }, Superclass = "Instance" },
	Clouds = { Properties = { "Color", "Cover", "Density", "Enabled" }, Superclass = "Instance" },
	CommandInstance = {
		Properties = {
			"AllowGUIAccessPoints",
			"Checked",
			"DefaultShortcut",
			"DisplayName",
			"Enabled",
			"Icon",
			"Name",
			"Permission",
			"StatusTip",
		},
		Superclass = "Instance",
	},
	Configuration = { Properties = {}, Superclass = "Instance" },
	Constraint = {
		Properties = { "Active", "Attachment0", "Attachment1", "Color", "Enabled", "Visible" },
		Superclass = "Instance",
	},
	AlignOrientation = {
		Properties = {
			"AlignType",
			"CFrame",
			"MaxAngularVelocity",
			"MaxTorque",
			"Mode",
			"PrimaryAxis",
			"PrimaryAxisOnly",
			"ReactionTorqueEnabled",
			"Responsiveness",
			"RigidityEnabled",
			"SecondaryAxis",
		},
		Superclass = "Constraint",
	},
	AlignPosition = {
		Properties = {
			"ApplyAtCenterOfMass",
			"MaxForce",
			"MaxVelocity",
			"Mode",
			"Position",
			"ReactionForceEnabled",
			"Responsiveness",
			"RigidityEnabled",
		},
		Superclass = "Constraint",
	},
	AngularVelocity = {
		Properties = { "AngularVelocity", "MaxTorque", "ReactionTorqueEnabled", "RelativeTo" },
		Superclass = "Constraint",
	},
	BallSocketConstraint = {
		Properties = {
			"LimitsEnabled",
			"MaxFrictionTorque",
			"Radius",
			"Restitution",
			"TwistLimitsEnabled",
			"TwistLowerAngle",
			"TwistUpperAngle",
			"UpperAngle",
		},
		Superclass = "Constraint",
	},
	HingeConstraint = {
		Properties = {
			"ActuatorType",
			"AngularResponsiveness",
			"AngularSpeed",
			"AngularVelocity",
			"CurrentAngle",
			"LimitsEnabled",
			"LowerAngle",
			"MotorMaxAcceleration",
			"MotorMaxTorque",
			"Radius",
			"Restitution",
			"ServoMaxTorque",
			"TargetAngle",
			"UpperAngle",
		},
		Superclass = "Constraint",
	},
	LineForce = {
		Properties = { "ApplyAtCenterOfMass", "InverseSquareLaw", "Magnitude", "MaxForce", "ReactionForceEnabled" },
		Superclass = "Constraint",
	},
	LinearVelocity = {
		Properties = {
			"LineDirection",
			"LineVelocity",
			"MaxForce",
			"PlaneVelocity",
			"PrimaryTangentAxis",
			"RelativeTo",
			"SecondaryTangentAxis",
			"VectorVelocity",
			"VelocityConstraintMode",
		},
		Superclass = "Constraint",
	},
	Plane = { Properties = {}, Superclass = "Constraint" },
	RodConstraint = {
		Properties = { "CurrentDistance", "Length", "LimitAngle0", "LimitAngle1", "LimitsEnabled", "Thickness" },
		Superclass = "Constraint",
	},
	RopeConstraint = {
		Properties = {
			"CurrentDistance",
			"Length",
			"Restitution",
			"Thickness",
			"WinchEnabled",
			"WinchForce",
			"WinchResponsiveness",
			"WinchSpeed",
			"WinchTarget",
		},
		Superclass = "Constraint",
	},
	SlidingBallConstraint = {
		Properties = {
			"ActuatorType",
			"CurrentPosition",
			"LimitsEnabled",
			"LinearResponsiveness",
			"LowerLimit",
			"MotorMaxAcceleration",
			"MotorMaxForce",
			"Restitution",
			"ServoMaxForce",
			"Size",
			"Speed",
			"TargetPosition",
			"UpperLimit",
			"Velocity",
		},
		Superclass = "Constraint",
	},
	CylindricalConstraint = {
		Properties = {
			"AngularActuatorType",
			"AngularLimitsEnabled",
			"AngularResponsiveness",
			"AngularRestitution",
			"AngularSpeed",
			"AngularVelocity",
			"CurrentAngle",
			"InclinationAngle",
			"LowerAngle",
			"MotorMaxAngularAcceleration",
			"MotorMaxTorque",
			"RotationAxisVisible",
			"ServoMaxTorque",
			"TargetAngle",
			"UpperAngle",
			"WorldRotationAxis",
		},
		Superclass = "SlidingBallConstraint",
	},
	PrismaticConstraint = { Properties = {}, Superclass = "SlidingBallConstraint" },
	SpringConstraint = {
		Properties = {
			"Coils",
			"CurrentLength",
			"Damping",
			"FreeLength",
			"LimitsEnabled",
			"MaxForce",
			"MaxLength",
			"MinLength",
			"Radius",
			"Stiffness",
			"Thickness",
		},
		Superclass = "Constraint",
	},
	Torque = { Properties = { "RelativeTo", "Torque" }, Superclass = "Constraint" },
	TorsionSpringConstraint = {
		Properties = {
			"Coils",
			"CurrentAngle",
			"Damping",
			"LimitsEnabled",
			"MaxAngle",
			"MaxTorque",
			"Radius",
			"Restitution",
			"Stiffness",
		},
		Superclass = "Constraint",
	},
	UniversalConstraint = {
		Properties = { "LimitsEnabled", "MaxAngle", "Radius", "Restitution" },
		Superclass = "Constraint",
	},
	VectorForce = { Properties = { "ApplyAtCenterOfMass", "Force", "RelativeTo" }, Superclass = "Constraint" },
	Controller = { Properties = {}, Superclass = "Instance" },
	HumanoidController = { Properties = {}, Superclass = "Controller" },
	SkateboardController = { Properties = { "Steer", "Throttle" }, Superclass = "Controller" },
	VehicleController = { Properties = {}, Superclass = "Controller" },
	CustomEvent = { Properties = {}, Superclass = "Instance" },
	CustomEventReceiver = { Properties = {}, Superclass = "Instance" },
	DataModelMesh = { Properties = { "Offset", "Scale", "VertexColor" }, Superclass = "Instance" },
	BevelMesh = { Properties = {}, Superclass = "DataModelMesh" },
	BlockMesh = { Properties = {}, Superclass = "BevelMesh" },
	CylinderMesh = { Properties = {}, Superclass = "BevelMesh" },
	FileMesh = { Properties = { "MeshId", "TextureId" }, Superclass = "DataModelMesh" },
	SpecialMesh = { Properties = { "MeshType" }, Superclass = "FileMesh" },
	DataModelSession = { Properties = {}, Superclass = "Instance" },
	DataStoreIncrementOptions = { Properties = {}, Superclass = "Instance" },
	DataStoreInfo = { Properties = { "CreatedTime", "DataStoreName", "UpdatedTime" }, Superclass = "Instance" },
	DataStoreKey = { Properties = { "KeyName" }, Superclass = "Instance" },
	DataStoreKeyInfo = { Properties = { "CreatedTime", "UpdatedTime", "Version" }, Superclass = "Instance" },
	DataStoreObjectVersionInfo = { Properties = { "CreatedTime", "IsDeleted", "Version" }, Superclass = "Instance" },
	DataStoreOptions = { Properties = { "AllScopes" }, Superclass = "Instance" },
	DataStoreSetOptions = { Properties = {}, Superclass = "Instance" },
	DebugSettings = {
		Properties = {
			"DataModel",
			"InstanceCount",
			"IsScriptStackTracingEnabled",
			"JobCount",
			"PlayerCount",
			"ReportSoundWarnings",
			"RobloxVersion",
			"TickCountPreciseOverride",
		},
		Superclass = "Instance",
	},
	DebuggerBreakpoint = {
		Properties = {
			"Condition",
			"ContinueExecution",
			"IsEnabled",
			"Line",
			"LogExpression",
			"isContextDependentBreakpoint",
		},
		Superclass = "Instance",
	},
	DebuggerConnection = { Properties = {}, Superclass = "Instance" },
	DebuggerLuaResponse = { Properties = {}, Superclass = "Instance" },
	DebuggerVariable = { Properties = {}, Superclass = "Instance" },
	DebuggerWatch = { Properties = { "Expression" }, Superclass = "Instance" },
	Dialog = {
		Properties = {
			"BehaviorType",
			"ConversationDistance",
			"GoodbyeChoiceActive",
			"GoodbyeDialog",
			"InUse",
			"InitialPrompt",
			"Purpose",
			"Tone",
			"TriggerDistance",
			"TriggerOffset",
		},
		Superclass = "Instance",
	},
	DialogChoice = {
		Properties = { "GoodbyeChoiceActive", "GoodbyeDialog", "ResponseDialog", "UserDialog" },
		Superclass = "Instance",
	},
	Dragger = { Properties = {}, Superclass = "Instance" },
	EulerRotationCurve = { Properties = { "RotationOrder" }, Superclass = "Instance" },
	Explosion = {
		Properties = {
			"BlastPressure",
			"BlastRadius",
			"DestroyJointRadiusPercent",
			"ExplosionType",
			"Position",
			"Visible",
		},
		Superclass = "Instance",
	},
	FaceControls = {
		Properties = {
			"ChinRaiser",
			"ChinRaiserUpperLip",
			"Corrugator",
			"EyesLookDown",
			"EyesLookLeft",
			"EyesLookRight",
			"EyesLookUp",
			"FlatPucker",
			"Funneler",
			"JawDrop",
			"JawLeft",
			"JawRight",
			"LeftBrowLowerer",
			"LeftCheekPuff",
			"LeftCheekRaiser",
			"LeftDimpler",
			"LeftEyeClosed",
			"LeftEyeUpperLidRaiser",
			"LeftInnerBrowRaiser",
			"LeftLipCornerDown",
			"LeftLipCornerPuller",
			"LeftLipStretcher",
			"LeftLowerLipDepressor",
			"LeftNoseWrinkler",
			"LeftOuterBrowRaiser",
			"LeftUpperLipRaiser",
			"LipPresser",
			"LipsTogether",
			"LowerLipSuck",
			"MouthLeft",
			"MouthRight",
			"Pucker",
			"RightBrowLowerer",
			"RightCheekPuff",
			"RightCheekRaiser",
			"RightDimpler",
			"RightEyeClosed",
			"RightEyeUpperLidRaiser",
			"RightInnerBrowRaiser",
			"RightLipCornerDown",
			"RightLipCornerPuller",
			"RightLipStretcher",
			"RightLowerLipDepressor",
			"RightNoseWrinkler",
			"RightOuterBrowRaiser",
			"RightUpperLipRaiser",
			"TongueDown",
			"TongueOut",
			"TongueUp",
			"UpperLipSuck",
		},
		Superclass = "Instance",
	},
	FaceInstance = { Properties = { "Face" }, Superclass = "Instance" },
	Decal = { Properties = { "Color3", "Texture", "Transparency", "ZIndex" }, Superclass = "FaceInstance" },
	Texture = {
		Properties = { "OffsetStudsU", "OffsetStudsV", "StudsPerTileU", "StudsPerTileV" },
		Superclass = "Decal",
	},
	Feature = { Properties = { "FaceId", "InOut", "LeftRight", "TopBottom" }, Superclass = "Instance" },
	Hole = { Properties = {}, Superclass = "Feature" },
	MotorFeature = { Properties = {}, Superclass = "Feature" },
	File = { Properties = {}, Superclass = "Instance" },
	Fire = { Properties = { "Color", "Enabled", "Heat", "SecondaryColor", "Size" }, Superclass = "Instance" },
	FloatCurve = { Properties = { "Length" }, Superclass = "Instance" },
	Folder = { Properties = {}, Superclass = "Instance" },
	ForceField = { Properties = { "Visible" }, Superclass = "Instance" },
	FunctionalTest = { Properties = { "Description" }, Superclass = "Instance" },
	GameSettings = {
		Properties = { "AdditionalCoreIncludeDirs", "OverrideStarterScript", "VideoCaptureEnabled", "VideoRecording" },
		Superclass = "Instance",
	},
	GlobalDataStore = { Properties = {}, Superclass = "Instance" },
	DataStore = { Properties = {}, Superclass = "GlobalDataStore" },
	OrderedDataStore = { Properties = {}, Superclass = "GlobalDataStore" },
	GuiBase = { Properties = {}, Superclass = "Instance" },
	GuiBase2d = {
		Properties = {
			"AbsolutePosition",
			"AbsoluteRotation",
			"AbsoluteSize",
			"AutoLocalize",
			"RootLocalizationTable",
		},
		Superclass = "GuiBase",
	},
	GuiObject = {
		Properties = {
			"Active",
			"AnchorPoint",
			"AutomaticSize",
			"BackgroundColor3",
			"BackgroundTransparency",
			"BorderColor3",
			"BorderMode",
			"BorderSizePixel",
			"ClipsDescendants",
			"LayoutOrder",
			"NextSelectionDown",
			"NextSelectionLeft",
			"NextSelectionRight",
			"NextSelectionUp",
			"Position",
			"Rotation",
			"Selectable",
			"SelectionImageObject",
			"Size",
			"SizeConstraint",
			"Visible",
			"ZIndex",
		},
		Superclass = "GuiBase2d",
	},
	CanvasGroup = { Properties = { "GroupColor", "Transparency" }, Superclass = "GuiObject" },
	Frame = { Properties = { "Style" }, Superclass = "GuiObject" },
	GuiButton = { Properties = { "AutoButtonColor", "Modal", "Selected", "Style" }, Superclass = "GuiObject" },
	ImageButton = {
		Properties = {
			"HoverImage",
			"Image",
			"ImageColor3",
			"ImageRectOffset",
			"ImageRectSize",
			"ImageTransparency",
			"IsLoaded",
			"PressedImage",
			"ResampleMode",
			"ScaleType",
			"SliceCenter",
			"SliceScale",
			"TileSize",
		},
		Superclass = "GuiButton",
	},
	TextButton = {
		Properties = {
			"ContentText",
			"Font",
			"LineHeight",
			"MaxVisibleGraphemes",
			"RichText",
			"Text",
			"TextBounds",
			"TextColor3",
			"TextFits",
			"TextScaled",
			"TextSize",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextTransparency",
			"TextTruncate",
			"TextWrapped",
			"TextXAlignment",
			"TextYAlignment",
		},
		Superclass = "GuiButton",
	},
	GuiLabel = { Properties = {}, Superclass = "GuiObject" },
	ImageLabel = {
		Properties = {
			"Image",
			"ImageColor3",
			"ImageRectOffset",
			"ImageRectSize",
			"ImageTransparency",
			"IsLoaded",
			"ResampleMode",
			"ScaleType",
			"SliceCenter",
			"SliceScale",
			"TileSize",
		},
		Superclass = "GuiLabel",
	},
	TextLabel = {
		Properties = {
			"ContentText",
			"Font",
			"LineHeight",
			"MaxVisibleGraphemes",
			"RichText",
			"Text",
			"TextBounds",
			"TextColor3",
			"TextFits",
			"TextScaled",
			"TextSize",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextTransparency",
			"TextTruncate",
			"TextWrapped",
			"TextXAlignment",
			"TextYAlignment",
		},
		Superclass = "GuiLabel",
	},
	ScrollingFrame = {
		Properties = {
			"AbsoluteCanvasSize",
			"AbsoluteWindowSize",
			"AutomaticCanvasSize",
			"BottomImage",
			"CanvasPosition",
			"CanvasSize",
			"ElasticBehavior",
			"HorizontalScrollBarInset",
			"MidImage",
			"ScrollBarImageColor3",
			"ScrollBarImageTransparency",
			"ScrollBarThickness",
			"ScrollingDirection",
			"ScrollingEnabled",
			"TopImage",
			"VerticalScrollBarInset",
			"VerticalScrollBarPosition",
		},
		Superclass = "GuiObject",
	},
	TextBox = {
		Properties = {
			"ClearTextOnFocus",
			"ContentText",
			"CursorPosition",
			"Font",
			"LineHeight",
			"MaxVisibleGraphemes",
			"MultiLine",
			"PlaceholderColor3",
			"PlaceholderText",
			"RichText",
			"SelectionStart",
			"ShowNativeInput",
			"Text",
			"TextBounds",
			"TextColor3",
			"TextEditable",
			"TextFits",
			"TextScaled",
			"TextSize",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextTransparency",
			"TextTruncate",
			"TextWrapped",
			"TextXAlignment",
			"TextYAlignment",
		},
		Superclass = "GuiObject",
	},
	VideoFrame = {
		Properties = {
			"IsLoaded",
			"Looped",
			"Playing",
			"Resolution",
			"TimeLength",
			"TimePosition",
			"Video",
			"Volume",
		},
		Superclass = "GuiObject",
	},
	ViewportFrame = {
		Properties = {
			"Ambient",
			"CurrentCamera",
			"ImageColor3",
			"ImageTransparency",
			"LightColor",
			"LightDirection",
		},
		Superclass = "GuiObject",
	},
	LayerCollector = { Properties = { "Enabled", "ResetOnSpawn", "ZIndexBehavior" }, Superclass = "GuiBase2d" },
	BillboardGui = {
		Properties = {
			"Active",
			"Adornee",
			"AlwaysOnTop",
			"Brightness",
			"ClipsDescendants",
			"CurrentDistance",
			"DistanceLowerLimit",
			"DistanceStep",
			"DistanceUpperLimit",
			"ExtentsOffset",
			"ExtentsOffsetWorldSpace",
			"LightInfluence",
			"MaxDistance",
			"PlayerToHideFrom",
			"Size",
			"SizeOffset",
			"StudsOffset",
			"StudsOffsetWorldSpace",
		},
		Superclass = "LayerCollector",
	},
	PluginGui = { Properties = { "Title" }, Superclass = "LayerCollector" },
	DockWidgetPluginGui = { Properties = { "HostWidgetWasRestored" }, Superclass = "PluginGui" },
	QWidgetPluginGui = { Properties = {}, Superclass = "PluginGui" },
	ScreenGui = { Properties = { "DisplayOrder", "IgnoreGuiInset" }, Superclass = "LayerCollector" },
	GuiMain = { Properties = {}, Superclass = "ScreenGui" },
	SurfaceGui = {
		Properties = {
			"Active",
			"Adornee",
			"AlwaysOnTop",
			"Brightness",
			"CanvasSize",
			"ClipsDescendants",
			"Face",
			"LightInfluence",
			"PixelsPerStud",
			"SizingMode",
			"ToolPunchThroughDistance",
			"ZOffset",
		},
		Superclass = "LayerCollector",
	},
	GuiBase3d = { Properties = { "Color3", "Transparency", "Visible" }, Superclass = "GuiBase" },
	FloorWire = {
		Properties = {
			"CycleOffset",
			"From",
			"StudsBetweenTextures",
			"Texture",
			"TextureSize",
			"To",
			"Velocity",
			"WireRadius",
		},
		Superclass = "GuiBase3d",
	},
	InstanceAdornment = { Properties = { "Adornee" }, Superclass = "GuiBase3d" },
	SelectionBox = {
		Properties = { "LineThickness", "SurfaceColor3", "SurfaceTransparency" },
		Superclass = "InstanceAdornment",
	},
	PVAdornment = { Properties = { "Adornee" }, Superclass = "GuiBase3d" },
	HandleAdornment = {
		Properties = { "AdornCullingMode", "AlwaysOnTop", "CFrame", "SizeRelativeOffset", "ZIndex" },
		Superclass = "PVAdornment",
	},
	BoxHandleAdornment = { Properties = { "Size" }, Superclass = "HandleAdornment" },
	ConeHandleAdornment = { Properties = { "Height", "Radius" }, Superclass = "HandleAdornment" },
	CylinderHandleAdornment = {
		Properties = { "Angle", "Height", "InnerRadius", "Radius" },
		Superclass = "HandleAdornment",
	},
	ImageHandleAdornment = { Properties = { "Image", "Size" }, Superclass = "HandleAdornment" },
	LineHandleAdornment = { Properties = { "Length", "Thickness" }, Superclass = "HandleAdornment" },
	SphereHandleAdornment = { Properties = { "Radius" }, Superclass = "HandleAdornment" },
	ParabolaAdornment = { Properties = {}, Superclass = "PVAdornment" },
	SelectionSphere = { Properties = { "SurfaceColor3", "SurfaceTransparency" }, Superclass = "PVAdornment" },
	PartAdornment = { Properties = { "Adornee" }, Superclass = "GuiBase3d" },
	HandlesBase = { Properties = {}, Superclass = "PartAdornment" },
	ArcHandles = { Properties = { "Axes" }, Superclass = "HandlesBase" },
	Handles = { Properties = { "Faces", "Style" }, Superclass = "HandlesBase" },
	SurfaceSelection = { Properties = { "TargetSurface" }, Superclass = "PartAdornment" },
	SelectionLasso = { Properties = { "Humanoid" }, Superclass = "GuiBase3d" },
	SelectionPartLasso = { Properties = { "Part" }, Superclass = "SelectionLasso" },
	SelectionPointLasso = { Properties = { "Point" }, Superclass = "SelectionLasso" },
	Highlight = {
		Properties = {
			"DepthMode",
			"Enabled",
			"FillColor",
			"FillTransparency",
			"OutlineColor",
			"OutlineTransparency",
		},
		Superclass = "Instance",
	},
	HttpRequest = { Properties = {}, Superclass = "Instance" },
	Humanoid = {
		Properties = {
			"AutoJumpEnabled",
			"AutoRotate",
			"AutomaticScalingEnabled",
			"BreakJointsOnDeath",
			"CameraOffset",
			"DisplayDistanceType",
			"DisplayName",
			"FloorMaterial",
			"Health",
			"HealthDisplayDistance",
			"HealthDisplayType",
			"HipHeight",
			"Jump",
			"JumpHeight",
			"JumpPower",
			"MaxHealth",
			"MaxSlopeAngle",
			"MoveDirection",
			"NameDisplayDistance",
			"NameOcclusion",
			"PlatformStand",
			"RequiresNeck",
			"RigType",
			"RootPart",
			"SeatPart",
			"Sit",
			"TargetPoint",
			"UseJumpPower",
			"WalkSpeed",
			"WalkToPart",
			"WalkToPoint",
		},
		Superclass = "Instance",
	},
	HumanoidDescription = {
		Properties = {
			"BackAccessory",
			"BodyTypeScale",
			"ClimbAnimation",
			"DepthScale",
			"Face",
			"FaceAccessory",
			"FallAnimation",
			"FrontAccessory",
			"GraphicTShirt",
			"HairAccessory",
			"HatAccessory",
			"Head",
			"HeadColor",
			"HeadScale",
			"HeightScale",
			"IdleAnimation",
			"JumpAnimation",
			"LeftArm",
			"LeftArmColor",
			"LeftLeg",
			"LeftLegColor",
			"NeckAccessory",
			"Pants",
			"ProportionScale",
			"RightArm",
			"RightArmColor",
			"RightLeg",
			"RightLegColor",
			"RunAnimation",
			"Shirt",
			"ShouldersAccessory",
			"SwimAnimation",
			"Torso",
			"TorsoColor",
			"WaistAccessory",
			"WalkAnimation",
			"WidthScale",
		},
		Superclass = "Instance",
	},
	ImporterBaseSettings = { Properties = { "Id", "ImportName", "ShouldImport" }, Superclass = "Instance" },
	ImporterGroupSettings = {
		Properties = { "Anchored", "ImportAsModelAsset", "InsertInWorkspace" },
		Superclass = "ImporterBaseSettings",
	},
	ImporterJointSettings = { Properties = {}, Superclass = "ImporterBaseSettings" },
	ImporterMeshSettings = {
		Properties = { "Anchored", "Dimensions", "DoubleSided", "IgnoreVertexColors", "PolygonCount" },
		Superclass = "ImporterBaseSettings",
	},
	ImporterRootSettings = {
		Properties = {
			"Anchored",
			"FileDimensions",
			"ImportAsModelAsset",
			"InsertInWorkspace",
			"InvertNegativeFaces",
			"MergeMeshes",
			"PolygonCount",
			"RigType",
			"ScaleUnit",
			"WorldForward",
			"WorldUp",
		},
		Superclass = "ImporterBaseSettings",
	},
	ImporterTextureSettings = { Properties = { "FilePath" }, Superclass = "ImporterBaseSettings" },
	InputObject = {
		Properties = { "Delta", "KeyCode", "Position", "UserInputState", "UserInputType" },
		Superclass = "Instance",
	},
	JointInstance = { Properties = { "Active", "C0", "C1", "Enabled", "Part0", "Part1" }, Superclass = "Instance" },
	DynamicRotate = { Properties = { "BaseAngle" }, Superclass = "JointInstance" },
	RotateP = { Properties = {}, Superclass = "DynamicRotate" },
	RotateV = { Properties = {}, Superclass = "DynamicRotate" },
	Glue = { Properties = { "F0", "F1", "F2", "F3" }, Superclass = "JointInstance" },
	ManualSurfaceJointInstance = { Properties = {}, Superclass = "JointInstance" },
	ManualGlue = { Properties = {}, Superclass = "ManualSurfaceJointInstance" },
	ManualWeld = { Properties = {}, Superclass = "ManualSurfaceJointInstance" },
	Motor = { Properties = { "CurrentAngle", "DesiredAngle", "MaxVelocity" }, Superclass = "JointInstance" },
	Motor6D = { Properties = {}, Superclass = "Motor" },
	Rotate = { Properties = {}, Superclass = "JointInstance" },
	Snap = { Properties = {}, Superclass = "JointInstance" },
	VelocityMotor = {
		Properties = { "CurrentAngle", "DesiredAngle", "Hole", "MaxVelocity" },
		Superclass = "JointInstance",
	},
	Weld = { Properties = {}, Superclass = "JointInstance" },
	Keyframe = { Properties = { "Time" }, Superclass = "Instance" },
	KeyframeMarker = { Properties = { "Value" }, Superclass = "Instance" },
	Light = { Properties = { "Brightness", "Color", "Enabled", "Shadows" }, Superclass = "Instance" },
	PointLight = { Properties = { "Range" }, Superclass = "Light" },
	SpotLight = { Properties = { "Angle", "Face", "Range" }, Superclass = "Light" },
	SurfaceLight = { Properties = { "Angle", "Face", "Range" }, Superclass = "Light" },
	LocalizationTable = { Properties = { "SourceLocaleId" }, Superclass = "Instance" },
	LodDataEntity = { Properties = {}, Superclass = "Instance" },
	LuaSettings = { Properties = {}, Superclass = "Instance" },
	LuaSourceContainer = { Properties = {}, Superclass = "Instance" },
	BaseScript = { Properties = { "Disabled" }, Superclass = "LuaSourceContainer" },
	CoreScript = { Properties = {}, Superclass = "BaseScript" },
	Script = { Properties = {}, Superclass = "BaseScript" },
	LocalScript = { Properties = {}, Superclass = "Script" },
	ModuleScript = { Properties = {}, Superclass = "LuaSourceContainer" },
	MaterialVariant = {
		Properties = { "BaseMaterial", "ColorMap", "MetalnessMap", "NormalMap", "RoughnessMap", "StudsPerTile" },
		Superclass = "Instance",
	},
	MemStorageConnection = { Properties = {}, Superclass = "Instance" },
	MemoryStoreQueue = { Properties = {}, Superclass = "Instance" },
	MemoryStoreSortedMap = { Properties = {}, Superclass = "Instance" },
	Message = { Properties = { "Text" }, Superclass = "Instance" },
	Hint = { Properties = {}, Superclass = "Message" },
	MessageBusConnection = { Properties = {}, Superclass = "Instance" },
	MetaBreakpoint = { Properties = {}, Superclass = "Instance" },
	MetaBreakpointContext = { Properties = {}, Superclass = "Instance" },
	Mouse = {
		Properties = {
			"Hit",
			"Icon",
			"Origin",
			"Target",
			"TargetFilter",
			"TargetSurface",
			"UnitRay",
			"ViewSizeX",
			"ViewSizeY",
			"X",
			"Y",
		},
		Superclass = "Instance",
	},
	PlayerMouse = { Properties = {}, Superclass = "Mouse" },
	PluginMouse = { Properties = {}, Superclass = "Mouse" },
	MultipleDocumentInterfaceInstance = { Properties = {}, Superclass = "Instance" },
	NetworkMarker = { Properties = {}, Superclass = "Instance" },
	NetworkPeer = { Properties = {}, Superclass = "Instance" },
	NetworkReplicator = { Properties = {}, Superclass = "Instance" },
	ClientReplicator = { Properties = {}, Superclass = "NetworkReplicator" },
	ServerReplicator = { Properties = {}, Superclass = "NetworkReplicator" },
	NoCollisionConstraint = { Properties = { "Enabled", "Part0", "Part1" }, Superclass = "Instance" },
	PVInstance = { Properties = {}, Superclass = "Instance" },
	BasePart = {
		Properties = {
			"Anchored",
			"AssemblyAngularVelocity",
			"AssemblyCenterOfMass",
			"AssemblyLinearVelocity",
			"AssemblyMass",
			"AssemblyRootPart",
			"BackSurface",
			"BottomSurface",
			"BrickColor",
			"CFrame",
			"CanCollide",
			"CanQuery",
			"CanTouch",
			"CastShadow",
			"CenterOfMass",
			"CollisionGroupId",
			"Color",
			"CustomPhysicalProperties",
			"FrontSurface",
			"LeftSurface",
			"Locked",
			"Mass",
			"Massless",
			"Material",
			"Orientation",
			"PivotOffset",
			"Position",
			"Reflectance",
			"ResizeIncrement",
			"ResizeableFaces",
			"RightSurface",
			"RootPriority",
			"Rotation",
			"Size",
			"TopSurface",
			"Transparency",
		},
		Superclass = "PVInstance",
	},
	CornerWedgePart = { Properties = {}, Superclass = "BasePart" },
	FormFactorPart = { Properties = {}, Superclass = "BasePart" },
	Part = { Properties = { "Shape" }, Superclass = "FormFactorPart" },
	FlagStand = { Properties = { "TeamColor" }, Superclass = "Part" },
	Platform = { Properties = {}, Superclass = "Part" },
	Seat = { Properties = { "Disabled", "Occupant" }, Superclass = "Part" },
	SkateboardPlatform = {
		Properties = { "Controller", "ControllingHumanoid", "Steer", "StickyWheels", "Throttle" },
		Superclass = "Part",
	},
	SpawnLocation = {
		Properties = { "AllowTeamChangeOnTouch", "Duration", "Enabled", "Neutral", "TeamColor" },
		Superclass = "Part",
	},
	WedgePart = { Properties = {}, Superclass = "FormFactorPart" },
	Terrain = {
		Properties = {
			"MaxExtents",
			"WaterColor",
			"WaterReflectance",
			"WaterTransparency",
			"WaterWaveSize",
			"WaterWaveSpeed",
		},
		Superclass = "BasePart",
	},
	TriangleMeshPart = { Properties = { "CollisionFidelity" }, Superclass = "BasePart" },
	MeshPart = {
		Properties = { "DoubleSided", "MeshId", "MeshSize", "RenderFidelity", "TextureID" },
		Superclass = "TriangleMeshPart",
	},
	PartOperation = {
		Properties = { "RenderFidelity", "SmoothingAngle", "TriangleCount", "UsePartColor" },
		Superclass = "TriangleMeshPart",
	},
	NegateOperation = { Properties = {}, Superclass = "PartOperation" },
	UnionOperation = { Properties = {}, Superclass = "PartOperation" },
	TrussPart = { Properties = { "Style" }, Superclass = "BasePart" },
	VehicleSeat = {
		Properties = {
			"AreHingesDetected",
			"Disabled",
			"HeadsUpDisplay",
			"MaxSpeed",
			"Occupant",
			"Steer",
			"SteerFloat",
			"Throttle",
			"ThrottleFloat",
			"Torque",
			"TurnSpeed",
		},
		Superclass = "BasePart",
	},
	Model = { Properties = { "LevelOfDetail", "PrimaryPart", "WorldPivot" }, Superclass = "PVInstance" },
	Actor = { Properties = {}, Superclass = "Model" },
	Status = { Properties = {}, Superclass = "Model" },
	WorldRoot = { Properties = {}, Superclass = "Model" },
	WorldModel = { Properties = {}, Superclass = "WorldRoot" },
	PackageLink = { Properties = { "PackageId", "Status", "VersionNumber" }, Superclass = "Instance" },
	Pages = { Properties = { "IsFinished" }, Superclass = "Instance" },
	CatalogPages = { Properties = {}, Superclass = "Pages" },
	DataStoreKeyPages = { Properties = {}, Superclass = "Pages" },
	DataStoreListingPages = { Properties = {}, Superclass = "Pages" },
	DataStorePages = { Properties = {}, Superclass = "Pages" },
	DataStoreVersionPages = { Properties = {}, Superclass = "Pages" },
	FriendPages = { Properties = {}, Superclass = "Pages" },
	InventoryPages = { Properties = {}, Superclass = "Pages" },
	EmotesPages = { Properties = {}, Superclass = "InventoryPages" },
	OutfitPages = { Properties = {}, Superclass = "Pages" },
	StandardPages = { Properties = {}, Superclass = "Pages" },
	PartOperationAsset = { Properties = {}, Superclass = "Instance" },
	ParticleEmitter = {
		Properties = {
			"Acceleration",
			"Brightness",
			"Color",
			"Drag",
			"EmissionDirection",
			"Enabled",
			"Lifetime",
			"LightEmission",
			"LightInfluence",
			"LockedToPart",
			"Orientation",
			"Rate",
			"RotSpeed",
			"Rotation",
			"Shape",
			"ShapeInOut",
			"ShapePartial",
			"ShapeStyle",
			"Size",
			"Speed",
			"SpreadAngle",
			"Squash",
			"Texture",
			"TimeScale",
			"Transparency",
			"VelocityInheritance",
			"ZOffset",
		},
		Superclass = "Instance",
	},
	Path = { Properties = { "Status" }, Superclass = "Instance" },
	PathfindingLink = { Properties = { "Attachment0", "Attachment1", "IsBidirectional" }, Superclass = "Instance" },
	PathfindingModifier = { Properties = { "ModifierId", "PassThrough" }, Superclass = "Instance" },
	PausedState = { Properties = {}, Superclass = "Instance" },
	PausedStateBreakpoint = { Properties = {}, Superclass = "PausedState" },
	PausedStateException = { Properties = {}, Superclass = "PausedState" },
	PhysicsSettings = {
		Properties = {
			"AllowSleep",
			"AreAnchorsShown",
			"AreAssembliesShown",
			"AreAwakePartsHighlighted",
			"AreBodyTypesShown",
			"AreContactIslandsShown",
			"AreContactPointsShown",
			"AreJointCoordinatesShown",
			"AreMechanismsShown",
			"AreModelCoordsShown",
			"AreOwnersShown",
			"ArePartCoordsShown",
			"AreRegionsShown",
			"AreTerrainReplicationRegionsShown",
			"AreTimestepsShown",
			"AreUnalignedPartsShown",
			"AreWorldCoordsShown",
			"DisableCSGv2",
			"IsInterpolationThrottleShown",
			"IsReceiveAgeShown",
			"IsTreeShown",
			"PhysicsEnvironmentalThrottle",
			"ShowDecompositionGeometry",
			"ThrottleAdjustTime",
			"UseCSGv2",
		},
		Superclass = "Instance",
	},
	Player = {
		Properties = {
			"AccountAge",
			"AutoJumpEnabled",
			"CameraMaxZoomDistance",
			"CameraMinZoomDistance",
			"CameraMode",
			"CanLoadCharacterAppearance",
			"Character",
			"CharacterAppearanceId",
			"DevCameraOcclusionMode",
			"DevComputerCameraMode",
			"DevComputerMovementMode",
			"DevEnableMouseLock",
			"DevTouchCameraMode",
			"DevTouchMovementMode",
			"DisplayName",
			"FollowUserId",
			"GameplayPaused",
			"HealthDisplayDistance",
			"MembershipType",
			"NameDisplayDistance",
			"Neutral",
			"ReplicationFocus",
			"RespawnLocation",
			"Team",
			"TeamColor",
			"UserId",
		},
		Superclass = "Instance",
	},
	PlayerScripts = { Properties = {}, Superclass = "Instance" },
	Plugin = { Properties = { "CollisionEnabled", "GridSize" }, Superclass = "Instance" },
	PluginAction = { Properties = { "ActionId", "AllowBinding", "StatusTip", "Text" }, Superclass = "Instance" },
	PluginDragEvent = { Properties = { "Data", "MimeType", "Position", "Sender" }, Superclass = "Instance" },
	PluginManager = { Properties = {}, Superclass = "Instance" },
	PluginManagerInterface = { Properties = {}, Superclass = "Instance" },
	PluginMenu = { Properties = { "Icon", "Title" }, Superclass = "Instance" },
	PluginToolbar = { Properties = {}, Superclass = "Instance" },
	PluginToolbarButton = {
		Properties = { "ClickableWhenViewportHidden", "Enabled", "Icon" },
		Superclass = "Instance",
	},
	PoseBase = { Properties = { "EasingDirection", "EasingStyle", "Weight" }, Superclass = "Instance" },
	NumberPose = { Properties = { "Value" }, Superclass = "PoseBase" },
	Pose = { Properties = { "CFrame" }, Superclass = "PoseBase" },
	PostEffect = { Properties = { "Enabled" }, Superclass = "Instance" },
	BloomEffect = { Properties = { "Intensity", "Size", "Threshold" }, Superclass = "PostEffect" },
	BlurEffect = { Properties = { "Size" }, Superclass = "PostEffect" },
	ColorCorrectionEffect = {
		Properties = { "Brightness", "Contrast", "Saturation", "TintColor" },
		Superclass = "PostEffect",
	},
	DepthOfFieldEffect = {
		Properties = { "FarIntensity", "FocusDistance", "InFocusRadius", "NearIntensity" },
		Superclass = "PostEffect",
	},
	SunRaysEffect = { Properties = { "Intensity", "Spread" }, Superclass = "PostEffect" },
	ProximityPrompt = {
		Properties = {
			"ActionText",
			"AutoLocalize",
			"ClickablePrompt",
			"Enabled",
			"Exclusivity",
			"GamepadKeyCode",
			"HoldDuration",
			"KeyboardKeyCode",
			"MaxActivationDistance",
			"ObjectText",
			"RequiresLineOfSight",
			"RootLocalizationTable",
			"Style",
			"UIOffset",
		},
		Superclass = "Instance",
	},
	ReflectionMetadata = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataCallbacks = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataClasses = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataEnums = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataEvents = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataFunctions = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataItem = {
		Properties = {
			"Browsable",
			"ClassCategory",
			"ClientOnly",
			"Constraint",
			"Deprecated",
			"EditingDisabled",
			"EditorType",
			"FFlag",
			"IsBackend",
			"PropertyOrder",
			"ScriptContext",
			"ServerOnly",
			"UIMaximum",
			"UIMinimum",
			"UINumTicks",
		},
		Superclass = "Instance",
	},
	ReflectionMetadataClass = {
		Properties = { "ExplorerImageIndex", "ExplorerOrder", "Insertable", "PreferredParent" },
		Superclass = "ReflectionMetadataItem",
	},
	ReflectionMetadataEnum = { Properties = {}, Superclass = "ReflectionMetadataItem" },
	ReflectionMetadataEnumItem = { Properties = {}, Superclass = "ReflectionMetadataItem" },
	ReflectionMetadataMember = { Properties = {}, Superclass = "ReflectionMetadataItem" },
	ReflectionMetadataProperties = { Properties = {}, Superclass = "Instance" },
	ReflectionMetadataYieldFunctions = { Properties = {}, Superclass = "Instance" },
	RemoteEvent = { Properties = {}, Superclass = "Instance" },
	RemoteFunction = { Properties = {}, Superclass = "Instance" },
	RenderingTest = {
		Properties = {
			"CFrame",
			"ComparisonDiffThreshold",
			"ComparisonMethod",
			"ComparisonPsnrThreshold",
			"Description",
			"FieldOfView",
			"Orientation",
			"Position",
			"QualityLevel",
			"ShouldSkip",
			"Ticket",
		},
		Superclass = "Instance",
	},
	RotationCurve = { Properties = { "Length" }, Superclass = "Instance" },
	ScriptDebugger = { Properties = { "CurrentLine", "IsDebugging", "IsPaused", "Script" }, Superclass = "Instance" },
	ServiceProvider = { Properties = {}, Superclass = "Instance" },
	DataModel = {
		Properties = {
			"CreatorId",
			"CreatorType",
			"GameId",
			"Genre",
			"JobId",
			"PlaceId",
			"PlaceVersion",
			"PrivateServerId",
			"PrivateServerOwnerId",
			"Workspace",
		},
		Superclass = "ServiceProvider",
	},
	GenericSettings = { Properties = {}, Superclass = "ServiceProvider" },
	AnalysticsSettings = { Properties = {}, Superclass = "GenericSettings" },
	GlobalSettings = { Properties = {}, Superclass = "GenericSettings" },
	UserSettings = { Properties = {}, Superclass = "GenericSettings" },
	Sky = {
		Properties = {
			"CelestialBodiesShown",
			"MoonAngularSize",
			"MoonTextureId",
			"SkyboxBk",
			"SkyboxDn",
			"SkyboxFt",
			"SkyboxLf",
			"SkyboxRt",
			"SkyboxUp",
			"StarCount",
			"SunAngularSize",
			"SunTextureId",
		},
		Superclass = "Instance",
	},
	Smoke = { Properties = { "Color", "Enabled", "Opacity", "RiseVelocity", "Size" }, Superclass = "Instance" },
	Sound = {
		Properties = {
			"ChannelCount",
			"IsLoaded",
			"IsPaused",
			"IsPlaying",
			"Looped",
			"PlayOnRemove",
			"PlaybackLoudness",
			"PlaybackSpeed",
			"Playing",
			"RollOffMaxDistance",
			"RollOffMinDistance",
			"RollOffMode",
			"SoundGroup",
			"SoundId",
			"TimeLength",
			"TimePosition",
			"Volume",
		},
		Superclass = "Instance",
	},
	SoundEffect = { Properties = { "Enabled", "Priority" }, Superclass = "Instance" },
	ChorusSoundEffect = { Properties = { "Depth", "Mix", "Rate" }, Superclass = "SoundEffect" },
	CompressorSoundEffect = {
		Properties = { "Attack", "GainMakeup", "Ratio", "Release", "SideChain", "Threshold" },
		Superclass = "SoundEffect",
	},
	CustomDspSoundEffect = { Properties = {}, Superclass = "SoundEffect" },
	ChannelSelectorSoundEffect = { Properties = { "Channel" }, Superclass = "CustomDspSoundEffect" },
	DistortionSoundEffect = { Properties = { "Level" }, Superclass = "SoundEffect" },
	EchoSoundEffect = { Properties = { "Delay", "DryLevel", "Feedback", "WetLevel" }, Superclass = "SoundEffect" },
	EqualizerSoundEffect = { Properties = { "HighGain", "LowGain", "MidGain" }, Superclass = "SoundEffect" },
	FlangeSoundEffect = { Properties = { "Depth", "Mix", "Rate" }, Superclass = "SoundEffect" },
	PitchShiftSoundEffect = { Properties = { "Octave" }, Superclass = "SoundEffect" },
	ReverbSoundEffect = {
		Properties = { "DecayTime", "Density", "Diffusion", "DryLevel", "WetLevel" },
		Superclass = "SoundEffect",
	},
	TremoloSoundEffect = { Properties = { "Depth", "Duty", "Frequency" }, Superclass = "SoundEffect" },
	SoundGroup = { Properties = { "Volume" }, Superclass = "Instance" },
	Sparkles = { Properties = { "Enabled", "SparkleColor" }, Superclass = "Instance" },
	Speaker = {
		Properties = {
			"ChannelCount",
			"PlaybackLoudness",
			"RollOffMaxDistance",
			"RollOffMinDistance",
			"RollOffMode",
			"SoundGroup",
			"Volume",
		},
		Superclass = "Instance",
	},
	StackFrame = { Properties = {}, Superclass = "Instance" },
	StandalonePluginScripts = { Properties = {}, Superclass = "Instance" },
	StarterGear = { Properties = {}, Superclass = "Instance" },
	StarterPlayerScripts = { Properties = {}, Superclass = "Instance" },
	StarterCharacterScripts = { Properties = {}, Superclass = "StarterPlayerScripts" },
	StatsItem = { Properties = {}, Superclass = "Instance" },
	RunningAverageItemDouble = { Properties = {}, Superclass = "StatsItem" },
	RunningAverageItemInt = { Properties = {}, Superclass = "StatsItem" },
	RunningAverageTimeIntervalItem = { Properties = {}, Superclass = "StatsItem" },
	TotalCountTimeIntervalItem = { Properties = {}, Superclass = "StatsItem" },
	StudioTheme = { Properties = {}, Superclass = "Instance" },
	SurfaceAppearance = {
		Properties = { "AlphaMode", "ColorMap", "MetalnessMap", "NormalMap", "RoughnessMap" },
		Superclass = "Instance",
	},
	Team = { Properties = { "AutoAssignable", "TeamColor" }, Superclass = "Instance" },
	TeleportAsyncResult = { Properties = { "PrivateServerId", "ReservedServerAccessCode" }, Superclass = "Instance" },
	TeleportOptions = {
		Properties = { "ReservedServerAccessCode", "ServerInstanceId", "ShouldReserveServer" },
		Superclass = "Instance",
	},
	TerrainRegion = { Properties = { "SizeInCells" }, Superclass = "Instance" },
	TextChannel = { Properties = {}, Superclass = "Instance" },
	TextFilterResult = { Properties = {}, Superclass = "Instance" },
	TextSource = { Properties = { "CanSend", "UserId" }, Superclass = "Instance" },
	ThreadState = { Properties = {}, Superclass = "Instance" },
	TouchTransmitter = { Properties = {}, Superclass = "Instance" },
	Trail = {
		Properties = {
			"Attachment0",
			"Attachment1",
			"Brightness",
			"Color",
			"Enabled",
			"FaceCamera",
			"Lifetime",
			"LightEmission",
			"LightInfluence",
			"MaxLength",
			"MinLength",
			"Texture",
			"TextureLength",
			"TextureMode",
			"Transparency",
			"WidthScale",
		},
		Superclass = "Instance",
	},
	Translator = { Properties = { "LocaleId" }, Superclass = "Instance" },
	TweenBase = { Properties = { "PlaybackState" }, Superclass = "Instance" },
	Tween = { Properties = { "Instance", "TweenInfo" }, Superclass = "TweenBase" },
	UIBase = { Properties = {}, Superclass = "Instance" },
	UIComponent = { Properties = {}, Superclass = "UIBase" },
	UIConstraint = { Properties = {}, Superclass = "UIComponent" },
	UIAspectRatioConstraint = {
		Properties = { "AspectRatio", "AspectType", "DominantAxis" },
		Superclass = "UIConstraint",
	},
	UISizeConstraint = { Properties = { "MaxSize", "MinSize" }, Superclass = "UIConstraint" },
	UITextSizeConstraint = { Properties = { "MaxTextSize", "MinTextSize" }, Superclass = "UIConstraint" },
	UICorner = { Properties = { "CornerRadius" }, Superclass = "UIComponent" },
	UIGradient = {
		Properties = { "Color", "Enabled", "Offset", "Rotation", "Transparency" },
		Superclass = "UIComponent",
	},
	UILayout = { Properties = {}, Superclass = "UIComponent" },
	UIGridStyleLayout = {
		Properties = {
			"AbsoluteContentSize",
			"FillDirection",
			"HorizontalAlignment",
			"SortOrder",
			"VerticalAlignment",
		},
		Superclass = "UILayout",
	},
	UIGridLayout = {
		Properties = {
			"AbsoluteCellCount",
			"AbsoluteCellSize",
			"CellPadding",
			"CellSize",
			"FillDirectionMaxCells",
			"StartCorner",
		},
		Superclass = "UIGridStyleLayout",
	},
	UIListLayout = { Properties = { "Padding" }, Superclass = "UIGridStyleLayout" },
	UIPageLayout = {
		Properties = {
			"Animated",
			"Circular",
			"CurrentPage",
			"EasingDirection",
			"EasingStyle",
			"GamepadInputEnabled",
			"Padding",
			"ScrollWheelInputEnabled",
			"TouchInputEnabled",
			"TweenTime",
		},
		Superclass = "UIGridStyleLayout",
	},
	UITableLayout = {
		Properties = { "FillEmptySpaceColumns", "FillEmptySpaceRows", "MajorAxis", "Padding" },
		Superclass = "UIGridStyleLayout",
	},
	UIPadding = {
		Properties = { "PaddingBottom", "PaddingLeft", "PaddingRight", "PaddingTop" },
		Superclass = "UIComponent",
	},
	UIScale = { Properties = { "Scale" }, Superclass = "UIComponent" },
	UIStroke = {
		Properties = { "ApplyStrokeMode", "Color", "Enabled", "LineJoinMode", "Thickness", "Transparency" },
		Superclass = "UIComponent",
	},
	UserGameSettings = {
		Properties = {
			"AllTutorialsDisabled",
			"CameraMode",
			"ChatVisible",
			"ComputerCameraMovementMode",
			"ComputerMovementMode",
			"ControlMode",
			"Fullscreen",
			"GamepadCameraSensitivity",
			"GraphicsQualityLevel",
			"HasEverUsedVR",
			"MasterVolume",
			"MouseSensitivity",
			"OnboardingsCompleted",
			"RCCProfilerRecordFrameRate",
			"RCCProfilerRecordTimeFrame",
			"RotationType",
			"SavedQualityLevel",
			"TouchCameraMovementMode",
			"TouchMovementMode",
			"UsedCoreGuiIsVisibleToggle",
			"UsedCustomGuiIsVisibleToggle",
			"UsedHideHudShortcut",
			"VREnabled",
			"VRRotationIntensity",
		},
		Superclass = "Instance",
	},
	ValueBase = { Properties = {}, Superclass = "Instance" },
	BinaryStringValue = { Properties = {}, Superclass = "ValueBase" },
	BoolValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	BrickColorValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	CFrameValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	Color3Value = { Properties = { "Value" }, Superclass = "ValueBase" },
	DoubleConstrainedValue = { Properties = { "MaxValue", "MinValue", "Value" }, Superclass = "ValueBase" },
	IntConstrainedValue = { Properties = { "MaxValue", "MinValue", "Value" }, Superclass = "ValueBase" },
	IntValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	NumberValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	ObjectValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	RayValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	StringValue = { Properties = { "Value" }, Superclass = "ValueBase" },
	Vector3Value = { Properties = { "Value" }, Superclass = "ValueBase" },
	Vector3Curve = { Properties = {}, Superclass = "Instance" },
	VoiceChannel = { Properties = {}, Superclass = "Instance" },
	VoiceSource = { Properties = { "UserId" }, Superclass = "Instance" },
	WeldConstraint = { Properties = { "Active", "Enabled", "Part0", "Part1" }, Superclass = "Instance" },
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="465">
              <Properties>
                <string name="Name">RobloxInstance</string>
                <string name="Source"><![CDATA[--!nonstrict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local RobloxApi = require(CurrentModule.RobloxApiDump)

local getType = require(Packages.JestGetType).getType

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object

local CurrentModuleExpect = require(CurrentModule.expect)
local equals = CurrentModuleExpect.equals
local isObjectWithKeys = CurrentModuleExpect.isObjectWithKeys
local hasPropertyInObject = CurrentModuleExpect.hasPropertyInObject
local isAsymmetric = CurrentModuleExpect.isAsymmetric

local exports = {}

-- Unsafe because no checks are performed that this property is readable.
local function readPropUnsafe(instance: Instance, propertyName: string): unknown
	return instance[propertyName]
end

-- Unsafe because no checks are performed that this property is writable.
local function writePropUnsafe(instance: Instance, propertyName: string, value: unknown): ()
	instance[propertyName] = value
end

function exports.readProp(instance: Instance, propertyName: string)
	return pcall(readPropUnsafe, instance, propertyName)
end

function exports.writeProp(instance: Instance, propertyName: string, value: unknown)
	return pcall(writePropUnsafe, instance, propertyName, value)
end

-- Unsafe because no checks are performed that these properties are readable.
local function listPropsUnsafe(className: string): { [string]: true }
	local unsafeProps = {}
	local inheritFrom = RobloxApi[className]
	while inheritFrom ~= nil do
		for _, unsafeProp in ipairs(inheritFrom.Properties) do
			unsafeProps[unsafeProp] = true
		end
		inheritFrom = RobloxApi[inheritFrom.Superclass]
	end
	return unsafeProps
end

function exports.listProps(instance: Instance, warmRead: boolean?): { [string]: unknown }
	local props = listPropsUnsafe(instance.ClassName)
	-- cold read - values may not be stable, but at least we can weed out
	-- property reads that will result in errors
	for unsafeProp in props do
		local ok, propValue = exports.readProp(instance, unsafeProp)
		if ok then
			props[unsafeProp] = if propValue == nil then Object.None else propValue
		else
			props[unsafeProp] = nil
		end
	end
	if warmRead then
		-- warm read - quantum UI bugs will no longer affect values here
		for safeProp in props do
			local propValue = readPropUnsafe(instance, safeProp)
			props[safeProp] = if propValue == nil then Object.None else propValue
		end
	end
	return props
end

do
	-- Hidden from outside code.
	local cachedDefaults = {}
	function exports.listDefaultProps(className: string): { [string]: unknown }
		local cached = cachedDefaults[className]
		if cached ~= nil then
			return cached
		end

		local ok, instance = pcall(Instance.new, className)
		if not ok then
			error("Class type is abstract or not creatable - cannot list defaults")
		end
		local defaults = exports.listProps(instance)
		instance:Destroy()

		cachedDefaults[className] = defaults
		return defaults
	end
end

-- given an Instance and a property-value table subset
-- returns true if all property-values in the subset table exist in the Instance
-- and returns false otherwise
-- returns nil for undefined behavior
function exports.instanceSubsetEquality(instance: any, subset: any): boolean | nil
	local function subsetEqualityWithContext(seenReferences)
		return function(localInstance, localSubset)
			seenReferences = seenReferences or {}

			if getType(localInstance) ~= "Instance" or not isObjectWithKeys(localSubset) then
				return nil
			end

			return Array.every(Object.keys(localSubset), function(prop)
				local subsetVal = localSubset[prop]
				if isObjectWithKeys(subsetVal) then
					-- return false for circular references
					if seenReferences[subsetVal] then
						return false
					end
					seenReferences[subsetVal] = true
				end
				local ok, value = exports.readProp(localInstance, prop)
				local result = ok and equals(value, subsetVal, { subsetEqualityWithContext(seenReferences) })

				seenReferences[subsetVal] = nil
				return result
			end)
		end
	end

	local inner = subsetEqualityWithContext()

	if inner then
		return inner(instance, subset)
	end
	return inner
end

-- InstanceSubset object behaves like an Instance when serialized by pretty-format

local InstanceSubset = {}
exports.InstanceSubset = InstanceSubset

InstanceSubset.__index = InstanceSubset

function InstanceSubset.new(className, subset)
	table.sort(subset)
	local self = {
		ClassName = className,
		subset = subset,
	}

	setmetatable(self, InstanceSubset)
	return self
end

-- given an Instance and an expected property-value table subset, returns
-- an InstanceSubset object representing the found subset of Instance with values in the subset table
-- and a InstanceSubset object representing the expected subset table
function exports.getInstanceSubset(instance: any, subset: any, seenReferences_: any?): (any, any)
	local seenReferences = seenReferences_ or {}

	local foundSubset: any = {}
	seenReferences[instance] = foundSubset

	-- return non-table primitives
	if equals(instance, subset) then
		return subset, subset
	elseif typeof(subset) ~= "table" or isAsymmetric(subset) then
		return instance, subset
	end

	-- collect non-table primitive values
	local expectedSubset = {}
	for k, v in pairs(subset) do
		if typeof(v) ~= "table" then
			expectedSubset[k] = v
		end
	end

	for name, subsetPropOrChild in pairs(subset) do
		local ok, realPropOrChild = exports.readProp(instance, name)
		if not ok then
			continue
		elseif seenReferences[realPropOrChild] ~= nil then
			error("Circular reference passed into .toMatchInstance(subset)")
		else
			expectedSubset[name] = {}
			foundSubset[name], expectedSubset[name] =
				exports.getInstanceSubset(realPropOrChild, subsetPropOrChild, seenReferences)
		end
	end

	-- serialize with a different ClassName if the subset has ClassName defined,
	-- otherwise treat it as the same class as the original Instance
	local subsetClassName = instance.ClassName
	if typeof(subset) == "table" and rawget(subset, "ClassName") then
		subsetClassName = rawget(subset, "ClassName")
	end

	local found = InstanceSubset.new(instance.ClassName, foundSubset)
	local expected = InstanceSubset.new(subsetClassName, expectedSubset)
	return found, expected
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="466">
              <Properties>
                <string name="Name">Writeable</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE:  no upstream: replaces node js writeable stream API

export type Writeable = {
	isTTY: boolean?,
	write: (self: Writeable, data: string) -> (),
}

local Writeable = {}
Writeable.__index = Writeable

function Writeable.new(options: { write: (data: string) -> () }?): Writeable
	local self = setmetatable({}, Writeable)
	self._writeFn = if options ~= nil and typeof(options.write) == "function" then options.write else print
	self.isTTY = false
	return (self :: any) :: Writeable
end

function Writeable:write(data: string)
	self._writeFn(data)
end

return {
	Writeable = Writeable,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="467">
              <Properties>
                <string name="Name">cleanLoadStringStack</string>
                <string name="Source"><![CDATA[local loadModuleEnabled = pcall((debug :: any).loadmodule, Instance.new("ModuleScript"))

return function(line: string): string
	if not loadModuleEnabled then
		local spacing, filePath, lineNumber, extra = line:match('(%s*)%[string "(.-)"%]:(%d+)(.*)')
		if filePath then
			local match = filePath
			if spacing then
				match = spacing .. match
			end
			if lineNumber then
				match = match .. ":" .. lineNumber
			end
			if extra then
				match = match .. extra
			end
			return match
		end
	end
	return line
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="468">
              <Properties>
                <string name="Name">dedent</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/graphql/graphql-js/blob/1951bce42092123e844763b6a8e985a8a3327511/src/__testUtils__/dedent.js
--[[
	MIT License

	Copyright (c) GraphQL Contributors
]]
local srcWorkspace = script.Parent
local rootWorkspace = srcWorkspace.Parent
local Packages = rootWorkspace

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local String = LuauPolyfill.String
type Array<T> = LuauPolyfill.Array<T>

function dedent(strings: Array<string> | string, ...): string
	local values: Array<string> = { ... }

	local str = ""

	-- ROBLOX TODO Luau: Array.isArray true should narrow to Array<?> and therefore narrow strings to Array<string>
	if Array.isArray(strings) then
		for i = 1, #strings do
			str ..= (strings :: Array<string>)[i]
			if i <= #values then
				local value = values[i]

				str ..= value
			end
		end
	else
		str = strings :: string
	end

	local trimmedStr = removeTrailingSpacesAndTabs(removeLeadingNewLines(str))
	local indent = ""
	for i = 1, string.len(trimmedStr) do
		local char = string.sub(trimmedStr, i, i)
		if char ~= " " and char ~= "\t" then
			break
		end
		indent ..= char
	end

	return removeCommonIndent(trimmedStr, indent)
end

function removeLeadingNewLines(str: string): string
	local leadingNewLinesMatch = String.findOr(str, { "\n*" })

	if leadingNewLinesMatch ~= nil and leadingNewLinesMatch.index == 1 then
		str = string.sub(str, string.len(leadingNewLinesMatch.match) + 1)
	end
	return str
end

function removeTrailingSpacesAndTabs(str: string): string
	local match
	local lastMatch: { index: number, match: string }?
	local init = 1
	repeat
		match = String.findOr(str, { " +", "\t+" }, init)

		if match ~= nil then
			if lastMatch ~= nil and lastMatch.index + string.len(lastMatch.match) == match.index then
				lastMatch = {
					index = lastMatch.index,
					match = lastMatch.match .. match.match,
				}
			else
				lastMatch = match
			end
			init = match.index + string.len(match.match)
		end
	until match == nil or init > string.len(str)
	if lastMatch ~= nil and lastMatch.index + string.len(lastMatch.match) == string.len(str) + 1 then
		return string.sub(str, 1, lastMatch.index - 1)
	end
	return str
end

function removeCommonIndent(str: string, commonIndent: string): string
	local trimmedStr = string.gsub(str, commonIndent, "", 1)
	trimmedStr = string.gsub(trimmedStr, "\n" .. commonIndent, "\n")
	return trimmedStr
end

return {
	dedent = dedent,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="469">
              <Properties>
                <string name="Name">ensureDirectoryExists</string>
                <string name="Source"><![CDATA[-- moved from jest-snapshot/utils.lua

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local getParent = require(script.Parent.getParent)
local getDataModelService = require(script.Parent.getDataModelService)

local FileSystemService = getDataModelService("FileSystemService")

local function ensureDirectoryExists(filePath: string)
	-- ROBLOX deviation: gets path of parent directory, GetScriptFilePath can only be called on ModuleScripts
	local path = getParent(filePath, 1)
	local ok, err = pcall(function()
		if FileSystemService and not FileSystemService:Exists(path) then
			FileSystemService:CreateDirectories(path)
		end
	end)

	if not ok and err:find("Error%(13%): Access Denied%. Path is outside of sandbox%.") then
		error(
			Error.new(
				"Provided path is invalid: you likely need to provide a different argument to --fs.readwrite.\n"
					.. "You may need to pass in `--fs.readwrite=$PWD`"
			)
		)
	end
end

return ensureDirectoryExists
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="470">
              <Properties>
                <string name="Name">escapePatternCharacters</string>
                <string name="Source"><![CDATA[local function escapePatternCharacters(str: string): string
	return string.gsub(str, "([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
end

return {
	escapePatternCharacters = escapePatternCharacters,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="471">
              <Properties>
                <string name="Name">expect</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/__tests__/matchers.test.js
-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/expect/src/utils.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local getType = require(Packages.JestGetType).getType

local LuauPolyfill = require(Packages.LuauPolyfill)
local toJSBoolean = LuauPolyfill.Boolean.toJSBoolean
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object

type Array<T> = LuauPolyfill.Array<T>
type Table = { [any]: any }
type Tester = (any, any) -> any

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function hasKey(obj: any, key: string)
	return rawget(obj, key) ~= nil
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function hasDefinedKey(obj: any, key: string)
	return hasKey(obj, key)
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function keys(obj: Table, _hasKey: (Table, string) -> boolean)
	local keys_ = {}
	for key in pairs(obj) do
		if obj[key] ~= nil then
			table.insert(keys_, key)
		end
	end

	-- ROBLOX deviation: code omitted for adding 'extraKeys' since we don't have
	-- similar concerns of overlooking symbols and non-numeric properties for
	-- arrays

	-- Thus, in the array case we should always just be returning an empty array

	return keys_
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function isA(typeName: string, value: any)
	return getType(value) == typeName
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function isAsymmetric(obj: any)
	if toJSBoolean(obj) and typeof(obj) == "table" then
		local ok, val = pcall(function()
			return obj.asymmetricMatch
		end)
		if ok and isA("function", val) then
			return true
		end
	end
	return false
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function asymmetricMatch(a: any, b: any)
	local asymmetricA = isAsymmetric(a)
	local asymmetricB = isAsymmetric(b)

	if asymmetricA and asymmetricB then
		return nil
	end

	if asymmetricA then
		return a:asymmetricMatch(b)
	end

	if asymmetricB then
		return b:asymmetricMatch(a)
	end

	return nil
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
-- Equality function lovingly adapted from isEqual in
--   [Underscore](http://underscorejs.org)
local function eq(
	a: any,
	b: any,
	aStack: Array<any>,
	bStack: Array<any>,
	customTesters: Array<Tester>,
	_hasKey: any
): boolean
	local result = true

	local asymmetricResult = asymmetricMatch(a, b)
	if asymmetricResult ~= nil then
		return asymmetricResult
	end

	for _, value in ipairs(customTesters) do
		local customTesterResult = value(a, b)
		if customTesterResult ~= nil then
			return customTesterResult
		end
	end

	-- ROBLOX deviation: code omitted because there are no error objects in Lua

	if Object.is(a, b) then
		return true
	end

	-- ROBLOX deviation: code omitted that does strict comparison because we don't
	-- have similar concerns in Lua where there are no distinct 'null' and
	-- 'undefined' types

	-- ROBLOX deviation: as part of the upstream className check, a type difference of
	-- array/non-array would be detected so we add this in manually
	local className = getType(a)
	if className ~= getType(b) then
		return false
	elseif Array.isArray(a) ~= Array.isArray(b) then
		return false
	end

	-- ROBLOX deviation: code omitted for elseif case with regular expressions since
	-- Lua doesn't have a built in regular expression type

	if className == "boolean" or className == "string" or className == "number" or className == "userdata" then
		return Object.is(a, b)
	elseif className == "DateTime" then
		return a == b
	elseif className == "regexp" then
		return tostring(a) == tostring(b)
	end

	if typeof(a) ~= "table" or typeof(b) ~= "table" then
		return false
	end

	-- DOM code omitted for now but translated here
	--[[
		if isDomNode(a) and isDomNode(b) then
		return a.isEqualNode(b)
		end
	--]]

	-- Used to detect circular references.
	local length = #aStack
	while length > 0 do
		-- Linear search. Performance is inversely proportional to the number of
		-- unique nested structures.
		-- circular references at same depth are equal
		-- circular reference is not equal to non-circular one
		if aStack[length] == a then
			return bStack[length] == b
		elseif bStack[length] == b then
			return false
		end

		length -= 1
	end

	-- Add the first object to the stack of traversed objects.
	table.insert(aStack, a)
	table.insert(bStack, b)

	-- Recursively compare objects and arrays.
	-- Compare array lengths to determine if a deep comparison is necessary.
	if Array.isArray(a) and #a ~= #b then
		return false
	end

	-- Deep compare objects
	local aKeys = keys(a, _hasKey)
	local size = #aKeys

	-- Ensure that both objects contain the same number of properties before comparing deep equality.
	if #keys(b, _hasKey) ~= size then
		return false
	end

	while size > 0 do
		local key = aKeys[size]

		-- Deep compare each member
		result = hasKey(b, key) and eq(a[key], b[key], aStack, bStack, customTesters, _hasKey)

		if not result then
			return false
		end

		size -= 1
	end

	-- Remove the first object from the stack of traversed objects.
	table.remove(aStack)
	table.remove(bStack)

	return result
end

-- ROBLOX MOVED: expect/jasmineUtils.lua
local function equals(a: any, b: any, customTesters: Array<Tester>?, strictCheck: boolean?): boolean
	customTesters = customTesters or {}
	strictCheck = strictCheck or false
	return eq(a, b, {}, {}, customTesters :: Array<Tester>, strictCheck and hasKey or hasDefinedKey)
end

-- ROBLOX MOVED: expect/utils.lua
local function hasPropertyInObject(object: any, key: string): boolean
	-- We don't have to deal with the complexities around prototype chains in
	-- javascript since a simple key access will look up the
	-- metatable chain for us
	local shouldBeFalse = not toJSBoolean(object) or typeof(object) ~= "table"

	if shouldBeFalse then
		return false
	end

	return object[key] ~= nil
end

-- ROBLOX MOVED: expect/utils.lua
local function isObject(a: any)
	return a ~= nil and getType(a) == "table"
end

-- ROBLOX MOVED: expect/utils.lua
local function isObjectWithKeys(a: any)
	return isObject(a) and (next(a) == nil or not Array.isArray(a))
end

-- ROBLOX MOVED: expect/utils.lua
local function iterableEquality(a: any, b: any, aStack_: Array<any>?, bStack_: Array<any>?): boolean | nil
	local aStack = (aStack_ or {}) :: Array<any>
	local bStack = (bStack_ or {}) :: Array<any>

	if getType(a) ~= "set" or getType(b) ~= "set" then
		return nil
	end

	-- ROBLOX deviation: omitting constructor check

	local length = #aStack
	while length > 0 do
		-- Linear search. Performance is inversely proportional to the number of
		-- unique nested structures.
		-- circular references at same depth are equal
		-- circular reference is not equal to non-circular one
		if aStack[length] == a then
			return bStack[length] == b
		end

		-- ROBLOX deviation: this if check is not included in upstream
		-- if bStack[length] == b then
		-- 	return aStack[length] == a
		-- end

		length -= 1
	end

	table.insert(aStack, a)
	table.insert(bStack, b)

	local function iterableEqualityWithStack(localA: any, localB: any)
		return iterableEquality(localA, localB, { unpack(aStack) }, { unpack(bStack) })
	end

	-- ROBLOX TODO: (ADO-1217) If we eventually have a Map polyfill, we can
	-- expand this to include the Map case as well
	if a.size ~= nil then
		if a.size ~= b.size then
			return false
		elseif isA("set", a) then
			local allFound = true
			for _, aValue in a:ipairs() do
				if not b:has(aValue) then
					local has = false
					for _, bValue in b:ipairs() do
						local isEqual = equals(aValue, bValue, { iterableEqualityWithStack })
						if isEqual == true then
							has = true
						end
					end

					if has == false then
						allFound = false
						break
					end
				end
			end
			table.remove(aStack)
			table.remove(bStack)
			return allFound
		end
	end

	return nil

	-- ROBLOX deviation: omitted section of code for handling the case of a different
	-- kind of iterable not covered by the above Set case
end

-- ROBLOX MOVED: expect/utils.lua
local function subsetEquality(object: any, subset: any): boolean | nil
	-- subsetEquality needs to keep track of the references
	-- it has already visited to avoid infinite loops in case
	-- there are circular references in the subset passed to it
	local function subsetEqualityWithContext(seenReferences_: { [any]: boolean }?)
		local seenReferences = (seenReferences_ or {}) :: { [any]: boolean }

		return function(object_: any, subset_: any): boolean | nil
			if not isObjectWithKeys(subset_) then
				return nil
			end

			return Array.every(Object.keys(subset_), function(key)
				if isObjectWithKeys(subset_[key]) then
					if seenReferences[subset_[key]] then
						--[[
								ROBLOX TODO: (ADO-1217) replace the line below
								once Map/Set functionality is implemented

								return equals(localObject[key], localSubset[key], {iterableEquality})
							]]
						return equals(object_[key], subset_[key], { iterableEquality })
					end
					seenReferences[subset_[key]] = true
				end
				local result = object_ ~= nil
					and hasPropertyInObject(object_, key)
					and equals(object_[key], subset_[key], {
						--[[
									ROBLOX TODO: (ADO-1217) uncomment the line
									iterableEquality,
								]]
						subsetEqualityWithContext(seenReferences),
					})
				-- The main goal of using seenReference is to avoid
				-- circular node on tree.
				-- It will only happen within a parent and its child, not a
				-- node and nodes next to it (same level)
				-- We should keep the reference for a parent and its child
				-- only
				-- Thus we should delete the reference immediately so that
				-- it doesn't interfere other nodes within the same level
				-- on tree.
				seenReferences[subset_[key]] = nil
				return result
			end)
		end
	end

	return subsetEqualityWithContext()(object, subset)
end

-- ROBLOX MOVED: expect/utils.lua
-- ROBLOX TODO: (LUAU) Add seenReferences type annotation once Luau can
-- recognize that the seenReferences or {} is sufficient to make seenReferences
-- non-nil
local function getObjectSubset(object: any, subset: any, seenReferences_: { [Object]: boolean }?): any
	local seenReferences = (if seenReferences_ then seenReferences_ else {}) :: { [Object]: boolean }

	if Array.isArray(object) then
		if Array.isArray(subset) and #subset == #object then
			-- The return correct subclass of subset
			local subsetMap = {}

			for i, sub in ipairs(subset) do
				table.insert(subsetMap, getObjectSubset(object[i], sub))
			end
			return subsetMap
		end
	elseif getType(object) == "DateTime" then
		return object
	elseif isObject(object) and isObject(subset) then
		if equals(object, subset, { iterableEquality, subsetEquality }) then
			return subset
		end

		local trimmed: any = {}
		seenReferences[object] = trimmed

		for i, key in
			ipairs(Array.filter(Object.keys(object), function(key)
				return hasPropertyInObject(subset, key)
			end))
		do
			if seenReferences[object[key]] ~= nil then
				trimmed[key] = seenReferences[object[key]]
			else
				trimmed[key] = getObjectSubset(object[key], subset[key], seenReferences)
			end
		end

		if #Object.keys(trimmed) > 0 then
			return trimmed
		end
	end

	return object
end

return {
	-- jasmineUtils.lua
	equals = equals,
	isA = isA,
	isAsymmetric = isAsymmetric,

	-- utils.lua
	getObjectSubset = getObjectSubset,
	iterableEquality = iterableEquality,
	subsetEquality = subsetEquality,
	isObjectWithKeys = isObjectWithKeys,
	hasPropertyInObject = hasPropertyInObject,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="472">
              <Properties>
                <string name="Name">getDataModelService</string>
                <string name="Source"><![CDATA[-- checks that the service exists and is accessible before returning it, otherwise returns nil
return function(service: string)
	local success, result = pcall(function()
		local service = game:GetService(service)
		local _ = service.Name
		return service
	end)

	return success and result or nil
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="473">
              <Properties>
                <string name="Name">getParent</string>
                <string name="Source"><![CDATA[-- ROBLOX deviation: added to handle file paths in snapshot/State
local function getParent(path: string, level_: number?): string
	local level = if level_ then level_ else 0

	local isUnixPath = string.sub(path, 1, 1) == "/"
	local t = {}

	for p in string.gmatch(path, "[^\\/][^\\/]*") do
		table.insert(t, p)
	end
	if level > 0 then
		t = { table.unpack(t, 1, #t - level) }
	end

	if isUnixPath then
		return "/" .. table.concat(t, "/")
	end

	return table.concat(t, "\\")
end

return getParent
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="474">
              <Properties>
                <string name="Name">getRelativePath</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream

local function getRelativePath(script_: Instance, rootDir: Instance?): string
	local path = script_.Name

	local curr: Instance = script_
	while curr.Parent and curr ~= rootDir do
		curr = curr.Parent
		path = curr.Name .. "/" .. path
	end

	return if rootDir ~= nil then path else "/" .. path
end

return getRelativePath
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="475">
              <Properties>
                <string name="Name">nodeUtils</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream

local WriteableModule = require(script.Parent.Writeable)
local Writeable = WriteableModule.Writeable
type Writeable = WriteableModule.Writeable
local process = {
	stdout = Writeable.new(),
	stderr = Writeable.new(),
}
local function exit(code: number)
	error(("Exited with code: %d"):format(code))
end
export type NodeJS_WriteStream = Writeable

local HttpService = game:GetService("HttpService")
local JSON = {
	stringify = function(obj: any, ...): string
		if select("#", ...) > 0 then
			warn(
				"JSON.stringify doesn't currently support more than 1 argument. All additional arguments will be ignored."
			)
		end
		return HttpService:JSONEncode(obj)
	end,
	parse = function(str: string, ...): any
		if select("#", ...) > 0 then
			warn("JSON.parse doesn't currently support more than 1 argument. All additional arguments will be ignored.")
		end
		return HttpService:JSONDecode(str)
	end,
}

return {
	process = process,
	exit = exit,
	JSON = JSON,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="476">
              <Properties>
                <string name="Name">normalizePromiseError</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX NOTE: no upstream
local srcWorkspace = script.Parent
local rootWorkspace = srcWorkspace.Parent
local Packages = rootWorkspace

local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
type Object = LuauPolyfill.Object

local function getPromiseErrorStack(error_: any)
	local currentError = error_
	while not Boolean.toJSBoolean(currentError.trace) and currentError.parent do
		currentError = currentError.parent
	end
	return currentError.trace or ""
end

local function getPromiseErrorMessage(error_: any)
	local currentError = error_
	local message = error_.error
	while not Boolean.toJSBoolean(currentError.trace) and currentError.parent do
		currentError = currentError.parent
		message = currentError.error or message
	end
	return currentError.message or message
end

return function(err: Object)
	err.message = getPromiseErrorMessage(err)
	err.stack = getPromiseErrorStack(err)
	return err
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="477">
              <Properties>
                <string name="Name">pruneDeps</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local cleanLoadStringStack = require(script.Parent.cleanLoadStringStack)

local function pruneDeps(str: string?): string?
	if str == nil then
		return nil
	end

	local newLines = {}
	for _, line in (str :: string):split("\n") do
		if line:find("LoadedCode.JestRoblox._Index.") then
			continue
		end
		line = cleanLoadStringStack(line)
		table.insert(newLines, line)
	end
	return table.concat(newLines, "\n")
end

return pruneDeps
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="478">
              <Properties>
                <string name="Name">redactStackTrace</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local TRACE_LINE = `[%w_%-]+%.[%w_%-%.]+%:%d+[%w \t_]*`
local REDACT_TRACE_WITH = ("\nRedacted.Stack.Trace:1337 function epicDuck"):rep(4):sub(2)
local LUA_ERROR_LINE = `[%w_%-]+%.[%w_%-%.]+%:%d+%:[%w \t_]*`
local REDACT_LUA_ERROR_WITH = "Redacted.Stack.Trace:1337: The epic duck is coming!"

local function redactStackTrace(str: string?): string?
	if str == nil then
		return nil
	else
		local newLines = {}
		local lastLineRedacted = false
		for _, line in (str :: string):split("\n") do
			local lineWithRedactions = line:gsub(TRACE_LINE, if lastLineRedacted then "" else REDACT_TRACE_WITH)
				:gsub(LUA_ERROR_LINE, if lastLineRedacted then "" else REDACT_LUA_ERROR_WITH)
			lastLineRedacted = line ~= lineWithRedactions
			if not lastLineRedacted or lineWithRedactions:match("%S") then
				table.insert(newLines, lineWithRedactions)
			end
		end
		return table.concat(newLines, "\n")
	end
end

return redactStackTrace
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="479">
              <Properties>
                <string name="Name">stripAnsi</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX upstream: no upstream
local function stripAnsi(text: string)
	local res = string.gsub(text, "[\27\155][][()#;?%d]*[A-PRZcf-ntqry=><~]", "")
	return res
end
return stripAnsi
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="480">
            <Properties>
              <string name="Name">SafeFlags</string>
              <string name="Source"><![CDATA[--[[
	FFlags:
	ReactEnableSchedulingProfiler
	ReactInlineMergeLanes
	ReactInstanceMapDisableErrorChecking
	ReactSchedulerEnableDeferredWork
	ReactSchedulerSetFrameMarkerOnHeartbeatEnd
	ReactSchedulerSetTargetMsByHeartbeatDelta

	FInts:
	ReactSchedulerDesiredFrameRate
	ReactSchedulerMinFrameRate
	ReactSchedulerYieldInterval2
]]

-- These flags are currently enabled in Roblox Studio.
local safeFlags = {
	-- ReactEnableSchedulingProfiler = true,
	ReactInlineMergeLanes = true,
	ReactInstanceMapDisableErrorChecking = true,
}

local function createGetFFlag(name: string): () -> boolean
	return function()
		return safeFlags[name] or false
	end
end

local function createGetFInt(name: string, default: number): () -> number
	return function()
		return default
	end
end

return {
	createGetFFlag = createGetFFlag,
	createGetFInt = createGetFInt,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="481">
            <Properties>
              <string name="Name">Shared</string>
              <string name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

-- ROBLOX deviation: Promote `shared` to an actual unpublished package with a
-- real interface instead of just a bag of loose source code
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local ReactTypes = require(script.ReactTypes)
local flowtypes = require(script["flowtypes.roblox"])
local ReactElementType = require(script.ReactElementType)
local ReactFiberHostConfig = require(script.ReactFiberHostConfig)
local ReactSharedInternals = require(script.ReactSharedInternals)
local ErrorHandling = require(script["ErrorHandling.roblox"])

-- Re-export all top-level public types
export type ReactEmpty = ReactTypes.ReactEmpty
export type ReactFragment = ReactTypes.ReactFragment
export type ReactNodeList = ReactTypes.ReactNodeList
export type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
export type ReactConsumer<T> = ReactTypes.ReactConsumer<T>
export type ReactProvider<T> = ReactTypes.ReactProvider<T>
export type ReactContext<T> = ReactTypes.ReactContext<T>
export type ReactPortal = ReactTypes.ReactPortal
export type RefObject<T = any> = ReactTypes.RefObject<T>
export type EventPriority = ReactTypes.EventPriority
export type ReactFundamentalComponentInstance<C, H> =
	ReactTypes.ReactFundamentalComponentInstance<C, H>
export type ReactFundamentalImpl<C, H> = ReactTypes.ReactFundamentalImpl<C, H>
export type ReactFundamentalComponent<C, H> = ReactTypes.ReactFundamentalComponent<C, H>
export type ReactScope = ReactTypes.ReactScope
export type ReactScopeQuery = ReactTypes.ReactScopeQuery
export type ReactScopeInstance = ReactTypes.ReactScopeInstance
-- ROBLOX deviation START: Re-export bindings types
export type ReactBinding<T> = ReactTypes.ReactBinding<T>
export type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- ROBLOX deviation END
export type MutableSourceVersion = ReactTypes.MutableSourceVersion
export type MutableSourceGetSnapshotFn<Source, Snapshot> =
	ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>
export type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
export type MutableSourceGetVersionFn = ReactTypes.MutableSourceGetVersionFn
export type MutableSource<Source> = ReactTypes.MutableSource<Source>
export type Wakeable = ReactTypes.Wakeable
export type Thenable<R> = ReactTypes.Thenable<R>
export type Source = ReactElementType.Source
export type ReactElement<P = Object, T = any> = ReactElementType.ReactElement<P, T>
export type OpaqueIDType = ReactFiberHostConfig.OpaqueIDType
export type Dispatcher = ReactSharedInternals.Dispatcher

-- re-export flowtypes from here. I wonder if this should be a separate 'package'?
export type React_Ref<ElementType> = flowtypes.React_Ref<ElementType>
export type React_Context<T> = flowtypes.React_Context<T>
export type React_AbstractComponent<Config, Instance> = flowtypes.React_AbstractComponent<
	Config,
	Instance
>
export type React_ForwardRefComponent<Config, Instance> =
	flowtypes.React_ForwardRefComponent<Config, Instance>
export type React_MemoComponent<Config, T> = flowtypes.React_MemoComponent<Config, T>
export type React_ComponentType<Config> = flowtypes.React_ComponentType<Config>
export type React_PureComponent<Props, State = nil> = flowtypes.React_PureComponent<
	Props,
	State
>
export type React_Component<Props, State> = flowtypes.React_Component<Props, State>
export type React_ElementProps<ElementType> = flowtypes.React_ElementProps<ElementType>
export type React_StatelessFunctionalComponent<Props> =
	flowtypes.React_StatelessFunctionalComponent<Props>
export type React_Node = flowtypes.React_Node
export type React_Element<ElementType> = flowtypes.React_Element<ElementType>
export type React_ElementType = flowtypes.React_ElementType
export type React_ElementConfig<C> = flowtypes.React_ElementConfig<C>
export type React_ElementRef<C> = flowtypes.React_ElementRef<C>
export type React_Portal = flowtypes.React_Portal
export type React_Key = flowtypes.React_Key

return {
	checkPropTypes = require(script.checkPropTypes),
	console = require(script.console),
	ConsolePatchingDev = require(script["ConsolePatchingDev.roblox"]),
	consoleWithStackDev = require(script.consoleWithStackDev),
	enqueueTask = require(script["enqueueTask.roblox"]),
	ExecutionEnvironment = require(script.ExecutionEnvironment),
	formatProdErrorMessage = require(script.formatProdErrorMessage),
	getComponentName = require(script.getComponentName),
	invariant = require(script.invariant),
	invokeGuardedCallbackImpl = require(script.invokeGuardedCallbackImpl),
	isValidElementType = require(script.isValidElementType),
	objectIs = require(script.objectIs),
	ReactComponentStackFrame = require(script.ReactComponentStackFrame),
	ReactElementType = require(script.ReactElementType),
	ReactErrorUtils = require(script.ReactErrorUtils),
	ReactFeatureFlags = require(script.ReactFeatureFlags),
	ReactInstanceMap = require(script.ReactInstanceMap),
	-- ROBLOX deviation: Instead of re-exporting from here, Shared actually owns
	-- these files itself
	ReactSharedInternals = ReactSharedInternals,
	-- ROBLOX deviation: Instead of extracting these out of the reconciler and
	-- then re-injecting the host config _into_ the reconciler, export these
	-- from shared for easier reuse
	ReactFiberHostConfig = ReactFiberHostConfig,

	ReactSymbols = require(script.ReactSymbols),
	ReactVersion = require(script.ReactVersion),
	shallowEqual = require(script.shallowEqual),
	UninitializedState = require(script["UninitializedState.roblox"]),
	ReactTypes = ReactTypes,

	-- ROBLOX DEVIATION: export error-stack-preserving utilities for use in
	-- scheduler and reconciler, and parsing function for use in public API
	describeError = ErrorHandling.describeError,
	errorToString = ErrorHandling.errorToString,
	parseReactError = ErrorHandling.parseReactError,

	-- ROBLOX DEVIATION: export Symbol and Type from Shared
	Symbol = require(script["Symbol.roblox"]),
	Type = require(script["Type.roblox"]),

	-- ROBLOX DEVIATION: export propmarkers from Shared
	Change = require(script.PropMarkers.Change),
	Event = require(script.PropMarkers.Event),
	Tag = require(script.PropMarkers.Tag),
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="482">
              <Properties>
                <string name="Name">ConsolePatchingDev.roblox</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/checkPropTypes.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

-- deviation: Lua objects don't have any special properties the way that JS
-- Objects do; this has been modified from the JS, which uses
-- `Object.defineProperties` to ensure that properties are modifiable. In Lua,
-- these operations are as simple as assigning to functions.
-- ROBLOX: use patched console from shared
local console = require(script.Parent.console)

-- Helpers to patch console.logs to avoid logging during side-effect free
-- replaying on render function. This currently only patches the object
-- lazily which won't cover if the log function was extracted eagerly.
-- We could also eagerly patch the method.
local disabledDepth = 0
local prevLog
local prevInfo
local prevWarn
local prevError
local prevGroup
local prevGroupCollapsed
local prevGroupEnd

local disabledLog = function() end

local exports = {}

-- ROBLOX deviation: console.log's name property is checked in SchedulerHostConfig.
-- But since Lua functions don't carry properties, we export this and import it there
-- for a reference equality.
exports.disabledLog = disabledLog

exports.disableLogs = function()
	if _G.__DEV__ then
		if disabledDepth == 0 then
			prevLog = console.log
			prevInfo = console.info
			prevWarn = console.warn
			prevError = console.error
			prevGroup = console.group
			prevGroupCollapsed = console.groupCollapsed
			prevGroupEnd = console.groupEnd

			console.info = disabledLog
			console.log = disabledLog
			console.warn = disabledLog
			console.error = disabledLog
			console.group = disabledLog
			console.groupCollapsed = disabledLog
			console.groupEnd = disabledLog
		end

		disabledDepth = disabledDepth + 1
	end
end

exports.reenableLogs = function()
	if _G.__DEV__ then
		disabledDepth = disabledDepth - 1

		if disabledDepth == 0 then
			console.log = prevLog
			console.info = prevInfo
			console.warn = prevWarn
			console.error = prevError
			console.group = prevGroup
			console.groupCollapsed = prevGroupCollapsed
			console.groupEnd = prevGroupEnd
		end

		if disabledDepth < 0 then
			console.error(
				"disabledDepth fell below zero. "
					.. "This is a bug in React. Please file an issue."
			)
		end
	end
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="483">
              <Properties>
                <string name="Name">ErrorHandling.roblox</string>
                <string name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect

local DIVIDER = "\n------ Error caught by React ------\n"

--[[
	React does a lot of catching, retrying, and rethrowing errors that would
	typically result in loss of meaningful stack information.

	We use xpcall combined with this error function to capture and rethrow in a
	way that retains some stack information.
]]
local function describeError(e: string | Error): Error
	if typeof(e) == "string" then
		local _, endOfStackFrame = string.find(e, ":[%d]+: ")
		local message = if endOfStackFrame then string.sub(e, endOfStackFrame + 1) else e

		local err = LuauPolyfill.Error.new(message)
		err.stack = debug.traceback(nil, 2)
		return err
	end
	return e :: Error
end

--[[
	Even though Luau can catch and rethrow arbitrary objects, only string errors
	are supported by the ScriptContext.ErrorDetailed signal (the mechanism used
	to catch unhandled errors at the top level).

	This function turns an arbitrary error object into a detailed string message
	to avoid any loss of information.
]]
local function errorToString(error_: Error | Object | string | Array<any>): string
	local errorString
	if typeof(error_) == "table" then
		if (error_ :: Error).message and (error_ :: Error).stack then
			-- Adding these clear dividers helps us split this error back up
			-- into pieces later. We include one at the beginning so that the
			-- final stack frame added by rethrowing can be carved off
			errorString = DIVIDER
				.. (error_ :: Error).message
				.. DIVIDER
				.. tostring((error_ :: Error).stack)
		else
			errorString = inspect(error_)
		end
	else
		errorString = inspect(error_)
	end

	return errorString
end

--[[
	If an error string was generated from an Error object via the errorToString
	function above, it can be easily split back out into an informative error
	object.
]]
local function parseReactError(error_: string): (Error, string)
	local split = string.split(error_, DIVIDER)

	if #split == 3 then
		local rethrow, message, stack = table.unpack(split)

		local newError = Error.new(message)
		newError.stack = stack

		return newError, rethrow
	else
		-- This error was not in the expected format, so we use the whole string
		-- as the 'message' value and nil out the stack (it would be misleading
		-- if we included the one generated here)
		local newError = Error.new(error_)
		newError.stack = nil

		return newError, ""
	end
end

return {
	describeError = describeError,
	errorToString = errorToString,
	parseReactError = parseReactError,
	-- Used only by tests
	__ERROR_DIVIDER = DIVIDER,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="484">
              <Properties>
                <string name="Name">ExecutionEnvironment</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/ExecutionEnvironment.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
local exports = {}

exports.canUseDOM = function()
	-- ROBLOX deviation START
	return false
	-- ROBLOX deviation END
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="485">
              <Properties>
                <string name="Name">PropMarkers</string>
              </Properties>
              <Item class="ModuleScript" referent="486">
                <Properties>
                  <string name="Name">Change</string>
                  <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent["Type.roblox"])

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return string.format("RoactHostChangeEvent(%s)", self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="487">
                <Properties>
                  <string name="Name">Event</string>
                  <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent["Type.roblox"])

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return string.format("RoactHostEvent(%s)", self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="488">
                <Properties>
                  <string name="Name">Tag</string>
                  <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Special value for assigning tags to roblox instances via Roact
]]
local Symbol = require(script.Parent.Parent["Symbol.roblox"])

local Tag = Symbol.named("RobloxTag")

return Tag
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="489">
              <Properties>
                <string name="Name">ReactComponentStackFrame</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/shared/ReactComponentStackFrame.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

type Object = { [string]: any }
type Function = (...any) -> ...any

local ReactElementType = require(script.Parent.ReactElementType)
type Source = ReactElementType.Source

-- ROBLOX deviation: Needed to properly type class components
local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_StatelessFunctionalComponent<P> = flowtypes.React_StatelessFunctionalComponent<
	P
>
type React_ComponentType<P> = flowtypes.React_ComponentType<P>
type ReactComponent<P> = React_StatelessFunctionalComponent<P> | React_ComponentType<P>

-- ROBLOX DEVIATION: Ignore enableComponentStackLocations
-- local ReactFeatureFlags = require(script.Parent.ReactFeatureFlags)
-- local enableComponentStackLocations = ReactFeatureFlags.enableComponentStackLocations

local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE

local ConsolePatchingDev = require(script.Parent["ConsolePatchingDev.roblox"])
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)
local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher

-- ROBLOX deviation: the prefix is constant because the console prints the stack
-- frames the same way on every platform.
local prefix = "    in "

-- ROBLOX deviation: declare these now because of scoping differences between in
-- Lua and JS
local describeComponentFrame
local describeFunctionComponentFrame

-- ROBLOX deviation: since owner could be a function or a class component, we
-- need to do additional handling to get its name. It's easier to make this a
-- reusable function
local function describeOwner(owner: nil | ReactComponent<any>): string?
	if type(owner) == "function" then
		return debug.info(owner :: (any) -> any, "n")
	elseif type(owner) == "table" then
		return tostring(owner)
	end
	return nil
end

local function describeBuiltInComponentFrame(
	name: string,
	source: Source | nil,
	-- ROBLOX deviation: owner could be a class component
	owner: nil | ReactComponent<any>
): string
	-- ROBLOX deviation START: for built-in components, we can provide the full
	-- description regardless of `enableStackLocations` since we don't actually
	-- need to do any callstack trickery to get it

	-- if enableComponentStackLocations then
	-- 	if prefix == nil then
	-- 		-- Extract the VM specific prefix used by each line.
	-- 		local _, x = pcall(error, debug.traceback())

	-- 		local match = x.stack.trim().match("\n00:00:00.000 - ")
	-- 		if match then
	-- 			prefix = match[1]
	-- 		else
	-- 			prefix = ''
	-- 		end
	-- 	end
	-- 	-- We use the prefix to ensure our stacks line up with native stack frames.
	-- 	return "\n" .. prefix .. name
	-- else
	-- 	local ownerName = nil
	-- 	if _G.__DEV__ and owner then
	-- 		ownerName = describeOwner(owner)
	-- 	end

	-- 	return describeComponentFrame(name, source, ownerName)
	-- end
	local ownerName = nil
	if _G.__DEV__ and owner then
		ownerName = describeOwner(owner)
	end

	return describeComponentFrame(name, source, ownerName)
	-- ROBLOX deviation END
end

local reentry = false
local componentFrameCache = nil
if _G.__DEV__ then
	componentFrameCache = setmetatable({}, { __mode = "k" })
end

local function describeNativeComponentFrame(
	fn: nil | ReactComponent<any>, -- ROBLOX TODO: only accept tables with __tostring metamethod overridden
	construct: boolean
): string
	-- // If something asked for a stack inside a fake render, it should get ignored.
	if not fn or reentry then
		return ""
	end

	if _G.__DEV__ then
		local frame = componentFrameCache[fn]

		if frame ~= nil then
			return frame
		end
	end

	local control
	reentry = true

	-- deviation: Error.prepareStackTrace is not implemented
	-- local previousPrepareStackTrace = Error.prepareStackTrace
	-- Error.prepareStackTrace = undefined
	local previousDispatcher

	if _G.__DEV__ then
		previousDispatcher = ReactCurrentDispatcher.current
		-- Set the dispatcher in DEV because this might be call in the render
		-- function for warnings.
		ReactCurrentDispatcher.current = nil
		disableLogs()
	end

	-- // This should throw.
	-- deviation: Lua does not have stack traces with errors, so we
	-- use xpcall to convert the error and append a stack trace.
	-- This will change the theorical stack trace we want, because of
	-- the function where we call 'debug.traceback()', but the control
	-- stack will have the same added frame.
	local traceback
	local _, sample = xpcall(function()
		if construct then
			-- deviation: since we can't have a meaningful stack trace when
			-- constructing from a component class (because it does not locate
			-- component definition), we skip this case.
		else
			local _, x = pcall(function()
				traceback = debug.traceback()
				error({
					stack = traceback,
				})
			end)
			control = x;
			-- ROBLOX FIXME: Luau flow analysis bug workaround
			(fn :: (...any) -> ...any)()
		end
	end, function(message)
		return {
			message = message,
			stack = traceback,
		}
	end)

	-- deviation: Lua does not have a structure that works like a try-catch-finally
	-- so we a variable to know if the catch block returns a value. If it returns,
	-- 'earlyOutValue' will be set and we can return its value after running the
	-- instructions in the finally block.
	local earlyOutValue = nil

	if sample and control and type(sample.stack) == "string" then
		-- // This extracts the first frame from the sample that isn't also in the control.
		-- // Skipping one frame that we assume is the frame that calls the two.
		local sampleLines = string.split(sample.stack, "\n")
		local controlLines = string.split(control.stack, "\n")
		-- deviation: remove one because our array of lines contains an empty string
		-- at the end
		local sampleIndex = #sampleLines - 1
		local controlIndex = #controlLines - 1

		while
			sampleIndex >= 2
			and controlIndex >= 0
			and sampleLines[sampleIndex] ~= controlLines[controlIndex]
		do
			-- // We expect at least one stack frame to be shared.
			-- // Typically this will be the root most one. However, stack frames may be
			-- // cut off due to maximum stack limits. In this case, one maybe cut off
			-- // earlier than the other. We assume that the sample is longer or the same
			-- // and there for cut off earlier. So we should find the root most frame in
			-- // the sample somewhere in the control.
			controlIndex = controlIndex - 1
		end

		while sampleIndex >= 3 and controlIndex >= 1 do
			sampleIndex = sampleIndex - 1
			controlIndex = controlIndex - 1
			-- // Next we find the first one that isn't the same which should be the
			-- // frame that called our sample function and the control.
			if sampleLines[sampleIndex] ~= controlLines[controlIndex] then
				-- // In V8, the first line is describing the message but other VMs don't.
				-- // If we're about to return the first line, and the control is also on the same
				-- // line, that'sampleIndex a pretty good indicator that our sample threw at same line as
				-- // the control. I.e. before we entered the sample frame. So we ignore this result.
				-- // This can happen if you passed a class to function component, or non-function.
				if sampleIndex ~= 1 or controlIndex ~= 1 then
					repeat
						sampleIndex = sampleIndex - 1
						controlIndex = controlIndex - 1
						-- // We may still have similar intermediate frames from the construct call.
						-- // The next one that isn't the same should be our match though.
						if
							controlIndex < 0
							or sampleLines[sampleIndex] ~= controlLines[controlIndex]
						then
							-- deviation: add the '    in ' prefix to format the component stack
							-- similar to React
							local frame = "\n" .. prefix .. sampleLines[sampleIndex]

							if _G.__DEV__ then
								componentFrameCache[fn] = frame
							end
							-- // Return the line we found.
							-- deviation: to mimic the behavior of the try-catch-finally
							-- we cannot return the value here.
							earlyOutValue = frame
						end
					until not (sampleIndex >= 3 and controlIndex >= 1)
				end

				break
			end
		end
	end

	reentry = false
	if _G.__DEV__ then
		ReactCurrentDispatcher.current = previousDispatcher
		reenableLogs()
	end

	-- deviation: Error.prepareStackTrace is not implemented
	-- Error.prepareStackTrace = previousPrepareStackTrace

	-- deviation: return here to micmic the end of the finally block
	if earlyOutValue ~= nil then
		return earlyOutValue
	end

	-- Fallback to just using the name if we couldn't make it throw.
	-- ROBLOX deviation START: Can't get displayName for functions, since fn can be a class, we can get the class name here
	local name = if type(fn) == "function"
		then debug.info(fn :: Function, "n")
		-- ROBLOX deviation :
		else if type(fn) == "table" then tostring(fn) else ""

	local syntheticFrame = ""
	if name ~= nil and name ~= "" then
		syntheticFrame = describeBuiltInComponentFrame(name)
	end

	if _G.__DEV__ then
		componentFrameCache[fn] = syntheticFrame
	end

	return syntheticFrame
end

-- ROBLOX deviation: Lua's patterns work slightly differently than regexes
local BEFORE_SLASH_PATTERN = "^(.*)[\\/]"

function describeComponentFrame(
	name: string | nil,
	source: Source | nil,
	ownerName: string | nil
): string
	local sourceInfo = ""

	if _G.__DEV__ and source then
		local path = source.fileName
		local fileName = string.gsub(path, BEFORE_SLASH_PATTERN, "")

		-- // In DEV, include code for a common special case:
		-- // prefer "folder/index.js" instead of just "index.js".
		-- ROBLOX deviation: instead of having a special case for 'index.',
		-- we use 'init.'
		if string.match(fileName, "^init%.") then
			-- deviation: finding matching strings works differently in Lua
			local pathBeforeSlash = string.match(path, BEFORE_SLASH_PATTERN)

			if pathBeforeSlash and #pathBeforeSlash ~= 0 then
				local folderName = string.gsub(pathBeforeSlash, BEFORE_SLASH_PATTERN, "")
				fileName = folderName .. "/" .. fileName
			end
		end

		sourceInfo = " (at " .. fileName .. ":" .. source.lineNumber .. ")"
	elseif ownerName then
		sourceInfo = " (created by " .. ownerName .. ")"
	end

	return "\n    in " .. (name or "Unknown") .. sourceInfo
end

local function describeClassComponentFrame(
	-- ROBLOX deviation: React.Component<any>
	ctor: any,
	source: nil | Source,
	-- ROBLOX deviation: this could be a class component OR a function component
	owner: nil | ReactComponent<any>
): string
	-- ROBLOX deviation START: In Roact, class components are tables, so we
	-- jump directly to using the basic component description.

	-- if enableComponentStackLocations then
	-- 	return describeNativeComponentFrame(componentClass, true)
	-- else
	-- 	return describeFunctionComponentFrame(ctor, source, ownerFn);
	-- end
	local name = tostring(ctor)
	local ownerName = nil
	if _G.__DEV__ and owner then
		ownerName = describeOwner(owner)
	end
	return describeComponentFrame(name, source, ownerName)
	-- ROBLOX deviation END
end

function describeFunctionComponentFrame(
	-- ROBLOX TODO: this annotation is incorrect upstream, we fix it here
	fn: nil | Function,
	source: nil | Source,
	-- ROBLOX deviation: this could be a class component OR a function component
	ownerFn: nil | ReactComponent<any>
): string
	-- ROBLOX DEVIATION Jump directly to using basic component description:
	-- if enableComponentStackLocations then
	-- 	return describeNativeComponentFrame(fn, false)
	-- else
	-- 	if not fn then
	-- 		return ""
	-- 	end
	-- 	-- ROBLOX deviation: use debug.info to discover function names
	-- 	local name = debug.info(fn :: Function, "n")
	-- 	local ownerName = nil
	-- 	if _G.__DEV__ and ownerFn then
	-- 		-- ROBLOX deviation: owner may be a function or a table
	-- 		ownerName = describeOwner(ownerFn)
	-- 	end
	-- 	return describeComponentFrame(name, source, ownerName)
	-- end
	if not fn then
		return ""
	end
	-- ROBLOX deviation: use debug.info to discover function names
	-- ROBLOX FIXME: find out how non-functions are getting into here, they pollute test output
	local name = if type(fn) == "function"
		then debug.info(fn :: Function, "n")
		else tostring(fn)
	local ownerName = nil
	if _G.__DEV__ and ownerFn then
		-- ROBLOX deviation: owner may be a function or a table
		ownerName = describeOwner(ownerFn)
	end
	return describeComponentFrame(name, source, ownerName)
end

-- ROBLOX deviation: because of deviations in other functions, this function is
-- not needed. If we need to bring it, it should return true if Component is a
-- class component, and false if a function component
-- local function shouldConstruct(Component)
-- 	local prototype = Component.prototype
-- 	return not not (prototype and prototype.isReactComponent)
-- end

local function describeUnknownElementTypeFrameInDEV(
	type_: any,
	source: nil | Source,
	-- ROBLOX deviation: owner could be a class component
	ownerFn: nil | ReactComponent<any>
): string
	if not _G.__DEV__ then
		return ""
	end
	if type_ == nil then
		return ""
	end

	-- ROBLOX deviation: in JavaScript, if `type` contains a class, typeof will
	-- return "function". We need to specifically check for the class.
	if type(type_) == "table" and type(type_.__ctor) == "function" then
		-- ROBLOX deviation: since Roact class components are tables, we can't
		-- count on describeClassComponent being a thin wrapper for
		-- describeFunctionComponent like upstream does implicitly
		return describeClassComponentFrame(type_, source, ownerFn)
	end

	if type(type_) == "function" then
		-- ROBLOX DEVIATION: ignore enableComponentStackLocations
		-- if enableComponentStackLocations then
		-- 	-- ROBLOX deviation: since functions and classes have different
		-- 	-- types in Lua, we already know that shouldConstruct would return
		-- 	-- false
		-- 	return describeNativeComponentFrame(type, false)
		-- else
		-- 	return describeFunctionComponentFrame(type, source, ownerFn)
		-- end
		return describeFunctionComponentFrame(type_, source, ownerFn)
	end

	if type(type_) == "string" then
		return describeBuiltInComponentFrame(type_, source, ownerFn)
	end

	if type_ == REACT_SUSPENSE_TYPE then
		return describeBuiltInComponentFrame("Suspense", source, ownerFn)
	elseif type_ == REACT_SUSPENSE_LIST_TYPE then
		return describeBuiltInComponentFrame("SuspenseList", source, ownerFn)
	end

	if type(type_) == "table" then
		local typeProp = type_["$$typeof"]
		if typeProp == REACT_FORWARD_REF_TYPE then
			return describeFunctionComponentFrame(type_.render, source, ownerFn)
		elseif typeProp == REACT_MEMO_TYPE then
			-- // Memo may contain any component type so we recursively resolve it.
			return describeUnknownElementTypeFrameInDEV(type_.type, source, ownerFn)
		elseif typeProp == REACT_BLOCK_TYPE then
			return describeFunctionComponentFrame(type_._render, source, ownerFn)
		elseif typeProp == REACT_LAZY_TYPE then
			local lazyComponent = type_
			local payload = lazyComponent._payload
			local init = lazyComponent._init

			local ok, result = pcall(function()
				describeUnknownElementTypeFrameInDEV(
					-- // Lazy may contain any component type so we recursively resolve it.
					init(payload),
					source,
					ownerFn
				)
			end)

			if ok then
				return result
			end
		end
	end

	return ""
end

return {
	-- deviation: ReactShallowRenderer depends on this, but the upstream `react`
	-- repo doesn't expose it; instead, the shallow-renderer's copies of shared
	-- modules do so. Since we opted to reuse the shared modules in this repo
	-- instead of duplicating, we need to have them include this field
	describeComponentFrame = describeComponentFrame,

	describeBuiltInComponentFrame = describeBuiltInComponentFrame,
	describeNativeComponentFrame = describeNativeComponentFrame,
	describeClassComponentFrame = describeClassComponentFrame,
	describeFunctionComponentFrame = describeFunctionComponentFrame,
	describeUnknownElementTypeFrameInDEV = describeUnknownElementTypeFrameInDEV,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="490">
              <Properties>
                <string name="Name">ReactElementType</string>
                <string name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_Element<ElementType> = flowtypes.React_Element<ElementType>
type React_StatelessFunctionalComponent<P> = flowtypes.React_StatelessFunctionalComponent<
	P
>
type React_ComponentType<P> = flowtypes.React_ComponentType<P>

export type Source = {
	fileName: string,
	lineNumber: number,
}
type Key = string | number
-- ROBLOX deviation: we're using the TypeScript definition here, which is more strict
export type ReactElement<P = Object, T = any> = {
	["$$typeof"]: number,

	-- ROBLOX FIXME Luau: Luau has some trouble and inlining the type param from createElement doesn't help
	type: React_StatelessFunctionalComponent<P> | React_ComponentType<P> | string,
	-- type: T,
	key: Key | nil,
	ref: any,
	props: P,

	-- ROBLOX deviation: upstream has this as interface, which is extensible, Luau types are closed by default
	-- ReactFiber
	_owner: any,

	-- __DEV__
	_store: any?,
	_self: React_Element<any>?,
	_shadowChildren: any?,
	_source: Source?,
}

-- deviation: Return something so that the module system is happy
return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="491">
              <Properties>
                <string name="Name">ReactErrorUtils</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactErrorUtils.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local invariant = require(script.Parent.invariant)
local invokeGuardedCallbackImpl = require(script.Parent.invokeGuardedCallbackImpl)

-- deviation: preemptively declare function
local clearCaughtError

-- Used by Fiber to simulate a try-catch.
local hasError = false
local caughtError = nil

-- Used by event system to capture/rethrow the first error.
local hasRethrowError = false
local rethrowError = nil
local reporter = {
	onError = function(err)
		hasError = true
		caughtError = err
	end,
}
local exports = {}

--[[*
* Call a function while guarding against errors that happens within it.
* Returns an error if it throws, otherwise nil.
*
* In production, this is implemented using a try-catch. The reason we don't
* use a try-catch directly is so that we can swap out a different
* implementation in DEV mode.
*
* @param {String} name of the guard to use for logging or debugging
* @param {Function} func The function to invoke
* @param {*} context The context to use when calling the function
* @param {...*} args Arguments for function
]]
exports.invokeGuardedCallback = function(...)
	hasError = false
	caughtError = nil
	-- deviation: passing in reporter directly
	invokeGuardedCallbackImpl(reporter, ...)
end

--[[*
* Same as invokeGuardedCallback, but instead of returning an error, it stores
* it in a global so it can be rethrown by `rethrowCaughtError` later.
* TODO: See if caughtError and rethrowError can be unified.
*
* @param {String} name of the guard to use for logging or debugging
* @param {Function} func The function to invoke
* @param {*} context The context to use when calling the function
* @param {...*} args Arguments for function
]]
exports.invokeGuardedCallbackAndCatchFirstError = function(...)
	-- deviation: instead of the weird `this` indirection, pass varargs through
	exports.invokeGuardedCallback(...)

	if hasError then
		local err = clearCaughtError()

		if not hasRethrowError then
			hasRethrowError = true
			rethrowError = err
		end
	end
end

--[[*
* During execution of guarded functions we will capture the first error which
* we will rethrow to be handled by the top level error handler.
]]
exports.rethrowCaughtError = function()
	if hasRethrowError then
		local err = rethrowError
		hasRethrowError = false
		rethrowError = nil
		error(err)
	end
end

exports.hasCaughtError = function()
	return hasError
end

clearCaughtError = function()
	if hasError then
		local err = caughtError
		hasError = false
		caughtError = nil
		return err
	else
		invariant(
			false,
			"clearCaughtError was called but no error was captured. This error "
				.. "is likely caused by a bug in React. Please file an issue."
		)
		-- deviation: luau doesn't know that invariant throws, so we return nil
		return nil
	end
end
exports.clearCaughtError = clearCaughtError

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="492">
              <Properties>
                <string name="Name">ReactFeatureFlags</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/ba82eea3837e4aaeb5a30b7827b664a8c2128d2e/packages/shared/ReactFeatureFlags.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Shared = script.Parent
local Packages = Shared.Parent
local SafeFlags = require(Packages.SafeFlags)
local GetFFlagReactEnableSchedulingProfiler =
	SafeFlags.createGetFFlag("ReactEnableSchedulingProfiler")

-- Unknown globals fail type checking (see "Unknown symbols" section of
-- https://roblox.github.io/luau/typecheck.html)
local exports = {}

-- Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
-- This prevents e.g. <img src=""> from making an unnecessary HTTP request for certain browsers.
exports.enableFilterEmptyStringAttributesDOM = true

-- Adds verbose console logging for e.g. state updates, suspense, and work loop stuff.
-- Intended to enable React core members to more easily debug scheduling issues in DEV builds.
exports.enableDebugTracing = false

-- Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
-- for an experimental scheduling profiler tool.
exports.enableSchedulingProfiler = GetFFlagReactEnableSchedulingProfiler()
	or (_G.__PROFILE__ and _G.__EXPERIMENTAL__)

-- Helps identify side effects in render-phase lifecycle hooks and setState
-- reducers by double invoking them in Strict Mode.
-- ROBLOX TODO: we'll want to enable this for DEV app bundles
exports.debugRenderPhaseSideEffectsForStrictMode = _G.__DEV__

-- To preserve the "Pause on caught exceptions" behavior of the debugger, we
-- replay the begin phase of a failed component inside invokeGuardedCallback.
exports.replayFailedUnitOfWorkWithInvokeGuardedCallback = _G.__DEV__

-- Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
exports.warnAboutDeprecatedLifecycles = true

-- Gather advanced timing metrics for Profiler subtrees.
exports.enableProfilerTimer = _G.__PROFILE__

-- Record durations for commit and passive effects phases.
exports.enableProfilerCommitHooks = _G.__PROFILE__

-- Trace which interactions trigger each commit.
exports.enableSchedulerTracing = false

-- SSR experiments
exports.enableSuspenseServerRenderer = _G.__EXPERIMENTAL__
exports.enableSelectiveHydration = _G.__EXPERIMENTAL__

-- Flight experiments
exports.enableBlocksAPI = _G.__EXPERIMENTAL__
exports.enableLazyElements = _G.__EXPERIMENTAL__

-- Only used in www builds.
exports.enableSchedulerDebugging = false

-- Disable javascript: URL strings in href for XSS protection.
exports.disableJavaScriptURLs = false

-- Experimental Host Component support.
exports.enableFundamentalAPI = false

-- Experimental Scope support.
exports.enableScopeAPI = false

-- Experimental Create Event Handle API.
exports.enableCreateEventHandleAPI = false

-- New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

-- We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v18?)
-- Till then, we warn about the missing mock, but still fallback to a legacy mode compatible version
exports.warnAboutUnmockedScheduler = false

-- Add a callback property to suspense to notify which promises are currently
-- in the update queue. This allows reporting and tracing of what is causing
-- the user to see a loading state.
-- Also allows hydration callbacks to fire when a dehydrated boundary gets
-- hydrated or deleted.
exports.enableSuspenseCallback = false

-- Part of the simplification of React.createElement so we can eventually move
-- from React.createElement to React.jsx
-- https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md
exports.warnAboutDefaultPropsOnFunctionComponents = false

exports.disableSchedulerTimeoutBasedOnReactExpirationTime = false

exports.enableTrustedTypesIntegration = false

-- Enables a warning when trying to spread a 'key' to an element
-- a deprecated pattern we want to get rid of in the future
exports.warnAboutSpreadingKeyToJSX = true

exports.enableComponentStackLocations = true

exports.enableNewReconciler = true

-- Errors that are thrown while unmounting (or after in the case of passive effects)
-- should bypass any error boundaries that are also unmounting (or have unmounted)
-- and be handled by the nearest still-mounted boundary.
-- If there are no still-mounted boundaries, the errors should be rethrown.
exports.skipUnmountedBoundaries = true

-- --------------------------
-- Future APIs to be deprecated
-- --------------------------

-- Prevent the value and checked attributes from syncing
-- with their related DOM properties
exports.disableInputAttributeSyncing = true

exports.warnAboutStringRefs = false

exports.disableLegacyContext = false

-- Disables children for <textarea> elements
exports.disableTextareaChildren = false

exports.disableModulePatternComponents = false

-- We should remove this flag once the above flag becomes enabled
exports.warnUnstableRenderSubtreeIntoContainer = false

-- Support legacy Primer support on internal FB www
exports.enableLegacyFBSupport = true

-- Updates that occur in the render phase are not officially supported. But when
-- they do occur, we defer them to a subsequent render by picking a lane that's
-- not currently rendering. We treat them the same as if they came from an
-- interleaved event. Remove this flag once we have migrated to the
-- new behavior.
exports.deferRenderPhaseUpdateToNextBatch = false

-- Replacement for runWithPriority in React internals.
exports.decoupleUpdatePriorityFromScheduler = true

exports.enableDiscreteEventFlushingChange = false

exports.enableEagerRootListeners = false

exports.enableDoubleInvokingEffects = false
return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="493">
              <Properties>
                <string name="Name">ReactFiberHostConfig</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	ROBLOX deviation: ReactFiberHostConfig captures singleton state across the
	whole workspace. This file and the modules it requires were moved from React
	to untangle a cyclic workspace member dependency.

	Before:
	* ReactFiberHostConfig (and the 5 associated modules) lived in React
	* React had a dependency on Shared
	* Shared reached into React source to re-export ReactFiberHostConfig (cycle)

	After:
	* ReactFiberHostConfig (and the 5 associated modules) live in Shared
	* React depends on Shared
	* Shared has no intra-workspace dependencies (no cycles)
]]

-- types that are common across ReactFiberHostConfig files, moved here to avoid circular deps
type Object = { [string]: any }
export type OpaqueIDType = string | Object

return {
	WithNoHydration = require(script.WithNoHydration),
	WithNoPersistence = require(script.WithNoPersistence),
	WithNoTestSelectors = require(script.WithNoTestSelectors),
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="494">
                <Properties>
                  <string name="Name">WithNoHydration</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactFiberHostConfigWithNoHydration.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support hydration
-- can re-export everything from this module.

function shim(...)
	invariant(
		false,
		"The current renderer does not support hydration. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Hydration (when unsupported)
export type SuspenseInstance = any
return {
	supportsHydration = false,
	canHydrateInstance = shim,
	canHydrateTextInstance = shim,
	canHydrateSuspenseInstance = shim,
	isSuspenseInstancePending = shim,
	isSuspenseInstanceFallback = shim,
	registerSuspenseInstanceRetry = shim,
	getNextHydratableSibling = shim,
	getFirstHydratableChild = shim,
	hydrateInstance = shim,
	hydrateTextInstance = shim,
	hydrateSuspenseInstance = shim,
	getNextHydratableInstanceAfterSuspenseInstance = shim,
	commitHydratedContainer = shim,
	commitHydratedSuspenseInstance = shim,
	clearSuspenseBoundary = shim,
	clearSuspenseBoundaryFromContainer = shim,
	didNotMatchHydratedContainerTextInstance = shim,
	didNotMatchHydratedTextInstance = shim,
	didNotHydrateContainerInstance = shim,
	didNotHydrateInstance = shim,
	didNotFindHydratableContainerInstance = shim,
	didNotFindHydratableContainerTextInstance = shim,
	didNotFindHydratableContainerSuspenseInstance = shim,
	didNotFindHydratableInstance = shim,
	didNotFindHydratableTextInstance = shim,
	didNotFindHydratableSuspenseInstance = shim,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="495">
                <Properties>
                  <string name="Name">WithNoPersistence</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactFiberHostConfigWithNoPersistence.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support persistence
-- can re-export everything from this module.

local function shim(...)
	invariant(
		false,
		"The current renderer does not support persistence. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Persistence (when unsupported)
return {
	supportsPersistence = false,
	cloneInstance = shim,
	cloneFundamentalInstance = shim,
	createContainerChildSet = shim,
	appendChildToContainerChildSet = shim,
	finalizeContainerChildren = shim,
	replaceContainerChildren = shim,
	cloneHiddenInstance = shim,
	cloneHiddenTextInstance = shim,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="496">
                <Properties>
                  <string name="Name">WithNoTestSelectors</string>
                  <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/3cde22a84e246fc5361f038bf0c23405b2572c22/packages/react-reconciler/src/ReactFiberHostConfigWithNoTestSelectors.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support test selectors
-- can re-export everything from this module.

local function shim(...)
	invariant(
		false,
		"The current renderer does not support test selectors. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Test selectors (when unsupported)
return {
	supportsTestSelectors = false,
	findFiberRoot = shim,
	getBoundingRect = shim,
	getTextContent = shim,
	isHiddenSubtree = shim,
	matchAccessibilityRole = shim,
	setFocusIfFocusable = shim,
	setupIntersectionObserver = shim,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="497">
              <Properties>
                <string name="Name">ReactInstanceMap</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/2ba43edc2675380a0f2222f351475bf9d750c6a9/packages/shared/ReactInstanceMap.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

--[[*
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 ]]

--[[*
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 ]]

local Shared = script.Parent
local Packages = Shared.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
local getComponentName = require(script.Parent.getComponentName)
local ReactUtils = script:FindFirstAncestor("ReactUtils")

local __DEV__ = _G.__DEV__ :: boolean
local SafeFlags = require(Packages.SafeFlags)
local GetFFlagReactInstanceMapDisableErrorChecking =
	SafeFlags.createGetFFlag("ReactInstanceMapDisableErrorChecking")
local FFlagReactInstanceMapDisableErrorChecking =
	GetFFlagReactInstanceMapDisableErrorChecking()

local exports = {}

local function isValidFiber(fiber): boolean
	return fiber.tag ~= nil
		and fiber.subtreeFlags ~= nil
		and fiber.lanes ~= nil
		and fiber.childLanes ~= nil
end

exports.remove = function(key)
	key._reactInternals = nil
end

if not FFlagReactInstanceMapDisableErrorChecking or __DEV__ then
	exports.get = function(key)
		local value = key._reactInternals
		if not isValidFiber(value) then
			error(
				Error.new(
					"invalid fiber in "
						.. (getComponentName(key) or "UNNAMED Component")
						.. " during get from ReactInstanceMap! "
						.. inspect(value)
				)
			)
		elseif value.alternate ~= nil and not isValidFiber(value.alternate) then
			error(
				Error.new(
					"invalid alternate fiber ("
						.. (getComponentName(key) or "UNNAMED alternate")
						.. ") in "
						.. (getComponentName(key) or "UNNAMED Component")
						.. " during get from ReactInstanceMap! "
						.. inspect(value.alternate)
				)
			)
		end
		return value
	end
else
	exports.get = function(key)
		return key._reactInternals
	end
end

exports.has = function(key)
	return key._reactInternals ~= nil
end

if not FFlagReactInstanceMapDisableErrorChecking or __DEV__ then
	exports.set = function(key, value)
		local parent = value
		local message
		while parent ~= nil do
			if not isValidFiber(parent) then
				message = "invalid fiber in "
					.. (getComponentName(key) or "UNNAMED Component")
					.. " being set in ReactInstanceMap! "
					.. inspect(parent)
					.. "\n"

				if value ~= parent then
					message ..= " (from original fiber " .. (getComponentName(key) or "UNNAMED Component") .. ")"
				end
				error(Error.new(message))
			elseif
				(parent :: any).alternate ~= nil
				and not isValidFiber((parent :: any).alternate)
			then
				message = "invalid alternate fiber ("
					.. (getComponentName(key) or "UNNAMED alternate")
					.. ") in "
					.. (getComponentName(key) or "UNNAMED Component")
					.. " being set in ReactInstanceMap! "
					.. inspect((parent :: any).alternate)
					.. "\n"

				if value ~= parent then
					message ..= " (from original fiber " .. (getComponentName(key) or "UNNAMED Component") .. ")"
				end
				error(Error.new(message))
			end
			parent = (parent :: any).return_
		end
		(key :: any)._reactInternals = value
	end
else
	exports.set = function(key, value)
		(key :: any)._reactInternals = value
	end
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="498">
              <Properties>
                <string name="Name">ReactSharedInternals</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/607148673b3156d051d1fed17cd49e83698dce54/packages/react/src/ReactSharedInternals.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]

--[[
	ROBLOX deviation: ReactSharedInternals captures singleton state across the
	whole workspace. This file and the modules it requires were moved from React
	to untangle a cyclic workspace member dependency.

	Before:
	* ReactSharedInternals (and the 5 associated modules) lived in React
	* React had a dependency on Shared
	* Shared reached into React source to re-export ReactSharedInternals (cycle)

	After:
	* ReactSharedInternals (and the 5 associated modules) live in Shared
	* React depends on Shared
	* Shared has no intra-workspace dependencies (no cycles)
]]
local Packages = script.Parent.Parent
local console = require(Packages.LuauPolyfill).console
local function onlyInTestError(functionName: string)
	return function()
		console.error(functionName .. " is only available in tests, not in production")
	end
end

-- import assign from 'object-assign';
local ReactCurrentDispatcher = require(script.ReactCurrentDispatcher)
export type Dispatcher = ReactCurrentDispatcher.Dispatcher
local ReactCurrentBatchConfig = require(script.ReactCurrentBatchConfig)
local ReactCurrentOwner = require(script.ReactCurrentOwner)
local ReactDebugCurrentFrame = require(script.ReactDebugCurrentFrame)
local IsSomeRendererActing = require(script.IsSomeRendererActing)

local ReactSharedInternals = {
	ReactCurrentDispatcher = ReactCurrentDispatcher,
	ReactCurrentBatchConfig = ReactCurrentBatchConfig,
	ReactCurrentOwner = ReactCurrentOwner,
	IsSomeRendererActing = IsSomeRendererActing,
	-- ROBLOX deviation: Luau type checking requires us to have a consistent export shape regardless of __DEV__
	-- ROBLOX TODO: use if-expressions when all clients are on 503+
	ReactDebugCurrentFrame = if _G.__DEV__
		then ReactDebugCurrentFrame
		else {
			setExtraStackFrame = function(_: string?): ()
				onlyInTestError("setExtraStackFrame")
			end,
		},
	-- deviation: We shouldn't have to worry about duplicate bundling here
	-- Used by renderers to avoid bundling object-assign twice in UMD bundles:
	-- assign,
}

return ReactSharedInternals
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="499">
                <Properties>
                  <string name="Name">IsSomeRendererActing</string>
                  <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/a457e02ae3a2d3903fcf8748380b1cc293a2445e/packages/react/src/IsSomeRendererActing.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[*
 * Used by act() to track whether you're inside an act() scope.
 ]]

local IsSomeRendererActing = {
	current = false,
}
return IsSomeRendererActing
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="500">
                <Properties>
                  <string name="Name">ReactCurrentBatchConfig</string>
                  <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/92fcd46cc79bbf45df4ce86b0678dcef3b91078d/packages/react/src/ReactCurrentBatchConfig.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[*
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
]]
local ReactCurrentBatchConfig = {
	transition = 0,
}

return ReactCurrentBatchConfig
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="501">
                <Properties>
                  <string name="Name">ReactCurrentDispatcher</string>
                  <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/376d5c1b5aa17724c5fea9412f8fcde14a7b23f1/packages/react/src/ReactCurrentDispatcher.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

--[[*
 * Keeps track of the current dispatcher.
]]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

-- ROBLOX deviation: we duplicate the Dispatcher type here because upstream has a circular dependency between Shared and Reconciler
local ReactElementType = require(script.Parent.Parent.ReactElementType)
type Source = ReactElementType.Source
local ReactTypes = require(script.Parent.Parent.ReactTypes)
type RefObject = ReactTypes.RefObject
type ReactContext<T> = ReactTypes.ReactContext<T>
-- ROBLOX deviation START: binding support
type ReactBinding<T> = ReactTypes.ReactBinding<T>
type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- ROBLOX deviation END: binding support
type MutableSourceVersion = ReactTypes.MutableSourceVersion
type MutableSource<Source> = ReactTypes.MutableSource<Source>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

export type Dispatcher = {
	readContext: <T>(
		context: ReactContext<T>,
		observedBits: nil | number | boolean
	) -> T,
	useState: <S>(initialState: (() -> S) | S) -> (S, Dispatch<BasicStateAction<S>>),
	useReducer: <S, I, A>(
		reducer: (S, A) -> S,
		initialArg: I,
		init: ((I) -> S)?
	) -> (S, Dispatch<A>),
	useContext: <T>(
		context: ReactContext<T>,
		observedBits: nil | number | boolean
	) -> T,
	useRef: <T>(initialValue: T) -> { current: T },
	-- ROBLOX deviation START: Bindings are a feature unique to Roact
	useBinding: <T>(initialValue: T) -> (ReactBinding<T>, ReactBindingUpdater<T>),
	-- ROBLOX deviation END
	useEffect: (
		-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
		create: (() -> ()) | (() -> (() -> ())),
		deps: Array<any> | nil
	) -> (),
	useLayoutEffect: (
		-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
		create: (() -> ()) | (() -> (() -> ())),
		deps: Array<any> | nil
	) -> (),
	useCallback: <T>(callback: T, deps: Array<any> | nil) -> T,
	useMemo: <T...>(nextCreate: () -> T..., deps: Array<any> | nil) -> T...,
	useImperativeHandle: <T>(
		ref: { current: T | nil } | ((inst: T | nil) -> any) | nil,
		create: () -> T,
		deps: Array<any> | nil
	) -> (),
	useDebugValue: <T>(value: T, formatterFn: ((value: T) -> any)?) -> (),
	-- ROBLOX TODO: make these non-optional and implement them in the dispatchers
	useDeferredValue: (<T>(value: T) -> T)?,
	useTransition: (() -> ((() -> ()) -> (), boolean))?, -- ROBLOX deviation: Luau doesn't support jagged array types [(() -> ()) -> (), boolean],
	useMutableSource: <Source, Snapshot>(
		source: MutableSource<Source>,
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		subscribe: MutableSourceSubscribeFn<Source, Snapshot>
	) -> Snapshot,
	useOpaqueIdentifier: () -> any,

	unstable_isNewReconciler: boolean?,
	-- [string]: any,
}

local ReactCurrentDispatcher: { current: nil | Dispatcher } = {
	--[[
		* @internal
		* @type {ReactComponent}
		*/
	]]
	current = nil,
}

return ReactCurrentDispatcher
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="502">
                <Properties>
                  <string name="Name">ReactCurrentOwner</string>
                  <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/376d5c1b5aa17724c5fea9412f8fcde14a7b23f1/packages/react/src/ReactCurrentOwner.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[*
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
]]
local ReactCurrentOwner = {
	--[[*
   * @internal
   * @type {ReactComponent}
   ]]
	-- ROBLOX deviation START: upstream types this as Fiber, but that would incur a circular dependency between reconciler and shared
	current = nil :: any,
	-- ROBLOX deviation END
}

return ReactCurrentOwner
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="503">
                <Properties>
                  <string name="Name">ReactDebugCurrentFrame</string>
                  <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/98d410f5005988644d01c9ec79b7181c3dd6c847/packages/react/src/ReactDebugCurrentFrame.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local ReactDebugCurrentFrame = {}

local currentExtraStackFrame = nil :: nil | string

function ReactDebugCurrentFrame.setExtraStackFrame(stack: string?): ()
	if _G.__DEV__ then
		currentExtraStackFrame = stack
	end
end

if _G.__DEV__ then
	-- deviation: in Lua, the implementation is duplicated
	-- function ReactDebugCurrentFrame.setExtraStackFrame(stack: string?)
	-- 	if _G.__DEV__ then
	-- 		currentExtraStackFrame = stack
	-- 	end
	-- end

	-- Stack implementation injected by the current renderer.
	ReactDebugCurrentFrame.getCurrentStack = nil :: nil | (() -> string)

	function ReactDebugCurrentFrame.getStackAddendum(): string
		local stack = ""

		-- Add an extra top frame while an element is being validated
		if currentExtraStackFrame then
			stack = stack .. currentExtraStackFrame
		end

		-- Delegate to the injected renderer-specific implementation
		local impl = ReactDebugCurrentFrame.getCurrentStack
		if impl then
			stack = stack .. (impl() or "")
		end

		return stack
	end
end

return ReactDebugCurrentFrame
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="504">
              <Properties>
                <string name="Name">ReactSymbols</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/b61174fb7b09580c1ec2a8f55e73204b706d2935/packages/shared/ReactSymbols.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

-- ATTENTION
-- When adding new symbols to this file,
-- Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'

-- local Packages = script.Parent.Parent
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Symbol = LuauPolyfill.Symbol

local exports: { [string]: any } = {}

-- The Symbol used to tag the ReactElement-like types. If there is no native Symbol
-- nor polyfill, then a plain number is used for performance.
exports.REACT_ELEMENT_TYPE = 0xeac7
exports.REACT_PORTAL_TYPE = 0xeaca
exports.REACT_FRAGMENT_TYPE = 0xeacb
exports.REACT_STRICT_MODE_TYPE = 0xeacc
exports.REACT_PROFILER_TYPE = 0xead2
exports.REACT_PROVIDER_TYPE = 0xeacd
exports.REACT_CONTEXT_TYPE = 0xeace
exports.REACT_FORWARD_REF_TYPE = 0xead0
exports.REACT_SUSPENSE_TYPE = 0xead1
exports.REACT_SUSPENSE_LIST_TYPE = 0xead8
exports.REACT_MEMO_TYPE = 0xead3
exports.REACT_LAZY_TYPE = 0xead4
exports.REACT_BLOCK_TYPE = 0xead9
exports.REACT_SERVER_BLOCK_TYPE = 0xeada
exports.REACT_FUNDAMENTAL_TYPE = 0xead5
exports.REACT_SCOPE_TYPE = 0xead7
exports.REACT_OPAQUE_ID_TYPE = 0xeae0
exports.REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1
exports.REACT_OFFSCREEN_TYPE = 0xeae2
exports.REACT_LEGACY_HIDDEN_TYPE = 0xeae3
exports.REACT_BINDING_TYPE = 0xeae4

-- ROBLOX TODO: Use Symbol again once jest-mock knows to exclude the LuauPolyfill module from being reset
-- deviation: In Lua, Symbol will be a callable table, not a function
-- if typeof(Symbol) == "table" and Symbol.for_ ~= nil then
--   local symbolFor = Symbol.for_
--   exports.REACT_ELEMENT_TYPE = symbolFor('react.element')
--   exports.REACT_PORTAL_TYPE = symbolFor('react.portal')
--   exports.REACT_FRAGMENT_TYPE = symbolFor('react.fragment')
--   exports.REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode')
--   exports.REACT_PROFILER_TYPE = symbolFor('react.profiler')
--   exports.REACT_PROVIDER_TYPE = symbolFor('react.provider')
--   exports.REACT_CONTEXT_TYPE = symbolFor('react.context')
--   exports.REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref')
--   exports.REACT_SUSPENSE_TYPE = symbolFor('react.suspense')
--   exports.REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list')
--   exports.REACT_MEMO_TYPE = symbolFor('react.memo')
--   exports.REACT_LAZY_TYPE = symbolFor('react.lazy')
--   exports.REACT_BLOCK_TYPE = symbolFor('react.block')
--   exports.REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block')
--   exports.REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental')
--   exports.REACT_SCOPE_TYPE = symbolFor('react.scope')
--   exports.REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id')
--   exports.REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode')
--   exports.REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen')
--   exports.REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden')
-- end

-- deviation: short circuit for now
--local MAYBE_ITERATOR_SYMBOL = false -- deviation: typeof(Symbol) == 'function' and Symbol.iterator
--local FAUX_ITERATOR_SYMBOL = '@@iterator'

type Iterator<T> = {
	next: () -> {
		value: T,
		key: any,
		done: boolean,
	},
}
-- ROBLOX deviation: upstream type is incorrect, as returned function takes a parameter in reconcileChildrenIterator()
exports.getIteratorFn = function(maybeIterable): nil | (...any) -> Iterator<any>
	if typeof(maybeIterable) == "table" then
		-- ROBLOX deviation: Upstream understands that portal objects are not
		-- iterable; we need to check explicitly
		if maybeIterable["$$typeof"] == exports.REACT_PORTAL_TYPE then
			return nil
		end
		return function()
			local currentKey: any, currentValue: any
			return {
				next = function()
					currentKey, currentValue = next(maybeIterable, currentKey)
					return {
						done = currentValue == nil,
						-- deviation: To support Roact's table-keys-as-stable-keys feature,
						-- we need the iterator to return the key as well
						key = currentKey,
						value = currentValue,
					}
				end,
			}
		end
	end

	return nil
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="505">
              <Properties>
                <string name="Name">ReactTypes</string>
                <string name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type void = nil
type NonMaybeType<T> = T

local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_Element<T> = flowtypes.React_Element<T>
type React_Node = flowtypes.React_Node
type SimpleMap<K, V> = { [K]: V }
type Iterable<T> = SimpleMap<string | number, T> | Array<T>

export type ReactNode<T = any> =
	React_Element<T>
	| ReactPortal
	-- | ReactText
	| ReactFragment
	| ReactProvider<T>
	| ReactConsumer<T>

export type ReactEmpty = nil | void | boolean

export type ReactFragment = ReactEmpty | Iterable<React_Node>

export type ReactNodeList = ReactEmpty | React_Node

-- ROBLOX deviation START: Roblox renderer doesn't support TextNode, only use of this type is in this file
-- export type ReactText = string | number;
-- ROBLOX deviation END
export type ReactProvider<T> = {
	["$$typeof"]: number,
	type: ReactProviderType<T>,
	key: nil | string,
	ref: nil,
	props: {
		value: T,
		children: ReactNodeList?,
		-- ROBLOX deviation START: only make this open to extension if absolutely necessary
		-- ...
		-- ROBLOX deviation END
	},
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactProviderType<T> = {
	["$$typeof"]: number,
	_context: ReactContext<T>,
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactConsumer<T> = {
	["$$typeof"]: number,
	type: ReactContext<T>, -- ROBLOX FIXME: Luau can't do <T> because:  Recursive type being used with different parameters
	key: nil | string,
	ref: nil,
	props: {
		children: (value: T) -> ReactNodeList,
		unstable_observedBits: number?,
		-- ROBLOX deviation START: only make this open to extension if absolutely necessary
		-- ...
		-- ROBLOX deviation END
	},
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactContext<T> = {
	["$$typeof"]: number,
	Consumer: ReactContext<T>,
	Provider: ReactProviderType<T>,
	_calculateChangedBits: ((T, T) -> number)?,
	_currentValue: T,
	_currentValue2: T,
	_threadCount: number,
	-- DEV only
	_currentRenderer: Object | nil,
	_currentRenderer2: Object | nil,
	-- This value may be added by application code
	-- to improve DEV tooling display names
	displayName: string?,
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactPortal = {
	["$$typeof"]: number,
	key: nil | string,
	containerInfo: any,
	children: ReactNodeList,
	-- TODO: figure out the API for cross-renderer implementation.
	implementation: any,
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type RefObject<T = any> = { current: T }

-- ROBLOX deviation START: No Luau support for numeric literal types
-- export type EventPriority = 0 | 1 | 2;
export type EventPriority = number
-- ROBLOX deviation END

local exports = {}
exports.DiscreteEvent = 0
exports.UserBlockingEvent = 1
exports.ContinuousEvent = 2

export type ReactFundamentalComponentInstance<C, H> = {
	currentFiber: Object,
	instance: any,
	prevProps: Object?,
	props: Object,
	impl: ReactFundamentalImpl<C, H>,
	state: Object,
}

export type ReactFundamentalImpl<C, H> = {
	displayName: string,
	reconcileChildren: boolean,
	getInitialState: nil | (Object) -> (Object),
	getInstance: (C, Object, Object) -> (H),
	getServerSideString: nil | (C, Object) -> (string),
	getServerSideStringClose: nil | (C, Object) -> (string),
	onMount: (C, any, Object, Object) -> (),
	shouldUpdate: nil | (C, Object?, Object, Object) -> (boolean),
	onUpdate: nil | (C, any, Object?, Object, Object) -> (),
	onUnmount: nil | (C, any, Object, Object) -> (),
	onHydrate: nil | (C, Object, Object) -> boolean,
	onFocus: nil | (C, Object, Object) -> boolean,
}
export type ReactFundamentalComponent<C, H> = {
	["$$typeof"]: number,
	impl: ReactFundamentalImpl<C, H>,
}

export type ReactScope = {
	["$$typeof"]: number,
}

export type ReactScopeQuery = (
	type: string,
	-- ROBLOX deviation START: leave closed to extension unless necessary
	props: { [string]: any? },
	-- ROBLOX deviation END
	instance: any
) -> boolean

export type ReactScopeInstance = {
	DO_NOT_USE_queryAllNodes: (ReactScopeQuery) -> nil | Array<Object>,
	DO_NOT_USE_queryFirstNode: (ReactScopeQuery) -> nil | Object,
	containsNode: (Object) -> boolean,
	getChildContextValues: <T>(context: ReactContext<T>) -> Array<T>,
}

-- ROBLOX deviation START: Bindings are unique to Roact
-- FIXME Luau: can't create recursive type with different parameters, so we
-- need to split the generic `map` method into a different type and then
-- re-combine those types together
type CoreReactBinding<T> = {
	getValue: (self: CoreReactBinding<T>) -> T,
	_source: string?,
}
type ReactBindingMap = {
	map: <T, U>(
		self: CoreReactBinding<T> & ReactBindingMap,
		(T) -> U
	) -> ReactBindingMap & CoreReactBinding<U>,
}

export type ReactBinding<T> = CoreReactBinding<T> & ReactBindingMap
export type ReactBindingUpdater<T> = (T) -> ()
-- ROBLOX deviation END

-- Mutable source version can be anything (e.g. number, string, immutable data structure)
-- so long as it changes every time any part of the source changes.
export type MutableSourceVersion = NonMaybeType<any>

export type MutableSourceGetSnapshotFn<Source, Snapshot> = (source: Source) -> Snapshot

export type MutableSourceSubscribeFn<Source, Snapshot> = (
	source: Source,
	callback: (snapshot: Snapshot) -> ()
) -> (() -> ())

export type MutableSourceGetVersionFn = (
	_source: NonMaybeType<any>
) -> MutableSourceVersion

export type MutableSource<Source> = {
	_source: Source,

	_getVersion: MutableSourceGetVersionFn,

	-- Tracks the version of this source at the time it was most recently read.
	-- Used to determine if a source is safe to read from before it has been subscribed to.
	-- Version number is only used during mount,
	-- since the mechanism for determining safety after subscription is expiration time.
	--
	-- As a workaround to support multiple concurrent renderers,
	-- we categorize some renderers as primary and others as secondary.
	-- We only expect there to be two concurrent renderers at most:
	-- React Native (primary) and Fabric (secondary);
	-- React DOM (primary) and React ART (secondary).
	-- Secondary renderers store their context values on separate fields.
	-- We use the same approach for Context.
	_workInProgressVersionPrimary: nil | MutableSourceVersion,
	_workInProgressVersionSecondary: nil | MutableSourceVersion,

	-- DEV only
	-- Used to detect multiple renderers using the same mutable source.
	_currentPrimaryRenderer: Object | nil,
	_currentSecondaryRenderer: Object | nil,
}

-- The subset of a Thenable required by things thrown by Suspense.
-- This doesn't require a value to be passed to either handler.
export type Wakeable = {
	andThen: (
		self: Wakeable,
		onFulfill: () -> ...any,
		onReject: () -> ...any
		-- ROBLOX FIXME Luau: needs union type packs to parse () | Wakeable
	) -> nil | Wakeable,
	-- Special flag to opt out of tracing interactions across a Suspense boundary.
	__reactDoNotTraceInteractions: boolean?,
}

-- The subset of a Promise that React APIs rely on. This resolves a value.
-- This doesn't require a return value neither from the handler nor the
-- then function.
-- ROBLOX FIXME: workaround for Luau recursive type used with different parameters. delete this copy once that issue is resolved.
export type _Thenable<R> = {
	andThen: <U>(
		self: _Thenable<R>,
		onFulfill: (R) -> ...U,
		onReject: (error: any) -> ...U
	) -> (),
}

export type Thenable<R> = {
	andThen: <U>(
		self: Thenable<R>,
		onFulfill: (R) -> ...(_Thenable<U> | U),
		onReject: (error: any) -> ...(_Thenable<U> | U)
		-- ROBLOX FIXME Luau: need union type packs to parse () | Thenable<U>: CLI-49836
	) -> nil | _Thenable<U>,
}

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="506">
              <Properties>
                <string name="Name">ReactVersion</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/a89854bc936668d325cac9a22e2ebfa128c7addf/packages/shared/ReactVersion.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- TODO: this is special because it gets imported during build.
return "17.0.1"
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="507">
              <Properties>
                <string name="Name">Symbol.roblox</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = string.format("Symbol(%s)", name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="508">
              <Properties>
                <string name="Name">Type.roblox</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent["Symbol.roblox"])

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("HostChangeEvent")
addType("HostEvent")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

return Type
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="509">
              <Properties>
                <string name="Name">UninitializedState.roblox</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!strict
local console = require(script.Parent.console)

-- ROBLOX DEVIATION: Initialize state to a singleton that warns on access and errors on assignment
-- initial state singleton
local UninitializedState = {}

setmetatable(UninitializedState, {
	__index = function(table, key)
		if _G.__DEV__ then
			console.warn(
				"Attempted to access uninitialized state. Use setState to initialize state"
			)
		end
		return nil
	end,
	__newindex = function(table, key)
		if _G.__DEV__ then
			console.error(
				"Attempted to directly mutate state. Use setState to assign new values to state."
			)
		end
		return nil
	end,
	__tostring = function(self)
		return "<uninitialized component state>"
	end,
	__metatable = "UninitializedState",
})

return UninitializedState
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="510">
              <Properties>
                <string name="Name">checkPropTypes</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/checkPropTypes.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Function = (...any) -> ...any

-- ROBLOX: use patched console from shared
local console = require(script.Parent.console)

local loggedTypeFailures = {}

local ReactComponentStackFrame = require(script.Parent.ReactComponentStackFrame)
local describeUnknownElementTypeFrameInDEV =
	ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)

local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame

-- ROBLOX FIXME Luau: doesn't see `if element` as nilable table, so we get TypeError: Type 'any?' could not be converted into '{| _owner: {| type: nil |}, _source: Source?, type: any |}'
local function setCurrentlyValidatingElement(element: any?)
	if _G.__DEV__ then
		if element then
			local owner = element._owner
			local stack = describeUnknownElementTypeFrameInDEV(
				element.type,
				element._source,
				if owner ~= nil then owner.type else nil
			);
			-- ROBLOX FIXME Luau: Cannot call non-function ((string?) -> ()) | ((string?) -> ())
			(ReactDebugCurrentFrame.setExtraStackFrame :: any)(stack)
		else
			(ReactDebugCurrentFrame.setExtraStackFrame :: any)(nil)
		end
	end
end

local function checkPropTypes<P>(
	-- ROBLOX deviation START: also checks validateProps if present
	propTypes: Object?,
	validateProps: (P) -> (boolean, string?)?,
	props: P,
	-- ROBLOX deviation END
	location: string,
	componentName: string?,
	element: any?
): ()
	if _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		-- deviation: hasOwnProperty shouldn't be relevant to lua objects
		-- $FlowFixMe This is okay but Flow doesn't know it.
		-- local has = Function.call.bind(Object.prototype.hasOwnProperty)

		-- ROBLOX deviation: warns if both propType and validateProps defined.
		if propTypes and validateProps then
			console.warn(
				"You've defined both propTypes and validateProps on "
					.. (componentName or "a component")
			)
		end

		-- ROBLOX deviation: also checks validateProps if present
		if validateProps then
			if typeof(validateProps) ~= "function" then
				console.error(
					("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
						typeof(validateProps),
						componentName or ""
					)
				)
			else
				local success, failureReason = validateProps(props)

				if not success then
					failureReason = failureReason
						or "<Validator function did not supply a message>"
					local message = string.format(
						"validateProps failed on a %s type in %s: %s",
						location,
						componentName or "<UNKNOWN Component>",
						tostring(failureReason)
					)
					-- ROBLOX deviation: In legacy Roact, prop validation
					-- failures throw. We replicate that behavior, even though
					-- it differs from propTypes (which only warns)
					-- ROBLOX FIXME: align with upstream behavior during React 18 Lua transition
					error(message)
				end
			end
		end

		if propTypes then
			-- ROBLOX deviation: since we can't constrain the generic, we assert so Luau knows propTypes is a table
			assert(typeof(propTypes) == "table", "propTypes needs to be a table")
			for typeSpecName, _ in propTypes do
				-- deviation: since our loop won't hit metatable members, we don't
				-- need to worry about encountering inherited properties here
				-- if has(propTypes, typeSpecName) then

				-- Prop type validation may throw. In case they do, we don't want to
				-- fail the render phase where it didn't fail before. So we log it.
				-- After these have been cleaned up, we'll local them throw.
				local _, result = xpcall(function()
					-- This is intentionally an invariant that gets caught. It's the same
					-- behavior as without this statement except with a better message.
					if typeof(propTypes[typeSpecName]) ~= "function" then
						local err = Error.new(
							(componentName or "React class")
								.. ": "
								.. location
								.. " type `"
								.. typeSpecName
								.. "` is invalid; "
								.. "it must be a function, usually from the `prop-types` package, but received `"
								.. typeof(propTypes[typeSpecName])
								.. "`."
								.. "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
						)
						err.name = "Invariant Violation"
						error(err)
					end

					return (propTypes[typeSpecName] :: Function)(
						props,
						typeSpecName,
						componentName,
						location,
						nil,
						"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
					)
				end, describeError)

				-- ROBLOX deviation: FIXME: Can we expose something from JSPolyfill that
				-- will let us verify that this is specifically the Error object
				-- defined there? if we check for result.message ~= nil, ReactNewContext.spec:1368 fails
				local isErrorObject = typeof(result) == "table"
				if result ~= nil and not isErrorObject then
					setCurrentlyValidatingElement(element)
					console.error(string.format(
						-- ROBLOX deviation: s/null/nil
						"%s: type specification of %s"
							.. " `%s` is invalid; the type checker "
							.. "function must return `nil` or an `Error` but returned a %s. "
							.. "You may have forgotten to pass an argument to the type checker "
							.. "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and "
							.. "shape all require an argument).",
						componentName or "React class",
						location,
						typeSpecName,
						typeof(result)
					))
					setCurrentlyValidatingElement(nil)
				end

				-- ROBLOX FIXME: Luau analyze doesn't understand isErrorObject's effect as a predicate meaning result ~= nil
				if
					isErrorObject
					and loggedTypeFailures[(result :: any).message] == nil
				then
					-- Only monitor this failure once because there tends to be a lot of the
					-- same error.
					loggedTypeFailures[tostring((result :: any).message)] = true
					setCurrentlyValidatingElement(element)
					console.warn(
						string.format(
							"Failed %s type: %s",
							location,
							tostring((result :: any).message)
						)
					)
					setCurrentlyValidatingElement(nil)
				end
			end
		end
	end
end

return checkPropTypes
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="511">
              <Properties>
                <string name="Name">console</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

-- deviation: this lets us have the same functionality as in React, without
-- having something like Babel to inject a different implementation of
-- console.warn and console.error into the code
-- Instead of using `LuauPolyfill.console`, React internals should use this
-- wrapper to be able to use consoleWithStackDev in dev mode
local Shared = script.Parent
local Packages = Shared.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local consoleWithStackDev = require(Shared.consoleWithStackDev)

if _G.__DEV__ then
	local newConsole = setmetatable({
		warn = consoleWithStackDev.warn,
		error = consoleWithStackDev.error,
	}, {
		__index = console,
	})
	return newConsole
end

return console
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="512">
              <Properties>
                <string name="Name">consoleWithStackDev</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/cb141681750c8221ac799074df09df2bb448c7a4/packages/shared/consoleWithStackDev.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local Array = LuauPolyfill.Array

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)
-- In DEV, calls to console.warn and console.error get replaced
-- by calls to these methods by a Babel plugin.
--
-- In PROD (or in packages without access to React internals),
-- they are left as they are instead.

-- deviation: declare this ahead of time so that `warn` and `error` are able to
-- reference it
local printWarning

local exports = {}
exports.warn = function(format, ...)
	if _G.__DEV__ then
		printWarning("warn", format, { ... })
	end
end
exports.error = function(format, ...)
	if _G.__DEV__ then
		printWarning("error", format, { ... })
	end
end

function printWarning(level, format, args)
	-- When changing this logic, you might want to also
	-- update consoleWithStackDev.www.js as well.
	if _G.__DEV__ then
		local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
		local stack = ReactDebugCurrentFrame.getStackAddendum()

		if stack ~= "" then
			format ..= "%s"
			-- deviation: no array `concat` function in lua
			args = Array.slice(args, 1)
			table.insert(args, stack)
		end

		local argsWithFormat = Array.map(args, tostring)
		-- Careful: RN currently depends on this prefix
		table.insert(argsWithFormat, 1, "Warning: " .. format)
		-- We intentionally don't use spread (or .apply) directly because it
		-- breaks IE9: https://github.com/facebook/react/issues/13610
		-- eslint-disable-next-line react-internal/no-production-logging
		console[level](unpack(argsWithFormat))
	end
end

return exports
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="513">
              <Properties>
                <string name="Name">enqueueTask.roblox</string>
                <string name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local setTimeout = LuauPolyfill.setTimeout

return function(task)
	-- deviation: Replace with setImmediate once we create an equivalent polyfill
	return setTimeout(task, 0)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="514">
              <Properties>
                <string name="Name">flowtypes.roblox</string>
                <string name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- built-in flowtypes reverse engineered based on usage and enabling strict type checking on test suites
--!strict
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>
type Object = { [string]: any }
-- duplicated from ReactElementType to avoid circular dep
type Source = {
	fileName: string,
	lineNumber: number,
}

-- ROBLOX deviation: alias for internal React$ flow types
export type React_Node =
	nil
	| boolean
	| number
	| string
	| React_Element<any>
	-- ROBLOX TODO: only include this once it's more specific than `any`
	-- | React_Portal
	| Array<React_Node?>
	-- ROBLOX TODO Luau: this more closely matches the upstream Iterable<>, hypothetically the UNIQUE_TAG field makes it so we don't unify with other tables and squad field resolution
	| { [string]: React_Node?, UNIQUE_TAG: any? }

export type React_Element<ElementType> = {
	type: ElementType,
	props: React_ElementProps<ElementType>?,
	key: React_Key | nil,
	ref: any,
}

export type React_PureComponent<Props, State = nil> = React_Component<Props, State>

export type React_AbstractComponent<Config, T> =
	React_ForwardRefComponent<Config, T>
	| React_MemoComponent<Config, T>

type React_BaseAbstractComponent<Config, T> = {
	["$$typeof"]: number,
	displayName: string?,
	defaultProps: Config?,
	-- not in React flowtype, but is in definitelytyped and is used in ReactElement
	name: string?,
}

-- ROBLOX note: this flowtype built-in is derived from the object shape returned by forwardRef
export type React_ForwardRefComponent<Config, Instance> = React_BaseAbstractComponent<
	Config,
	Instance
> & {
	render: (props: Config, ref: React_Ref<Instance>) -> React_Node,
	-- allows methods to be hung on a component, used in forwardRef.spec regression test we added
	[string]: any,
}

export type React_MemoComponent<Config, T> = React_BaseAbstractComponent<Config, T> & {
	type: React_StatelessFunctionalComponent<Config>,
	compare: ((oldProps: Config, newProps: Config) -> boolean)?,
}

-- ROBLOX TODO: ElementConfig: something like export type React_ElementConfig<React_Component<P>> = P
export type React_ElementConfig<C> = Object

-- ROBLOX deviation: this is a class export upstream, so optional overrides are nil-able, and it's extensible by default
export type React_Component<Props, State = nil> = {
	-- fields
	props: Props,
	state: State,

	-- action methods

	setState: (
		self: React_Component<Props, State>,
		partialState: State | ((State, Props) -> State?),
		callback: (() -> ())?
	) -> (),

	forceUpdate: (self: React_Component<Props, State>, callback: (() -> ())?) -> (),

	-- lifecycle methods

	init: ((
		self: React_Component<Props, State>,
		props: Props,
		context: any?
	) -> ())?,
	render: (self: React_Component<Props, State>) -> React_Node,
	componentWillMount: ((self: React_Component<Props, State>) -> ())?,
	UNSAFE_componentWillMount: ((self: React_Component<Props, State>) -> ())?,
	componentDidMount: ((self: React_Component<Props, State>) -> ())?,
	componentWillReceiveProps: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextContext: any
	) -> ())?,
	UNSAFE_componentWillReceiveProps: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextContext: any
	) -> ())?,
	shouldComponentUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> boolean)?,
	componentWillUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> ())?,
	UNSAFE_componentWillUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> ())?,
	componentDidUpdate: ((
		self: React_Component<Props, State>,
		prevProps: Props,
		prevState: State,
		prevContext: any
	) -> ())?,
	componentWillUnmount: ((self: React_Component<Props, State>) -> ())?,
	componentDidCatch: ((
		self: React_Component<Props, State>,
		error: Error,
		info: {
			componentStack: string,
		}
	) -> ())?,
	getDerivedStateFromProps: ((props: Props, state: State) -> State?)?,
	getDerivedStateFromError: ((error: Error) -> State?)?,
	getSnapshotBeforeUpdate: ((props: Props, state: State) -> any)?,

	-- long tail of other stuff not modeled very well

	-- ROBLOX deviation START: these fields are mostly used internally including in ReactBaseClasses
	__refs: Object,
	__updater: any,
	-- ROBLOX deviation END

	-- ROBLOX deviation: this field is only used in relation to string refs, which we do not support
	-- refs: any,
	context: any,
	getChildContext: (self: React_Component<Props, State>) -> any,
	-- statics
	__componentName: string,
	displayName: string?,
	-- ROBLOX deviation: not in React flowtype, but is in definitelytyped and is used in ReactElement
	name: string?,
	childContextTypes: any?,
	contextTypes: any?,
	propTypes: any?,

	-- ROBLOX FIXME: this is a legacy Roact field and should be removed in React 18 Lua
	validateProps: ((Props) -> (boolean, string?))?,

	-- We don't add a type for `defaultProps` so that its type may be entirely
	-- inferred when we diff the type for `defaultProps` with `Props`. Otherwise
	-- the user would need to define a type (which would be redundant) to override
	-- the type we provide here in the base class.
	-- ROBLOX deviation: Luau doesn't do the inference above
	defaultProps: Props?,
	-- ROBLOX deviation: class export allows assigning additional custom instance fields
	[string]: any,
}

-- ROBLOX deviation: Lua doesn't allow fields on functions, and we haven't implemented callable tables as "function" components
export type React_StatelessFunctionalComponent<Props> = (
	props: Props,
	context: any
) -> React_Node
export type React_ComponentType<Config> = React_Component<Config, any>

export type React_ElementType = string | React_Component<any, any>

-- This was reverse engineered from usage, no specific flowtype or TS artifact
export type React_ElementProps<ElementType> = {
	ref: React_Ref<ElementType>?,
	key: React_Key?,
	__source: Source?,
	children: any?,
}

-- ROBLOX deviation: this is a built-in flow type, and very complex. we fudge this with `any`
-- type ElementRef<
--   C extends keyof JSX.IntrinsicElements
--   | React.ForwardRefExoticComponent<any>
--   | (new (props: any) -> React.Component<any, {}, any>)
--   | ((props: any, context?: any) -> ReactElement | null)
--   > = "ref" extends keyof ComponentPropsWithRef<C>
--     ? NonNullable<ComponentPropsWithRef<C>["ref"]> extends Ref<infer Instance>
--       ? Instance
--       : never
--     : never

-- ROBLOX TODO: Not sure how to model this, upstream: https://github.com/facebook/flow/blob/main/tests/react_instance/class.js#L10
-- ROBLOX FIXME Luau: if I make this Object, we run into normalization issues: '{| current: React_ElementRef<any>? |}' could not be converted into '(((?) -> any) | {| current: ? |})?
export type React_ElementRef<C> = C

export type React_Ref<ElementType> =
	{ current: React_ElementRef<ElementType> | nil }
	| ((React_ElementRef<ElementType> | nil) -> ())
-- ROBLOX deviation: we don't support string refs, and this is unsound flowtype when used with ref param of useImperativeHandle
-- | string

export type React_Context<T> = {
	Provider: React_ComponentType<{ value: T, children: React_Node? }>,
	Consumer: React_ComponentType<{ children: (value: T) -> React_Node? }>,
}

-- ROBLOX TODO: declared as an opaque type in flowtype: https://github.com/facebook/flow/blob/422821fd42c09c3ef609c60516fe754b601ea205/lib/react.js#L182
export type React_Portal = any
export type React_Key = string | number

return {}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="515">
              <Properties>
                <string name="Name">formatProdErrorMessage</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/75955bf1d7ff6c2c1f4052f4a84dd2ce6944c62e/packages/shared/formatProdErrorMessage.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]

-- Do not require this module directly! Use normal `invariant` calls with
-- template literal strings. The messages will be replaced with error codes
-- during build.

local HttpService = game:GetService("HttpService")

local function formatProdErrorMessage(code, ...)
	local url = "https://reactjs.org/docs/error-decoder.html?invariant=" .. tostring(code)
	local argsLength = select("#", ...)
	for i = 1, argsLength, 1 do
		-- deviation: UrlEncode should be equivalent to encodeURIComponent
		url = url .. "&args[]=" .. HttpService:UrlEncode(select(i, ...))
	end
	return string.format(
		"Minified React error #%d; visit %s for the full message or "
			.. "use the non-minified dev environment for full errors and additional "
			.. "helpful warnings.",
		code,
		url
	)
end

return formatProdErrorMessage
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="516">
              <Properties>
                <string name="Name">getComponentName</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/a774502e0ff2a82e3c0a3102534dbc3f1406e5ea/packages/shared/getComponentName.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]
type Function = (...any) -> ...any
local console = require(script.Parent.console)

-- ROBLOX deviation: inline this typedef to avoid upstream's circular dependency
type LazyComponent<T, P> = {
	["$$typeof"]: number,
	_payload: P,
	_init: (payload: P) -> T,
}

local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local ReactTypes = require(script.Parent.ReactTypes)
type ReactContext<T> = ReactTypes.ReactContext<T>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>

local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

local function getWrappedName(outerType: any, innerType: any, wrapperName: string): string
	-- deviation: Account for indexing into function
	local functionName = "<function>"
	if typeof(innerType) == "table" then
		functionName = innerType.displayName or innerType.name or ""
	end
	return outerType.displayName
		or (
			functionName ~= "" and string.format("%s(%s)", wrapperName, functionName)
			or wrapperName
		)
end

local function getContextName(type: ReactContext<any>): string
	return type.displayName or "Context"
end

local function getComponentName(type: any): string | nil
	if type == nil then
		-- Host root, text node or just invalid type.
		return nil
	end
	local typeofType = typeof(type)

	if _G.__DEV__ then
		if typeofType == "table" and typeof(type.tag) == "number" then
			console.warn(
				"Received an unexpected object in getComponentName(). "
					.. "This is likely a bug in React. Please file an issue."
			)
		end
	end

	if typeofType == "function" then
		-- ROBLOX deviation: we can't deref functions in Lua, so get the name of the function and move logic to table section
		-- ROBLOX FIXME Luau: this line gets a bunch of bizarre errors in strict mode
		local name = debug.info((type :: any) :: Function, "n")
		-- ROBLOX deviaton:when name = (null) we want it to be treated as nil, not as an empty (truthy) string
		if name and string.len(name) > 0 then
			return name
		else
			local fileName, line = debug.info((type :: any) :: Function, "sl")
			return string.format("%s:%d", fileName, line)
		end
	end

	if typeofType == "string" then
		return (type :: any) :: string
	end

	if type == REACT_FRAGMENT_TYPE then
		return "Fragment"
	elseif type == REACT_PORTAL_TYPE then
		return "Portal"
	elseif type == REACT_PROFILER_TYPE then
		return "Profiler"
	elseif type == REACT_STRICT_MODE_TYPE then
		return "StrictMode"
	elseif type == REACT_SUSPENSE_TYPE then
		return "Suspense"
	elseif type == REACT_SUSPENSE_LIST_TYPE then
		return "SuspenseList"
	end

	if typeofType == "table" then
		local typeProp = type["$$typeof"]
		if typeProp == REACT_CONTEXT_TYPE then
			local context: ReactContext<any> = type :: any
			return getContextName(context) .. ".Consumer"
		elseif typeProp == REACT_PROVIDER_TYPE then
			local provider: ReactProviderType<any> = type :: any
			return getContextName(provider._context) .. ".Provider"
		elseif typeProp == REACT_FORWARD_REF_TYPE then
			return getWrappedName(type, type.render, "ForwardRef")
		elseif typeProp == REACT_MEMO_TYPE then
			return getComponentName(type.type)
		elseif typeProp == REACT_BLOCK_TYPE then
			return getComponentName(type._render)
		elseif typeProp == REACT_LAZY_TYPE then
			local lazyComponent: LazyComponent<any, any> = type :: any
			local payload = lazyComponent._payload
			local init = lazyComponent._init

			-- ROBLOX performance: getComponentName won't throw, but init() might, extract it out to eliminate an anon function
			local ok, result = xpcall(init, describeError, payload)
			if ok then
				return getComponentName(result)
			else
				return nil
			end
		else
			-- ROBLOX deviation: Normally, the `typeofType == "function"` check would
			-- cover this case, but in Lua, class components are tables. We need
			-- to check for that here and use the name the component was
			-- assigned.
			if type.displayName then
				return type.displayName
			end
			if type.name then
				return type.name
			end
			-- ROBLOX note: only use tostring() if its overridden to avoid "table: 0xabcd9012"
			local mt = getmetatable(type)
			if mt and rawget(mt, "__tostring") then
				return tostring(type)
			end
		end
	end

	return nil
end

return getComponentName
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="517">
              <Properties>
                <string name="Name">invariant</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/42c3c967d1e4ca4731b47866f2090bc34caa086c/packages/shared/invariant.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
]]

--[[*
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local function invariant(condition, format, ...)
	-- ROBLOX TODO: we should encapsulate all formatting compatibility here,
	-- rather than spreading workarounds throughout the codebase, eg this
	-- should print an array without the need for a table.concat on the consumer side
	if not condition then
		error(Error(string.format(format, ...)))
	end
end

return invariant
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="518">
              <Properties>
                <string name="Name">invokeGuardedCallbackImpl</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/shared/invokeGuardedCallbackImpl.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
-- local invariant = require(script.Parent.invariant)
local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

-- deviation: with flow types stripped, it's easier to use varargs directly
local function invokeGuardedCallbackProd(reporter, name, func, context, ...)
	-- local funcArgs = Array.prototype.slice.call(arguments, 3)

	-- ROBLOX deviation: YOLO flag for disabling pcall
	local ok, result
	if not _G.__YOLO__ then
		-- deviation: Since functions in lua _explicitly_ accept 'self' as a
		-- first argument when they use it, it becomes incorrect for us to call
		-- a function with a nil "context", where context in this case is
		-- analogous to the implicit `self` that we get with a `:` call
		if context == nil then
			ok, result = xpcall(func, describeError, ...)
		else
			ok, result = xpcall(func, describeError, context, ...)
		end
	else
		ok = true
		if context == nil then
			func(...)
		else
			func(context, ...)
		end
	end

	if not ok then
		-- deviation: functions have no notion of "this"/"self", so we expect
		-- the first argument to be the reporter itself, in conjunction with
		-- deviations in `ReactErrorUtils`
		reporter.onError(result)
	end
end

local invokeGuardedCallbackImpl = invokeGuardedCallbackProd

if _G.__DEV__ then
	-- In DEV mode, we swap out invokeGuardedCallback for a special version
	-- that plays more nicely with the browser's DevTools. The idea is to preserve
	-- "Pause on exceptions" behavior. Because React wraps all user-provided
	-- functions in invokeGuardedCallback, and the production version of
	-- invokeGuardedCallback uses a try-catch, all user exceptions are treated
	-- like caught exceptions, and the DevTools won't pause unless the developer
	-- takes the extra step of enabling pause on caught exceptions. This is
	-- unintuitive, though, because even though React has caught the error, from
	-- the developer's perspective, the error is uncaught.
	--
	-- To preserve the expected "Pause on exceptions" behavior, we don't use a
	-- try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
	-- DOM node, and call the user-provided callback from inside an event handler
	-- for that fake event. If the callback throws, the error is "captured" using
	-- a global event handler. But because the error happens in a different
	-- event loop context, it does not interrupt the normal program flow.
	-- Effectively, this gives us try-catch behavior without actually using
	-- try-catch. Neat!
	-- Check that the browser supports the APIs we need to implement our special
	-- DEV version of invokeGuardedCallback

	-- deviation: `window` is not defined in our environment
	-- deviation: FIXME: should we define our own impl for invokeGuardedCallbackDev?
	--[[
	if typeof window ~= 'undefined' and typeof window.dispatchEvent == 'function' and typeof document ~= 'undefined' and typeof document.createEvent == 'function' then
		local fakeNode = document.createElement('react')

		invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
			-- If document doesn't exist we know for sure we will crash in this method
			-- when we call document.createEvent(). However this can cause confusing
			-- errors: https://github.com/facebookincubator/create-react-app/issues/3482
			-- So we preemptively throw with a better message instead.
			invariant(typeof document ~= 'undefined', 'The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.')
			local evt = document.createEvent('Event')
			local didCall = false; -- Keeps track of whether the user-provided callback threw an error. We
			-- set this to true at the beginning, then set it to false right after
			-- calling the function. If the function errors, `didError` will never be
			-- set to false. This strategy works even if the browser is flaky and
			-- fails to call our global error handler, because it doesn't rely on
			-- the error event at all.

			local didError = true; -- Keeps track of the value of window.event so that we can reset it
			-- during the callback to local user code access window.event in the
			-- browsers that support it.

			local windowEvent = window.event; -- Keeps track of the descriptor of window.event to restore it after event
			-- dispatching: https://github.com/facebook/react/issues/13688

			local windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event')

			function restoreAfterDispatch() {
				-- We immediately remove the callback from event listeners so that
				-- nested `invokeGuardedCallback` calls do not clash. Otherwise, a
				-- nested call would trigger the fake event handlers of any call higher
				-- in the stack.
				fakeNode.removeEventListener(evtType, callCallback, false); -- We check for window.hasOwnProperty('event') to prevent the
				-- window.event assignment in both IE <= 10 as they throw an error
				-- "Member not found" in strict mode, and in Firefox which does not
				-- support window.event.

				if typeof window.event ~= 'undefined' and window.hasOwnProperty('event') then
					window.event = windowEvent
				}
			} -- Create an event handler for our fake event. We will synchronously
			-- dispatch our fake event using `dispatchEvent`. Inside the handler, we
			-- call the user-provided callback.


			local funcArgs = Array.prototype.slice.call(arguments, 3)

			function callCallback() {
				didCall = true
				restoreAfterDispatch()
				func.apply(context, funcArgs)
				didError = false
			} -- Create a global error event handler. We use this to capture the value
			-- that was thrown. It's possible that this error handler will fire more
			-- than once; for example, if non-React code also calls `dispatchEvent`
			-- and a handler for that event throws. We should be resilient to most of
			-- those cases. Even if our error event handler fires more than once, the
			-- last error event is always used. If the callback actually does error,
			-- we know that the last error event is the correct one, because it's not
			-- possible for anything else to have happened in between our callback
			-- erroring and the code that follows the `dispatchEvent` call below. If
			-- the callback doesn't error, but the error event was fired, we know to
			-- ignore it because `didError` will be false, as described above.


			local error; -- Use this to track whether the error event is ever called.

			local didSetError = false
			local isCrossOriginError = false

			function handleWindowError(event) {
				error = event.error
				didSetError = true

				if error == nil and event.colno == 0 and event.lineno == 0 then
					isCrossOriginError = true
				}

				if event.defaultPrevented then
					-- Some other error handler has prevented default.
					-- Browsers silence the error report if this happens.
					-- We'll remember this to later decide whether to log it or not.
					if error ~= nil and typeof error == 'object' then
						try {
							error._suppressLogging = true
						} catch (inner) {-- Ignore.
						}
					}
				}
			} -- Create a fake event type.


			local evtType = `react-${function () {
				if name then
					return name
				}

				return 'invokeguardedcallback'
			}()}`; -- Attach our event handlers

			window.addEventListener('error', handleWindowError)
			fakeNode.addEventListener(evtType, callCallback, false); -- Synchronously dispatch our fake event. If the user-provided function
			-- errors, it will trigger our global error handler.

			evt.initEvent(evtType, false, false)
			fakeNode.dispatchEvent(evt)

			if windowEventDescriptor then
				Object.defineProperty(window, 'event', windowEventDescriptor)
			}

			if didCall and didError then
				if !didSetError then
					-- The callback errored, but the error event never fired.
					error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.')
				} else if isCrossOriginError then
					error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.')
				}

				this.onError(error)
			} -- Remove our event listeners


			window.removeEventListener('error', handleWindowError)

			if !didCall then
				-- Something went really wrong, and our event was not dispatched.
				-- https://github.com/facebook/react/issues/16734
				-- https://github.com/facebook/react/issues/16585
				-- Fall back to the production implementation.
				restoreAfterDispatch()
				return invokeGuardedCallbackProd.apply(this, arguments)
			}
		}
	}
]]
end

return invokeGuardedCallbackImpl
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="519">
              <Properties>
                <string name="Name">isValidElementType</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/b61174fb7b09580c1ec2a8f55e73204b706d2935/packages/shared/isValidElementType.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 ]]
local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_DEBUG_TRACING_MODE_TYPE = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
-- local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_FUNDAMENTAL_TYPE = ReactSymbols.REACT_FUNDAMENTAL_TYPE
-- local REACT_SCOPE_TYPE = ReactSymbols.REACT_SCOPE_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local REACT_SERVER_BLOCK_TYPE = ReactSymbols.REACT_SERVER_BLOCK_TYPE
local REACT_LEGACY_HIDDEN_TYPE = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE

-- local ReactFeatureFlags = require(script.Parent.ReactFeatureFlags)
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI

return function(type)
	local typeofType = typeof(type)
	if typeofType == "string" or typeofType == "function" then
		return true
	end

	-- Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
	if
		type == REACT_FRAGMENT_TYPE
		or type == REACT_PROFILER_TYPE
		or type == REACT_DEBUG_TRACING_MODE_TYPE
		or type == REACT_STRICT_MODE_TYPE
		or type == REACT_SUSPENSE_TYPE
		or type == REACT_LEGACY_HIDDEN_TYPE
		-- ROBLOX performance: eliminate compares that will only be true in React 18
		-- or type == REACT_SUSPENSE_LIST_TYPE
		-- or (enableScopeAPI and type == REACT_SCOPE_TYPE)
	then
		return true
	end

	if typeofType == "table" then
		-- ROBLOX deviation: In React, component classes are of type 'function'; for
		-- us, they're tables with a special value on their metatable
		if type.isReactComponent then
			return true
		end

		if
			type["$$typeof"] == REACT_LAZY_TYPE
			or type["$$typeof"] == REACT_MEMO_TYPE
			or type["$$typeof"] == REACT_PROVIDER_TYPE
			or type["$$typeof"] == REACT_CONTEXT_TYPE
			or type["$$typeof"] == REACT_FORWARD_REF_TYPE
			or type["$$typeof"] == REACT_FUNDAMENTAL_TYPE
			or type["$$typeof"] == REACT_BLOCK_TYPE
			or type[1] == REACT_SERVER_BLOCK_TYPE
		then
			return true
		end
	end

	return false
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="520">
              <Properties>
                <string name="Name">objectIs</string>
                <string name="Source"><![CDATA[--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/6faf6f5eb1705eef39a1d762d6ee381930f36775/packages/shared/objectIs.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

--[[*
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 ]]
local function is(x: any, y: any): boolean
	return x == y and (x ~= 0 or 1 / x == 1 / y) or x ~= x and y ~= y -- eslint-disable-line no-self-compare
end

-- deviation: Object isn't a global in lua, so `Object.is` will never exist
local objectIs = is

return objectIs
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="521">
              <Properties>
                <string name="Name">shallowEqual</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/react/blob/a9b035b0c2b8235405835beca0c4db2cc37f18d0/packages/shared/shallowEqual.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
]]
local is = require(script.Parent.objectIs)

--[[*
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
]]
local function shallowEqual(objA, objB)
	if is(objA, objB) then
		return true
	end

	if
		typeof(objA) ~= "table"
		or objA == nil
		or typeof(objB) ~= "table"
		or objB == nil
	then
		return false
	end

	-- deviation: `Object.keys` does not have an equivalent in Lua, so we
	-- iterate through each table instead
	for key, value in objA do
		if not is(objB[key], value) then
			return false
		end
	end

	for key, value in objB do
		if not is(objA[key], value) then
			return false
		end
	end

	return true
end

return shallowEqual
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="522">
            <Properties>
              <string name="Name">String</string>
              <string name="Source"><![CDATA[return {
	charCodeAt = require(script.charCodeAt),
	endsWith = require(script.endsWith),
	findOr = require(script.findOr),
	includes = require(script.includes),
	indexOf = require(script.indexOf),
	lastIndexOf = require(script.lastIndexOf),
	slice = require(script.slice),
	split = require(script.split),
	startsWith = require(script.startsWith),
	substr = require(script.substr),
	trim = require(script.trim),
	trimEnd = require(script.trimEnd),
	trimStart = require(script.trimStart),
	-- aliases for trimEnd and trimStart
	trimRight = require(script.trimEnd),
	trimLeft = require(script.trimStart),
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="523">
              <Properties>
                <string name="Name">charCodeAt</string>
                <string name="Source"><![CDATA[--!strict
local String = script.Parent
local Packages = String.Parent
local Number = require(Packages.Number)

local NaN = Number.NaN

-- js  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
-- lua http://www.lua.org/manual/5.4/manual.html#pdf-utf8.codepoint
return function(str: string, index: number): number
	if type(index) ~= "number" then
		index = 1
	end
	--[[
		Initial bounds check. Checking string.len is not an exhaustive upper bound,
		but it is cheaper to check string.len and handle utf8.offset than to check
		utf.len, which iterates over all codepoints.
	]]
	local length = string.len(str)
	if index < 1 or index > length then
		return NaN
	end

	-- utf8.offset returns nil for out of bounds
	local offset = utf8.offset(str, index)

	-- check that offset is not greater than the length of the string
	if offset == nil or offset > length then
		return NaN
	end

	local value = utf8.codepoint(str, offset, offset)

	if value == nil then
		return NaN
	end

	return value
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="524">
              <Properties>
                <string name="Name">endsWith</string>
                <string name="Source"><![CDATA[--!strict
local function endsWith(value: string, substring: string, optionalLength: number?): boolean
	local substringLength = substring:len()
	if substringLength == 0 then
		return true
	end
	local valueLength = value:len()
	local length = optionalLength or valueLength
	if length > valueLength then
		length = valueLength
	end
	if length < 1 then
		return false
	end
	local position = length - substringLength + 1
	return value:find(substring, position, true) == position
end

return endsWith
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="525">
              <Properties>
                <string name="Name">findOr</string>
                <string name="Source"><![CDATA[--!strict
type Match = {
	index: number,
	match: string,
}

-- excluding the `+` and `*` character, since findOr tests and graphql use them explicitly
local luaPatternCharacters = "([" .. ("$%^()-[].?"):gsub("(.)", "%%%1") .. "])"

local function findOr(str: string, patternTable: { string }, initIndex: number?): Match | nil
	-- loop through all options in patern patternTable

	local init = utf8.offset(str, initIndex or 1)
	local matches = {}
	for _, value in patternTable do
		value = value:gsub(luaPatternCharacters, "%%%1")
		local iStart, iEnd = string.find(str, value, init)
		if iStart then
			local prefix = string.sub(str, 1, iStart - 1)
			local prefixEnd, invalidBytePosition = utf8.len(prefix)
			if prefixEnd == nil then
				error(("string `%s` has an invalid byte at position %s"):format(prefix, tostring(invalidBytePosition)))
			end
			local iStartIndex = prefixEnd :: number + 1
			local match = {
				index = iStartIndex,
				match = string.sub(str, iStart, iEnd),
			}
			table.insert(matches, match)
		end
	end

	-- if no matches, return nil
	if #matches == 0 then
		return nil
	end

	-- find the first matched index (after the init param)
	-- for each, if we get a hit, return the earliest index and matched term

	local firstMatch
	for _, value in matches do
		-- load first condition
		if firstMatch == nil then
			firstMatch = value
		end
		-- identify if current match comes before first match
		if value.index < firstMatch.index then
			firstMatch = value
		end
	end

	-- return first match
	return firstMatch
end

return findOr
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="526">
              <Properties>
                <string name="Name">includes</string>
                <string name="Source"><![CDATA[--!strict

-- excluding the `+` and `*` character, since findOr tests and graphql use them explicitly
local luaPatternCharacters = "([" .. ("$%^()-[].?"):gsub("(.)", "%%%1") .. "])"

local function includes(str: string, substring: string, position: (string | number)?): boolean
	local strLen, invalidBytePosition = utf8.len(str)
	assert(strLen ~= nil, ("string `%s` has an invalid byte at position %s"):format(str, tostring(invalidBytePosition)))
	if strLen == 0 then
		return false
	end

	if #substring == 0 then
		return true
	end

	local startIndex = 1
	if position ~= nil then
		startIndex = tonumber(position) or 1
		if startIndex > strLen then
			return false
		end
	end

	if startIndex < 1 then
		startIndex = 1
	end

	local init = utf8.offset(str, startIndex)
	local value = substring:gsub(luaPatternCharacters, "%%%1")
	local iStart, _ = string.find(str, value, init)
	return iStart ~= nil
end

return includes
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="527">
              <Properties>
                <string name="Name">indexOf</string>
                <string name="Source"><![CDATA[--!strict

-- excluding the `+` and `*` character, since findOr tests and graphql use them explicitly
local luaPatternCharacters = "([" .. ("$%^()-[].?"):gsub("(.)", "%%%1") .. "])"

-- Implements equivalent functionality to JavaScript's `String.indexOf`,
-- implementing the interface and behaviors defined at:
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf
return function(str: string, searchElement: string, fromIndex: number?): number
	local length = #str
	local fromIndex_ = if fromIndex ~= nil then if fromIndex < 1 then 1 else fromIndex :: number else 1

	if #searchElement == 0 then
		return if fromIndex_ > length then length else fromIndex_
	end

	if fromIndex_ > length then
		return -1
	end

	searchElement = searchElement:gsub(luaPatternCharacters, "%%%1")
	local searchElementLength = #searchElement

	for i = fromIndex_, length do
		if string.sub(str, i, i + searchElementLength - 1) == searchElement then
			return i
		end
	end

	return -1
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="528">
              <Properties>
                <string name="Name">lastIndexOf</string>
                <string name="Source"><![CDATA[--!strict
local function lastIndexOf(str: string, searchValue: string, fromIndex: number?): number
	local strLength = string.len(str)
	local calculatedFromIndex
	if fromIndex then
		calculatedFromIndex = fromIndex
	else
		calculatedFromIndex = strLength
	end
	if fromIndex and fromIndex < 1 then
		calculatedFromIndex = 1
	end
	if fromIndex and fromIndex > strLength then
		calculatedFromIndex = strLength
	end
	if searchValue == "" then
		-- FIXME: Luau DFA doesn't understand that
		return calculatedFromIndex :: number
	end

	local lastFoundStartIndex, foundStartIndex
	-- Luau FIXME: Luau doesn't look beyond assignment for type, it should infer number? from loop bound
	local foundEndIndex: number? = 0
	repeat
		lastFoundStartIndex = foundStartIndex
		-- Luau FIXME: DFA doesn't understand until clause means foundEndIndex is never nil within loop
		foundStartIndex, foundEndIndex = string.find(str, searchValue, foundEndIndex :: number + 1, true)
	until foundStartIndex == nil or foundStartIndex > calculatedFromIndex

	if lastFoundStartIndex == nil then
		return -1
	end
	-- Luau FIXME: Luau should see the predicate above and known the line below can only be a number
	return lastFoundStartIndex :: number
end

return lastIndexOf
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="529">
              <Properties>
                <string name="Name">slice</string>
                <string name="Source"><![CDATA[--!strict
local function slice(str: string, startIndexStr: string | number, lastIndexStr: (string | number)?): string
	local strLen, invalidBytePosition = utf8.len(str)
	assert(strLen ~= nil, ("string `%s` has an invalid byte at position %s"):format(str, tostring(invalidBytePosition)))
	local startIndex = tonumber(startIndexStr)
	assert(typeof(startIndex) == "number", "startIndexStr should be a number")

	if startIndex + strLen < 0 then
		-- then |start index| is greater than string length
		startIndex = 1
	end

	if startIndex > strLen then
		return ""
	end

	-- if no last index length set, go to str length + 1
	local lastIndex = strLen + 1
	if lastIndexStr ~= nil then
		-- ROBLOX FIXME: add parseInt to encapsulate this logic and use it here
		local NaN = 0 / 0
		lastIndex = tonumber(lastIndexStr) or NaN -- this works because 0 is truthy in Lua
	end
	assert(typeof(lastIndex) == "number", "lastIndexStr should convert to number")

	if lastIndex > strLen then
		lastIndex = strLen + 1
	end

	local startIndexByte = utf8.offset(str, startIndex)
	-- get char length of charset retunred at offset
	local lastIndexByte = utf8.offset(str, lastIndex) - 1

	return string.sub(str, startIndexByte, lastIndexByte)
end

return slice
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="530">
              <Properties>
                <string name="Name">split</string>
                <string name="Source"><![CDATA[--!strict
local String = script.Parent
local findOr = require(String.findOr)
local slice = require(String.slice)

local Packages = String.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local MAX_SAFE_INTEGER = require(Packages.Number).MAX_SAFE_INTEGER

type Pattern = string | Array<string>

local function split(str: string, _pattern: Pattern?, _limit: number?): Array<string>
	if _pattern == nil then
		return { str }
	end
	if _limit == 0 then
		return {}
	end
	local limit = if _limit == nil or _limit < 0 then MAX_SAFE_INTEGER else _limit
	local pattern = _pattern
	local patternList: Array<string>
	if typeof(pattern) == "string" then
		if pattern == "" then
			local result = {}
			for c in str:gmatch(".") do
				table.insert(result, c)
			end
			return result
		end
		patternList = { pattern }
	else
		patternList = pattern :: Array<string>
	end
	local init = 1
	local result = {}
	local lastMatch
	local strLen, invalidBytePosition = utf8.len(str)
	assert(strLen ~= nil, ("string `%s` has an invalid byte at position %s"):format(str, tostring(invalidBytePosition)))

	repeat
		local match = findOr(str, patternList, init)
		if match ~= nil then
			table.insert(result, slice(str, init, match.index))
			local matchLength = utf8.len(match.match)
			-- Luau FIXME? Luau doesn't understand that str has already been shown to be valid utf8 on line 26 and therefore won't be nil
			init = match.index + matchLength :: number
		else
			table.insert(result, slice(str, init, nil))
		end
		if match ~= nil then
			lastMatch = match
		end
	until match == nil or init > strLen or #result >= limit
	if lastMatch ~= nil then
		local lastMatchLength, invalidBytePosition_ = utf8.len(lastMatch.match)
		assert(
			lastMatchLength ~= nil,
			("string `%s` has an invalid byte at position %s"):format(lastMatch.match, tostring(invalidBytePosition_))
		)
		if lastMatch.index + lastMatchLength == strLen + 1 then
			table.insert(result, "")
		end
	end
	return result
end

return split
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="531">
              <Properties>
                <string name="Name">startsWith</string>
                <string name="Source"><![CDATA[--!strict
local function startsWith(value: string, substring: string, position: number?): boolean
	if string.len(substring) == 0 then
		return true
	end
	-- Luau FIXME: we have to use a tmp variable, as Luau doesn't understand the logic below narrow position to `number`
	local position_
	if position == nil or position < 1 then
		position_ = 1
	else
		position_ = position
	end

	if position_ > string.len(value) then
		return false
	end
	return value:find(substring, position_, true) == position_
end

return startsWith
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="532">
              <Properties>
                <string name="Name">substr</string>
                <string name="Source"><![CDATA[--!strict
return function(s: string, startIndex: number, numberOfCharacters: number?): string
	if numberOfCharacters and numberOfCharacters <= 0 then
		return ""
	end
	return string.sub(s, startIndex, numberOfCharacters and startIndex + numberOfCharacters - 1 or nil)
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="533">
              <Properties>
                <string name="Name">trim</string>
                <string name="Source"><![CDATA[--!strict

local trimStart = require(script.Parent.trimStart)
local trimEnd = require(script.Parent.trimEnd)

return function(source: string): string
	return trimStart(trimEnd(source))
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="534">
              <Properties>
                <string name="Name">trimEnd</string>
                <string name="Source"><![CDATA[--!strict
return function(source: string): string
	return (source:gsub("[%s]+$", ""))
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="535">
              <Properties>
                <string name="Name">trimStart</string>
                <string name="Source"><![CDATA[--!strict
return function(source: string): string
	return (source:gsub("^[%s]+", ""))
end
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="536">
            <Properties>
              <string name="Name">Symbol</string>
              <string name="Source"><![CDATA[--!strict
--[[
	A 'Symbol' is an opaque marker type, implemented to behave similarly to JS:
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
]]
local Symbol = require(script.Symbol)
export type Symbol = Symbol.Symbol
local GlobalRegistry = require(script["Registry.global"])

local SymbolObject = setmetatable({}, {
	--[[
		Creates a new symbol, using the given name when printed. Symbols are
		opaque, so this will always create a new, unique object
	]]
	__call = function(_, name: string?): Symbol.Symbol
		return Symbol.new(name)
	end,
})

SymbolObject.for_ = GlobalRegistry.getOrInit

return SymbolObject
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="537">
              <Properties>
                <string name="Name">Registry.global</string>
                <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local GlobalRegistry: { [string]: Symbol.Symbol } = {}

return {
	getOrInit = function(name: string): Symbol.Symbol
		if GlobalRegistry[name] == nil then
			GlobalRegistry[name] = Symbol.new(name)
		end

		return GlobalRegistry[name]
	end,
	-- Used for testing
	__clear = function()
		GlobalRegistry = {}
	end,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="538">
              <Properties>
                <string name="Name">Symbol</string>
                <string name="Source"><![CDATA[--!strict
--[[
	Symbols have the type 'userdata', but when printed or coerced to a string,
	the symbol will turn into the string given as its name.

	**This implementation provides only the `Symbol()` constructor and the
	global registry via `Symbol.for_`.**

	Other behaviors, including the ability to find all symbol properties on
	objects, are not implemented.
]]
export type Symbol = typeof(newproxy(true)) & { [string]: any }

return {
	new = function(name: string?): Symbol
		local self = newproxy(true) :: any

		local wrappedName = "Symbol()"
		if name then
			wrappedName = ("Symbol(%s)"):format(name)
		end

		getmetatable(self).__tostring = function()
			return wrappedName
		end

		return (self :: any) :: Symbol
	end,
}
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="539">
            <Properties>
              <string name="Name">TestUtils</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/test-utils/src/index.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script

local alignedAnsiStyleSerializer = require(CurrentModule.alignedAnsiStyleSerializer)
local configModule = require(CurrentModule.config)

--[[
	ROBLOX deviation: ommiting ConditionalTest and config imports
	original code:
	export {
	  isJestJasmineRun,
	  skipSuiteOnJasmine,
	  skipSuiteOnJestCircus,
	  onNodeVersions,
	} from './ConditionalTest';

	export {makeGlobalConfig, makeProjectConfig} from './config';
]]

return {
	alignedAnsiStyleSerializer = alignedAnsiStyleSerializer,
	makeGlobalConfig = configModule.makeGlobalConfig,
	makeProjectConfig = configModule.makeProjectConfig,
}
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="540">
              <Properties>
                <string name="Name">alignedAnsiStyleSerializer</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/test-utils/src/alignedAnsiStyleSerializer.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local ansiRegex = require(Packages.PrettyFormat).plugins.ConvertAnsi.ansiRegex
-- ROBLOX deviation: imported chalk instead of ansi-styles
local chalk = require(Packages.ChalkLua)
-- ROBLOX deviation: omitting prettyFormat import

local function serialize(val: string): string
	-- Return the string itself, not escaped nor enclosed in double quote marks.
	local ansiLookupTable = {
		[chalk.inverse.open] = "<i>",
		[chalk.inverse.close] = "</i>",
		[chalk.bold.open] = "<b>",
		[chalk.dim.open] = "<d>",
		[chalk.green.open] = "<g>",
		[chalk.red.open] = "<r>",
		[chalk.yellow.open] = "<y>",
		[chalk.bgYellow.open] = "<Y>",
		[chalk.bold.close] = "</>",
		[chalk.dim.close] = "</>",
		[chalk.green.close] = "</>",
		[chalk.red.close] = "</>",
		[chalk.yellow.close] = "</>",
		[chalk.bgYellow.close] = "</>",
	}

	return val:gsub(ansiRegex, function(match)
		if ansiLookupTable[match] then
			return ansiLookupTable[match]
		else
			return match
		end
	end)
end

local function test(val: any)
	return typeof(val) == "string"
end

return {
	serialize = serialize,
	test = test,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="541">
              <Properties>
                <string name="Name">config</string>
                <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/facebook/jest/blob/v28.0.0/packages/test-utils/src/config.ts
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */
local CurrentModule = script.Parent
local Packages = CurrentModule.Parent

local jestTypesModule = require(Packages.JestTypes)

type Config_GlobalConfig = jestTypesModule.Config_GlobalConfig
type Config_ProjectConfig = jestTypesModule.Config_ProjectConfig

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local inspect = LuauPolyfill.util.inspect
local Set = LuauPolyfill.Set

local exports = {}

local DEFAULT_GLOBAL_CONFIG: Config_GlobalConfig = {
	bail = 0,
	changedFilesWithAncestor = false,
	changedSince = "",
	ci = false,
	collectCoverage = false,
	collectCoverageFrom = {},
	collectCoverageOnlyFrom = Object.None,
	coverageDirectory = "coverage",
	coverageProvider = "babel",
	coverageReporters = {},
	coverageThreshold = { global = {} },
	detectLeaks = false,
	detectOpenHandles = false,
	errorOnDeprecated = false,
	expand = false,
	filter = Object.None,
	findRelatedTests = false,
	forceExit = false,
	globalSetup = Object.None,
	globalTeardown = Object.None,
	json = false,
	lastCommit = false,
	listTests = false,
	logHeapUsage = false,
	maxConcurrency = 5,
	maxWorkers = 2,
	noSCM = Object.None,
	noStackTrace = false,
	nonFlagArgs = {},
	notify = false,
	notifyMode = "failure-change",
	onlyChanged = false,
	onlyFailures = false,
	outputFile = Object.None,
	passWithNoTests = false,
	projects = {},
	replname = Object.None,
	reporters = {},
	rootDir = "/test_root_dir/" :: any,
	runTestsByPath = false,
	silent = false,
	skipFilter = false,
	snapshotFormat = {},
	testFailureExitCode = 1,
	testNamePattern = "",
	testPathPattern = "",
	testResultsProcessor = Object.None,
	testSequencer = "@jest/test-sequencer",
	testTimeout = 5000,
	updateSnapshot = "none",
	useStderr = false,
	verbose = false,
	watch = false,
	watchAll = false,
	watchPlugins = {},
	watchman = false,
}

local DEFAULT_PROJECT_CONFIG: Config_ProjectConfig = {
	automock = false,
	cache = false,
	-- ROBLOX deviation START: caching not supported
	-- cacheDirectory = "/test_cache_dir/",
	-- ROBLOX deviation END
	clearMocks = false,
	coveragePathIgnorePatterns = {},
	cwd = "/test_root_dir/",
	detectLeaks = false,
	detectOpenHandles = false,
	displayName = Object.None,
	errorOnDeprecated = false,
	extensionsToTreatAsEsm = {},
	fakeTimers = { enableGlobally = false },
	filter = Object.None,
	forceCoverageMatch = {},
	globalSetup = Object.None,
	globalTeardown = Object.None,
	globals = {},
	haste = {},
	id = "test_name",
	injectGlobals = true,
	moduleDirectories = {},
	moduleFileExtensions = { "js" },
	moduleNameMapper = {},
	modulePathIgnorePatterns = {},
	modulePaths = {},
	-- ROBLOX deviation: mock data model
	mockDataModel = false,
	-- ROBLOX deviation: inject alike types
	oldFunctionSpying = true,
	prettierPath = "prettier",
	resetMocks = false,
	resetModules = false,
	resolver = Object.None,
	restoreMocks = false,
	rootDir = "/test_root_dir/" :: any,
	roots = {},
	runner = "jest-runner",
	runtime = "/test_module_loader_path",
	sandboxInjectedGlobals = {},
	setupFiles = {},
	setupFilesAfterEnv = {},
	skipFilter = false,
	skipNodeResolution = false,
	slowTestThreshold = 5,
	snapshotFormat = {},
	snapshotResolver = Object.None,
	snapshotSerializers = {},
	testEnvironment = Packages.JestEnvironmentLuau,
	testEnvironmentOptions = {},
	testLocationInResults = false,
	testMatch = {},
	testPathIgnorePatterns = {},
	testRegex = { "\\.test\\.js$" },
	testRunner = "jest-circus/runner",
	testURL = "http =//localhost",
	timers = "real",
	transform = {},
	transformIgnorePatterns = {},
	unmockedModulePathPatterns = Object.None,
	watchPathIgnorePatterns = {},
}

exports.makeGlobalConfig = function(overrides_: { [string]: any }?): Config_GlobalConfig
	local overrides = overrides_ or {}
	local overridesKeys = Set.new(Object.keys(overrides))

	Array.forEach(Object.keys(DEFAULT_GLOBAL_CONFIG), function(key)
		overridesKeys:delete(key)
	end)

	if overridesKeys.size > 0 then
		error("Properties that are not part of GlobalConfig type were passed:" .. inspect(Array.from(overridesKeys)))
	end

	return Object.assign({}, DEFAULT_GLOBAL_CONFIG, overrides)
end

exports.makeProjectConfig = function(overrides: { [string]: any }): Config_ProjectConfig
	overrides = overrides or {}
	local overridesKeys = Set.new(Object.keys(overrides))

	Array.forEach(Object.keys(DEFAULT_PROJECT_CONFIG), function(key)
		overridesKeys:delete(key)
	end)

	if overridesKeys.size > 0 then
		error("Properties that are not part of ProjectConfig type were passed:" .. inspect(Array.from(overridesKeys)))
	end

	return Object.assign({}, DEFAULT_PROJECT_CONFIG, overrides)
end

return exports
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="542">
            <Properties>
              <string name="Name">Throat</string>
              <string name="Source"><![CDATA[-- ROBLOX upstream: https://github.com/ForbesLindesay/throat/blob/6.0.1/index.js
-- ROBLOX upstream types: https://github.com/ForbesLindesay/throat/blob/6.0.1/index.d.ts
--[[
	Copyright (c) 2013 Forbes Lindesay

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
]]
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>
local Promise = require(Packages.Promise)
type Promise<T> = LuauPolyfill.Promise<T>

local TypeError = Error

local exports = {}

-- ROBLOX deviation START: predeclare classes
local Delayed = {} :: Delayed
local Queue: Queue
-- ROBLOX deviation END

-- ROBLOX deviation START: additional types for Luau
type ThroatFn<TResult, TArgs> = (...TArgs) -> Promise<TResult>

type ThroatFnOrCallableFn<TResult, TArgs> = ThroatFn<TResult, TArgs> | typeof(setmetatable({}, {
	__call = (function() end :: any) :: (self: any, ...TArgs) -> Promise<TResult>,
}))

export type ThroatLateBound<TResult, TArgs> = (
	fn: ThroatFnOrCallableFn<TResult, TArgs>,
	...TArgs
) -> Promise<TResult>
export type ThroatEarlyBound<TResult, TArgs> = (...TArgs) -> Promise<TResult>
-- ROBLOX deviation END

--[[
	ROBLOX deviation START:
	additional checking function to allow for both functions and callable tables to be passed as arguments
]]
local function isCallable(f: any): boolean
	return typeof(f) == "function"
		or (
			typeof(f) == "table"
			and typeof(getmetatable(f)) == "table"
			and typeof(getmetatable(f).__call) == "function"
		)
end
-- ROBLOX deviation END

local function throatInternal(size: number)
	-- ROBLOX deviation START: hoist functions declarations
	local runDelayed
	local onFulfill
	local onReject
	local release
	-- ROBLOX deviation END

	local queue = Queue.new()
	local s = bit32.bor(size, 0)
	local function run<TResult, TArgs>(fn: ThroatFnOrCallableFn<TResult, TArgs>, args: Array<TArgs>)
		if bit32.bor(s, 0) ~= 0 then
			s = bit32.bor(s, 0) - 1
			return Promise.new(function(resolve)
				resolve((fn :: ThroatFn<TResult, TArgs>)(table.unpack(args)))
			end):andThen(onFulfill, onReject)
		end
		return Promise.new(function(resolve)
			queue:push(Delayed.new(resolve, fn :: ThroatFn<TResult, TArgs>, args))
		end):andThen(runDelayed)
	end
	function runDelayed(d): any?
		local ok, result, hasReturned = pcall(function()
			return Promise.resolve(d.fn(table.unpack(d.args))):andThen(onFulfill, onReject), true
		end)
		if not ok then
			local ex = result
			onReject(ex)
		end
		if hasReturned then
			return result
		end
		return
	end
	function onFulfill(result)
		release()
		return result
	end
	function onReject(error_)
		release()
		error(error_)
	end
	function release()
		local next_ = queue:shift()
		if next_ ~= nil then
			next_:resolve(next_)
		else
			s = bit32.bor(s, 0) + 1
		end
	end
	return run
end

local function earlyBound<TResult, TArgs>(size: number, fn: (...TArgs) -> Promise<TResult>): ThroatEarlyBound<TResult, TArgs>
	local run = throatInternal(bit32.bor(size, 0))
	return function(...)
		local arguments = { ... }
		local args = {}
		for i = 0, #arguments - 1 do
			args[i + 1] = arguments[i + 1]
		end
		return run(fn, args)
	end
end
local function lateBound<TResult, TArgs>(size: number): ThroatLateBound<TResult, TArgs>
	local run = throatInternal(bit32.bor(size, 0))
	return function(fn, ...)
		local arguments = { fn :: any, ... }
		-- ROBLOX deviation: using isCallable to allow for callable tables being passed
		if not isCallable(fn) then
			error(TypeError.new("Expected throat fn to be a function but got " .. tostring(typeof(fn))))
		end
		local args = {} :: Array<TArgs>
		for i = 1, #arguments - 1 do
			args[i] = arguments[i + 1]
		end
		return run(fn, args)
	end
end

exports.default = function<TResult, TArgs>(
	size: number,
	fn: ((...TArgs) -> Promise<TResult>)?
): ((...TArgs) -> Promise<TResult>) | ((fn: (...TArgs) -> Promise<TResult>, ...TArgs) -> Promise<TResult>)
	-- ROBLOX deviation: using isCallable to allow for callable tables being passed
	if isCallable(size) then
		local temp = fn
		fn = (size :: any) :: (...TArgs) -> Promise<TResult>
		size = (temp :: any) :: number
	end
	if typeof(size) ~= "number" then
		error(TypeError.new("Expected throat size to be a number but got " .. tostring(typeof(size))))
	end
	-- ROBLOX deviation: using isCallable to allow for callable tables being passed
	if fn ~= nil and not isCallable(fn) then
		error(TypeError.new("Expected throat fn to be a function but got " .. tostring(typeof(fn))))
	end
	-- ROBLOX deviation: using isCallable to allow for callable tables being passed
	if fn ~= nil and isCallable(fn) then
		return earlyBound(bit32.bor(size, 0), fn)
	else
		return lateBound(bit32.bor(size, 0))
	end
end

-- ROBLOX deviation: only exporting as default
-- module.exports.default = module.exports;

type Delayed = {
	new: (resolve: (...any) -> (), fn: (...any) -> ...any, args: Array<any>) -> Delayed,
}

(Delayed :: any).__index = Delayed
function Delayed.new(resolve, fn, args): Delayed
	local self = setmetatable({}, Delayed)
	self.resolve = resolve
	self.fn = fn
	self.args = args
	return (self :: any) :: Delayed
end

local blockSize = 64

type Queue = {
	new: () -> Queue,
	push: (self: Queue, value: any) -> (),
	shift: (self: Queue) -> any?,
}
type QueuePrivate = {
	new: () -> QueuePrivate,
	push: (self: QueuePrivate, value: any) -> (),
	shift: (self: QueuePrivate) -> any?,
	_s1: Array<any>,
	_s2: Array<any>,
	_pushBlock: Array<any>,
	_shiftBlock: Array<any>,
	_pushIndex: number,
	_shiftIndex: number,
}
local QueuePrivate = {} :: QueuePrivate;
(QueuePrivate :: any).__index = QueuePrivate
function QueuePrivate.new(): QueuePrivate
	local self = setmetatable({}, QueuePrivate)
	self._s1 = {}
	self._s2 = {}
	self._pushBlock = {}
	self._shiftBlock = self._pushBlock
	self._pushIndex = 0
	self._shiftIndex = 0
	return (self :: any) :: QueuePrivate
end

function QueuePrivate:push(value)
	if self._pushIndex == blockSize then
		self._pushIndex = 0
		self._pushBlock = {}
		self._s1[#self._s1 + 1] = self._pushBlock
	end
	self._pushBlock[self._pushIndex + 1] = value
	self._pushIndex += 1
end

function QueuePrivate:shift()
	if self._shiftIndex == blockSize then
		self._shiftIndex = 0
		local s2 = self._s2
		if #s2 == 0 then
			local s1 = self._s1
			if #s1 == 0 then
				return nil
			end
			self._s1 = s2
			self._s2 = Array.reverse(s1)
			s2 = self._s2
		end
		self._shiftBlock = table.remove(s2) :: Array<any>
	end
	if self._pushBlock == self._shiftBlock and self._pushIndex == self._shiftIndex then
		return nil
	end
	local result = self._shiftBlock[self._shiftIndex + 1]
	self._shiftBlock[self._shiftIndex + 1] = nil
	self._shiftIndex += 1

	return result
end
Queue = (QueuePrivate :: any) :: Queue

return exports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="543">
            <Properties>
              <string name="Name">Timers</string>
              <string name="Source"><![CDATA[--!strict
local Packages = script.Parent

local Object = require(Packages.Collections).Object

local makeTimerImpl = require(script.makeTimerImpl)
local makeIntervalImpl = require(script.makeIntervalImpl)

export type Timeout = makeTimerImpl.Timeout
export type Interval = makeIntervalImpl.Interval

return Object.assign({}, makeTimerImpl(task.delay), makeIntervalImpl(task.delay))
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="544">
              <Properties>
                <string name="Name">makeIntervalImpl</string>
                <string name="Source"><![CDATA[local Status = newproxy(false)

type TaskStatus = number
export type Interval = { [typeof(Status)]: TaskStatus }

local SCHEDULED = 1
local CANCELLED = 3

return function(delayImpl)
	local function setInterval(callback, intervalTime: number, ...): Interval
		local args = { ... }
		local task = {
			[Status] = SCHEDULED,
		}

		-- delayTime is an optional parameter
		if intervalTime == nil then
			intervalTime = 0
		end

		-- To mimic the JS interface, we're expecting delayTime to be in ms
		local intervalTimeMs = intervalTime / 1000
		local delay_
		delay_ = function()
			delayImpl(intervalTimeMs, function()
				if task[Status] == SCHEDULED then
					callback(unpack(args))
					delay_()
				end
			end)
		end

		delay_()

		return task
	end

	local function clearInterval(task: Interval)
		if task == nil then
			return
		end

		if task[Status] == SCHEDULED then
			task[Status] = CANCELLED
		end
	end

	return {
		setInterval = setInterval,
		clearInterval = clearInterval,
	}
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="545">
              <Properties>
                <string name="Name">makeTimerImpl</string>
                <string name="Source"><![CDATA[local Status = newproxy(false)

type TaskStatus = number
export type Timeout = { [typeof(Status)]: TaskStatus }

local SCHEDULED = 1
local DONE = 2
local CANCELLED = 3

return function(delayImpl)
	local function setTimeout(callback, delayTime: number?, ...): Timeout
		local args = { ... }
		local task = {
			[Status] = SCHEDULED,
		}

		-- delayTime is an optional parameter
		if delayTime == nil then
			delayTime = 0
		end

		-- To mimic the JS interface, we're expecting delayTime to be in ms
		local delayTimeMs = delayTime :: number / 1000
		delayImpl(delayTimeMs, function()
			if task[Status] == SCHEDULED then
				callback(unpack(args))
				task[Status] = DONE
			end
		end)

		return task
	end

	local function clearTimeout(task: Timeout)
		if task == nil then
			return
		end
		if task[Status] == SCHEDULED then
			task[Status] = CANCELLED
		end
	end

	return {
		setTimeout = setTimeout,
		clearTimeout = clearTimeout,
	}
end
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="546">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="547">
      <Properties>
        <string name="Name">base</string>
      </Properties>
      <Item class="Folder" referent="548">
        <Properties>
          <string name="Name">server</string>
        </Properties>
        <Item class="Script" referent="549">
          <Properties>
            <string name="Name">runtime</string>
            <token name="RunContext">1</token>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "ServerScriptService", "base", "server", "services" } })
Flamework.ignite()
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="550">
          <Properties>
            <string name="Name">services</string>
          </Properties>
          <Item class="ModuleScript" referent="551">
            <Properties>
              <string name="Name">test</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Service = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "flamework", "out").Service
local Server
do
	Server = setmetatable({}, {
		__tostring = function()
			return "Server"
		end,
	})
	Server.__index = Server
	function Server.new(...)
		local self = setmetatable({}, Server)
		return self:constructor(...) or self
	end
	function Server:constructor()
	end
	function Server:onStart()
		print("Base Server")
	end
	Server = Service({})(Server) or Server
end
return {
	Server = Server,
}
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="552">
      <Properties>
        <string name="Name">lobby</string>
      </Properties>
      <Item class="Folder" referent="553">
        <Properties>
          <string name="Name">server</string>
        </Properties>
        <Item class="Script" referent="554">
          <Properties>
            <string name="Name">runtime</string>
            <token name="RunContext">1</token>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "ServerScriptService", "lobby", "server", "services" } })
Flamework.ignite()
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="555">
          <Properties>
            <string name="Name">services</string>
          </Properties>
          <Item class="ModuleScript" referent="556">
            <Properties>
              <string name="Name">test</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Service = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "flamework", "out").Service
local Server
do
	Server = setmetatable({}, {
		__tostring = function()
			return "Server"
		end,
	})
	Server.__index = Server
	function Server.new(...)
		local self = setmetatable({}, Server)
		return self:constructor(...) or self
	end
	function Server:constructor()
	end
	function Server:onStart()
		print("Base Server")
	end
	Server = Service({})(Server) or Server
end
return {
	Server = Server,
}
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>